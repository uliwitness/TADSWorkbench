<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>_main.t</title></head><body>
<table class=ban><tr><td><h1>_main.t</h1><td align=right><a href="../file/_main.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/* 
<a name="4"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts.  All Rights Reserved.
<a name="5"></a> *   
<a name="6"></a> *   This module defines a number of low-level functions and classes that
<a name="7"></a> *   most TADS 3 programs will need, whether based on the adv3 library or
<a name="8"></a> *   not.  This module includes the main program entrypoint, the basic
<a name="9"></a> *   Exception classes, and the modular initialization framework.
<a name="10"></a> *   
<a name="11"></a> *   The compiler automatically links this module into every program by
<a name="12"></a> *   default, but you can override this by specifying the "-nodef" option
<a name="13"></a> *   to t3make.  If you remove this module, you'll have to provide your own
<a name="14"></a> *   implementations for many of the functions and classes defined here.  
<a name="15"></a> */
<a name="16"></a>
<a name="17"></a>#include "tads.h"
<a name="18"></a>#include "reflect.h"
<a name="19"></a>
<a name="20"></a>
<a name="21"></a>/* ------------------------------------------------------------------------ */
<a name="22"></a>/*
<a name="23"></a> *   Main program entrypoint.  The VM invokes this function at program
<a name="24"></a> *   startup.  
<a name="25"></a> */
<a name="26"></a>_main(args)
<a name="27"></a>{
<a name="28"></a>    /* call the common main entrypoint, with no startup file specified */
<a name="29"></a>    _mainCommon(args, nil);
<a name="30"></a>}
<a name="31"></a>
<a name="32"></a>/*
<a name="33"></a> *   Main program entrypoint for restoring a saved state.  The VM invokes
<a name="34"></a> *   this function at startup instead of _main() when the user explicitly
<a name="35"></a> *   specifies a saved state file to restore when starting the program.
<a name="36"></a> *   (On a command-line interpreter, this would involve using a special
<a name="37"></a> *   option on the T3 interpreter command line; for a GUI shell, this
<a name="38"></a> *   might simply involve double-clicking on the desktop icon for a saved
<a name="39"></a> *   state file.)
<a name="40"></a> *   
<a name="41"></a> *   Note that we must export this as the 'mainRestore' symbol so that the
<a name="42"></a> *   interpreter knows how to find it.  
<a name="43"></a> */
<a name="44"></a>export _mainRestore 'mainRestore';
<a name="45"></a>_mainRestore(args, restoreFile)
<a name="46"></a>{
<a name="47"></a>    /* call the common main entrypoint */
<a name="48"></a>    _mainCommon(args, restoreFile);
<a name="49"></a>}
<a name="50"></a>
<a name="51"></a>/*
<a name="52"></a> *   Common main entrypoint.  This function can be called with or without
<a name="53"></a> *   a saved state file to restore.  
<a name="54"></a> */
<a name="55"></a>_mainCommon(args, restoreFile)
<a name="56"></a>{    
<a name="57"></a>    /* keep going as long as we keep restarting */
<a name="58"></a>    for (;;)
<a name="59"></a>    {
<a name="60"></a>        try
<a name="61"></a>        {
<a name="62"></a>            /* perform load-time initialization */
<a name="63"></a>            initAfterLoad();
<a name="64"></a>            
<a name="65"></a>            /* if we're not in preinit-only mode, run the program */
<a name="66"></a>            if (!t3GetVMPreinitMode())
<a name="67"></a>            {
<a name="68"></a>                /* 
<a name="69"></a>                 *   If there's a saved state file to restore, call our
<a name="70"></a>                 *   mainRestore() function instead of main().  If
<a name="71"></a>                 *   mainRestore() isn't defined, show a message to this
<a name="72"></a>                 *   effect but keep going. 
<a name="73"></a>                 */
<a name="74"></a>                if (restoreFile != nil)
<a name="75"></a>                {
<a name="76"></a>                    /* check for a mainRestore function */
<a name="77"></a>                    if (dataType(mainGlobal.mainRestoreFunc) == TypeFuncPtr)
<a name="78"></a>                    {
<a name="79"></a>                        try
<a name="80"></a>                        {
<a name="81"></a>                            /* 
<a name="82"></a>                             *   Call the user's main startup-and-restore
<a name="83"></a>                             *   entrypoint function.  Note that we call
<a name="84"></a>                             *   indirectly through our function pointer
<a name="85"></a>                             *   so that we don't force a function called
<a name="86"></a>                             *   mainRestore() to be linked with the
<a name="87"></a>                             *   program.  
<a name="88"></a>                             */
<a name="89"></a>                            (mainGlobal.mainRestoreFunc)(args, restoreFile);
<a name="90"></a>                        }
<a name="91"></a>                        finally
<a name="92"></a>                        {
<a name="93"></a>                            /* 
<a name="94"></a>                             *   whatever happens, forget the saved state
<a name="95"></a>                             *   file, since we do not want to restore it
<a name="96"></a>                             *   again after restarting or anything else
<a name="97"></a>                             *   that takes us back through the main
<a name="98"></a>                             *   entrypoint again 
<a name="99"></a>                             */
<a name="100"></a>                            restoreFile = nil;
<a name="101"></a>                        }
<a name="102"></a>                    }
<a name="103"></a>                    else
<a name="104"></a>                    {
<a name="105"></a>                        /* 
<a name="106"></a>                         *   there's no mainRestore, so we can't restore
<a name="107"></a>                         *   the saved state - note the problem 
<a name="108"></a>                         */
<a name="109"></a>                        "\n[This program cannot restore the saved position
<a name="110"></a>                        file automatically.  Please try restoring the
<a name="111"></a>                        saved position file again using a command within
<a name="112"></a>                        the program.]\b";
<a name="113"></a>
<a name="114"></a>                        /* call the ordinary main */
<a name="115"></a>                        main(args);
<a name="116"></a>                    }
<a name="117"></a>                }
<a name="118"></a>                else
<a name="119"></a>                {
<a name="120"></a>                    /* call the user's main program entrypoint */
<a name="121"></a>                    main(args);
<a name="122"></a>                }
<a name="123"></a>            }
<a name="124"></a>
<a name="125"></a>            /* we're done - break out of the restart loop */
<a name="126"></a>            break;
<a name="127"></a>        }
<a name="128"></a>        catch (RestartSignal rsig)
<a name="129"></a>        {
<a name="130"></a>            /* 
<a name="131"></a>             *   call the intrinsic restartGame function to reset all of
<a name="132"></a>             *   the static objects to their initial state 
<a name="133"></a>             */
<a name="134"></a>            restartGame();
<a name="135"></a>
<a name="136"></a>            /* 
<a name="137"></a>             *   Now that we've reset the VM, update the restart ID in the
<a name="138"></a>             *   main globals.  Note that we waited until now to do this,
<a name="139"></a>             *   because this change would have been lost in the reset if
<a name="140"></a>             *   we'd made the change before the reset.  Note also that the
<a name="141"></a>             *   'rsig' object itself will survive the reset because the
<a name="142"></a>             *   thrower presumably allocated it dynamically, hence it's
<a name="143"></a>             *   not a static object subject to reset.  
<a name="144"></a>             */
<a name="145"></a>            mainGlobal.restartID = rsig.restartID;
<a name="146"></a>
<a name="147"></a>            /*
<a name="148"></a>             *   Now we can just continue on to the next iteration of the
<a name="149"></a>             *   restart loop.  This will take us back to the
<a name="150"></a>             *   initialization and enter the game as though we'd just
<a name="151"></a>             *   started the program again. 
<a name="152"></a>             */
<a name="153"></a>        }
<a name="154"></a>        catch (ProgramException exc)
<a name="155"></a>        {
<a name="156"></a>            /* 
<a name="157"></a>             *   just re-throw these out to the VM, so that the VM exits to
<a name="158"></a>             *   the operating system with an error indication 
<a name="159"></a>             */
<a name="160"></a>            throw exc;
<a name="161"></a>        }
<a name="162"></a>        catch (Exception exc)
<a name="163"></a>        {
<a name="164"></a>            /* display the unhandled exception */
<a name="165"></a>            "\n&lt;&lt;exc.displayException()&gt;&gt;\n";
<a name="166"></a>
<a name="167"></a>            /* we can't go on - break out of the restart loop */
<a name="168"></a>            break;
<a name="169"></a>        }
<a name="170"></a>    }
<a name="171"></a>}
<a name="172"></a>
<a name="173"></a>/* ------------------------------------------------------------------------ */
<a name="174"></a>/*
<a name="175"></a> *   Restart signal.  This can be used to restart from the main
<a name="176"></a> *   entrypoint.  The caller should create one of these objects, then use
<a name="177"></a> *   restartGame() (or an equivalent from a different function set, if
<a name="178"></a> *   appropriate) to reset static object state to the initial program load
<a name="179"></a> *   conditions, then throw the signal object.  
<a name="180"></a> */
<a name="181"></a>class RestartSignal: Exception
<a name="182"></a>    construct()
<a name="183"></a>    {
<a name="184"></a>        /* 
<a name="185"></a>         *   use the next restart ID, so we can tell that we're on a fresh
<a name="186"></a>         *   run on this session 
<a name="187"></a>         */
<a name="188"></a>        restartID = mainGlobal.restartID + 1;
<a name="189"></a>    }
<a name="190"></a>;
<a name="191"></a>
<a name="192"></a>/* ------------------------------------------------------------------------ */
<a name="193"></a>/*
<a name="194"></a> *   General post-load initialization.  The main program entrypoint
<a name="195"></a> *   _main() calls this routine to set up the default display function,
<a name="196"></a> *   run pre-initialization if necessary, and run initialization.  This
<a name="197"></a> *   routine is also useful for the target of a restartGame() routine, to
<a name="198"></a> *   perform all of the basic load-time initialization again after a
<a name="199"></a> *   restart.  
<a name="200"></a> */
<a name="201"></a>initAfterLoad()
<a name="202"></a>{
<a name="203"></a>    /* establish the default display function */
<a name="204"></a>    t3SetSay(_default_display_fn);
<a name="205"></a>
<a name="206"></a>    /* if we haven't run preinit, do so now */
<a name="207"></a>    if (!mainGlobal.preinited_)
<a name="208"></a>    {
<a name="209"></a>        /* 
<a name="210"></a>         *   Explicitly run garbage collection prior to preinit.  This is
<a name="211"></a>         *   usually harmless but unnecessary, since it usually doesn't
<a name="212"></a>         *   much matter whether unreachable objects are still sitting in
<a name="213"></a>         *   memory or not; but under certain conditions it's important.
<a name="214"></a>         *   
<a name="215"></a>         *   In particular, object loops (over all objects, or over all
<a name="216"></a>         *   instances of a given class) can still see otherwise
<a name="217"></a>         *   unreachable objects.  It's common to do these kinds of loops
<a name="218"></a>         *   in preinit to set up static data caches and tables and so on.
<a name="219"></a>         *   So, if there were any garbage objects lying around, preinit
<a name="220"></a>         *   might find them and register them into tables or what not.
<a name="221"></a>         *   
<a name="222"></a>         *   Even considering the preinit object loop, doing a garbage
<a name="223"></a>         *   collection sweep would *still* be redundant in most cases,
<a name="224"></a>         *   since preinit is normally done right after compilation, when
<a name="225"></a>         *   the program wouldn't yet have had a chance to create any
<a name="226"></a>         *   garbage objects to be worried about in object loops.  However,
<a name="227"></a>         *   there's still one more case to consider, and that's RESTART:
<a name="228"></a>         *   in a debug build, or even in some release builds, we'd have to
<a name="229"></a>         *   re-run preinit after a RESTART, and there certainly could be
<a name="230"></a>         *   garbage objects left around from before the RESTART.
<a name="231"></a>         *   
<a name="232"></a>         *   To ensure that we deal gracefully with this combination of
<a name="233"></a>         *   conditions - garbage objects, RESTART, and object loops in
<a name="234"></a>         *   preinit - simply perform an explicit garbage collection cycle
<a name="235"></a>         *   before invoking preinit.  
<a name="236"></a>         */
<a name="237"></a>        t3RunGC();
<a name="238"></a>
<a name="239"></a>        /* run our internal preinit */
<a name="240"></a>        _preinit();
<a name="241"></a>        
<a name="242"></a>        /* remember that we've run preinit */
<a name="243"></a>        mainGlobal.preinited_ = true;
<a name="244"></a>    }
<a name="245"></a>
<a name="246"></a>    /* if we're not in preinit-only mode, run internal initialization */
<a name="247"></a>    if (!t3GetVMPreinitMode())
<a name="248"></a>        _init();
<a name="249"></a>}
<a name="250"></a>
<a name="251"></a>
<a name="252"></a>
<a name="253"></a>/* ------------------------------------------------------------------------ */
<a name="254"></a>/*
<a name="255"></a> *   Module Execution Object.  This is an abstract base class for various
<a name="256"></a> *   classes that provide modular execution hooks.  This class and its
<a name="257"></a> *   subclasses are mix-in classes - they can be multiply inherited by any
<a name="258"></a> *   object (as long as it's not already some other kind of module
<a name="259"></a> *   execution object).
<a name="260"></a> *   
<a name="261"></a> *   The point of the Module Execution Object and its subclasses is to
<a name="262"></a> *   allow libraries and user code to define execution hooks, without
<a name="263"></a> *   having to worry about what other libraries and user code bits are
<a name="264"></a> *   defining the same hook.  When we need to execute a hook defined via
<a name="265"></a> *   this object, we iterate over all of the instances of the appropriate
<a name="266"></a> *   subclass and invoke its execute() method.
<a name="267"></a> *   
<a name="268"></a> *   By default, the order of execution is arbitrary.  In some cases,
<a name="269"></a> *   though, dependencies will exist, so that one object cannot be invoked
<a name="270"></a> *   until another object has already been invoked.  In these cases, you
<a name="271"></a> *   must set the execBeforeMe property to contain a list of the objects
<a name="272"></a> *   whose execute() methods must be invoked before this object's
<a name="273"></a> *   execute() method is invoked.  The library will check this list before
<a name="274"></a> *   calling execute() on this object, and ensure that each object in the
<a name="275"></a> *   list has been invoked before calling this object's execute().  
<a name="276"></a> */
<a name="277"></a>class ModuleExecObject: object
<a name="278"></a>    /* 
<a name="279"></a>     *   List of objects that must be executed before me - by default, the
<a name="280"></a>     *   order doesn't matter, so we'll set this to an empty list.
<a name="281"></a>     *   Instances can override this if it is necessary to execute other
<a name="282"></a>     *   objects before this object can be executed.  
<a name="283"></a>     */
<a name="284"></a>    execBeforeMe = []
<a name="285"></a>
<a name="286"></a>    /*
<a name="287"></a>     *   List of objects that must be executed after me - this is
<a name="288"></a>     *   analogous to execBeforeMe, but we make sure we run before these. 
<a name="289"></a>     */
<a name="290"></a>    execAfterMe = []
<a name="291"></a>
<a name="292"></a>    /* 
<a name="293"></a>     *   Subclass-specific execution method.  Each subclass should
<a name="294"></a>     *   override this method to provide its execution code.  
<a name="295"></a>     */
<a name="296"></a>    execute() { }
<a name="297"></a>
<a name="298"></a>
<a name="299"></a>    /* 
<a name="300"></a>     *   PRIVATE METHODS AND PROPERTIES.  Subclasses and instances should
<a name="301"></a>     *   not need to override or invoke these.  
<a name="302"></a>     */
<a name="303"></a>
<a name="304"></a>    /* flag - true if we've been executed on this round */
<a name="305"></a>    isExecuted_ = nil
<a name="306"></a>
<a name="307"></a>    /* flag - true if we're in the process of executing */
<a name="308"></a>    isDoingExec_ = nil
<a name="309"></a>
<a name="310"></a>    /* execute - internal method: checks dependency order */
<a name="311"></a>    _execute()
<a name="312"></a>    {
<a name="313"></a>        /*
<a name="314"></a>         *   If I've already been executed, there's nothing more that I
<a name="315"></a>         *   need to do.  We might be called by the arbitrarily-ordered
<a name="316"></a>         *   iteration over all objects after we've already been executed,
<a name="317"></a>         *   because we might be executed explicitly by an object that
<a name="318"></a>         *   depends upon us if it's reached before we are.  
<a name="319"></a>         */
<a name="320"></a>        if (isExecuted_)
<a name="321"></a>            return;
<a name="322"></a>
<a name="323"></a>        /* 
<a name="324"></a>         *   If we're in the process of executing any of the objects we
<a name="325"></a>         *   depend upon, and a dependent calls us, we have a circular
<a name="326"></a>         *   dependency.  
<a name="327"></a>         */
<a name="328"></a>        if (isDoingExec_)
<a name="329"></a>            throw new CircularExecException(self);
<a name="330"></a>
<a name="331"></a>        /*
<a name="332"></a>         *   Mark ourselves as being in the process of executing.  If
<a name="333"></a>         *   there are any circular dependencies (i.e., if we depend on an
<a name="334"></a>         *   object, which in turn depends on us), it's clearly an error,
<a name="335"></a>         *   in that both objects can't be executed before the other.
<a name="336"></a>         *   This flag allows us to detect circular dependencies by
<a name="337"></a>         *   noticing if we're called by a dependent while we're in the
<a name="338"></a>         *   process of calling the things we depend upon.  
<a name="339"></a>         */
<a name="340"></a>        isDoingExec_ = true;
<a name="341"></a>        
<a name="342"></a>        /*
<a name="343"></a>         *   Check each entry in my 'before' list to ensure that they've
<a name="344"></a>         *   all been executed already.  Invoke execute() now for any that
<a name="345"></a>         *   haven't.  
<a name="346"></a>         */
<a name="347"></a>        for (local i = 1, local cnt = execBeforeMe.length() ;
<a name="348"></a>             i &lt;= cnt ; ++i)
<a name="349"></a>        {
<a name="350"></a>            local cur;
<a name="351"></a>
<a name="352"></a>            /* get this object */
<a name="353"></a>            cur = execBeforeMe[i];
<a name="354"></a>            
<a name="355"></a>            /* if this one hasn't been executed yet, do so now */
<a name="356"></a>            if (!cur.isExecuted_)
<a name="357"></a>            {
<a name="358"></a>                /* 
<a name="359"></a>                 *   This one hasn't been executed yet - explicitly
<a name="360"></a>                 *   execute it now.  Note that we do this recursively
<a name="361"></a>                 *   through the internal execution method, so that 'cur'
<a name="362"></a>                 *   has a chance to execute any objects that it depends
<a name="363"></a>                 *   upon.  
<a name="364"></a>                 */
<a name="365"></a>                cur._execute();
<a name="366"></a>            }
<a name="367"></a>        }
<a name="368"></a>
<a name="369"></a>        /* 
<a name="370"></a>         *   we've resolved all of our dependencies, so we're good to go -
<a name="371"></a>         *   run the user's execution code 
<a name="372"></a>         */
<a name="373"></a>        execute();
<a name="374"></a>
<a name="375"></a>        /* 
<a name="376"></a>         *   mark ourselves as having been executed, so we don't run the
<a name="377"></a>         *   user's code again should we be called again by a dependent or
<a name="378"></a>         *   by the global iteration loop later in the scan 
<a name="379"></a>         */
<a name="380"></a>        isExecuted_ = true;
<a name="381"></a>        isDoingExec_ = nil;
<a name="382"></a>    }
<a name="383"></a>
<a name="384"></a>    /* flag to indicate that this is the first time running classExec */
<a name="385"></a>    hasInitialized_ = nil
<a name="386"></a>
<a name="387"></a>    /*
<a name="388"></a>     *   Class execution.  Call this method on the particular class of
<a name="389"></a>     *   modules to execute.  We'll iterate over all instances of that
<a name="390"></a>     *   class and invoke each instance's _execute() method. 
<a name="391"></a>     */
<a name="392"></a>    classExec()
<a name="393"></a>    {
<a name="394"></a>        /*
<a name="395"></a>         *   If this is the first time running this classExec, turn
<a name="396"></a>         *   execAfterMe dependencies into appropriate execBeforeMe
<a name="397"></a>         *   dependencies.  
<a name="398"></a>         */
<a name="399"></a>        if (!hasInitialized_)
<a name="400"></a>        {
<a name="401"></a>            /* 
<a name="402"></a>             *   Go through all instances of this type of initializer, and
<a name="403"></a>             *   re-cast the execAfterMe lists as execBeforeMe lists.  
<a name="404"></a>             */
<a name="405"></a>            forEachInstance(self,
<a name="406"></a>                new function(obj)
<a name="407"></a>                {
<a name="408"></a>                    foreach(local dependent in obj.execAfterMe)
<a name="409"></a>                        dependent.execBeforeMe += obj;
<a name="410"></a>                });
<a name="411"></a>
<a name="412"></a>            /* remember that we're now initialized */
<a name="413"></a>            hasInitialized_ = true;
<a name="414"></a>        }
<a name="415"></a>        
<a name="416"></a>        /* 
<a name="417"></a>         *   since we're starting a new round, clear all of the 'executed'
<a name="418"></a>         *   flags in all of the objects, to ensure that we execute all
<a name="419"></a>         *   objects on this round (this cleans up the flag settings from
<a name="420"></a>         *   any previous rounds) 
<a name="421"></a>         */
<a name="422"></a>        forEachInstance(self,
<a name="423"></a>            { obj: obj.isExecuted_ = obj.isDoingExec_ = nil });
<a name="424"></a>
<a name="425"></a>        /* execute all objects */
<a name="426"></a>        forEachInstance(self, { obj: obj._execute() });
<a name="427"></a>    }
<a name="428"></a>;
<a name="429"></a>
<a name="430"></a>/*
<a name="431"></a> *   Pre-Initialization object.  During pre-initialization, we'll invoke
<a name="432"></a> *   the execute() method on each instance of this class.  
<a name="433"></a> */
<a name="434"></a>class PreinitObject: ModuleExecObject
<a name="435"></a>    /*
<a name="436"></a>     *   Each instance of this object MUST override execute() with the
<a name="437"></a>     *   specific pre-initialization code that the instance wants to
<a name="438"></a>     *   perform.
<a name="439"></a>     *   
<a name="440"></a>     *   In addition, each instance can optionally set the property
<a name="441"></a>     *   execBeforeMe to a list of the other PreinitObject's that must be
<a name="442"></a>     *   invoked before this object is.  If this property is not set, this
<a name="443"></a>     *   object's place in the preinit execution order will be arbitrary.  
<a name="444"></a>     */
<a name="445"></a>;
<a name="446"></a>
<a name="447"></a>/*
<a name="448"></a> *   Initialization object.  During initialization, just before calling
<a name="449"></a> *   the user's main(args) function, we'll invoke the execute() method on
<a name="450"></a> *   each instance of this class. 
<a name="451"></a> */
<a name="452"></a>class InitObject: ModuleExecObject
<a name="453"></a>    /*
<a name="454"></a>     *   Each instance of this object MUST override execute() with the
<a name="455"></a>     *   specific initialization code that the instance wants to perform.
<a name="456"></a>     *   
<a name="457"></a>     *   In addition, each instance can optionally set the property
<a name="458"></a>     *   execBeforeMe to a list of the other InitObject's that must be
<a name="459"></a>     *   invoked before this object is.  If this property is not set, this
<a name="460"></a>     *   object's place in the initialization execution order will be
<a name="461"></a>     *   arbitrary.  
<a name="462"></a>     */
<a name="463"></a>;
<a name="464"></a>
<a name="465"></a>
<a name="466"></a>/*
<a name="467"></a> *   Exception: circular execution dependency in ModuleExecObject
<a name="468"></a> */
<a name="469"></a>class CircularExecException: Exception
<a name="470"></a>    construct(obj) { obj_ = obj; }
<a name="471"></a>    displayException()
<a name="472"></a>    {
<a name="473"></a>        "circular module dependency detected (refer to
<a name="474"></a>        ModuleExecObject._execute() in _main.t)";
<a name="475"></a>    }
<a name="476"></a>
<a name="477"></a>    /* 
<a name="478"></a>     *   The object that detected the circular dependency.  We can't use
<a name="479"></a>     *   this for much ourselves, but it might be useful to store this
<a name="480"></a>     *   information so that it's available to the programmer from within
<a name="481"></a>     *   the debugger.  
<a name="482"></a>     */
<a name="483"></a>    obj_ = nil
<a name="484"></a>;
<a name="485"></a>
<a name="486"></a>/*
<a name="487"></a> *   Library pre-initialization.  This is called immediately after
<a name="488"></a> *   compilation to pre-initialize the program.  Any changes made here to
<a name="489"></a> *   object states become part of the initial state stored in the image
<a name="490"></a> *   file, so this establishes the static initial state of the program.
<a name="491"></a> *   
<a name="492"></a> *   The advantage of doing work during pre-initialization is that this
<a name="493"></a> *   work is done once, during compilation, and is thus not repeated each
<a name="494"></a> *   time a user starts the program.  Time-consuming initialization work
<a name="495"></a> *   can thus be made invisible to the user.
<a name="496"></a> *   
<a name="497"></a> *   Note that the pre-initialization code should never do anything that
<a name="498"></a> *   involves the user interface, since this code runs during compilation
<a name="499"></a> *   and does not run again when users start the program.  So, anything
<a name="500"></a> *   that you want a user to see must be done during normal initialization
<a name="501"></a> *   (such as in the main() routine), not here.  
<a name="502"></a> */
<a name="503"></a>_preinit()
<a name="504"></a>{
<a name="505"></a>    local symtab;
<a name="506"></a>
<a name="507"></a>    /* try getting the mainRestore() function from the global symbol table */
<a name="508"></a>    if ((symtab = t3GetGlobalSymbols()) != nil)
<a name="509"></a>        mainGlobal.mainRestoreFunc = symtab['mainRestore'];
<a name="510"></a>
<a name="511"></a>    /* execute all preinit objects */
<a name="512"></a>    PreinitObject.classExec();
<a name="513"></a>}
<a name="514"></a>
<a name="515"></a>/*
<a name="516"></a> *   Library initialization.  This is called during each program start-up
<a name="517"></a> *   to initialize the program.  Since this is run each time the user
<a name="518"></a> *   starts the program, this can display any introductory messages, set
<a name="519"></a> *   up the user interface, and so on.  
<a name="520"></a> */
<a name="521"></a>_init()
<a name="522"></a>{
<a name="523"></a>    /* execute all init objects */
<a name="524"></a>    InitObject.classExec();
<a name="525"></a>}
<a name="526"></a>
<a name="527"></a>/* ------------------------------------------------------------------------ */
<a name="528"></a>/*
<a name="529"></a> *   For convenience, a simple object iterator function.  This function
<a name="530"></a> *   invokes a callback function for each instance of the given class, in
<a name="531"></a> *   arbitrary order.
<a name="532"></a> *   
<a name="533"></a> *   The callback is invoked with one argument, which gives the current
<a name="534"></a> *   instance.  The callback can "break" out of the loop by throwing a
<a name="535"></a> *   BreakLoopSignal, which can be done conveniently using the breakLoop
<a name="536"></a> *   macro.  
<a name="537"></a> */
<a name="538"></a>forEachInstance(cls, func)
<a name="539"></a>{
<a name="540"></a>    try
<a name="541"></a>    {
<a name="542"></a>        /* loop over all objects of the given class */
<a name="543"></a>        for (local obj = firstObj(cls) ; obj != nil ; obj = nextObj(obj, cls))
<a name="544"></a>            func(obj);
<a name="545"></a>    }
<a name="546"></a>    catch (BreakLoopSignal sig)
<a name="547"></a>    {
<a name="548"></a>        /* 
<a name="549"></a>         *   ignore the signal - it simply means we want to terminate the
<a name="550"></a>         *   loop and return to the caller 
<a name="551"></a>         */
<a name="552"></a>    }
<a name="553"></a>}
<a name="554"></a>
<a name="555"></a>/*
<a name="556"></a> *   Find an instance of the given class for which the given function
<a name="557"></a> *   returns true.  We iterate over objects of the given class in
<a name="558"></a> *   arbitrary order, and return the first instance for which the function
<a name="559"></a> *   returns true.  Retursn nil if there is no such instance.  
<a name="560"></a> */
<a name="561"></a>instanceWhich(cls, func)
<a name="562"></a>{
<a name="563"></a>    /* loop over all objects of the given class */
<a name="564"></a>    for (local obj = firstObj(cls) ; obj != nil ; obj = nextObj(obj, cls))
<a name="565"></a>    {
<a name="566"></a>        /* if the callback returns true for this object, return the object */
<a name="567"></a>        if (func(obj))
<a name="568"></a>            return obj;
<a name="569"></a>    }
<a name="570"></a>
<a name="571"></a>    /* 
<a name="572"></a>     *   we didn't find any instances for which the callback returns true;
<a name="573"></a>     *   indicate this by returning nil 
<a name="574"></a>     */
<a name="575"></a>    return nil;
<a name="576"></a>}
<a name="577"></a>
<a name="578"></a>/*
<a name="579"></a> *   An exception object for breaking out of a callback loop, such as
<a name="580"></a> *   forEachInstance. 
<a name="581"></a> */
<a name="582"></a>class BreakLoopSignal: Exception
<a name="583"></a>    displayException() { "loop break signal"; }
<a name="584"></a>;
<a name="585"></a>
<a name="586"></a>
<a name="587"></a>/* ------------------------------------------------------------------------ */
<a name="588"></a>/*
<a name="589"></a> *   Get the "translated" datatype of a value.  This is essentially the
<a name="590"></a> *   same as dataType(), except that anonymous function objects are
<a name="591"></a> *   indicated as ordinary function pointer (TypeFuncPtr).  
<a name="592"></a> */
<a name="593"></a>dataTypeXlat(val)
<a name="594"></a>{
<a name="595"></a>    local t;
<a name="596"></a>
<a name="597"></a>    /* get the base type */
<a name="598"></a>    t = dataType(val);
<a name="599"></a>    
<a name="600"></a>    /* if it's an anonymous function, return TypeFuncPtr */
<a name="601"></a>    if (t == TypeObject &amp;&amp; val.ofKind(AnonFuncPtr))
<a name="602"></a>        return TypeFuncPtr;
<a name="603"></a>
<a name="604"></a>    /* otherwise, just return the base type */
<a name="605"></a>    return t;
<a name="606"></a>}
<a name="607"></a>
<a name="608"></a>/* ------------------------------------------------------------------------ */
<a name="609"></a>/*
<a name="610"></a> *   Base class for all exception objects.  We derive all exceptions from
<a name="611"></a> *   this base class so that we can write 'catch' blocks that catch all
<a name="612"></a> *   exceptions by catching 'Exception'.
<a name="613"></a> *   
<a name="614"></a> *   The displayException() method displays a message describing the
<a name="615"></a> *   exception.  Subclasses should override this method.  
<a name="616"></a> */
<a name="617"></a>class Exception: object
<a name="618"></a>    /* display the exception - should always be overridden */
<a name="619"></a>    displayException()
<a name="620"></a>    {
<a name="621"></a>        "Unknown exception";
<a name="622"></a>    }
<a name="623"></a>
<a name="624"></a>    /* 
<a name="625"></a>     *   Display a stack trace, given a list of T3StackInfo objects.  Note
<a name="626"></a>     *   that, for efficiency, we do not by default cache a stack trace
<a name="627"></a>     *   when an exception occurs; individual subclasses can obtain a
<a name="628"></a>     *   stack trace if desired at construction and use the information to
<a name="629"></a>     *   show a stack trace for the exception. 
<a name="630"></a>     */
<a name="631"></a>    showStackTrace(stackList)
<a name="632"></a>    {
<a name="633"></a>        local haveSrc;
<a name="634"></a>
<a name="635"></a>        /* check to see if there's any source info in the stack trace */
<a name="636"></a>        haveSrc = nil;
<a name="637"></a>        foreach (local cur in stackList)
<a name="638"></a>        {
<a name="639"></a>            /* note if we have source info here */
<a name="640"></a>            if (cur.srcInfo_ != nil)
<a name="641"></a>            {
<a name="642"></a>                /* 
<a name="643"></a>                 *   we have source information - note it and stop
<a name="644"></a>                 *   searching, since even one bit of source info is
<a name="645"></a>                 *   enough to show the stack 
<a name="646"></a>                 */
<a name="647"></a>                haveSrc = true;
<a name="648"></a>                break;
<a name="649"></a>            }
<a name="650"></a>        }
<a name="651"></a>
<a name="652"></a>        /* 
<a name="653"></a>         *   if we have any source information at all, or we have
<a name="654"></a>         *   reflection services available to decode the stack trace
<a name="655"></a>         *   symbolically, show the stack 
<a name="656"></a>         */
<a name="657"></a>        if (haveSrc || mainGlobal.reflectionObj != nil)
<a name="658"></a>        {
<a name="659"></a>            "\nStack trace:\n";
<a name="660"></a>            for (local i = 1, local cnt = stackList.length() ; i &lt;= cnt ; ++i)
<a name="661"></a>            {
<a name="662"></a>                local cur = stackList[i];
<a name="663"></a>                
<a name="664"></a>                /* show a mark next to level 1, spaces elsewhere */
<a name="665"></a>                if (i == 1)
<a name="666"></a>                    "--&amp;gt;";
<a name="667"></a>                else
<a name="668"></a>                    "\ \ ";
<a name="669"></a>
<a name="670"></a>                /* 
<a name="671"></a>                 *   if there's a system reflection object, show symbolic
<a name="672"></a>                 *   information on the current function call; otherwise,
<a name="673"></a>                 *   simply show the source location 
<a name="674"></a>                 */
<a name="675"></a>                if (mainGlobal.reflectionObj != nil)
<a name="676"></a>                {
<a name="677"></a>                    /* reflection is available - show full symbolic info */
<a name="678"></a>                    _tads_io_say(mainGlobal.reflectionObj.
<a name="679"></a>                                 formatStackFrame(cur, true));
<a name="680"></a>                }
<a name="681"></a>                else
<a name="682"></a>                {
<a name="683"></a>                    /* no reflection information - show source only */
<a name="684"></a>                    if (cur.srcInfo_ != nil)
<a name="685"></a>                        "&lt;&lt;cur.srcInfo_[1]&gt;&gt;, line &lt;&lt;cur.srcInfo_[2]&gt;&gt;";
<a name="686"></a>                    else if (cur.isSystem())
<a name="687"></a>                        "&amp;lt;System&amp;gt;";
<a name="688"></a>                    else
<a name="689"></a>                        "???";
<a name="690"></a>                }
<a name="691"></a>
<a name="692"></a>                /* end the line */
<a name="693"></a>                "\n";
<a name="694"></a>            }
<a name="695"></a>        }
<a name="696"></a>    }
<a name="697"></a>;
<a name="698"></a>
<a name="699"></a>
<a name="700"></a>/* ------------------------------------------------------------------------ */
<a name="701"></a>/*
<a name="702"></a> *   RuntimeError exception class.  The VM creates and throws an instance
<a name="703"></a> *   of this class when any run-time error occurs.  The VM explicitly sets
<a name="704"></a> *   the exceptionMessage property to a string giving the VM error message
<a name="705"></a> *   for the run-time error that occurred.  
<a name="706"></a> */
<a name="707"></a>class RuntimeError: Exception
<a name="708"></a>    construct(errno, ...)
<a name="709"></a>    {
<a name="710"></a>        /* remember the VM error number */
<a name="711"></a>        errno_ = errno;
<a name="712"></a>
<a name="713"></a>        /* 
<a name="714"></a>         *   Store a stack trace for the current location.  Always discard
<a name="715"></a>         *   the first element of the result, since this will reflect
<a name="716"></a>         *   RuntimeError.construct, which is obviously not interesting.  
<a name="717"></a>         */
<a name="718"></a>        stack_ = t3GetStackTrace().sublist(2);
<a name="719"></a>
<a name="720"></a>        /* 
<a name="721"></a>         *   The next element of the stack trace is usually a native code
<a name="722"></a>         *   frame, because the VM itself invokes our constructor in
<a name="723"></a>         *   response to a runtime exception; this is not an interesting
<a name="724"></a>         *   frame, so if it's present, remove it.  
<a name="725"></a>         */
<a name="726"></a>        if (stack_.length() &gt; 0 &amp;&amp; stack_[1].isSystem())
<a name="727"></a>            stack_ = stack_.sublist(2);
<a name="728"></a>    }
<a name="729"></a>
<a name="730"></a>    /* display the exception */
<a name="731"></a>    displayException()
<a name="732"></a>    {
<a name="733"></a>        /* show the exception message */
<a name="734"></a>        "Runtime error: &lt;&lt;exceptionMessage&gt;&gt;";
<a name="735"></a>
<a name="736"></a>        /* show a stack trace if possible */
<a name="737"></a>        showStackTrace(stack_);
<a name="738"></a>    }
<a name="739"></a>
<a name="740"></a>    /* check to see if it's a debugger signal of some kind */
<a name="741"></a>    isDebuggerSignal()
<a name="742"></a>    {
<a name="743"></a>        switch(errno_)
<a name="744"></a>        {
<a name="745"></a>        case 2391:                       /* debugger 'abort command' signal */
<a name="746"></a>        case 2392:                             /* debugger 'restart' signal */
<a name="747"></a>            /* it's a debugger signal */
<a name="748"></a>            return true;
<a name="749"></a>
<a name="750"></a>        default:
<a name="751"></a>            /* not a debugger signal */
<a name="752"></a>            return nil;
<a name="753"></a>        }
<a name="754"></a>    }
<a name="755"></a>
<a name="756"></a>    /* the VM error number of the exception */
<a name="757"></a>    errno_ = 0
<a name="758"></a>
<a name="759"></a>    /* the exception message, provided to us by the VM after creation */
<a name="760"></a>    exceptionMessage = ''
<a name="761"></a>
<a name="762"></a>    /* the stack trace, which we store at the time we're created */
<a name="763"></a>    stack_ = nil
<a name="764"></a>;
<a name="765"></a>
<a name="766"></a>/*
<a name="767"></a> *   Export our RuntimeError class so that the VM knows about it and can
<a name="768"></a> *   create instances of it.  Also export our exceptionMessage property,
<a name="769"></a> *   so the VM can store its explanatory text there.
<a name="770"></a> */
<a name="771"></a>export RuntimeError;
<a name="772"></a>export exceptionMessage;
<a name="773"></a>
<a name="774"></a>/*
<a name="775"></a> *   Unknown character set exception - this is thrown from any routine that
<a name="776"></a> *   needs a local character set mapping when no mapping exists on the local
<a name="777"></a> *   platform. 
<a name="778"></a> */
<a name="779"></a>class UnknownCharSetException: Exception
<a name="780"></a>;
<a name="781"></a>
<a name="782"></a>/* 
<a name="783"></a> *   this exception object must be exported for use by the CharacterSet
<a name="784"></a> *   intrinsic class 
<a name="785"></a> */
<a name="786"></a>export UnknownCharSetException 'CharacterSet.UnknownCharSetException';
<a name="787"></a>
<a name="788"></a>
<a name="789"></a>/*
<a name="790"></a> *   A Program Exception terminates the entire program, passing an error
<a name="791"></a> *   indication to the operating system.  The VM doesn't provide a way to
<a name="792"></a> *   specify the *particular* error code to return to the OS, as there's no
<a name="793"></a> *   portable set of error codes; rather, the VM simply returns a code to
<a name="794"></a> *   the OS that means generically that an error occurred, if there's any
<a name="795"></a> *   such concept on the local operating system.  The VM will normally
<a name="796"></a> *   display this message just before it terminates the program, possibly
<a name="797"></a> *   with some additional text mentioning that a program error occurred
<a name="798"></a> *   (such as "unhandled exception: &lt;your message&gt;").
<a name="799"></a> */
<a name="800"></a>class ProgramException: Exception
<a name="801"></a>    construct(msg) { exceptionMessage = msg.htmlify(); }
<a name="802"></a>    displayException() { "&lt;&lt;exceptionMessage&gt;&gt; "; }
<a name="803"></a>;
<a name="804"></a>
<a name="805"></a>/* ------------------------------------------------------------------------ */
<a name="806"></a>/*
<a name="807"></a> *   Default string display function.  Our main entrypoint code
<a name="808"></a> *   establishes this function as the default output function.  
<a name="809"></a> */
<a name="810"></a>_default_display_fn(str) { _tads_io_say(str); }
<a name="811"></a>
<a name="812"></a>
<a name="813"></a>/* ------------------------------------------------------------------------ */
<a name="814"></a>/*
<a name="815"></a> *   The stack information object.  The intrinsic function
<a name="816"></a> *   t3GetStackTrace() in the 't3vm' function set returns a list of these
<a name="817"></a> *   objects; each object represents a level in the stack trace.  
<a name="818"></a> */
<a name="819"></a>class T3StackInfo: object
<a name="820"></a>    /*
<a name="821"></a>     *   Construct a stack level object.  The system invokes this
<a name="822"></a>     *   constructor with information on the stack level.
<a name="823"></a>     */
<a name="824"></a>    construct(func, obj, prop, selfObj, argList, srcInfo)
<a name="825"></a>    {
<a name="826"></a>        /* remember the values */
<a name="827"></a>        func_ = func;
<a name="828"></a>        obj_ = obj;
<a name="829"></a>        prop_ = prop;
<a name="830"></a>        self_ = selfObj;
<a name="831"></a>        argList_ = argList;
<a name="832"></a>        srcInfo_ = srcInfo;
<a name="833"></a>    }
<a name="834"></a>
<a name="835"></a>    /*
<a name="836"></a>     *   Is this a system routine?  This returns true if an intrinsic
<a name="837"></a>     *   function or an intrinsic class method is running at this level. 
<a name="838"></a>     */
<a name="839"></a>    isSystem()
<a name="840"></a>    {
<a name="841"></a>        /* 
<a name="842"></a>         *   if it's a system routine, we won't have a function OR an
<a name="843"></a>         *   object method 
<a name="844"></a>         */
<a name="845"></a>        return func_ == nil &amp;&amp; obj_ == nil;
<a name="846"></a>    }
<a name="847"></a>
<a name="848"></a>    /* 
<a name="849"></a>     *   the function running at this stack level - this is nil if an
<a name="850"></a>     *   object property is running instead of a function 
<a name="851"></a>     */
<a name="852"></a>    func_ = nil
<a name="853"></a>
<a name="854"></a>    /* 
<a name="855"></a>     *   The object and property running at this stack level - these are
<a name="856"></a>     *   nil if a function is running instead of an object method.  The
<a name="857"></a>     *   object is the object where the method is actually defined - this
<a name="858"></a>     *   might not be the same as self, because the object might have
<a name="859"></a>     *   inherited the method from a base class.  
<a name="860"></a>     */
<a name="861"></a>    obj_ = nil
<a name="862"></a>    prop_ = nil
<a name="863"></a>
<a name="864"></a>    /* 
<a name="865"></a>     *   the 'self' object at this level - this is nil if a function is
<a name="866"></a>     *   running at this level instead of an object method 
<a name="867"></a>     */
<a name="868"></a>    self_ = nil
<a name="869"></a>
<a name="870"></a>    /* the list of arguments to the function or method */
<a name="871"></a>    argList_ = []
<a name="872"></a>
<a name="873"></a>    /*
<a name="874"></a>     *   The source location of the next code to be executed in the
<a name="875"></a>     *   function or method in this frame.  If debugging records are
<a name="876"></a>     *   available for the current execution point in this frame, this
<a name="877"></a>     *   will contain a list of two values:
<a name="878"></a>     *   
<a name="879"></a>     *   srcInfo_[1] = string giving the name of the source file
<a name="880"></a>     *.  srcInfo_[2] = integer giving the line number in the source file
<a name="881"></a>     *   
<a name="882"></a>     *   If the program wasn't compiled with debugging records, or the
<a name="883"></a>     *   current code location in the frame doesn't have any source
<a name="884"></a>     *   information, this will be set to nil.
<a name="885"></a>     *   
<a name="886"></a>     *   Note that this gives the location of the *next* statement to be
<a name="887"></a>     *   executed in this frame, when control returns to the frame.  This
<a name="888"></a>     *   means that the location is frequently the next statement after
<a name="889"></a>     *   the one that called the next inner frame, because this is where
<a name="890"></a>     *   execution will resume when control returns to the frame.  
<a name="891"></a>     */
<a name="892"></a>    srcInfo_ = nil
<a name="893"></a>;
<a name="894"></a>
<a name="895"></a>/* export T3StackInfo for use by the system */
<a name="896"></a>export T3StackInfo;
<a name="897"></a>
<a name="898"></a>
<a name="899"></a>/* ------------------------------------------------------------------------ */
<a name="900"></a>/*
<a name="901"></a> *   global data object for this module
<a name="902"></a> */
<a name="903"></a>mainGlobal: object
<a name="904"></a>    /* flag: we've run pre-initialization */
<a name="905"></a>    preinited_ = nil
<a name="906"></a>
<a name="907"></a>    /* 
<a name="908"></a>     *   The global reflection object - if the program is compiled with
<a name="909"></a>     *   the standard reflection module, that module will set this
<a name="910"></a>     *   property to point to the reflection object.
<a name="911"></a>     *   
<a name="912"></a>     *   We use this so that we don't require the reflection module to be
<a name="913"></a>     *   included.  If the module isn't included, this will be nil, so
<a name="914"></a>     *   we'll know not to use reflection.  If this is not nil, we'll know
<a name="915"></a>     *   we can use reflection services.  
<a name="916"></a>     */
<a name="917"></a>    reflectionObj = nil
<a name="918"></a>
<a name="919"></a>    /*
<a name="920"></a>     *   Restart ID.  This is an integer that indicates how the main
<a name="921"></a>     *   entrypoint was last reached.  This is initially zero; each time
<a name="922"></a>     *   we restart the game, this is incremented.
<a name="923"></a>     *   
<a name="924"></a>     *   The restart ID is the only information that survives across a
<a name="925"></a>     *   restart boundary.  Other than this, entering via a restart is
<a name="926"></a>     *   exactly like loading the program from scratch; all other
<a name="927"></a>     *   information about the program state before the restart is lost in
<a name="928"></a>     *   the restart operation.  
<a name="929"></a>     */
<a name="930"></a>    restartID = 0
<a name="931"></a>
<a name="932"></a>    /* pointer to mainRestore function, if defined */
<a name="933"></a>    mainRestoreFunc = nil
<a name="934"></a>;
<a name="935"></a>
</pre>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/6/2009 from TADS version 3.0.18.1</div>
</body>
</html>
