<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>report.t</title></head><body>
<table class=ban><tr><td><h1>report.t</h1><td align=right><a href="../file/report.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/* 
<a name="4"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts.  All Rights Reserved. 
<a name="5"></a> *   
<a name="6"></a> *   TADS 3 Library: command reports
<a name="7"></a> *   
<a name="8"></a> *   This module defines the "command report" classes, which the command
<a name="9"></a> *   execution engine uses to keep track of the status of a command.  
<a name="10"></a> */
<a name="11"></a>
<a name="12"></a>#include "adv3.h"
<a name="13"></a>
<a name="14"></a>
<a name="15"></a>/* ------------------------------------------------------------------------ */
<a name="16"></a>/*
<a name="17"></a> *   Command report objects.  The library uses these to control how the
<a name="18"></a> *   text from a command is displayed.  Game code can also use report
<a name="19"></a> *   objects to show and control command results, but this isn't usually
<a name="20"></a> *   necessary; game code can usually simply display messages directly.
<a name="21"></a> *   
<a name="22"></a> *   Reports are divided into two broad classes: "default" and "full"
<a name="23"></a> *   reports.
<a name="24"></a> *   
<a name="25"></a> *   A "default" report is one that simply confirms that an action was
<a name="26"></a> *   performed, and provides little additional information.  The library
<a name="27"></a> *   uses default reports for simple commands whose full implications
<a name="28"></a> *   should normally be obvious to a player typing such commands: take,
<a name="29"></a> *   drop, put in, and the like.  The library's default reports are
<a name="30"></a> *   usually quite terse: "Taken", "Dropped", "Done".
<a name="31"></a> *   
<a name="32"></a> *   A "full" report is one that gives the player more information than a
<a name="33"></a> *   simple confirmation.  These reports typically describe either the
<a name="34"></a> *   changes to the game state caused by a command or surprising side
<a name="35"></a> *   effects of a command.  For example, if the command is "push button,"
<a name="36"></a> *   and pushing the button opens the door next to the button, a full
<a name="37"></a> *   report would describe the door opening.
<a name="38"></a> *   
<a name="39"></a> *   Note that a full report is warranted any time a command describes
<a name="40"></a> *   anything beyond a simple confirmation.  In our door-opening button
<a name="41"></a> *   example, opening the door by pushing the button always warrants a
<a name="42"></a> *   full report, even if the player has already seen the effects of the
<a name="43"></a> *   button a hundred times before, and even if the button is labeled
<a name="44"></a> *   "push to open door."  It doesn't matter whether or not the
<a name="45"></a> *   consequences of the command ought to be obvious to the player; what
<a name="46"></a> *   matters is that the command warrants a report beyond a simple
<a name="47"></a> *   confirmation.  Any time a report is more than a simple confirmation,
<a name="48"></a> *   it is a full report, no matter how obvious to the player the effects
<a name="49"></a> *   of the action.
<a name="50"></a> *   
<a name="51"></a> *   Full reports are further divided into three subcategories by time
<a name="52"></a> *   ordering: "main," "before," and "after."  "Before" and "after"
<a name="53"></a> *   reports are ordered before and after (respectively) a main report.  
<a name="54"></a> */
<a name="55"></a>class CommandReport: object
<a name="56"></a>    construct()
<a name="57"></a>    {
<a name="58"></a>        /* 
<a name="59"></a>         *   remember the action with which we're associated, unless a
<a name="60"></a>         *   subclass already specifically set the action 
<a name="61"></a>         */
<a name="62"></a>        if (action_ == nil)
<a name="63"></a>            action_ = gAction;
<a name="64"></a>    }
<a name="65"></a>
<a name="66"></a>    /* get/set my action */
<a name="67"></a>    getAction() { return action_; }
<a name="68"></a>    setAction(action) { action_ = action; }
<a name="69"></a>
<a name="70"></a>    /* check to see if my action is implicit */
<a name="71"></a>    isActionImplicit() { return action_ != nil &amp;&amp; action_.isImplicit; }
<a name="72"></a>
<a name="73"></a>    /* check to see if my action is nested in the other report's action */
<a name="74"></a>    isActionNestedIn(other)
<a name="75"></a>    {
<a name="76"></a>        return (action_ != nil
<a name="77"></a>                &amp;&amp; other.getAction() != nil
<a name="78"></a>                &amp;&amp; action_.isNestedIn(other.getAction()));
<a name="79"></a>    }
<a name="80"></a>
<a name="81"></a>    /*
<a name="82"></a>     *   Flag: if this property is true, this report indicates a failure.
<a name="83"></a>     *   By default, a report does not indicate failure.  
<a name="84"></a>     */
<a name="85"></a>    isFailure = nil
<a name="86"></a>
<a name="87"></a>    /*
<a name="88"></a>     *   Flag: if this property is true, this report indicates an
<a name="89"></a>     *   interruption for interactive input. 
<a name="90"></a>     */
<a name="91"></a>    isQuestion = nil
<a name="92"></a>
<a name="93"></a>    /* iteration number current when we were added to the transcript */
<a name="94"></a>    iter_ = nil
<a name="95"></a>
<a name="96"></a>    /* the action I'm associated with */
<a name="97"></a>    action_ = nil
<a name="98"></a>
<a name="99"></a>    /*
<a name="100"></a>     *   Am I part of the same action as the given report?  Returns true if
<a name="101"></a>     *   this action is part of the same iteration and part of the same
<a name="102"></a>     *   action as the other report.  
<a name="103"></a>     */
<a name="104"></a>    isPartOf(report)
<a name="105"></a>    {
<a name="106"></a>        /* 
<a name="107"></a>         *   if I don't have an action, or the other report doesn't have an
<a name="108"></a>         *   action, we're not related 
<a name="109"></a>         */
<a name="110"></a>        if (action_ == nil || report.action_ == nil)
<a name="111"></a>            return nil;
<a name="112"></a>
<a name="113"></a>        /* if our iterations don't match, we're not related */
<a name="114"></a>        if (iter_ != report.iter_)
<a name="115"></a>            return nil;
<a name="116"></a>
<a name="117"></a>        /* check if I'm part of the other report's action */
<a name="118"></a>        return action_.isPartOf(report.action_);
<a name="119"></a>    }
<a name="120"></a>;
<a name="121"></a>
<a name="122"></a>/*
<a name="123"></a> *   Group separator.  This simply displays separation between groups of
<a name="124"></a> *   messages - that is, between one set of messages associated with a
<a name="125"></a> *   single action and a set of messages associated with a different
<a name="126"></a> *   action.  
<a name="127"></a> */
<a name="128"></a>class GroupSeparatorMessage: CommandReport
<a name="129"></a>    construct(report)
<a name="130"></a>    {
<a name="131"></a>        /* use the same action and iteration as the given report */
<a name="132"></a>        action_ = report.getAction();
<a name="133"></a>        iter_ = report.iter_;
<a name="134"></a>    }
<a name="135"></a>
<a name="136"></a>    /* show the normal command results separator */
<a name="137"></a>    showMessage() { say(gLibMessages.complexResultsSeparator); }
<a name="138"></a>;
<a name="139"></a>
<a name="140"></a>/*
<a name="141"></a> *   Internal separator.  This displays separation within a group of
<a name="142"></a> *   messages for a command, to visually separate the results from an
<a name="143"></a> *   implied command from the results for the enclosing command. 
<a name="144"></a> */
<a name="145"></a>class InternalSeparatorMessage: CommandReport
<a name="146"></a>    construct(report)
<a name="147"></a>    {
<a name="148"></a>        /* use the same action and iteration as the given report */
<a name="149"></a>        action_ = report.getAction();
<a name="150"></a>        iter_ = report.iter_;
<a name="151"></a>    }
<a name="152"></a>
<a name="153"></a>    /* show the normal command results separator */
<a name="154"></a>    showMessage() { say(gLibMessages.internalResultsSeparator); }
<a name="155"></a>;
<a name="156"></a>
<a name="157"></a>/*
<a name="158"></a> *   Report boundary marker.  This is a pseudo-report that doesn't display
<a name="159"></a> *   anything; its purpose is to allow a caller to identify a block of
<a name="160"></a> *   reports (the reports between two markers) for later removal or
<a name="161"></a> *   reordering.  
<a name="162"></a> */
<a name="163"></a>class MarkerReport: CommandReport
<a name="164"></a>    showMessage() { }
<a name="165"></a>;
<a name="166"></a>
<a name="167"></a>/*
<a name="168"></a> *   End-of-description marker.  This serves as a marker in the transcript
<a name="169"></a> *   stream to let us know where the descriptive reports for a given
<a name="170"></a> *   action end.  
<a name="171"></a> */
<a name="172"></a>class EndOfDescReport: MarkerReport
<a name="173"></a>;
<a name="174"></a>
<a name="175"></a>/*
<a name="176"></a> *   Simple MessageResult-based command report 
<a name="177"></a> */
<a name="178"></a>class CommandReportMessage: CommandReport, MessageResult
<a name="179"></a>    construct([params])
<a name="180"></a>    {
<a name="181"></a>        /* invoke our base class constructors */
<a name="182"></a>        inherited CommandReport();
<a name="183"></a>        inherited MessageResult(params...);
<a name="184"></a>    }
<a name="185"></a>;
<a name="186"></a>
<a name="187"></a>/* 
<a name="188"></a> *   default report 
<a name="189"></a> */
<a name="190"></a>class DefaultCommandReport: CommandReportMessage
<a name="191"></a>;
<a name="192"></a>
<a name="193"></a>/*
<a name="194"></a> *   extra information report 
<a name="195"></a> */
<a name="196"></a>class ExtraCommandReport: CommandReportMessage
<a name="197"></a>;
<a name="198"></a>
<a name="199"></a>/*
<a name="200"></a> *   default descriptive report 
<a name="201"></a> */
<a name="202"></a>class DefaultDescCommandReport: CommandReportMessage
<a name="203"></a>;
<a name="204"></a>
<a name="205"></a>/*
<a name="206"></a> *   cosmetic spacing report 
<a name="207"></a> */
<a name="208"></a>class CosmeticSpacingCommandReport: CommandReportMessage
<a name="209"></a>;
<a name="210"></a>
<a name="211"></a>/*
<a name="212"></a> *   base class for all "full" reports 
<a name="213"></a> */
<a name="214"></a>class FullCommandReport: CommandReportMessage
<a name="215"></a>    /* 
<a name="216"></a>     *   a full report has a sequence number that tells us where the
<a name="217"></a>     *   report goes relative to the others - the higher this number, the
<a name="218"></a>     *   later the report goes 
<a name="219"></a>     */
<a name="220"></a>    seqNum = nil
<a name="221"></a>;
<a name="222"></a>
<a name="223"></a>/*
<a name="224"></a> *   "before" report - these come before the main report 
<a name="225"></a> */
<a name="226"></a>class BeforeCommandReport: FullCommandReport
<a name="227"></a>    seqNum = 1
<a name="228"></a>;
<a name="229"></a>
<a name="230"></a>/*
<a name="231"></a> *   main report 
<a name="232"></a> */
<a name="233"></a>class MainCommandReport: FullCommandReport
<a name="234"></a>    seqNum = 2
<a name="235"></a>;
<a name="236"></a>
<a name="237"></a>/*
<a name="238"></a> *   failure report 
<a name="239"></a> */
<a name="240"></a>class FailCommandReport: FullCommandReport
<a name="241"></a>    seqNum = 2
<a name="242"></a>    isFailure = true
<a name="243"></a>;
<a name="244"></a>
<a name="245"></a>/*
<a name="246"></a> *   failure marker - this is a silent report that marks an action as
<a name="247"></a> *   having failed without actually generating any message text 
<a name="248"></a> */
<a name="249"></a>class FailCommandMarker: MarkerReport
<a name="250"></a>    isFailure = true
<a name="251"></a>;
<a name="252"></a>
<a name="253"></a>/*
<a name="254"></a> *   "after" report - these come after the main report 
<a name="255"></a> */
<a name="256"></a>class AfterCommandReport: FullCommandReport
<a name="257"></a>    seqNum = 3
<a name="258"></a>;
<a name="259"></a>
<a name="260"></a>/*
<a name="261"></a> *   An interruption for interactive input.  This is used to report a
<a name="262"></a> *   prompt for more information that's needed before the command can
<a name="263"></a> *   proceed, such as a prompt for a missing object, or a disambiguation
<a name="264"></a> *   prompt. 
<a name="265"></a> */
<a name="266"></a>class QuestionCommandReport: MainCommandReport
<a name="267"></a>    isQuestion = true;
<a name="268"></a>;
<a name="269"></a>
<a name="270"></a>/*
<a name="271"></a> *   A conversation begin/end report.  This is a special marker we insert
<a name="272"></a> *   into the transcript to flag the boundaries of an NPC's conversational
<a name="273"></a> *   message.  
<a name="274"></a> */
<a name="275"></a>class ConvBoundaryReport: CommandReport
<a name="276"></a>    construct(id) { actorID = id; }
<a name="277"></a>
<a name="278"></a>    /* the actor's ID number, as assigned by the ConversationManager */
<a name="279"></a>    actorID = nil
<a name="280"></a>;
<a name="281"></a>class ConvBeginReport: ConvBoundaryReport
<a name="282"></a>    showMessage() { say('&lt;.convbegin ' + actorID + '&gt;'); }
<a name="283"></a>;
<a name="284"></a>class ConvEndReport: ConvBoundaryReport
<a name="285"></a>    construct(id, node)
<a name="286"></a>    {
<a name="287"></a>        inherited(id);
<a name="288"></a>        defConvNode = node;
<a name="289"></a>    }
<a name="290"></a>    
<a name="291"></a>    showMessage()
<a name="292"></a>    {
<a name="293"></a>        if (actorID != nil)
<a name="294"></a>            say('&lt;.convend ' + actorID + ' '
<a name="295"></a>                + (defConvNode == nil ? '' : defConvNode) + '&gt;');
<a name="296"></a>    }
<a name="297"></a>
<a name="298"></a>    /* the default new ConvNode for the actor */
<a name="299"></a>    defConvNode = nil
<a name="300"></a>;
<a name="301"></a>
<a name="302"></a>/* ------------------------------------------------------------------------ */
<a name="303"></a>/*
<a name="304"></a> *   Announcements.  We use these to track announcements to be made as
<a name="305"></a> *   part of an action's results. 
<a name="306"></a> */
<a name="307"></a>class CommandAnnouncement: CommandReport
<a name="308"></a>    construct([params])
<a name="309"></a>    {
<a name="310"></a>        /* inherit default handling */
<a name="311"></a>        inherited();
<a name="312"></a>
<a name="313"></a>        /* remember our text */
<a name="314"></a>        messageText_ = getMessageText(params...);
<a name="315"></a>    }
<a name="316"></a>
<a name="317"></a>    /* 
<a name="318"></a>     *   Get our message text.  By default, we simply get the gLibMessages
<a name="319"></a>     *   message given by the property. 
<a name="320"></a>     */
<a name="321"></a>    getMessageText([params])
<a name="322"></a>    {
<a name="323"></a>        /* get the library message */
<a name="324"></a>        return gLibMessages.(messageProp_)(params...);
<a name="325"></a>    }
<a name="326"></a>
<a name="327"></a>    /* 
<a name="328"></a>     *   Show our message.  Our default implementation shows the library
<a name="329"></a>     *   message given by our messageProp_ property, using the parameters
<a name="330"></a>     *   we stored in our constructor.  
<a name="331"></a>     */
<a name="332"></a>    showMessage()
<a name="333"></a>    {
<a name="334"></a>        /* call gLibMessages to show our message */
<a name="335"></a>        say(messageText_);
<a name="336"></a>    }
<a name="337"></a>
<a name="338"></a>    /* our gLibMessages property */
<a name="339"></a>    messageProp_ = nil
<a name="340"></a>
<a name="341"></a>    /* our message text */
<a name="342"></a>    messageText_ = ''
<a name="343"></a>;
<a name="344"></a>
<a name="345"></a>/*
<a name="346"></a> *   Multiple-object announcement.  When the player applies a single
<a name="347"></a> *   command to a series of objects (as in "take the book and the folder"
<a name="348"></a> *   or "take all"), we'll show one of these announcements for each object,
<a name="349"></a> *   just before we execute the command for that object.  This announcement
<a name="350"></a> *   usually just shows the object's name plus suitable punctuation (in
<a name="351"></a> *   English, a colon), and helps the player see which results go with
<a name="352"></a> *   which objects.  
<a name="353"></a> */
<a name="354"></a>class MultiObjectAnnouncement: CommandAnnouncement
<a name="355"></a>    /* show the announceMultiActionObject message */
<a name="356"></a>    messageProp_ = &amp;announceMultiActionObject
<a name="357"></a>;
<a name="358"></a>
<a name="359"></a>/*
<a name="360"></a> *   Default object announcement.  We display this announcement whenever
<a name="361"></a> *   the player leaves out a required object from a command, but the parser
<a name="362"></a> *   is able to infer which object they must have meant.  The parser infers
<a name="363"></a> *   that an object was intended when a verb requires an object that the
<a name="364"></a> *   player didn't specify, and there's only one logical choice for the
<a name="365"></a> *   missing object.  We announce our assumption to put it out in the open,
<a name="366"></a> *   to ensure that the player is immediately alerted if they had something
<a name="367"></a> *   else in mind.
<a name="368"></a> *   
<a name="369"></a> *   In English, this type of announcement conventionally consists of
<a name="370"></a> *   simply the name of the assumed object, in parenthesis and on a line by
<a name="371"></a> *   itself.  In cases where the object role involves a prepositional
<a name="372"></a> *   phrase in the verb structure, we generally show the preposition before
<a name="373"></a> *   the object name.  This format usually reads intuitively, by combining
<a name="374"></a> *   with the text just above of the player's own command:
<a name="375"></a> *
<a name="376"></a> *.  &gt;open
<a name="377"></a> *.  (the door&gt;
<a name="378"></a> *.  You try opening the door, but it seems to be locked.
<a name="379"></a> *.
<a name="380"></a> *.  &gt;unlock the door
<a name="381"></a> *   (with the key)
<a name="382"></a> */
<a name="383"></a>class DefaultObjectAnnouncement: CommandAnnouncement
<a name="384"></a>    construct(obj, whichObj, action, allResolved)
<a name="385"></a>    {
<a name="386"></a>        /* remember our object */
<a name="387"></a>        obj_ = obj;
<a name="388"></a>
<a name="389"></a>        /* remember the message parameters */
<a name="390"></a>        whichObj_ = whichObj;
<a name="391"></a>        allResolved_ = allResolved;
<a name="392"></a>
<a name="393"></a>        /* remember my action */
<a name="394"></a>        action_ = action;
<a name="395"></a>
<a name="396"></a>        /* inherit default handling */
<a name="397"></a>        inherited();
<a name="398"></a>    }
<a name="399"></a>
<a name="400"></a>    /* get our message text */
<a name="401"></a>    getMessageText()
<a name="402"></a>    {
<a name="403"></a>        /* get the announcement message from our object */
<a name="404"></a>        return obj_.announceDefaultObject(whichObj_, action_, allResolved_);
<a name="405"></a>    }
<a name="406"></a>
<a name="407"></a>    /* our defaulted object */
<a name="408"></a>    obj_ = nil
<a name="409"></a>
<a name="410"></a>    /* our message parameters */
<a name="411"></a>    whichObj_ = nil
<a name="412"></a>    allResolved_ = nil
<a name="413"></a>;
<a name="414"></a>
<a name="415"></a>/*
<a name="416"></a> *   Ambiguous object announcement.  We display this when the parser
<a name="417"></a> *   manages to resolve a noun phrase to an object (or objects) from an
<a name="418"></a> *   ambiguous set of possibilities, without having to ask the player for
<a name="419"></a> *   help but also without absolute certainty that the objects selected are
<a name="420"></a> *   the ones the player meant.  This happens when more than enough objects
<a name="421"></a> *   are logical possibilities for selection, but some objects are more
<a name="422"></a> *   logical choices than others.  The parser picks the most logical of the
<a name="423"></a> *   available options, but since other logical choices are present, the
<a name="424"></a> *   parser can't be certain that it chose the ones the player actually
<a name="425"></a> *   meant.  Because of this uncertainty, we generate one of these
<a name="426"></a> *   announcements each time this happens.  This report lets the player
<a name="427"></a> *   know exactly which object we chose, which will immediately alert the
<a name="428"></a> *   player when our selection is different from what they had in mind.
<a name="429"></a> *   
<a name="430"></a> *   In form, this type of announcement usually looks just like a default
<a name="431"></a> *   object announcement.  
<a name="432"></a> */
<a name="433"></a>class AmbigObjectAnnouncement: CommandAnnouncement
<a name="434"></a>    /* show the announceAmbigObject announcement */
<a name="435"></a>    messageProp_ = &amp;announceAmbigActionObject
<a name="436"></a>;
<a name="437"></a>
<a name="438"></a>/*
<a name="439"></a> *   Remapped action announcement.  This is used when we need to mention a
<a name="440"></a> *   defaulted or disambiguated object, but the player's original input was
<a name="441"></a> *   remapped to a different action that rearranges the object roles.  In
<a name="442"></a> *   these cases, rather than just announcing the defaulted object name, we
<a name="443"></a> *   announce the entire remapped action; we show the full action
<a name="444"></a> *   description because rearrangement of the object roles usually makes
<a name="445"></a> *   the standard object-only announcement confusing to read, since it
<a name="446"></a> *   doesn't naturally fit in as a continuation of what the user typed.
<a name="447"></a> *   
<a name="448"></a> *   In English, this message is usually shown with the entire verb phrase,
<a name="449"></a> *   in present participle form ("opening the door"), enclosed in
<a name="450"></a> *   parentheses and on a line by itself.  
<a name="451"></a> */
<a name="452"></a>class RemappedActionAnnouncement: CommandAnnouncement
<a name="453"></a>    construct()
<a name="454"></a>    {
<a name="455"></a>        /* use the action as the message parameter */
<a name="456"></a>        inherited(gAction);
<a name="457"></a>    }
<a name="458"></a>
<a name="459"></a>    messageProp_ = &amp;announceRemappedAction
<a name="460"></a>;
<a name="461"></a>
<a name="462"></a>/*
<a name="463"></a> *   Each language module must define a class called
<a name="464"></a> *   ImplicitAnnouncementContext, and three instances of the class, for use
<a name="465"></a> *   by the generic library.  The language module can define other
<a name="466"></a> *   instances of the context class as needed.  We minimally need the
<a name="467"></a> *   following instances to be defined by the language module:
<a name="468"></a> *   
<a name="469"></a> *   standardImpCtx: this is the standard context, which indicates that we
<a name="470"></a> *   want the default format for the implicit action announcement.
<a name="471"></a> *   
<a name="472"></a> *   tryingImpCtx: this is the "trying" context, which indicates that we
<a name="473"></a> *   want the announcement to phrase the action to indicate that we're only
<a name="474"></a> *   trying the action, not actually performing it.  We use this when the
<a name="475"></a> *   implicit action has failed, in which case we want our announcement to
<a name="476"></a> *   say that we're merely attempting the action; the announcement
<a name="477"></a> *   shouldn't imply that the action has actually been performed.
<a name="478"></a> *   
<a name="479"></a> *   askingImpCtx: this is the "asking" context, which indicates that the
<a name="480"></a> *   action was interrupted with an interactive question, such as a prompt
<a name="481"></a> *   for a missing direct object.
<a name="482"></a> *   
<a name="483"></a> *   We leave it up to the language module to define the class and these
<a name="484"></a> *   two instances.  This lets the language module represent the context
<a name="485"></a> *   types any way it likes.  
<a name="486"></a> */
<a name="487"></a>
<a name="488"></a>/*
<a name="489"></a> *   Implicit action announcement.  This is displayed when we perform a
<a name="490"></a> *   command implicitly, which we usually do to fulfill a precondition of
<a name="491"></a> *   an action.
<a name="492"></a> *   
<a name="493"></a> *   In English, we usually show an implied action as the verb participle
<a name="494"></a> *   phrase ("opening the door"), prefixed with "first", and enclosed in
<a name="495"></a> *   parentheses on a line by itself (hence, "(first opening the door)").  
<a name="496"></a> */
<a name="497"></a>class ImplicitActionAnnouncement: CommandAnnouncement
<a name="498"></a>    construct(action, msg)
<a name="499"></a>    {
<a name="500"></a>        /* use the given message property */
<a name="501"></a>        messageProp_ = msg;
<a name="502"></a>
<a name="503"></a>        /* 
<a name="504"></a>         *   Inherit default.  The first message parameter is the action;
<a name="505"></a>         *   the second is our standard implicit action context object,
<a name="506"></a>         *   indicating that we want the normal context.  
<a name="507"></a>         */
<a name="508"></a>        inherited(action, standardImpCtx);
<a name="509"></a>    }
<a name="510"></a>
<a name="511"></a>    /* 
<a name="512"></a>     *   Make this announcement silent.  This eliminates any announcement
<a name="513"></a>     *   for this action, but makes it otherwise behave like a normal
<a name="514"></a>     *   implied action. 
<a name="515"></a>     */
<a name="516"></a>    makeSilent()
<a name="517"></a>    {
<a name="518"></a>        /* clear my message text */
<a name="519"></a>        messageText_ = '';
<a name="520"></a>
<a name="521"></a>        /* 
<a name="522"></a>         *   use the silent announcement message if we have to regenerate
<a name="523"></a>         *   our text for another context 
<a name="524"></a>         */
<a name="525"></a>        messageProp_ = &amp;silentImplicitAction;
<a name="526"></a>    }
<a name="527"></a>
<a name="528"></a>    /*
<a name="529"></a>     *   Note that the action we're attempting is merely an attempt that
<a name="530"></a>     *   failed.  This will change our report to indicate that we're only
<a name="531"></a>     *   trying the action, rather than suggesting that we actually carried
<a name="532"></a>     *   it out.  
<a name="533"></a>     */
<a name="534"></a>    noteJustTrying()
<a name="535"></a>    {
<a name="536"></a>        /* note that we're just trying the action */
<a name="537"></a>        justTrying = true;
<a name="538"></a>
<a name="539"></a>        /* change our message to the "trying" form */
<a name="540"></a>        messageText_ = getMessageText(getAction(), tryingImpCtx);
<a name="541"></a>    }
<a name="542"></a>
<a name="543"></a>    /* 
<a name="544"></a>     *   Note that the action we're attempting is incomplete, as it was
<a name="545"></a>     *   interupted for interactive input (such as asking for a missing
<a name="546"></a>     *   object). 
<a name="547"></a>     */
<a name="548"></a>    noteQuestion()
<a name="549"></a>    {
<a name="550"></a>        /* note that the action was interrupted with a question */
<a name="551"></a>        justAsking = true;
<a name="552"></a>
<a name="553"></a>        /* change our message to the "asking" form */
<a name="554"></a>        messageText_ = getMessageText(getAction(), askingImpCtx);
<a name="555"></a>    }
<a name="556"></a>
<a name="557"></a>    /* 
<a name="558"></a>     *   Flag: we're just attempting the action; this is set when we
<a name="559"></a>     *   determine that the implicit action has failed, in which case we
<a name="560"></a>     *   want an announcement indicating that we're merely attempting the
<a name="561"></a>     *   action, not actually performing it.  Presume that we're actually
<a name="562"></a>     *   going to perform the action; the action can change this if
<a name="563"></a>     *   necessary.  
<a name="564"></a>     */
<a name="565"></a>    justTrying = nil
<a name="566"></a>
<a name="567"></a>    /* flag: the action was interrupted with an interactive question */
<a name="568"></a>    justAsking = nil
<a name="569"></a>;
<a name="570"></a>
<a name="571"></a>class CommandSepAnnouncement: CommandAnnouncement
<a name="572"></a>    construct()
<a name="573"></a>    {
<a name="574"></a>        /* we're not associated with an iteration or action */
<a name="575"></a>        action_ = nil;
<a name="576"></a>        iter_ = 0;
<a name="577"></a>    }
<a name="578"></a>
<a name="579"></a>    showMessage()
<a name="580"></a>    {
<a name="581"></a>        /* show a command separator */
<a name="582"></a>        "&lt;.commandsep&gt;";
<a name="583"></a>    }
<a name="584"></a>;
<a name="585"></a>
<a name="586"></a>/* ------------------------------------------------------------------------ */
<a name="587"></a>/*
<a name="588"></a> *   Command Transcript.  This is a "semantic transcript" of the results of
<a name="589"></a> *   a command.  This provides a list of CommandReport objects describing
<a name="590"></a> *   the results of the command.  
<a name="591"></a> */
<a name="592"></a>class CommandTranscript: OutputFilter
<a name="593"></a>    construct()
<a name="594"></a>    {
<a name="595"></a>        /* set up a vector to hold the reports */
<a name="596"></a>        reports_ = new Vector(5);
<a name="597"></a>    }
<a name="598"></a>
<a name="599"></a>    /* 
<a name="600"></a>     *   flag: the command has failed (i.e., at least one failure report
<a name="601"></a>     *   has been generated) 
<a name="602"></a>     */
<a name="603"></a>    isFailure = nil
<a name="604"></a>
<a name="605"></a>    /*
<a name="606"></a>     *   Note that the current action has failed.  This is equivalent to
<a name="607"></a>     *   adding a reportFailure() message to the transcript.  
<a name="608"></a>     */
<a name="609"></a>    noteFailure()
<a name="610"></a>    {
<a name="611"></a>        /* add an empty reportFailure message */
<a name="612"></a>        reportFailure('');
<a name="613"></a>    }
<a name="614"></a>
<a name="615"></a>    /*
<a name="616"></a>     *   Did the given action fail?  This scans the transcript to determine
<a name="617"></a>     *   if there are any failure messages associated with the given
<a name="618"></a>     *   action.   
<a name="619"></a>     */
<a name="620"></a>    actionFailed(action)
<a name="621"></a>    {
<a name="622"></a>        /* 
<a name="623"></a>         *   scan the transcript for failure messages that are associated
<a name="624"></a>         *   with the given action 
<a name="625"></a>         */
<a name="626"></a>        return reports_.indexWhich(
<a name="627"></a>            {x: x.isPartOf(action) &amp;&amp; x.isFailure}) != nil;
<a name="628"></a>    }
<a name="629"></a>
<a name="630"></a>    /* 
<a name="631"></a>     *   flag: I'm active; when this is nil, we'll pass text through our
<a name="632"></a>     *   filter routine unchanged 
<a name="633"></a>     */
<a name="634"></a>    isActive = true
<a name="635"></a>
<a name="636"></a>    /*
<a name="637"></a>     *   Summarize the current action's reports.  This allows a caller to
<a name="638"></a>     *   turn a series of iterated reports into a single report for the
<a name="639"></a>     *   entire action.  For example, we could change something like this:
<a name="640"></a>     *   
<a name="641"></a>     *   gold coin: Bob accepts the gold coin.
<a name="642"></a>     *.  gold coin: Bob accepts the gold coin.
<a name="643"></a>     *.  gold coin: Bob accepts the gold coin.
<a name="644"></a>     *   
<a name="645"></a>     *   into this:
<a name="646"></a>     *   
<a name="647"></a>     *   Bob accepts the three gold coins.
<a name="648"></a>     *   
<a name="649"></a>     *   This function runs through the reports for the current action,
<a name="650"></a>     *   submitting each one to the 'cond' callback to see if it's of
<a name="651"></a>     *   interest to the summary.  For each consecutive run of two or more
<a name="652"></a>     *   reports that can be summarized, we'll remove the reports that
<a name="653"></a>     *   'cond' accepted, and we'll remove the multiple-object announcement
<a name="654"></a>     *   reports associated with them, and we'll insert a new report with
<a name="655"></a>     *   the message returned by the 'report' callback.
<a name="656"></a>     *   
<a name="657"></a>     *   'cond' is called as cond(x), where 'x' is a report object.  This
<a name="658"></a>     *   callback returns true if the report can be summarized for the
<a name="659"></a>     *   caller's purposes, nil if not.
<a name="660"></a>     *   
<a name="661"></a>     *   'report' is called as report(vec), where 'vec' is a Vector
<a name="662"></a>     *   consisting of all of the consecutive report objects that we're now
<a name="663"></a>     *   summarizing.  This function returns a string giving the message to
<a name="664"></a>     *   use in place of the reports we're removing.  This should be a
<a name="665"></a>     *   summary message, standing in for the set of individual reports
<a name="666"></a>     *   we're removing.
<a name="667"></a>     *   
<a name="668"></a>     *   There's an important subtlety to note.  If the messages you're
<a name="669"></a>     *   summarizing are conversational (that is, if they're generated by
<a name="670"></a>     *   TopicEntry responses), you should take care to generate the full
<a name="671"></a>     *   replacement text in the 'report' part, rather than doing so in
<a name="672"></a>     *   separate code that you run after summarizeAction() returns.  This
<a name="673"></a>     *   is important because it ensures that the Conversation Manager
<a name="674"></a>     *   knows that your replacement message is part of the same
<a name="675"></a>     *   conversation.  If you wait until after summarizeAction() returns
<a name="676"></a>     *   to generate more response text, the conversation manager won't
<a name="677"></a>     *   realize that the additional text is part of the same conversation.
<a name="678"></a>     */
<a name="679"></a>    summarizeAction(cond, report)
<a name="680"></a>    {
<a name="681"></a>        local vec = new Vector(8);
<a name="682"></a>        local rpt = reports_;
<a name="683"></a>        local cnt = rpt.length();
<a name="684"></a>        local i;
<a name="685"></a>
<a name="686"></a>        /* find the first report for the current action */
<a name="687"></a>        for (i = 1 ; i &lt;= cnt &amp;&amp; rpt[i].getAction() != gAction ; ++i) ;
<a name="688"></a>
<a name="689"></a>        /* iterate over the transcript for the current action */
<a name="690"></a>        for ( ; ; ++i)
<a name="691"></a>        {
<a name="692"></a>            local ok;
<a name="693"></a>
<a name="694"></a>            /* presume we won't find a summarizable item */
<a name="695"></a>            ok = nil;
<a name="696"></a>            
<a name="697"></a>            /* if we're still in range, check what we have */
<a name="698"></a>            if (i &lt;= cnt)
<a name="699"></a>            {
<a name="700"></a>                /* get the current item */
<a name="701"></a>                local cur = rpt[i];
<a name="702"></a>
<a name="703"></a>                /* if this one is of interest, note it in the vector */
<a name="704"></a>                if (cond(cur))
<a name="705"></a>                {
<a name="706"></a>                    /* add it to our vector of summarizable reports */
<a name="707"></a>                    vec.append(cur);
<a name="708"></a>
<a name="709"></a>                    /* note that we're okay on this round */
<a name="710"></a>                    ok = true;
<a name="711"></a>                }
<a name="712"></a>                else if (cur.ofKind(ImplicitActionAnnouncement)
<a name="713"></a>                         || cur.ofKind(MultiObjectAnnouncement)
<a name="714"></a>                         || cur.ofKind(DefaultCommandReport)
<a name="715"></a>                         || cur.ofKind(ConvBoundaryReport))
<a name="716"></a>                {
<a name="717"></a>                    /* we can keep these in summaries */
<a name="718"></a>                    ok = true;
<a name="719"></a>                }
<a name="720"></a>            }
<a name="721"></a>
<a name="722"></a>            /* 
<a name="723"></a>             *   If this item isn't summarizable, or we've reached the last
<a name="724"></a>             *   item, generate a summary of any we have so far.  (We need
<a name="725"></a>             *   to generate the summary on reaching the last item because
<a name="726"></a>             *   there are no further items that could go in the summary.)
<a name="727"></a>             */
<a name="728"></a>            if (!ok || i == cnt)
<a name="729"></a>            {
<a name="730"></a>                /* if we have two or more items, generate a summary */
<a name="731"></a>                if (vec.length() &gt; 1)
<a name="732"></a>                {
<a name="733"></a>                    local insIdx;
<a name="734"></a>                    local txt;
<a name="735"></a>                
<a name="736"></a>                    /* remove each item in the vector */
<a name="737"></a>                    foreach (local cur in vec)
<a name="738"></a>                    {
<a name="739"></a>                        local idx;
<a name="740"></a>                        
<a name="741"></a>                        /* get the index of the current item */
<a name="742"></a>                        idx = rpt.indexOf(cur);
<a name="743"></a>
<a name="744"></a>                        /* 
<a name="745"></a>                         *   we're summarizing this item, so remove the
<a name="746"></a>                         *   individual item - subsume it into the summary 
<a name="747"></a>                         */
<a name="748"></a>                        rpt.removeElementAt(idx);
<a name="749"></a>                        --i;
<a name="750"></a>                        --cnt;
<a name="751"></a>
<a name="752"></a>                        /* insert the summary here */
<a name="753"></a>                        insIdx = idx;
<a name="754"></a>
<a name="755"></a>                        /* 
<a name="756"></a>                         *   skip any implicit action announcements,
<a name="757"></a>                         *   default command announcements, and
<a name="758"></a>                         *   conversational boundary markers 
<a name="759"></a>                         */
<a name="760"></a>                        for (--idx ;
<a name="761"></a>                             idx &gt; 0
<a name="762"></a>                             &amp;&amp; (rpt[idx].ofKind(ImplicitActionAnnouncement)
<a name="763"></a>                                 || rpt[idx].ofKind(DefaultCommandReport)
<a name="764"></a>                                 || rpt[idx].ofKind(ConvBoundaryReport)) ;
<a name="765"></a>                             --idx) ;
<a name="766"></a>
<a name="767"></a>                        /*
<a name="768"></a>                         *   if the preceding element is a multi-object
<a name="769"></a>                         *   announcement, remove it - let the summary
<a name="770"></a>                         *   mention the individual objects if it wants to 
<a name="771"></a>                         */
<a name="772"></a>                        if (idx &gt; 0
<a name="773"></a>                            &amp;&amp; rpt[idx].ofKind(MultiObjectAnnouncement))
<a name="774"></a>                        {
<a name="775"></a>                            /* remove this element and adjust the counters */
<a name="776"></a>                            rpt.removeElementAt(idx);
<a name="777"></a>                            --i;
<a name="778"></a>                            --cnt;
<a name="779"></a>                            --insIdx;
<a name="780"></a>
<a name="781"></a>                            /*
<a name="782"></a>                             *   If this leaves us with a &lt;.convbegin&gt;
<a name="783"></a>                             *   preceded directly by a &lt;.convend&gt; for the
<a name="784"></a>                             *   same actor, the two cancel each other out.
<a name="785"></a>                             *   Simply remove both of them.  
<a name="786"></a>                             */
<a name="787"></a>                            if (idx &lt;= rpt.length()
<a name="788"></a>                                &amp;&amp; idx &gt; 1
<a name="789"></a>                                &amp;&amp; rpt[idx].ofKind(ConvBeginReport)
<a name="790"></a>                                &amp;&amp; rpt[idx-1].ofKind(ConvEndReport)
<a name="791"></a>                                &amp;&amp; rpt[idx].actorID == rpt[idx-1].actorID)
<a name="792"></a>                            {
<a name="793"></a>                                /* 
<a name="794"></a>                                 *   we have a canceling &lt;.convend&gt; +
<a name="795"></a>                                 *   &lt;.convbegin&gt; pair - simply remove them
<a name="796"></a>                                 *   both and adjust the counters
<a name="797"></a>                                 *   accordingly 
<a name="798"></a>                                 */
<a name="799"></a>                                rpt.removeRange(idx - 1, idx);
<a name="800"></a>                                i -= 2;
<a name="801"></a>                                cnt -= 2;
<a name="802"></a>                                insIdx -= 2;
<a name="803"></a>                            }
<a name="804"></a>                        }
<a name="805"></a>                    }
<a name="806"></a>
<a name="807"></a>                    /* ask the caller for the summary */
<a name="808"></a>                    txt = report(vec);
<a name="809"></a>
<a name="810"></a>                    /* insert it */
<a name="811"></a>                    rpt.insertAt(insIdx, new MainCommandReport(txt));
<a name="812"></a>                    ++cnt;
<a name="813"></a>                    ++i;
<a name="814"></a>                }
<a name="815"></a>
<a name="816"></a>                /* clear the vector */
<a name="817"></a>                if (vec.length() &gt; 0)
<a name="818"></a>                    vec.removeRange(1, vec.length());
<a name="819"></a>            }
<a name="820"></a>
<a name="821"></a>            /* if we've reached the end of the list, we're done */
<a name="822"></a>            if (i &gt; cnt)
<a name="823"></a>                break;
<a name="824"></a>        }
<a name="825"></a>    }
<a name="826"></a>
<a name="827"></a>    /* activate - set up to capture output */
<a name="828"></a>    activate()
<a name="829"></a>    {
<a name="830"></a>        /* make myself active */
<a name="831"></a>        isActive = true;
<a name="832"></a>    }
<a name="833"></a>
<a name="834"></a>    /* deactivate - stop capturing output */
<a name="835"></a>    deactivate()
<a name="836"></a>    {
<a name="837"></a>        /* make myself inactive */
<a name="838"></a>        isActive = nil;
<a name="839"></a>    }
<a name="840"></a>
<a name="841"></a>    /* 
<a name="842"></a>     *   Count an iteration.  An Action should call this once per iteration
<a name="843"></a>     *   if it's a top-level (non-nested) command.
<a name="844"></a>     */
<a name="845"></a>    newIter() { ++iter_; }
<a name="846"></a>
<a name="847"></a>    /* 
<a name="848"></a>     *   Flush the transcript in preparation for reading input.  This shows
<a name="849"></a>     *   all pending reports, clears the backlog of reports (so that we
<a name="850"></a>     *   don't show them again in the future), and deactivates the
<a name="851"></a>     *   transcript's capture feature so that subsequent output goes
<a name="852"></a>     *   directly to the output stream.
<a name="853"></a>     *   
<a name="854"></a>     *   We return the former activation status - that is, we return true
<a name="855"></a>     *   if the transcript was activated before the call, nil if not.  
<a name="856"></a>     */
<a name="857"></a>    flushForInput()
<a name="858"></a>    {
<a name="859"></a>        /* show our reports, and deactivate output capture */
<a name="860"></a>        local wasActive = showReports(true);
<a name="861"></a>
<a name="862"></a>        /* clear the reports, since we've now shown them all */
<a name="863"></a>        clearReports();
<a name="864"></a>
<a name="865"></a>        /* return the previous activation status */
<a name="866"></a>        return wasActive;
<a name="867"></a>    }
<a name="868"></a>
<a name="869"></a>    /* 
<a name="870"></a>     *   Show our reports.  Returns true if the transcript was previously
<a name="871"></a>     *   active, nil if not. 
<a name="872"></a>     */
<a name="873"></a>    showReports(deact)
<a name="874"></a>    {
<a name="875"></a>        local wasActive;
<a name="876"></a>        
<a name="877"></a>        /* 
<a name="878"></a>         *   remember whether we were active or not originally, then
<a name="879"></a>         *   deactivate (maybe just temporarily) so that we can write out
<a name="880"></a>         *   our reports without recursively intercepting them
<a name="881"></a>         */
<a name="882"></a>        wasActive = isActive;
<a name="883"></a>        deactivate();
<a name="884"></a>
<a name="885"></a>        /* first, apply all defined transformations to our transcript */
<a name="886"></a>        applyTransforms();
<a name="887"></a>        
<a name="888"></a>        /*
<a name="889"></a>         *   Temporarily cancel any sense context message blocking.  We
<a name="890"></a>         *   have already taken into account for each report whether or
<a name="891"></a>         *   not the report was visible when it was generated, so we can
<a name="892"></a>         *   display each report that made it past that check without any
<a name="893"></a>         *   further conditions.  
<a name="894"></a>         */
<a name="895"></a>        callWithSenseContext(nil, nil, new function()
<a name="896"></a>        {
<a name="897"></a>            /* show the reports */            
<a name="898"></a>            foreach (local cur in reports_)
<a name="899"></a>            {
<a name="900"></a>                /* if we're allowed to show this report, show it */
<a name="901"></a>                if (canShowReport(cur))
<a name="902"></a>                    cur.showMessage();
<a name="903"></a>            }
<a name="904"></a>        });
<a name="905"></a>            
<a name="906"></a>        /* 
<a name="907"></a>         *   if we were active and we're not being asked to deactivate,
<a name="908"></a>         *   re-activate now that we're finished showing our reports 
<a name="909"></a>         */
<a name="910"></a>        if (wasActive &amp;&amp; !deact)
<a name="911"></a>            activate();
<a name="912"></a>
<a name="913"></a>        /* return the former activation status */
<a name="914"></a>        return wasActive;
<a name="915"></a>    }
<a name="916"></a>
<a name="917"></a>    /*
<a name="918"></a>     *   Add a report. 
<a name="919"></a>     */
<a name="920"></a>    addReport(report)
<a name="921"></a>    {
<a name="922"></a>        /* check for a failure report */
<a name="923"></a>        if (report.isFailure)
<a name="924"></a>        {
<a name="925"></a>            /* set the failure flag for the entire command */
<a name="926"></a>            isFailure = true;
<a name="927"></a>
<a name="928"></a>            /* 
<a name="929"></a>             *   If this is an implied command, and the actor is in "NPC
<a name="930"></a>             *   mode", suppress the report.  When an implied action fails
<a name="931"></a>             *   in NPC mode, we act as though we never attempted the
<a name="932"></a>             *   action. 
<a name="933"></a>             */
<a name="934"></a>            if (gAction.isImplicit &amp;&amp; gActor.impliedCommandMode() == ModeNPC)
<a name="935"></a>            {
<a name="936"></a>                /* add a failure marker, not the message report */
<a name="937"></a>                reports_.append(new FailCommandMarker());
<a name="938"></a>
<a name="939"></a>                /* that's all we need to add */
<a name="940"></a>                return;
<a name="941"></a>            }
<a name="942"></a>        }
<a name="943"></a>
<a name="944"></a>        /* 
<a name="945"></a>         *   Do not queue reports made while the sense context is blocking
<a name="946"></a>         *   output because the player character cannot sense the locus of
<a name="947"></a>         *   the action.  Note that this check comes before we queue the
<a name="948"></a>         *   report, but after we've noted any effect on the status of the
<a name="949"></a>         *   overall action; even if we're not going to show the report,
<a name="950"></a>         *   its status effects are still valid.  
<a name="951"></a>         */
<a name="952"></a>        if (senseContext.isBlocking)
<a name="953"></a>            return;
<a name="954"></a>
<a name="955"></a>        /* 
<a name="956"></a>         *   If the new report's iteration ID hasn't been set already, note
<a name="957"></a>         *   the current iteration in the report.  Some types of reports
<a name="958"></a>         *   will have already set a specific iteration before we get here,
<a name="959"></a>         *   so set the iteration ID only if the report hasn't done so
<a name="960"></a>         *   already.  
<a name="961"></a>         */
<a name="962"></a>        if (report.iter_ == nil)
<a name="963"></a>            report.iter_ = iter_;
<a name="964"></a>
<a name="965"></a>        /* append the report */
<a name="966"></a>        reports_.append(report);
<a name="967"></a>    }
<a name="968"></a>
<a name="969"></a>    /* get the last report added */
<a name="970"></a>    getLastReport()
<a name="971"></a>    {
<a name="972"></a>        local cnt = reports_.length();
<a name="973"></a>        return (cnt == 0 ? nil : reports_[cnt]);
<a name="974"></a>    }
<a name="975"></a>
<a name="976"></a>    /* delete the last report added */
<a name="977"></a>    deleteLastReport()
<a name="978"></a>    {
<a name="979"></a>        local cnt = reports_.length();
<a name="980"></a>        if (cnt != 0)
<a name="981"></a>            reports_.removeElementAt(cnt);
<a name="982"></a>    }
<a name="983"></a>
<a name="984"></a>    /*
<a name="985"></a>     *   Add a marker report.  This adds a marker to the report stream,
<a name="986"></a>     *   and returns the marker object.  The marker doesn't show any
<a name="987"></a>     *   message in the final display, but callers can use a pair of
<a name="988"></a>     *   markers to identify a range of reports for later reordering or
<a name="989"></a>     *   removal. 
<a name="990"></a>     */
<a name="991"></a>    addMarker()
<a name="992"></a>    {
<a name="993"></a>        /* create the new report */
<a name="994"></a>        local marker = new MarkerReport();
<a name="995"></a>
<a name="996"></a>        /* add it to the stream */
<a name="997"></a>        addReport(marker);
<a name="998"></a>
<a name="999"></a>        /* return the new report */
<a name="1000"></a>        return marker;
<a name="1001"></a>    }
<a name="1002"></a>
<a name="1003"></a>    /* delete the reports between two markers */
<a name="1004"></a>    deleteRange(marker1, marker2)
<a name="1005"></a>    {
<a name="1006"></a>        local idx1, idx2;
<a name="1007"></a>        
<a name="1008"></a>        /* find the indices of the two markers */
<a name="1009"></a>        idx1 = reports_.indexOf(marker1);
<a name="1010"></a>        idx2 = reports_.indexOf(marker2);
<a name="1011"></a>
<a name="1012"></a>        /* if we found both, delete the range */
<a name="1013"></a>        if (idx1 != nil &amp;&amp; idx2 != nil)
<a name="1014"></a>            reports_.removeRange(idx1, idx2);
<a name="1015"></a>    }
<a name="1016"></a>
<a name="1017"></a>    /* 
<a name="1018"></a>     *   Pull out the reports between two markers, and reinsert them at
<a name="1019"></a>     *   the end of the transcript.  
<a name="1020"></a>     */
<a name="1021"></a>    moveRangeAppend(marker1, marker2)
<a name="1022"></a>    {
<a name="1023"></a>        local idx1, idx2;
<a name="1024"></a>        
<a name="1025"></a>        /* find the indices of the two markers */
<a name="1026"></a>        idx1 = reports_.indexOf(marker1);
<a name="1027"></a>        idx2 = reports_.indexOf(marker2);
<a name="1028"></a>
<a name="1029"></a>        /* if we didn't find both, ignore the request */
<a name="1030"></a>        if (idx1 == nil || idx2 == nil)
<a name="1031"></a>            return;
<a name="1032"></a>
<a name="1033"></a>        /* append each item in the range to the end of the report list */
<a name="1034"></a>        for (local i = idx1 ; i &lt;= idx2 ; ++i)
<a name="1035"></a>            reports_.append(reports_[i]);
<a name="1036"></a>
<a name="1037"></a>        /* delete the original copies */
<a name="1038"></a>        reports_.removeRange(idx1, idx2);
<a name="1039"></a>    }
<a name="1040"></a>
<a name="1041"></a>    /* 
<a name="1042"></a>     *   Perform a callback on all of the reports in the transcript.
<a name="1043"></a>     *   We'll invoke the given callback function func(rpt) once for each
<a name="1044"></a>     *   report, with the report object as the parameter. 
<a name="1045"></a>     */
<a name="1046"></a>    forEachReport(func) { reports_.forEach(func); }
<a name="1047"></a>
<a name="1048"></a>    /*
<a name="1049"></a>     *   End the description section of the report.  This adds a marker
<a name="1050"></a>     *   report that indicates that anything following (and part of the
<a name="1051"></a>     *   same action) is no longer part of the description; this can be
<a name="1052"></a>     *   important when we apply the default description suppression
<a name="1053"></a>     *   transformation, because it tells us not to consider the
<a name="1054"></a>     *   non-descriptive messages following this marker when, for example,
<a name="1055"></a>     *   suppressing default descriptive messages.  
<a name="1056"></a>     */
<a name="1057"></a>    endDescription()
<a name="1058"></a>    {
<a name="1059"></a>        /* add an end-of-description report */
<a name="1060"></a>        addReport(new EndOfDescReport());
<a name="1061"></a>    }
<a name="1062"></a>
<a name="1063"></a>    /*
<a name="1064"></a>     *   Announce that the action is implicit
<a name="1065"></a>     */
<a name="1066"></a>    announceImplicit(action, msgProp)
<a name="1067"></a>    {
<a name="1068"></a>        /* 
<a name="1069"></a>         *   If the actor performing the command is not in "player" mode,
<a name="1070"></a>         *   save an implicit action announcement; for NPC mode, we treat
<a name="1071"></a>         *   implicit command results like any other results, so we don't
<a name="1072"></a>         *   want a separate announcement.  
<a name="1073"></a>         */
<a name="1074"></a>        if (gActor.impliedCommandMode() == ModePlayer)
<a name="1075"></a>        {
<a name="1076"></a>            /* create the new report */
<a name="1077"></a>            local report = new ImplicitActionAnnouncement(action, msgProp);
<a name="1078"></a>
<a name="1079"></a>            /* add it to the transcript */
<a name="1080"></a>            addReport(report);
<a name="1081"></a>
<a name="1082"></a>            /* return it */
<a name="1083"></a>            return report;
<a name="1084"></a>        }
<a name="1085"></a>        else
<a name="1086"></a>        {
<a name="1087"></a>            /* no need for a report */
<a name="1088"></a>            return nil;
<a name="1089"></a>        }
<a name="1090"></a>    }
<a name="1091"></a>
<a name="1092"></a>    /*
<a name="1093"></a>     *   Announce a remapped action 
<a name="1094"></a>     */
<a name="1095"></a>    announceRemappedAction()
<a name="1096"></a>    {
<a name="1097"></a>        /* save a remapped-action announcement */
<a name="1098"></a>        addReport(new RemappedActionAnnouncement());
<a name="1099"></a>    }
<a name="1100"></a>
<a name="1101"></a>    /*
<a name="1102"></a>     *   Announce one of a set of objects to a multi-object action.  We'll
<a name="1103"></a>     *   record this announcement for display with our report list.  
<a name="1104"></a>     */
<a name="1105"></a>    announceMultiActionObject(obj, whichObj)
<a name="1106"></a>    {
<a name="1107"></a>        /* save a multi-action object announcement */
<a name="1108"></a>        addReport(new MultiObjectAnnouncement(obj, whichObj, gAction));
<a name="1109"></a>    }
<a name="1110"></a>
<a name="1111"></a>    /*
<a name="1112"></a>     *   Announce an object that was resolved with slight ambiguity. 
<a name="1113"></a>     */
<a name="1114"></a>    announceAmbigActionObject(obj, whichObj)
<a name="1115"></a>    {
<a name="1116"></a>        /* save an ambiguous object announcement */
<a name="1117"></a>        addReport(new AmbigObjectAnnouncement(obj, whichObj, gAction));
<a name="1118"></a>    }
<a name="1119"></a>
<a name="1120"></a>    /*
<a name="1121"></a>     *   Announce a default object. 
<a name="1122"></a>     */
<a name="1123"></a>    announceDefaultObject(obj, whichObj, action, allResolved)
<a name="1124"></a>    {
<a name="1125"></a>        /* save the default object announcement */
<a name="1126"></a>        addReport(new DefaultObjectAnnouncement(
<a name="1127"></a>            obj, whichObj, action, allResolved));
<a name="1128"></a>    }
<a name="1129"></a>
<a name="1130"></a>    /*
<a name="1131"></a>     *   Add a command separator. 
<a name="1132"></a>     */
<a name="1133"></a>    addCommandSep()
<a name="1134"></a>    {
<a name="1135"></a>        /* add a command separator announcement */
<a name="1136"></a>        addReport(new CommandSepAnnouncement());
<a name="1137"></a>    }
<a name="1138"></a>
<a name="1139"></a>    /*
<a name="1140"></a>     *   clear our reports 
<a name="1141"></a>     */
<a name="1142"></a>    clearReports()
<a name="1143"></a>    {
<a name="1144"></a>        /* forget all of the reports in the main list */
<a name="1145"></a>        if (reports_.length() != 0)
<a name="1146"></a>            reports_.removeRange(1, reports_.length());
<a name="1147"></a>    }
<a name="1148"></a>
<a name="1149"></a>    /*
<a name="1150"></a>     *   Can we show a given report?  By default, we always return true,
<a name="1151"></a>     *   but subclasses might want to override this to suppress certain
<a name="1152"></a>     *   types of reports.  
<a name="1153"></a>     */
<a name="1154"></a>    canShowReport(report) { return true; }
<a name="1155"></a>
<a name="1156"></a>    /*
<a name="1157"></a>     *   Filter text.  If we're active, we'll turn the text into a command
<a name="1158"></a>     *   report and add it to our report list, blocking the text from
<a name="1159"></a>     *   reaching the underlying stream; otherwise, we'll pass it through
<a name="1160"></a>     *   unchanged.  
<a name="1161"></a>     */
<a name="1162"></a>    filterText(ostr, txt)
<a name="1163"></a>    {
<a name="1164"></a>        /* if we're inactive, pass text through unchanged */
<a name="1165"></a>        if (!isActive)
<a name="1166"></a>            return txt;
<a name="1167"></a>        
<a name="1168"></a>        /* 
<a name="1169"></a>         *   If the current sense context doesn't allow any messages to be
<a name="1170"></a>         *   generated, block the generated text entirely.  We want to
<a name="1171"></a>         *   block text or not according to the sense context in effect
<a name="1172"></a>         *   now; so we must note it now rather than wait until we
<a name="1173"></a>         *   actually display the report, since the context could be
<a name="1174"></a>         *   different by then.  
<a name="1175"></a>         */
<a name="1176"></a>        if (senseContext.isBlocking)
<a name="1177"></a>            return nil;
<a name="1178"></a>
<a name="1179"></a>        /* add a main report to our list if the text is non-empty */
<a name="1180"></a>        if (txt != '')
<a name="1181"></a>            addReport(new MainCommandReport(txt));
<a name="1182"></a>
<a name="1183"></a>        /* capture the text - send nothing to the underlying stream */
<a name="1184"></a>        return nil;
<a name="1185"></a>    }
<a name="1186"></a>
<a name="1187"></a>    /* apply transformations */
<a name="1188"></a>    applyTransforms()
<a name="1189"></a>    {
<a name="1190"></a>        /* apply each defined transformation */
<a name="1191"></a>        foreach (local cur in transforms_)
<a name="1192"></a>            cur.applyTransform(self, reports_);
<a name="1193"></a>    }
<a name="1194"></a>
<a name="1195"></a>    /* 
<a name="1196"></a>     *   check to see if the current action has a report matching the given
<a name="1197"></a>     *   criteria 
<a name="1198"></a>     */
<a name="1199"></a>    currentActionHasReport(func)
<a name="1200"></a>    {
<a name="1201"></a>        /* check to see if we can find a matching report */
<a name="1202"></a>        return (findCurrentActionReport(func) != nil);
<a name="1203"></a>    }
<a name="1204"></a>
<a name="1205"></a>    /* find a report in the current action that matches the given criteria */
<a name="1206"></a>    findCurrentActionReport(func)
<a name="1207"></a>    {
<a name="1208"></a>        /* 
<a name="1209"></a>         *   Find an action that's part of the current iteration and which
<a name="1210"></a>         *   matches the given function's criteria.  Return the first match
<a name="1211"></a>         *   we find.  
<a name="1212"></a>         */
<a name="1213"></a>        return reports_.valWhich({x: x.iter_ == iter_ &amp;&amp; (func)(x)});
<a name="1214"></a>    }
<a name="1215"></a>
<a name="1216"></a>    /* 
<a name="1217"></a>     *   iteration number - for an iterated top-level command, this helps
<a name="1218"></a>     *   us keep the results for a particular iteration grouped together 
<a name="1219"></a>     */
<a name="1220"></a>    iter_ = 1
<a name="1221"></a>
<a name="1222"></a>    /* our vector of reports */
<a name="1223"></a>    reports_ = nil
<a name="1224"></a>
<a name="1225"></a>    /* our list of transformations */
<a name="1226"></a>    transforms_ = [defaultReportTransform, implicitGroupTransform,
<a name="1227"></a>                   reportOrderTransform, complexMultiTransform]
<a name="1228"></a>;
<a name="1229"></a>
<a name="1230"></a>/* ------------------------------------------------------------------------ */
<a name="1231"></a>/*
<a name="1232"></a> *   Transcript Transform. 
<a name="1233"></a> */
<a name="1234"></a>class TranscriptTransform: object
<a name="1235"></a>    /*
<a name="1236"></a>     *   Apply our transform to the transcript vector.  By default, we do
<a name="1237"></a>     *   nothing; each subclass must override this to manipulate the vector
<a name="1238"></a>     *   to make the change it wants to make.  
<a name="1239"></a>     */
<a name="1240"></a>    applyTransform(trans, vec) { }
<a name="1241"></a>;
<a name="1242"></a>
<a name="1243"></a>/* ------------------------------------------------------------------------ */
<a name="1244"></a>/*
<a name="1245"></a> *   Transcript Transform: set before/main/after report order.  We'll look
<a name="1246"></a> *   for any before/after reports that are out of order with respect to
<a name="1247"></a> *   their main reports, and move them into the appropriate positions. 
<a name="1248"></a> */
<a name="1249"></a>reportOrderTransform: TranscriptTransform
<a name="1250"></a>    applyTransform(trans, vec)
<a name="1251"></a>    {
<a name="1252"></a>        /* scan for before/after reports */
<a name="1253"></a>        for (local i = 1, local len = vec.length() ; i &lt;= len ; ++i)
<a name="1254"></a>        {
<a name="1255"></a>            /* get this item */
<a name="1256"></a>            local cur = vec[i];
<a name="1257"></a>
<a name="1258"></a>            /* if this is a before/after report, consider moving it */
<a name="1259"></a>            if (cur.ofKind(FullCommandReport) &amp;&amp; cur.seqNum != nil)
<a name="1260"></a>            {
<a name="1261"></a>                local idx;
<a name="1262"></a>                
<a name="1263"></a>                /* 
<a name="1264"></a>                 *   This item cares about its sequencing, so it could be
<a name="1265"></a>                 *   out of order with respect to other items from the same
<a name="1266"></a>                 *   sequence.  Find the first item with a higher sequence
<a name="1267"></a>                 *   number from the same group, and make sure this item is
<a name="1268"></a>                 *   before the first such item.  
<a name="1269"></a>                 */
<a name="1270"></a>                for (idx = 1 ; idx &lt; i ; ++idx)
<a name="1271"></a>                {
<a name="1272"></a>                    local x;
<a name="1273"></a>                    
<a name="1274"></a>                    /* get this item */
<a name="1275"></a>                    x = vec[idx];
<a name="1276"></a>
<a name="1277"></a>                    /* if x should come after cur, we need to move cur */
<a name="1278"></a>                    if (x.ofKind(FullCommandReport)
<a name="1279"></a>                        &amp;&amp; x.seqNum &gt; cur.seqNum
<a name="1280"></a>                        &amp;&amp; x.isPartOf(cur))
<a name="1281"></a>                    {
<a name="1282"></a>                        /* remove cur and reinsert it before x */
<a name="1283"></a>                        vec.removeElementAt(i);
<a name="1284"></a>                        vec.insertAt(idx, cur);
<a name="1285"></a>
<a name="1286"></a>                        /* adjust our scan index for the removal */
<a name="1287"></a>                        --i;
<a name="1288"></a>                        
<a name="1289"></a>                        /* no need to look any further */
<a name="1290"></a>                        break;
<a name="1291"></a>                    }
<a name="1292"></a>                }
<a name="1293"></a>            }
<a name="1294"></a>        }
<a name="1295"></a>    }
<a name="1296"></a>;
<a name="1297"></a>
<a name="1298"></a>/* ------------------------------------------------------------------------ */
<a name="1299"></a>/*
<a name="1300"></a> *   Transcript Transform: remove unnecessary default reports.  We'll scan
<a name="1301"></a> *   the transcript for default reports for actions which also have
<a name="1302"></a> *   implicit announcements or non-default reports, and remove those
<a name="1303"></a> *   default reports.  We'll also remove default descriptive reports which
<a name="1304"></a> *   also have non-default reports in the same action.  
<a name="1305"></a> */
<a name="1306"></a>defaultReportTransform: TranscriptTransform
<a name="1307"></a>    applyTransform(trans, vec)
<a name="1308"></a>    {
<a name="1309"></a>        /* scan for default reports */
<a name="1310"></a>        for (local i = 1, local len = vec.length() ; i &lt;= len ; ++i)
<a name="1311"></a>        {
<a name="1312"></a>            local cur;
<a name="1313"></a>            
<a name="1314"></a>            /* get this item */
<a name="1315"></a>            cur = vec[i];
<a name="1316"></a>            
<a name="1317"></a>            /* 
<a name="1318"></a>             *   if this is a default report, check to see if we want to
<a name="1319"></a>             *   keep it 
<a name="1320"></a>             */
<a name="1321"></a>            if (cur.ofKind(DefaultCommandReport))
<a name="1322"></a>            {
<a name="1323"></a>                /* 
<a name="1324"></a>                 *   check for a main report or an implicit announcement
<a name="1325"></a>                 *   associated with the same action; if we find anything,
<a name="1326"></a>                 *   we don't need to keep the default report 
<a name="1327"></a>                 */
<a name="1328"></a>                if (vec.indexWhich(
<a name="1329"></a>                    {x: (x != cur
<a name="1330"></a>                         &amp;&amp; cur.isPartOf(x)
<a name="1331"></a>                         &amp;&amp; (x.ofKind(FullCommandReport)
<a name="1332"></a>                             || x.ofKind(ImplicitActionAnnouncement)))
<a name="1333"></a>                    }) != nil)
<a name="1334"></a>                {
<a name="1335"></a>                    /* we don't need this default report */
<a name="1336"></a>                    vec.removeElementAt(i);
<a name="1337"></a>
<a name="1338"></a>                    /* adjust our scan index for the removal */
<a name="1339"></a>                    --i;
<a name="1340"></a>                    --len;
<a name="1341"></a>                }
<a name="1342"></a>            }
<a name="1343"></a>
<a name="1344"></a>            /*
<a name="1345"></a>             *   if this is a default descriptive report, check to see if
<a name="1346"></a>             *   we want to keep it 
<a name="1347"></a>             */
<a name="1348"></a>            if (cur.ofKind(DefaultDescCommandReport))
<a name="1349"></a>            {
<a name="1350"></a>                local fullIdx;
<a name="1351"></a>                
<a name="1352"></a>                /* 
<a name="1353"></a>                 *   check for a main report associated with the same
<a name="1354"></a>                 *   action
<a name="1355"></a>                 */
<a name="1356"></a>                fullIdx = vec.indexWhich(
<a name="1357"></a>                    {x: (x != cur
<a name="1358"></a>                         &amp;&amp; cur.isPartOf(x)
<a name="1359"></a>                         &amp;&amp; x.ofKind(FullCommandReport))});
<a name="1360"></a>                
<a name="1361"></a>                /* 
<a name="1362"></a>                 *   if we found another report, check to see if it comes
<a name="1363"></a>                 *   before or after any 'end of description' for the same
<a name="1364"></a>                 *   action 
<a name="1365"></a>                 */
<a name="1366"></a>                if (fullIdx != nil)
<a name="1367"></a>                {
<a name="1368"></a>                    local endIdx;
<a name="1369"></a>
<a name="1370"></a>                    /* find the 'end of description' report, if any */
<a name="1371"></a>                    endIdx = vec.indexWhich(
<a name="1372"></a>                        {x: (x != cur
<a name="1373"></a>                             &amp;&amp; cur.isPartOf(x)
<a name="1374"></a>                             &amp;&amp; x.ofKind(EndOfDescReport))});
<a name="1375"></a>
<a name="1376"></a>                    /* 
<a name="1377"></a>                     *   if we found a full report before the
<a name="1378"></a>                     *   end-of-description report, then the full report is
<a name="1379"></a>                     *   part of the description and thus should suppress
<a name="1380"></a>                     *   the default report; otherwise, the description
<a name="1381"></a>                     *   portion includes only the default report and the
<a name="1382"></a>                     *   default report should thus remain 
<a name="1383"></a>                     */
<a name="1384"></a>                    if (endIdx == nil || fullIdx &lt; endIdx)
<a name="1385"></a>                    {
<a name="1386"></a>                        /* don't keep the default descriptive report */
<a name="1387"></a>                        vec.removeElementAt(i);
<a name="1388"></a>
<a name="1389"></a>                        /* adjust our indices for the removal */
<a name="1390"></a>                        --i;
<a name="1391"></a>                        --len;
<a name="1392"></a>                    }
<a name="1393"></a>                }
<a name="1394"></a>            }
<a name="1395"></a>        }
<a name="1396"></a>    }
<a name="1397"></a>;
<a name="1398"></a>
<a name="1399"></a>/* ------------------------------------------------------------------------ */
<a name="1400"></a>/*
<a name="1401"></a> *   Transcript Transform: group implicit announcements.  We'll find any
<a name="1402"></a> *   runs of consecutive implicit command announcements, and group each run
<a name="1403"></a> *   into a single announcement listing all of the implied actions.  For
<a name="1404"></a> *   example, we'll turn this:
<a name="1405"></a> *   
<a name="1406"></a> *.  &gt;go south
<a name="1407"></a> *.  (first opening the door)
<a name="1408"></a> *.  (first unlocking the door)
<a name="1409"></a> *   
<a name="1410"></a> *   this into:
<a name="1411"></a> *   
<a name="1412"></a> *.  &gt;go south
<a name="1413"></a> *.  (first opening the door and unlocking the door)
<a name="1414"></a> *   
<a name="1415"></a> *   In addition, if we find an implicit announcement in the middle of a
<a name="1416"></a> *   set of regular command reports, and it's for an action nested within
<a name="1417"></a> *   the action generating the regular reports, we'll start a new paragraph
<a name="1418"></a> *   before the implicit announcement.  
<a name="1419"></a> */
<a name="1420"></a>implicitGroupTransform: TranscriptTransform
<a name="1421"></a>    applyTransform(trans, vec)
<a name="1422"></a>    {
<a name="1423"></a>        /* 
<a name="1424"></a>         *   Scan for implicit announcements whose actions failed, and mark
<a name="1425"></a>         *   the implicit actions as such.  This allows us to phrase the
<a name="1426"></a>         *   implicit announcements as attempts rather than as actual
<a name="1427"></a>         *   actions, which sounds a little better because it doesn't clash
<a name="1428"></a>         *   with the failure report that immediately follows.  
<a name="1429"></a>         */
<a name="1430"></a>        for (local i = 1, local len = vec.length() ; i &lt;= len ; ++i)
<a name="1431"></a>        {
<a name="1432"></a>            local sub;
<a name="1433"></a>            
<a name="1434"></a>            /* get this item */
<a name="1435"></a>            local cur = vec[i];
<a name="1436"></a>
<a name="1437"></a>            /* 
<a name="1438"></a>             *   If this is an implicit action announcement, and its
<a name="1439"></a>             *   corresponding action (or any nested action) failed, mark
<a name="1440"></a>             *   the implicit announcement as a mere attempt.  Likewise, if
<a name="1441"></a>             *   we're interrupting the action for interactive input, it's
<a name="1442"></a>             *   likewise just an incomplete attempt.  
<a name="1443"></a>             */
<a name="1444"></a>            if (cur.ofKind(ImplicitActionAnnouncement)
<a name="1445"></a>                &amp;&amp; (sub = vec.valWhich(
<a name="1446"></a>                    {x: ((x.isFailure || x.isQuestion)
<a name="1447"></a>                         &amp;&amp; (x.isPartOf(cur)
<a name="1448"></a>                             || x.isActionNestedIn(cur)))})) != nil)
<a name="1449"></a>            {
<a name="1450"></a>                /* 
<a name="1451"></a>                 *   it's either a failed attempt or an interruption for a
<a name="1452"></a>                 *   question - note which one 
<a name="1453"></a>                 */
<a name="1454"></a>                if (sub.isFailure)
<a name="1455"></a>                    cur.noteJustTrying();
<a name="1456"></a>                else
<a name="1457"></a>                    cur.noteQuestion();
<a name="1458"></a>            }
<a name="1459"></a>        }
<a name="1460"></a>
<a name="1461"></a>        /* 
<a name="1462"></a>         *   Scan for implicit announcement groups.  Since we're only
<a name="1463"></a>         *   scanning for runs of two or more announcements, we can stop
<a name="1464"></a>         *   scanning one short of the end of the list - there's no need to
<a name="1465"></a>         *   check the last item because it can't possibly be followed by
<a name="1466"></a>         *   another item.  Thus, scan while i &lt; len.  
<a name="1467"></a>         */
<a name="1468"></a>        for (local i = 1, local len = vec.length() ; i &lt; len ; ++i)
<a name="1469"></a>        {
<a name="1470"></a>            local origI = i;
<a name="1471"></a>            
<a name="1472"></a>            /* get this item */
<a name="1473"></a>            local cur = vec[i];
<a name="1474"></a>            
<a name="1475"></a>            /* 
<a name="1476"></a>             *   If it's an implied action announcement, and the next one
<a name="1477"></a>             *   qualifies for group inclusion, build a group.  Note that
<a name="1478"></a>             *   because we only loop until we reach the second-to-last
<a name="1479"></a>             *   item, we know for sure there is indeed a next item to
<a name="1480"></a>             *   index here.  
<a name="1481"></a>             */
<a name="1482"></a>            if (cur.ofKind(ImplicitActionAnnouncement)
<a name="1483"></a>                &amp;&amp; canGroupWith(cur, vec[i+1]))
<a name="1484"></a>            {
<a name="1485"></a>                local j;
<a name="1486"></a>                local groupVec;
<a name="1487"></a>
<a name="1488"></a>                /* create a vector to hold the re-sorted group listing */
<a name="1489"></a>                groupVec = new Vector(16);
<a name="1490"></a>
<a name="1491"></a>                /* 
<a name="1492"></a>                 *   Scan items for grouping.  This time, we want to scan
<a name="1493"></a>                 *   to the last (not second-to-last) item in the main
<a name="1494"></a>                 *   list, since we could conceivably group everything
<a name="1495"></a>                 *   remaining. 
<a name="1496"></a>                 */
<a name="1497"></a>                for (j = i ; j &lt;= len ; )
<a name="1498"></a>                {
<a name="1499"></a>                    /* get this item */
<a name="1500"></a>                    cur = vec[j];
<a name="1501"></a>                    
<a name="1502"></a>                    /* unstack any recursive grouping */
<a name="1503"></a>                    j = unstackRecursiveGroup(groupVec, vec, j);
<a name="1504"></a>
<a name="1505"></a>                    /* 
<a name="1506"></a>                     *   if we've used now everything in the list, or the
<a name="1507"></a>                     *   next item can't be grouped with the current item,
<a name="1508"></a>                     *   we're done 
<a name="1509"></a>                     */
<a name="1510"></a>                    if (j &gt; len || !canGroupWith(cur, vec[j]))
<a name="1511"></a>                        break;
<a name="1512"></a>                }
<a name="1513"></a>
<a name="1514"></a>                /* process default object announcements */
<a name="1515"></a>                processDefaultAnnouncements(groupVec);
<a name="1516"></a>
<a name="1517"></a>                /* build the composite message for the entire group */
<a name="1518"></a>                vec[i].messageText_ = implicitAnnouncementGrouper
<a name="1519"></a>                    .compositeMessage(groupVec);
<a name="1520"></a>
<a name="1521"></a>                /* 
<a name="1522"></a>                 *   Clear the messages in the second through last grouped
<a name="1523"></a>                 *   announcements.  Leave the report objects themselves
<a name="1524"></a>                 *   intact, so that our internal structural record of the
<a name="1525"></a>                 *   transcript remains as it was, but make them silent in
<a name="1526"></a>                 *   the displayed text, since these messages are now
<a name="1527"></a>                 *   subsumed into the combined first message.  
<a name="1528"></a>                 */
<a name="1529"></a>                for (++i ; i &lt; j ; ++i)
<a name="1530"></a>                    vec[i].messageText_ = '';
<a name="1531"></a>
<a name="1532"></a>                /* 
<a name="1533"></a>                 *   continue the main loop from the next element after the
<a name="1534"></a>                 *   last one we included in the group 
<a name="1535"></a>                 */
<a name="1536"></a>                i = j - 1;
<a name="1537"></a>            }
<a name="1538"></a>
<a name="1539"></a>            /*
<a name="1540"></a>             *   If this is an implied action or default object
<a name="1541"></a>             *   announcement that interrupts a set of regular command
<a name="1542"></a>             *   reports, and it's for an action nested within the action
<a name="1543"></a>             *   generating the reports, add a paragraph spacer before the
<a name="1544"></a>             *   implicit announcement.  
<a name="1545"></a>             */
<a name="1546"></a>            if ((cur.ofKind(ImplicitActionAnnouncement)
<a name="1547"></a>                 || cur.ofKind(DefaultObjectAnnouncement))
<a name="1548"></a>                &amp;&amp; cur.messageText_ != '')
<a name="1549"></a>            {
<a name="1550"></a>                local j;
<a name="1551"></a>                
<a name="1552"></a>                /* scan back for the nearest announcement with text */
<a name="1553"></a>                for (j = origI - 1 ; j &gt;= 1 &amp;&amp; vec[j].messageText_ == '' ;
<a name="1554"></a>                     --j) ;
<a name="1555"></a>
<a name="1556"></a>                /* 
<a name="1557"></a>                 *   if it's a regular command report, and our implied or
<a name="1558"></a>                 *   default announcement is nested within it, add a
<a name="1559"></a>                 *   paragraph spacer 
<a name="1560"></a>                 */
<a name="1561"></a>                if (j &gt;= 1
<a name="1562"></a>                    &amp;&amp; vec[j].ofKind(FullCommandReport)
<a name="1563"></a>                    &amp;&amp; cur.isActionNestedIn(vec[j]))
<a name="1564"></a>                {
<a name="1565"></a>                    /* 
<a name="1566"></a>                     *   insert a paragraph spacer before the announcement
<a name="1567"></a>                     *   - this will make the implied action and its
<a name="1568"></a>                     *   results stand out as separate actions, rather than
<a name="1569"></a>                     *   running everything together without spacing 
<a name="1570"></a>                     */
<a name="1571"></a>                    vec.insertAt(origI, new GroupSeparatorMessage(cur));
<a name="1572"></a>
<a name="1573"></a>                    /* adjust our indices for the insertion */
<a name="1574"></a>                    ++i;
<a name="1575"></a>                    ++len;
<a name="1576"></a>                }
<a name="1577"></a>            }
<a name="1578"></a>        }
<a name="1579"></a>    }
<a name="1580"></a>
<a name="1581"></a>    /*
<a name="1582"></a>     *   "Unstack" a recursive group of nested announcements.  Adds the
<a name="1583"></a>     *   recursive group to the output group vector in chronological order,
<a name="1584"></a>     *   and returns the index of the next item after the recursive group.
<a name="1585"></a>     *   
<a name="1586"></a>     *   A recursive group is a set of nested implicit commands, where one
<a name="1587"></a>     *   implicit command triggered another, which triggered another, and
<a name="1588"></a>     *   so on.  The innermost of the nested set is the one that's actually
<a name="1589"></a>     *   executed first chronologically, since an implied command must be
<a name="1590"></a>     *   carried out before its enclosing command can proceed.  For
<a name="1591"></a>     *   example:
<a name="1592"></a>     *   
<a name="1593"></a>     *.  &gt;go south
<a name="1594"></a>     *.  (first opening the door)
<a name="1595"></a>     *.  (first unlocking the door)
<a name="1596"></a>     *.  (first taking the key out of the bag)
<a name="1597"></a>     *   
<a name="1598"></a>     *   Going south implies opening the door, but before we can open the
<a name="1599"></a>     *   door, we must unlock it, and before we can unlock it we must be
<a name="1600"></a>     *   holding the key.  In report order, the innermost command is listed
<a name="1601"></a>     *   last, since it's nested within the enclosing commands.
<a name="1602"></a>     *   Chronologically, though, the innermost command is actually
<a name="1603"></a>     *   executed first.  The purpose of this routine is to unstack these
<a name="1604"></a>     *   nested sets, rearranging them into chronological order.  
<a name="1605"></a>     */
<a name="1606"></a>    unstackRecursiveGroup(groupVec, vec, idx)
<a name="1607"></a>    {
<a name="1608"></a>        local cur;
<a name="1609"></a>
<a name="1610"></a>        /* remember the item we're tasked to work on */
<a name="1611"></a>        cur = vec[idx];
<a name="1612"></a>
<a name="1613"></a>        /* skip the current item */
<a name="1614"></a>        ++idx;
<a name="1615"></a>        
<a name="1616"></a>        /*
<a name="1617"></a>         *   Scan for items nested within vec[idx].  Process each child
<a name="1618"></a>         *   item first.  An item is nested within us if can be grouped
<a name="1619"></a>         *   with us, and its action is a child of our action.  
<a name="1620"></a>         */
<a name="1621"></a>        for (local len = vec.length() ; idx &lt;= len ; )
<a name="1622"></a>        {
<a name="1623"></a>            /* if the next item is nested within 'cur', process it */
<a name="1624"></a>            if (canGroupWith(cur, vec[idx])
<a name="1625"></a>                &amp;&amp; vec[idx].getAction().isNestedIn(cur.getAction()))
<a name="1626"></a>            {
<a name="1627"></a>                /* 
<a name="1628"></a>                 *   It's nested with us - process it recursively.  Since
<a name="1629"></a>                 *   our goal is to unstack these reports into
<a name="1630"></a>                 *   chronological order, we must process our children
<a name="1631"></a>                 *   first, so that they get added to the group vector
<a name="1632"></a>                 *   first, since children chronologically predede their
<a name="1633"></a>                 *   parents. 
<a name="1634"></a>                 */
<a name="1635"></a>                idx = unstackRecursiveGroup(groupVec, vec, idx);
<a name="1636"></a>            }
<a name="1637"></a>            else
<a name="1638"></a>            {
<a name="1639"></a>                /* it's not nested within us, so we're done */
<a name="1640"></a>                break;
<a name="1641"></a>            }
<a name="1642"></a>        }
<a name="1643"></a>
<a name="1644"></a>        /* add our item to the result vector */
<a name="1645"></a>        groupVec.append(cur);
<a name="1646"></a>
<a name="1647"></a>        /* 
<a name="1648"></a>         *   return the index of the next item; this is simply the current
<a name="1649"></a>         *   'idx' value, since we've advanced it past each item we've
<a name="1650"></a>         *   processed 
<a name="1651"></a>         */
<a name="1652"></a>        return idx;
<a name="1653"></a>    }
<a name="1654"></a>
<a name="1655"></a>    /*
<a name="1656"></a>     *   Process default object announcements in a grouped message vector.
<a name="1657"></a>     *   
<a name="1658"></a>     *   Default object announcements come in two flavors: with and without
<a name="1659"></a>     *   message text.  Those without message text are present purely to
<a name="1660"></a>     *   retain a structural record of the default object in the internal
<a name="1661"></a>     *   transcript; we can simply remove these, since the actions that
<a name="1662"></a>     *   created them didn't even want default messages.  For those that do
<a name="1663"></a>     *   include message text, remove them as well, but also use their
<a name="1664"></a>     *   actions to replace the corresponding parent actions, so that the
<a name="1665"></a>     *   parent actions reflect what actually happened with the final
<a name="1666"></a>     *   defaulted objects.  
<a name="1667"></a>     */
<a name="1668"></a>    processDefaultAnnouncements(vec)
<a name="1669"></a>    {
<a name="1670"></a>        /* scan the vector for default announcements */
<a name="1671"></a>        for (local i = 1, local len = vec.length() ; i &lt;= len ; ++i)
<a name="1672"></a>        {
<a name="1673"></a>            local cur = vec[i];
<a name="1674"></a>            
<a name="1675"></a>            /* if this is a default announcement, process it */
<a name="1676"></a>            if (cur.ofKind(DefaultObjectAnnouncement))
<a name="1677"></a>            {
<a name="1678"></a>                /* 
<a name="1679"></a>                 *   If it has a message, use its action to replace the
<a name="1680"></a>                 *   parent action.  The only way an implied command can
<a name="1681"></a>                 *   have a defaulted object is for the implied command to
<a name="1682"></a>                 *   have been stated with too few objects, so that an
<a name="1683"></a>                 *   askForIobj (for example) occurred.  In such cases, the
<a name="1684"></a>                 *   default announcement will be a child action of the
<a name="1685"></a>                 *   original underspecified action, so we can simply find
<a name="1686"></a>                 *   the original action and replace it with the defaulted
<a name="1687"></a>                 *   action.
<a name="1688"></a>                 */
<a name="1689"></a>                if (cur.messageText_ != '')
<a name="1690"></a>                {
<a name="1691"></a>                    /* 
<a name="1692"></a>                     *   Scan for the parent announcement.
<a name="1693"></a>                     *   
<a name="1694"></a>                     *   Note that the implicit announcement containing the
<a name="1695"></a>                     *   parent action will follow the default announcement
<a name="1696"></a>                     *   in the result list, since the default announcement
<a name="1697"></a>                     *   is a child of the parent.  
<a name="1698"></a>                     */
<a name="1699"></a>                    for (local j = i + 1 ; j &lt;= len ; ++j)
<a name="1700"></a>                    {
<a name="1701"></a>                        /* if this is the parent action, replace it */
<a name="1702"></a>                        if (vec[j].getAction()
<a name="1703"></a>                            == cur.getAction().parentAction)
<a name="1704"></a>                        {
<a name="1705"></a>                            /* this is it - replace the action */
<a name="1706"></a>                            vec[j].setAction(cur.getAction());
<a name="1707"></a>                            
<a name="1708"></a>                            /* no need to look any further */
<a name="1709"></a>                            break;
<a name="1710"></a>                        }
<a name="1711"></a>                    }
<a name="1712"></a>                }
<a name="1713"></a>
<a name="1714"></a>                /* remove the default announcement from the list */
<a name="1715"></a>                vec.removeElementAt(i);
<a name="1716"></a>                
<a name="1717"></a>                /* adjust our list index and length for the deletion */
<a name="1718"></a>                --i;
<a name="1719"></a>                --len;
<a name="1720"></a>            }
<a name="1721"></a>        }
<a name="1722"></a>    }
<a name="1723"></a>
<a name="1724"></a>    /* 
<a name="1725"></a>     *   Can we group the second item with the first?  Returns true if the
<a name="1726"></a>     *   second item is also an implicit action announcement, or it's a
<a name="1727"></a>     *   default object announcement whose parent action is the first
<a name="1728"></a>     *   item's action. 
<a name="1729"></a>     */
<a name="1730"></a>    canGroupWith(a, b)
<a name="1731"></a>    {
<a name="1732"></a>        /* if 'b' is also an implicit announcement, we can include it */
<a name="1733"></a>        if (b.ofKind(ImplicitActionAnnouncement))
<a name="1734"></a>            return true;
<a name="1735"></a>
<a name="1736"></a>        /* 
<a name="1737"></a>         *   if 'b' is a default object announcement, and has the same
<a name="1738"></a>         *   parent action as 'a', then we can group it; otherwise we can't
<a name="1739"></a>         */
<a name="1740"></a>        return (b.ofKind(DefaultObjectAnnouncement)
<a name="1741"></a>                &amp;&amp; b.getAction().parentAction == a.getAction());
<a name="1742"></a>    }
<a name="1743"></a>;
<a name="1744"></a>
<a name="1745"></a>/* ------------------------------------------------------------------------ */
<a name="1746"></a>/*
<a name="1747"></a> *   Transcript Transform: Complex Multi-object Separation.  If we have an
<a name="1748"></a> *   action that's being applied to one of a bunch of iterated objects, and
<a name="1749"></a> *   the action has any implied command announcements associated with it,
<a name="1750"></a> *   we'll set off the result for this command from its preceding and
<a name="1751"></a> *   following commands by a paragraph separator.  
<a name="1752"></a> */
<a name="1753"></a>complexMultiTransform: TranscriptTransform
<a name="1754"></a>    applyTransform(trans, vec)
<a name="1755"></a>    {
<a name="1756"></a>        /* scan the list for multi-object announcements */
<a name="1757"></a>        foreach (local cur in vec)
<a name="1758"></a>        {
<a name="1759"></a>            /* if it's a multi-object announcement, check it */
<a name="1760"></a>            if (cur.ofKind(MultiObjectAnnouncement))
<a name="1761"></a>            {
<a name="1762"></a>                local idx;
<a name="1763"></a>                local cnt;
<a name="1764"></a>                local sep;
<a name="1765"></a>                    
<a name="1766"></a>                /* 
<a name="1767"></a>                 *   We have a multi-object announcement.  If we find only
<a name="1768"></a>                 *   one other report within the group, and the report's
<a name="1769"></a>                 *   text is short, let this report run together with its
<a name="1770"></a>                 *   neighbors without any additional visual separation.
<a name="1771"></a>                 *   Otherwise, set this group apart from its neighbors by
<a name="1772"></a>                 *   adding a paragraph break before and after the group;
<a name="1773"></a>                 *   this will make the results easier to read by visually
<a name="1774"></a>                 *   separating each longish response as a separate
<a name="1775"></a>                 *   paragraph.
<a name="1776"></a>                 *   
<a name="1777"></a>                 *   First, find the current item's index.  
<a name="1778"></a>                 */
<a name="1779"></a>                idx = vec.indexWhich({x: x == cur});
<a name="1780"></a>
<a name="1781"></a>                /* 
<a name="1782"></a>                 *   now scan subsequent items in the same command
<a name="1783"></a>                 *   iteration, and check to see if (1) we have more than
<a name="1784"></a>                 *   one item, or (2) the item has a longish message 
<a name="1785"></a>                 */
<a name="1786"></a>                for (cnt = 0, ++idx, sep = nil ;
<a name="1787"></a>                     idx &lt;= vec.length() &amp;&amp; cnt &lt; 2 ; ++idx, ++cnt)
<a name="1788"></a>                {
<a name="1789"></a>                    local sub = vec[idx];
<a name="1790"></a>                    
<a name="1791"></a>                    /* if we've reached the end of the group, stop scanning */
<a name="1792"></a>                    if (sub.iter_ != cur.iter_)
<a name="1793"></a>                        break;
<a name="1794"></a>                    
<a name="1795"></a>                    /* 
<a name="1796"></a>                     *   If it has long text, add visual separation.  Note
<a name="1797"></a>                     *   that "long" is just a heuristic, because we can't
<a name="1798"></a>                     *   tell whether the text will wrap in any given
<a name="1799"></a>                     *   interpreter - that depends on the width of the
<a name="1800"></a>                     *   interpreter window and the font size, among other
<a name="1801"></a>                     *   things, and we have no way of knowing any of this
<a name="1802"></a>                     *   here.  
<a name="1803"></a>                     */
<a name="1804"></a>                    if (sub.ofKind(CommandReportMessage)
<a name="1805"></a>                        &amp;&amp; sub.messageText_ != nil
<a name="1806"></a>                        &amp;&amp; sub.messageText_.length() &gt; 60)
<a name="1807"></a>                    {
<a name="1808"></a>                        /* it's long - add separation */
<a name="1809"></a>                        sep = true;
<a name="1810"></a>                        break;
<a name="1811"></a>                    }
<a name="1812"></a>                }
<a name="1813"></a>
<a name="1814"></a>                /* if we need separation, add it now */
<a name="1815"></a>                if (sep || cnt &gt; 1)   
<a name="1816"></a>                {
<a name="1817"></a>                    /* 
<a name="1818"></a>                     *   This is indeed a complex iterated item.  Set it
<a name="1819"></a>                     *   off by paragraph breaks before and after the
<a name="1820"></a>                     *   iteration.
<a name="1821"></a>                     *   
<a name="1822"></a>                     *   First, find the first item in this iteration.  If
<a name="1823"></a>                     *   it's not the first item in the whole transcript,
<a name="1824"></a>                     *   insert a separator before it.  
<a name="1825"></a>                     */
<a name="1826"></a>                    idx = vec.indexWhich({x: x.iter_ == cur.iter_});
<a name="1827"></a>                    if (idx != 1)
<a name="1828"></a>                        vec.insertAt(idx, new GroupSeparatorMessage(cur));
<a name="1829"></a>
<a name="1830"></a>                    /* 
<a name="1831"></a>                     *   Next, find the last item in this iteration.  If
<a name="1832"></a>                     *   it's no the last item in the entire transcript,
<a name="1833"></a>                     *   add a separator after it. 
<a name="1834"></a>                     */
<a name="1835"></a>                    idx = vec.lastIndexWhich({x: x.iter_ == cur.iter_});
<a name="1836"></a>                    if (idx != vec.length())
<a name="1837"></a>                        vec.insertAt(idx + 1, new GroupSeparatorMessage(cur));
<a name="1838"></a>                }
<a name="1839"></a>            }
<a name="1840"></a>
<a name="1841"></a>            /* 
<a name="1842"></a>             *   if it's a command result from an implied command, and we
<a name="1843"></a>             *   have another command result following from the enclosing
<a name="1844"></a>             *   command, add a separator between this result and the next
<a name="1845"></a>             *   result 
<a name="1846"></a>             */
<a name="1847"></a>            if (cur.ofKind(CommandReportMessage) &amp;&amp; cur.isActionImplicit)
<a name="1848"></a>            {
<a name="1849"></a>                local idx;
<a name="1850"></a>
<a name="1851"></a>                /* get the index of this element */
<a name="1852"></a>                idx = vec.indexOf(cur);
<a name="1853"></a>
<a name="1854"></a>                /* 
<a name="1855"></a>                 *   if there's another element following, check to see if
<a name="1856"></a>                 *   it's a command report for an enclosing action (i.e.,
<a name="1857"></a>                 *   an action that initiated this implied action) 
<a name="1858"></a>                 */
<a name="1859"></a>                if (idx &lt; vec.length())
<a name="1860"></a>                {
<a name="1861"></a>                    local nxt;
<a name="1862"></a>
<a name="1863"></a>                    /* get the next element */
<a name="1864"></a>                    nxt = vec[idx + 1];
<a name="1865"></a>
<a name="1866"></a>                    /* 
<a name="1867"></a>                     *   if it's a command report for an action that
<a name="1868"></a>                     *   encloses this action, or it's another implicit
<a name="1869"></a>                     *   announcement, then put a separator before it 
<a name="1870"></a>                     */
<a name="1871"></a>                    if ((nxt.ofKind(CommandReportMessage)
<a name="1872"></a>                         &amp;&amp; nxt.getAction() != cur.getAction()
<a name="1873"></a>                         &amp;&amp; cur.isActionNestedIn(nxt))
<a name="1874"></a>                        || nxt.ofKind(ImplicitActionAnnouncement))
<a name="1875"></a>                         
<a name="1876"></a>                    {
<a name="1877"></a>                        /* add a separator */
<a name="1878"></a>                        vec.insertAt(idx + 1,
<a name="1879"></a>                                     new InternalSeparatorMessage(cur));
<a name="1880"></a>                    }
<a name="1881"></a>                }
<a name="1882"></a>            }
<a name="1883"></a>        }
<a name="1884"></a>    }
<a name="1885"></a>;
<a name="1886"></a>
<a name="1887"></a>/* ------------------------------------------------------------------------ */
<a name="1888"></a>/*
<a name="1889"></a> *   Invoke a callback function using a transcript of the given class.
<a name="1890"></a> *   Returns the return value of the callback function.  
<a name="1891"></a> */
<a name="1892"></a>withCommandTranscript(transcriptClass, func)
<a name="1893"></a>{
<a name="1894"></a>    local transcript;
<a name="1895"></a>    local oldTranscript;
<a name="1896"></a>
<a name="1897"></a>    /* 
<a name="1898"></a>     *   if we already have an active transcript, just invoke the
<a name="1899"></a>     *   function, running everything through the existing active
<a name="1900"></a>     *   transcript 
<a name="1901"></a>     */
<a name="1902"></a>    if (gTranscript != nil &amp;&amp; gTranscript.isActive)
<a name="1903"></a>    {
<a name="1904"></a>        /* invoke the callback and return the result */
<a name="1905"></a>        return (func)();
<a name="1906"></a>    }
<a name="1907"></a>
<a name="1908"></a>    /* 
<a name="1909"></a>     *   Create a transcript of the given class.  Make the transcript
<a name="1910"></a>     *   transient, since it's effectively part of the output stream state
<a name="1911"></a>     *   and thus shouldn't be saved or undone. 
<a name="1912"></a>     */
<a name="1913"></a>    transcript = transcriptClass.createTransientInstance();
<a name="1914"></a>
<a name="1915"></a>    /* make this transcript the current global transcript */
<a name="1916"></a>    oldTranscript = gTranscript;
<a name="1917"></a>    gTranscript = transcript;
<a name="1918"></a>
<a name="1919"></a>    /* install the transcript as a filter on the main output stream */
<a name="1920"></a>    mainOutputStream.addOutputFilter(transcript);
<a name="1921"></a>
<a name="1922"></a>    /* make sure we undo our global changes before we leave */
<a name="1923"></a>    try
<a name="1924"></a>    {
<a name="1925"></a>        /* invoke the callback and return the result */
<a name="1926"></a>        return (func)();
<a name="1927"></a>    }
<a name="1928"></a>    finally
<a name="1929"></a>    {
<a name="1930"></a>        /* uninstall the transcript output filter */
<a name="1931"></a>        mainOutputStream.removeOutputFilter(transcript);
<a name="1932"></a>
<a name="1933"></a>        /* restore the previous global transcript */
<a name="1934"></a>        gTranscript = oldTranscript;
<a name="1935"></a>
<a name="1936"></a>        /* show the transcript results */
<a name="1937"></a>        transcript.showReports(true);
<a name="1938"></a>    }
<a name="1939"></a>}
<a name="1940"></a>
</pre>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/6/2009 from TADS version 3.0.18.1</div>
</body>
</html>
