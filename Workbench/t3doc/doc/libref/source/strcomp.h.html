<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>strcomp.h</title></head><body>
<table class=ban><tr><td><h1>strcomp.h</h1><td align=right><a href="../file/strcomp.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/*
<a name="4"></a> *   Copyright 2000, 2006 Michael J. Roberts.
<a name="5"></a> *   
<a name="6"></a> *   This file is part of TADS 3.
<a name="7"></a> *   
<a name="8"></a> *   This header defines the StringComparator intrinsic class.  
<a name="9"></a> */
<a name="10"></a>
<a name="11"></a>/* include our base class definition */
<a name="12"></a>#include "systype.h"
<a name="13"></a>
<a name="14"></a>/*
<a name="15"></a> *   StringComparator intrinsic class.  This class provides support for
<a name="16"></a> *   dictionaries based on complex string matches, including truncation
<a name="17"></a> *   (matching an input word to a dictionary word when the input word is at
<a name="18"></a> *   least some minimum length, and matches the dictionary word up to the
<a name="19"></a> *   full length of the input word, but the input word is shorter than the
<a name="20"></a> *   dictionary word); case folding (matching upper-case letters to
<a name="21"></a> *   lower-case letters and vice versa); and character equivalences (for
<a name="22"></a> *   matching accented characters to non-accented equivalents, or matching
<a name="23"></a> *   special characters to multi-character equivalents, such as matching a
<a name="24"></a> *   German "ess-zet" ("sharp-s") ligature to a pair of lower-case "s"
<a name="25"></a> *   characters in input).  
<a name="26"></a> */
<a name="27"></a>intrinsic class StringComparator 'string-comparator/030000': Object
<a name="28"></a>{
<a name="29"></a>    /*
<a name="30"></a>     *   Constructor:
<a name="31"></a>     *   
<a name="32"></a>     *   new StringComparator(truncLen, caseSensitive, mappings)
<a name="33"></a>     *   
<a name="34"></a>     *   truncLen = the minimum truncation length.  An input string that
<a name="35"></a>     *   matches a dictionary string up to the full length of the input
<a name="36"></a>     *   string, and is shorter than the dictionary string but at least this
<a name="37"></a>     *   truncation length, will match the dictionary string.  If truncLen is
<a name="38"></a>     *   zero or nil, no truncated matches are allowed.
<a name="39"></a>     *   
<a name="40"></a>     *   caseSensitive = true if matches are to be sensitive to case, nil if
<a name="41"></a>     *   not.  If this parameter is nil, then an upper-case letter in an
<a name="42"></a>     *   input string will match a lower-case letter in a dictionary string,
<a name="43"></a>     *   and vice versa.  If this parameter is true, each character must
<a name="44"></a>     *   match exactly.
<a name="45"></a>     *   
<a name="46"></a>     *   mappings is a list of equivalent character mappings.  Each mapping
<a name="47"></a>     *   in the list is a sublist in this format:
<a name="48"></a>     *   
<a name="49"></a>     *.     ['dictChar', 'inputString', ucFlags, lcFlags]
<a name="50"></a>     *   
<a name="51"></a>     *   'dictChar' is a one-character string giving the character to be
<a name="52"></a>     *   mapped in dictionary strings.  'inputString' is a string of one or
<a name="53"></a>     *   more characters that is to be considered equivalent to the
<a name="54"></a>     *   dictionary character when the inputString appears in an input
<a name="55"></a>     *   string.  ucFlags and lcFlags are integer values giving the flag
<a name="56"></a>     *   values to bitwise-OR into the results when this mapping is used to
<a name="57"></a>     *   match an upper-case or lower-case input string, respectively.
<a name="58"></a>     *   
<a name="59"></a>     *   For example, a mapping to allow the German ess-zet character (whose
<a name="60"></a>     *   Unicode value is 0x00DF) to match "ss" sequences in input strings,
<a name="61"></a>     *   with no result flag additions, would look like this:
<a name="62"></a>     *   
<a name="63"></a>     *.    ['\u00DF', 'ss', 0, 0]
<a name="64"></a>     *   
<a name="65"></a>     *   Only one mapping is allowed for each dictionary character.  If more
<a name="66"></a>     *   than one mapping is given for a single dictionary character, only
<a name="67"></a>     *   the latest one in the list is actually used.
<a name="68"></a>     *   
<a name="69"></a>     *   Flag values 0x0001 through 0x0080 are reserved for use by
<a name="70"></a>     *   StringComparator itself.  Callers are free to use any flag values
<a name="71"></a>     *   0x0100 and above.  Note that the system flag values are used as
<a name="72"></a>     *   bitwise OR'd values, so callers should not define any flag values
<a name="73"></a>     *   'f' for which (f &amp; 0xFF) != 0.  
<a name="74"></a>     */
<a name="75"></a>
<a name="76"></a>    /*
<a name="77"></a>     *   Calculate a hash value.  This returns an integer giving the hash
<a name="78"></a>     *   value for the given string. 
<a name="79"></a>     */
<a name="80"></a>    calcHash(str);
<a name="81"></a>
<a name="82"></a>    /*
<a name="83"></a>     *   Match two values.  The first value is the input string, and the
<a name="84"></a>     *   second is the dictionary string.  Each character in the dictionary
<a name="85"></a>     *   string can match the corresponding input string character exactly
<a name="86"></a>     *   (with or without case sensitivity, as specified in our
<a name="87"></a>     *   constructor), or can match the equivalence mapping sequence for the
<a name="88"></a>     *   dictionary character.
<a name="89"></a>     *   
<a name="90"></a>     *   The return value is zero if the values do not match.  If the values
<a name="91"></a>     *   do match, the return value is a non-zero integer, which will be a
<a name="92"></a>     *   bitwise OR combination of all of the flag values applicable to the
<a name="93"></a>     *   match.  This is a combination of pre-defined flag values (see
<a name="94"></a>     *   below) and any flag values from equivalence mappings.  The flag
<a name="95"></a>     *   values from ALL equivalence mappings that were actually used to
<a name="96"></a>     *   make the match are included.  
<a name="97"></a>     */
<a name="98"></a>    matchValues(inputStr, dictStr);
<a name="99"></a>}
<a name="100"></a>
<a name="101"></a>/*
<a name="102"></a> *   Pre-defined matchValues result flags.  These are set when applicable in
<a name="103"></a> *   the return value of matchValues().
<a name="104"></a> *   
<a name="105"></a> *   This class reserves flag values 0x0001 through 0x0080.  Callers should
<a name="106"></a> *   not use any flag values with any of these bits set.  Even though we
<a name="107"></a> *   don't define values for all of these flags currently, the ones we don't
<a name="108"></a> *   use are reserved for possible use in future versions; to ensure
<a name="109"></a> *   compatibility with future versions, callers should not use any of the
<a name="110"></a> *   reserved flags for their own purposes.  
<a name="111"></a> */
<a name="112"></a>
<a name="113"></a>/* 
<a name="114"></a> *   Match - this flag is set in the return code for all matching strings.
<a name="115"></a> *   (This flag isn't as useless as it might sound; its purpose is to ensure
<a name="116"></a> *   that the return value from matchValues() is non-zero for all matches,
<a name="117"></a> *   even when no other flag values are applicable.)
<a name="118"></a> */
<a name="119"></a>#define StrCompMatch     0x0001
<a name="120"></a>
<a name="121"></a>/* 
<a name="122"></a> *   Case folding - this flag is set when the two values match, but one or
<a name="123"></a> *   more characters differ in case (in other words, an upper-case letter in
<a name="124"></a> *   the input string matched a lower-case letter in the dictionary string,
<a name="125"></a> *   or vice versa).  
<a name="126"></a> */
<a name="127"></a>#define StrCompCaseFold  0x0002
<a name="128"></a>
<a name="129"></a>/* 
<a name="130"></a> *   Truncation - this flag is set when the input string is shorter than the
<a name="131"></a> *   value string (but matches the dictionary completely up to the input
<a name="132"></a> *   string's full length, and is at least as long as the truncation length
<a name="133"></a> *   specified in the constructor).  This flag can only be returned when
<a name="134"></a> *   truncation is allowed (as indicated by a non-zero truncation length in
<a name="135"></a> *   the constructor), because truncated strings will never match at all
<a name="136"></a> *   when truncation isn't allowed.  
<a name="137"></a> */
<a name="138"></a>#define StrCompTrunc     0x0004
<a name="139"></a>
</pre>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/6/2009 from TADS version 3.0.18.1</div>
</body>
</html>
