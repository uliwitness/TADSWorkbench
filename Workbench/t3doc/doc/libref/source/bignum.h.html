<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>bignum.h</title></head><body>
<table class=ban><tr><td><h1>bignum.h</h1><td align=right><a href="../file/bignum.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/* 
<a name="4"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts
<a name="5"></a> *   
<a name="6"></a> *   This file is part of TADS 3.
<a name="7"></a> *   
<a name="8"></a> *   This header defines the BigNumber intrinsic class.  
<a name="9"></a> */
<a name="10"></a>
<a name="11"></a>#ifndef _BIGNUM_H_
<a name="12"></a>#define _BIGNUM_H_
<a name="13"></a>
<a name="14"></a>/* include our base class definition */
<a name="15"></a>#include "systype.h"
<a name="16"></a>
<a name="17"></a>/*
<a name="18"></a> *   The BigNumber intrinsic class lets you perform floating-point and
<a name="19"></a> *   integer arithmetic with (almost) any desired precision.  BigNumber uses
<a name="20"></a> *   a decimal representation, which means that decimal values can be
<a name="21"></a> *   represented exactly (i.e., with no rounding errors, as can happen with
<a name="22"></a> *   IEEE 'double' and 'float' values that languages like C typically
<a name="23"></a> *   support).  BigNumber combines a varying-length mantissa with an
<a name="24"></a> *   exponent; the length of the mantissa determines how many digits of
<a name="25"></a> *   precision a given BigNumber can store, and the exponent lets you
<a name="26"></a> *   represent very large or very small values with minimal storage.  You can
<a name="27"></a> *   specify the desired precision when you create a BigNumber explicitly;
<a name="28"></a> *   when BigNumber values are created implicitly by computations, the system
<a name="29"></a> *   chooses a precision based on the inputs to the calculations, typically
<a name="30"></a> *   equal to the largest of the precisions of the input values.
<a name="31"></a> *   
<a name="32"></a> *   The maximum precision for a BigNumber is about 64,000 digits, and the
<a name="33"></a> *   exponent can range from -32768 to +32767.  Since this is a decimal
<a name="34"></a> *   exponent, this implies an absolute value range from 1.0e-32768 to
<a name="35"></a> *   1.0e+32767.  The more digits of precision stored in a given BigNumber
<a name="36"></a> *   value, the more memory the object consumes, and the more time it takes
<a name="37"></a> *   to perform calculations using the value.  
<a name="38"></a> */
<a name="39"></a>intrinsic class BigNumber 'bignumber/030000': Object
<a name="40"></a>{
<a name="41"></a>    /* format to a string */
<a name="42"></a>    formatString(maxDigits, flags?,
<a name="43"></a>                 wholePlaces?, fracDigits?, expDigits?, leadFiller?);
<a name="44"></a>
<a name="45"></a>    /* 
<a name="46"></a>     *   compare for equality after rounding to the smaller of my
<a name="47"></a>     *   precision and num's precision 
<a name="48"></a>     */
<a name="49"></a>    equalRound(num);
<a name="50"></a>
<a name="51"></a>    /* 
<a name="52"></a>     *   returns an integer giving the number of digits of precision that
<a name="53"></a>     *   this number stores 
<a name="54"></a>     */
<a name="55"></a>    getPrecision();
<a name="56"></a>
<a name="57"></a>    /* 
<a name="58"></a>     *   Return a new number, with the same value as this number but with
<a name="59"></a>     *   the given number of decimal digits of precision.  If the new
<a name="60"></a>     *   precision is higher than the old precision, this will increase
<a name="61"></a>     *   the precision to the requested new size and add trailing zeroes
<a name="62"></a>     *   to the value.  If the new precision is lower than the old
<a name="63"></a>     *   precision, we'll round the number for the reduced precision.  
<a name="64"></a>     */
<a name="65"></a>    setPrecision(digits);
<a name="66"></a>
<a name="67"></a>    /* get the fractional part */
<a name="68"></a>    getFraction();
<a name="69"></a>
<a name="70"></a>    /* get the whole part (truncates the fraction - doesn't round) */
<a name="71"></a>    getWhole();
<a name="72"></a>
<a name="73"></a>    /* 
<a name="74"></a>     *   round to the given number of digits after the decimal point; if
<a name="75"></a>     *   the value is zero, round to integer; if the value is negative,
<a name="76"></a>     *   round to the given number of places before the decimal point 
<a name="77"></a>     */
<a name="78"></a>    roundToDecimal(places);
<a name="79"></a>
<a name="80"></a>    /* return the absolute value */
<a name="81"></a>    getAbs();
<a name="82"></a>
<a name="83"></a>    /* least integer greater than or equal to this number */
<a name="84"></a>    getCeil();
<a name="85"></a>
<a name="86"></a>    /* greatest integer less than or equal to this number */
<a name="87"></a>    getFloor();
<a name="88"></a>
<a name="89"></a>    /* get the base-10 scale of the number */
<a name="90"></a>    getScale();
<a name="91"></a>
<a name="92"></a>    /* 
<a name="93"></a>     *   scale by 10^x - if x is positive, this multiplies the number by
<a name="94"></a>     *   ten the given number of times; if x is negative, this divides the
<a name="95"></a>     *   number by ten the given number of times 
<a name="96"></a>     */
<a name="97"></a>    scaleTen(x);
<a name="98"></a>
<a name="99"></a>    /* negate - invert the sign of the number */
<a name="100"></a>    negate();
<a name="101"></a>
<a name="102"></a>    /* 
<a name="103"></a>     *   copySignFrom - combine the absolute value of self with the sign
<a name="104"></a>     *   of x 
<a name="105"></a>     */
<a name="106"></a>    copySignFrom(x);
<a name="107"></a>
<a name="108"></a>    /* determine if the value is negative */
<a name="109"></a>    isNegative();
<a name="110"></a>
<a name="111"></a>    /* 
<a name="112"></a>     *   Calculate the integer quotient and the remainder; returns a list
<a name="113"></a>     *   whose first element is the integer quotient (a BigNumber
<a name="114"></a>     *   containing an integer value), and whose second element is the
<a name="115"></a>     *   remainder (the value R such that dividend = quotient*x + R).
<a name="116"></a>     *   
<a name="117"></a>     *   Note that the quotient returned will not necessarily have the
<a name="118"></a>     *   same value as the whole part of dividing self by x with the '/'
<a name="119"></a>     *   operator, because this division handles rounding differently.  In
<a name="120"></a>     *   particular, the '/' operator will perform the appropriate
<a name="121"></a>     *   rounding on the quotient if the quotient has insufficient
<a name="122"></a>     *   precision to represent the exact result.  This routine, in
<a name="123"></a>     *   contrast, does NOT round the quotient, but merely truncates any
<a name="124"></a>     *   trailing digits that cannot be represented in the result's
<a name="125"></a>     *   precision.  The reason for this difference is that it ensures
<a name="126"></a>     *   that the relation (dividend=quotient*x+remainder) holds, which
<a name="127"></a>     *   would not always be the case if the quotient were rounded up.
<a name="128"></a>     *   
<a name="129"></a>     *   Note also that the remainder will not necessarily be less than
<a name="130"></a>     *   the divisor.  If the quotient cannot be exactly represented
<a name="131"></a>     *   (which occurs if the precision of the quotient is smaller than
<a name="132"></a>     *   its scale), the remainder will be the correct value so that the
<a name="133"></a>     *   relationship above holds, rather than the unique remainder that
<a name="134"></a>     *   is smaller than the divisor.  In all cases where there is
<a name="135"></a>     *   sufficient precision to represent the quotient exactly (to the
<a name="136"></a>     *   units digit only, since the quotient returned from this method
<a name="137"></a>     *   will always be an integer), the remainder will satisfy the
<a name="138"></a>     *   relationship AND will be the unique remainder with absolute value
<a name="139"></a>     *   less than the divisor.  
<a name="140"></a>     */
<a name="141"></a>    divideBy(x);
<a name="142"></a>
<a name="143"></a>    /* 
<a name="144"></a>     *   calculate and return the trigonometric sine of the value (taken
<a name="145"></a>     *   as a radian value) 
<a name="146"></a>     */
<a name="147"></a>    sine();
<a name="148"></a>
<a name="149"></a>    /* 
<a name="150"></a>     *   calculate and return the trigonometric cosine of the value (taken
<a name="151"></a>     *   as a radian value) 
<a name="152"></a>     */
<a name="153"></a>    cosine();
<a name="154"></a>
<a name="155"></a>    /* 
<a name="156"></a>     *   calculate and return the trigonometric tangent of the value
<a name="157"></a>     *   (taken as a radian value) 
<a name="158"></a>     */
<a name="159"></a>    tangent();
<a name="160"></a>
<a name="161"></a>    /* 
<a name="162"></a>     *   interpreting this number as a number of degrees, convert the
<a name="163"></a>     *   value to radians and return the result 
<a name="164"></a>     */
<a name="165"></a>    degreesToRadians();
<a name="166"></a>
<a name="167"></a>    /* 
<a name="168"></a>     *   interpreting this number as a number of radians, convert the
<a name="169"></a>     *   value to degrees and return the result 
<a name="170"></a>     */
<a name="171"></a>    radiansToDegrees();
<a name="172"></a>
<a name="173"></a>    /* 
<a name="174"></a>     *   Calculate and return the arcsine (in radians) of the value.  Note
<a name="175"></a>     *   that the value must be between -1 and +1 inclusive, since sine()
<a name="176"></a>     *   never has a value outside of this range. 
<a name="177"></a>     */
<a name="178"></a>    arcsine();
<a name="179"></a>
<a name="180"></a>    /* 
<a name="181"></a>     *   Calculate and return the arccosine (in radians).  The value must
<a name="182"></a>     *   be between -1 and +1 inclusive. 
<a name="183"></a>     */
<a name="184"></a>    arccosine();
<a name="185"></a>
<a name="186"></a>    /* calculate and return the arctangent (in radians) */
<a name="187"></a>    arctangent();
<a name="188"></a>
<a name="189"></a>    /* calculate the square root and return the result */
<a name="190"></a>    sqrt();
<a name="191"></a>
<a name="192"></a>    /* 
<a name="193"></a>     *   calculate the natural logarithm of this number and return the
<a name="194"></a>     *   result 
<a name="195"></a>     */
<a name="196"></a>    logE();
<a name="197"></a>
<a name="198"></a>    /* 
<a name="199"></a>     *   raise e (the base of the natural logarithm) to the power of this
<a name="200"></a>     *   value and return the result 
<a name="201"></a>     */
<a name="202"></a>    expE();
<a name="203"></a>
<a name="204"></a>    /* calculate the base-10 logarithm of the number and return the result */
<a name="205"></a>    log10();
<a name="206"></a>
<a name="207"></a>    /* 
<a name="208"></a>     *   raise this number to the power of the argument and return the
<a name="209"></a>     *   result 
<a name="210"></a>     */
<a name="211"></a>    raiseToPower(x);
<a name="212"></a>
<a name="213"></a>    /* calculate the hyperbolic sine, cosine, and tangent */
<a name="214"></a>    sinh();
<a name="215"></a>    cosh();
<a name="216"></a>    tanh();
<a name="217"></a>
<a name="218"></a>    /* get the value of pi to a given precision */
<a name="219"></a>    getPi(digits);
<a name="220"></a>
<a name="221"></a>    /* get the value of e to a given precision */
<a name="222"></a>    getE(digits);
<a name="223"></a>}
<a name="224"></a>
<a name="225"></a>/*
<a name="226"></a> *   flags for formatString 
<a name="227"></a> */
<a name="228"></a>
<a name="229"></a>/* always show a sign, even if positive */
<a name="230"></a>#define BignumSign          0x0001
<a name="231"></a>
<a name="232"></a>/* always show in exponential format */
<a name="233"></a>#define BignumExp           0x0002
<a name="234"></a>
<a name="235"></a>/* always show a sign in the exponent, even if positive */
<a name="236"></a>#define BignumExpSign      0x0004
<a name="237"></a>
<a name="238"></a>/* 
<a name="239"></a> *   show a zero before the decimal point - this is only relevant in
<a name="240"></a> *   non-exponential format when the number is between -1 and +1 
<a name="241"></a> */
<a name="242"></a>#define BignumLeadingZero  0x0008
<a name="243"></a>
<a name="244"></a>/* always show a decimal point */
<a name="245"></a>#define BignumPoint         0x0010
<a name="246"></a>
<a name="247"></a>/* insert commas to denote thousands, millions, etc */
<a name="248"></a>#define BignumCommas        0x0020
<a name="249"></a>
<a name="250"></a>/* show a leading space if the number is positive */
<a name="251"></a>#define BignumPosSpace     0x0040
<a name="252"></a>
<a name="253"></a>/* 
<a name="254"></a> *   use European-style formatting: use a comma instead of a period for
<a name="255"></a> *   the decimal point, and use periods instead of commas to set off
<a name="256"></a> *   thousands, millions, etc 
<a name="257"></a> */
<a name="258"></a>#define BignumEuroStyle     0x0080
<a name="259"></a>
<a name="260"></a>#endif /* _BIGNUM_H_ */
<a name="261"></a>
</pre>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/6/2009 from TADS version 3.0.18.1</div>
</body>
</html>
