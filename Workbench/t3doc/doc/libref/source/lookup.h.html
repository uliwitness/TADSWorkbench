<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>lookup.h</title></head><body>
<table class=ban><tr><td><h1>lookup.h</h1><td align=right><a href="../file/lookup.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/* 
<a name="4"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts
<a name="5"></a> *   
<a name="6"></a> *   This file is part of TADS 3.
<a name="7"></a> *   
<a name="8"></a> *   The header defines the LookupTable and WeakRefLookupTable intrinsic
<a name="9"></a> *   classes, as well as LookupTableIterator, the special Iterator type for
<a name="10"></a> *   these classes.  
<a name="11"></a> */
<a name="12"></a>
<a name="13"></a>#ifndef _LOOKUP_H_
<a name="14"></a>#define _LOOKUP_H_
<a name="15"></a>
<a name="16"></a>/* include our base class definitions */
<a name="17"></a>#include "systype.h"
<a name="18"></a>
<a name="19"></a>/*
<a name="20"></a> *   The LookupTable intrinsic class provides a general-purpose hash table
<a name="21"></a> *   implementation.  LookupTable can be used syntactically as though it were
<a name="22"></a> *   a list, but the index values are arbitrary hash key values rather than
<a name="23"></a> *   being limited to sequential integers.  
<a name="24"></a> */
<a name="25"></a>intrinsic class LookupTable 'lookuptable/030002': Collection
<a name="26"></a>{
<a name="27"></a>    /* 
<a name="28"></a>     *   Determine if a given key is present in the table.  Returns true if
<a name="29"></a>     *   the key is present, nil if not. 
<a name="30"></a>     */
<a name="31"></a>    isKeyPresent(key);
<a name="32"></a>
<a name="33"></a>    /*
<a name="34"></a>     *   Remove an entry from the table.  Removes the key/value pair
<a name="35"></a>     *   associated with the given key, and returns the value that was
<a name="36"></a>     *   associated with the key.  If the key isn't present in the table,
<a name="37"></a>     *   the return value is nil, and the method has no other effect. 
<a name="38"></a>     */
<a name="39"></a>    removeElement(key);
<a name="40"></a>
<a name="41"></a>    /*
<a name="42"></a>     *   Apply the given function to each entry, and replace the value of
<a name="43"></a>     *   the entry with the return value of the function.  The callback is
<a name="44"></a>     *   invoked with the key and value as arguments for each entry:
<a name="45"></a>     *   func(key, value).  No return value.
<a name="46"></a>     */
<a name="47"></a>    applyAll(func);
<a name="48"></a>
<a name="49"></a>    /*
<a name="50"></a>     *   Invoke the given function with each entry in the table.  The
<a name="51"></a>     *   function is invoked with value of an entry as its argument:
<a name="52"></a>     *   func(value).  Any return value of the function is ignored.  No
<a name="53"></a>     *   return value.  
<a name="54"></a>     */
<a name="55"></a>    forEach(func);
<a name="56"></a>
<a name="57"></a>    /*
<a name="58"></a>     *   Get the number of buckets (i.e., slots for unique hash values).
<a name="59"></a>     *   The number of buckets doesn't vary over the life of the table, so
<a name="60"></a>     *   this simply returns the number of buckets that was specified in the
<a name="61"></a>     *   constructor when the table was created.  This can be used to create
<a name="62"></a>     *   a new table with the same parameters as an existing table.  
<a name="63"></a>     */
<a name="64"></a>    getBucketCount();
<a name="65"></a>
<a name="66"></a>    /*
<a name="67"></a>     *   Get the number of entries.  This returns the number of key/value
<a name="68"></a>     *   pairs stored in the table.  Note that this is not the same as the
<a name="69"></a>     *   initial capacity specified in the constructor when the table was
<a name="70"></a>     *   created; this is the number of entries actually stored in the
<a name="71"></a>     *   table.  
<a name="72"></a>     */
<a name="73"></a>    getEntryCount();
<a name="74"></a>
<a name="75"></a>    /*
<a name="76"></a>     *   Invoke the given function with each entry in the table, passing the
<a name="77"></a>     *   key and value to the callback.  The function is invoked with key
<a name="78"></a>     *   and value of an entry as its arguments: func(key, value).  Any
<a name="79"></a>     *   return value of the function is ignored.  No return value.  
<a name="80"></a>     */
<a name="81"></a>    forEachAssoc(func);
<a name="82"></a>
<a name="83"></a>    /*
<a name="84"></a>     *   Make a list of all of my keys or values.  The return value is a
<a name="85"></a>     *   list, in arbitrary order, of all of the keys or values in the table.
<a name="86"></a>     */
<a name="87"></a>    keysToList();
<a name="88"></a>    valsToList();
<a name="89"></a>}
<a name="90"></a>
<a name="91"></a>/*
<a name="92"></a> *   WeakRefLookupTable is a "weak reference" version of the basic lookup
<a name="93"></a> *   table.  This is similar to the regular LookupTable, and has the same
<a name="94"></a> *   methods; the only difference is that this type of table references its
<a name="95"></a> *   values "weakly."  A value that is reachable only through weak references
<a name="96"></a> *   is subject to deletion by the garbage collector.  A weak-reference
<a name="97"></a> *   lookup table is useful when you don't want a value's presence in the
<a name="98"></a> *   table to force the value to stay active, such as when the lookup table
<a name="99"></a> *   is merely a fast index to a set of values that must be otherwise
<a name="100"></a> *   reachable to be useful.  When the garbage collector deletes one of our
<a name="101"></a> *   values, the key/value pair for the value is automatically deleted from
<a name="102"></a> *   the table.  
<a name="103"></a> */
<a name="104"></a>intrinsic class WeakRefLookupTable 'weakreflookuptable/030000': LookupTable
<a name="105"></a>{
<a name="106"></a>}
<a name="107"></a>
<a name="108"></a>/*
<a name="109"></a> *   LookupTable iterator - this type of iterator is used for LookupTable and
<a name="110"></a> *   WeakRefLookupTable instances.  
<a name="111"></a> */
<a name="112"></a>intrinsic class LookupTableIterator 'lookuptable-iterator/030000': Iterator
<a name="113"></a>{
<a name="114"></a>}
<a name="115"></a>
<a name="116"></a>#endif /* _LOOKUP_H_ */
</pre>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/6/2009 from TADS version 3.0.18.1</div>
</body>
</html>
