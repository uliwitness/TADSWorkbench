<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>travel.t</title></head><body>
<table class=ban><tr><td><h1>travel.t</h1><td align=right><a href="../file/travel.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/* 
<a name="4"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts.  All Rights Reserved. 
<a name="5"></a> *   
<a name="6"></a> *   TADS 3 Library - travel
<a name="7"></a> *   
<a name="8"></a> *   This module defines the parts of the simulation model related to
<a name="9"></a> *   travel: rooms and other locations, directions, passages.  
<a name="10"></a> */
<a name="11"></a>
<a name="12"></a>/* include the library header */
<a name="13"></a>#include "adv3.h"
<a name="14"></a>
<a name="15"></a>
<a name="16"></a>/* ------------------------------------------------------------------------ */
<a name="17"></a>/*
<a name="18"></a> *   Directions.  Each direction is represented by an instance of
<a name="19"></a> *   Direction.
<a name="20"></a> *   
<a name="21"></a> *   A Direction object encapsulates information about a travel direction.
<a name="22"></a> *   By using an object to represent each possible travel direction, we
<a name="23"></a> *   make it possible for a game or library extension to add new custom
<a name="24"></a> *   directions without having to change the basic library.  
<a name="25"></a> */
<a name="26"></a>class Direction: object
<a name="27"></a>    /*
<a name="28"></a>     *   The link property for the direction.  This is a property pointer
<a name="29"></a>     *   that we use to ask an actor's location for a TravelConnector when
<a name="30"></a>     *   the actor attempts to travel in this direction.  
<a name="31"></a>     */
<a name="32"></a>    dirProp = nil
<a name="33"></a>
<a name="34"></a>    /* 
<a name="35"></a>     *   The default TravelConnector when an actor attempts travel in this
<a name="36"></a>     *   direction, but the actor's location does not define the dirProp
<a name="37"></a>     *   property for this direction.  This is almost always a connector
<a name="38"></a>     *   that goes nowhere, such as noTravel, since this is used only when
<a name="39"></a>     *   a location doesn't have a link for travel in this direction.  
<a name="40"></a>     */
<a name="41"></a>    defaultConnector(loc) { return noTravel; }
<a name="42"></a>
<a name="43"></a>    /*
<a name="44"></a>     *   Initialize.  We'll use this routine to add each Direction
<a name="45"></a>     *   instance to the master direction list (Direction.allDirections)
<a name="46"></a>     *   during pre-initialization.  
<a name="47"></a>     */
<a name="48"></a>    initializeDirection()
<a name="49"></a>    {
<a name="50"></a>        /* add myself to the master direction list */
<a name="51"></a>        Direction.allDirections.append(self);
<a name="52"></a>    }
<a name="53"></a>
<a name="54"></a>    /*
<a name="55"></a>     *   Class initialization - this is called once on the class object.
<a name="56"></a>     *   We'll build our master list of all of the Direction objects in
<a name="57"></a>     *   the game, and then sort the list using the sorting order.  
<a name="58"></a>     */
<a name="59"></a>    initializeDirectionClass()
<a name="60"></a>    {
<a name="61"></a>        /* initialize each individual Direction object */
<a name="62"></a>        forEachInstance(Direction, { dir: dir.initializeDirection() });
<a name="63"></a>
<a name="64"></a>        /* 
<a name="65"></a>         *   sort the direction list according to the individual Directin
<a name="66"></a>         *   objects' defined sorting orders 
<a name="67"></a>         */
<a name="68"></a>        allDirections.sort(SortAsc, {a, b: a.sortingOrder - b.sortingOrder});
<a name="69"></a>    }
<a name="70"></a>
<a name="71"></a>    /* 
<a name="72"></a>     *   Our sorting order in the master list.  We use this to present
<a name="73"></a>     *   directions in a consistent, aesthetically pleasing order in
<a name="74"></a>     *   listings involving multiple directions.  The sorting order is
<a name="75"></a>     *   simply an integer that gives the relative position in the list;
<a name="76"></a>     *   the list of directions is sorted from lowest sorting order to
<a name="77"></a>     *   highest.  Sorting order numbers don't have to be contiguous,
<a name="78"></a>     *   since we simply put the directions in an order that makes the
<a name="79"></a>     *   sortingOrder values ascend through the list.  
<a name="80"></a>     */
<a name="81"></a>    sortingOrder = 1
<a name="82"></a>
<a name="83"></a>    /* 
<a name="84"></a>     *   A master list of the defined directions.  We build this
<a name="85"></a>     *   automatically during initialization to include each Direction
<a name="86"></a>     *   instance.  Any operation that wants to iterate over all possible
<a name="87"></a>     *   directions can run through this list.
<a name="88"></a>     *   
<a name="89"></a>     *   By using this master list to enumerate all possible directions
<a name="90"></a>     *   rather than a hard-coded set of pre-defined directions, we can
<a name="91"></a>     *   ensure that any new directions that a game or library extension
<a name="92"></a>     *   adds will be incorporated automatically into the library simply
<a name="93"></a>     *   by virtue of the existence Direction instances to represent the
<a name="94"></a>     *   new directions.  
<a name="95"></a>     */
<a name="96"></a>    allDirections = static new Vector(10)
<a name="97"></a>;
<a name="98"></a>
<a name="99"></a>/*
<a name="100"></a> *   The base class for compass directions (north, south, etc).  We don't
<a name="101"></a> *   add anything to the basic Direction class, but we use a separate
<a name="102"></a> *   class for compass directions to allow language-specific
<a name="103"></a> *   customizations for all of the directions and to allow travel commands
<a name="104"></a> *   to treat these specially when needed.  
<a name="105"></a> */
<a name="106"></a>class CompassDirection: Direction
<a name="107"></a>;
<a name="108"></a>
<a name="109"></a>/*
<a name="110"></a> *   The base class for shipboard directions (port, aft, etc).
<a name="111"></a> */
<a name="112"></a>class ShipboardDirection: Direction
<a name="113"></a>    defaultConnector(loc)
<a name="114"></a>    {
<a name="115"></a>        /* 
<a name="116"></a>         *   If 'loc' is aboard a ship, use noTravel as the default
<a name="117"></a>         *   connector, since we simply can't go this direction.  If we're
<a name="118"></a>         *   not aboard ship, use the special connector noShipTravel,
<a name="119"></a>         *   which is meant to convey that shipboard directions make no
<a name="120"></a>         *   sense when not aboard a ship.  
<a name="121"></a>         */
<a name="122"></a>        return (loc.isShipboard ? noTravel : noShipTravel);
<a name="123"></a>    }
<a name="124"></a>;
<a name="125"></a>
<a name="126"></a>/*
<a name="127"></a> *   The base class for vertical directions (up, down) 
<a name="128"></a> */
<a name="129"></a>class VerticalDirection: Direction
<a name="130"></a>;
<a name="131"></a>
<a name="132"></a>/*
<a name="133"></a> *   The base class for "relative" directions (in, out) 
<a name="134"></a> */
<a name="135"></a>class RelativeDirection: Direction
<a name="136"></a>;
<a name="137"></a>
<a name="138"></a>/*
<a name="139"></a> *   Individual compass directions.  
<a name="140"></a> *   
<a name="141"></a> *   Our macro defines a direction object with a name based on the
<a name="142"></a> *   direction's room travel link property and the base class.  So,
<a name="143"></a> *   DefineDirection(north, Compass) defines a direction object called
<a name="144"></a> *   'northDirection' based on the CompassDirection class, with the link
<a name="145"></a> *   property 'north' and default travel connector 'noTravel'.
<a name="146"></a> *   
<a name="147"></a> *   Note that we define a sorting order among the default directions as
<a name="148"></a> *   follows.  First, we define several groups of related directions,
<a name="149"></a> *   which we put in a relative order: the compass directions, then the
<a name="150"></a> *   vertical directions, then the "relative" (in/out) directions, and
<a name="151"></a> *   finally the shipboard directions.  Then, we order the directions
<a name="152"></a> *   within these groups.  For the sortingOrder values, we use arbitrary
<a name="153"></a> *   integers with fairly wide separations, to leave plenty of room for
<a name="154"></a> *   custom game-specific directions to be added before, between, after,
<a name="155"></a> *   or within these pre-defined groups.  
<a name="156"></a> */
<a name="157"></a>#define DefineDirection(prop, base, order) \
<a name="158"></a>    prop##Direction: base##Direction \
<a name="159"></a>    dirProp = &amp;prop \
<a name="160"></a>    sortingOrder = order
<a name="161"></a>
<a name="162"></a>DefineDirection(north, Compass, 1000);
<a name="163"></a>DefineDirection(south, Compass, 1100);
<a name="164"></a>DefineDirection(east, Compass,  1200);
<a name="165"></a>DefineDirection(west, Compass,  1300);
<a name="166"></a>DefineDirection(northeast, Compass, 1400);
<a name="167"></a>DefineDirection(northwest, Compass, 1500);
<a name="168"></a>DefineDirection(southeast, Compass, 1600);
<a name="169"></a>DefineDirection(southwest, Compass, 1700);
<a name="170"></a>
<a name="171"></a>DefineDirection(up, Vertical, 3000);
<a name="172"></a>DefineDirection(down, Vertical, 3100);
<a name="173"></a>
<a name="174"></a>DefineDirection(in, Relative, 5000)
<a name="175"></a>    defaultConnector(loc) { return noTravelIn; }
<a name="176"></a>;
<a name="177"></a>
<a name="178"></a>DefineDirection(out, Relative, 5100)
<a name="179"></a>    defaultConnector(loc) { return noTravelOut; }
<a name="180"></a>;
<a name="181"></a>
<a name="182"></a>DefineDirection(fore, Shipboard, 7000);
<a name="183"></a>DefineDirection(aft, Shipboard, 7100);
<a name="184"></a>DefineDirection(port, Shipboard, 7200);
<a name="185"></a>DefineDirection(starboard, Shipboard, 7300);
<a name="186"></a>
<a name="187"></a>
<a name="188"></a>/* ------------------------------------------------------------------------ */
<a name="189"></a>/*
<a name="190"></a> *   Travel Message Handler.  This contains a set of messages that are
<a name="191"></a> *   specific to different types of TravelConnector objects, to describe
<a name="192"></a> *   NPC arrivals and departures via these connectors when the NPC's are in
<a name="193"></a> *   view of the player character.
<a name="194"></a> *   
<a name="195"></a> *   This base class implements the methods simply by calling the
<a name="196"></a> *   corresponding gLibMessages message methods.
<a name="197"></a> *   
<a name="198"></a> *   The purpose of providing this variety of connector-specific handlers
<a name="199"></a> *   is to make it easy for individual travelers to customize the
<a name="200"></a> *   arrival/departure messages for specific connector subclasses.  These
<a name="201"></a> *   messages sometimes benefit from customization for specific
<a name="202"></a> *   traveler/connector combinations; the easiest way to enable such
<a name="203"></a> *   granular customization is to make it possible to override a message
<a name="204"></a> *   per connector type on the traveler object.  
<a name="205"></a> */
<a name="206"></a>class TravelMessageHandler: object
<a name="207"></a>    /* 
<a name="208"></a>     *   Get the traveler for the purposes of arrival/departure messages.
<a name="209"></a>     *   Implementations that aren't themselves the travelers should
<a name="210"></a>     *   override this to supply the correct nominal traveler. 
<a name="211"></a>     */
<a name="212"></a>    getNominalTraveler() { return self; }
<a name="213"></a>
<a name="214"></a>    /* generic arrival/departure - for the base TravelConnector class */
<a name="215"></a>    sayArriving(conn) { gLibMessages.sayArriving(getNominalTraveler()); }
<a name="216"></a>    sayDeparting(conn) { gLibMessages.sayDeparting(getNominalTraveler()); }
<a name="217"></a>
<a name="218"></a>    /* generic local arrival and departure messages */
<a name="219"></a>    sayArrivingLocally(dest, conn)
<a name="220"></a>        { gLibMessages.sayArrivingLocally(getNominalTraveler(), dest); }
<a name="221"></a>    sayDepartingLocally(dest, conn)
<a name="222"></a>        { gLibMessages.sayDepartingLocally(getNominalTraveler(), dest); }
<a name="223"></a>
<a name="224"></a>    /* generic remote travel message */
<a name="225"></a>    sayTravelingRemotely(dest, conn)
<a name="226"></a>        { gLibMessages.sayTravelingRemotely(getNominalTraveler(), dest); }
<a name="227"></a>
<a name="228"></a>    /* directional arrival/departure - for RoomConnector */
<a name="229"></a>    sayArrivingDir(dir, conn) { dir.sayArriving(getNominalTraveler()); }
<a name="230"></a>    sayDepartingDir(dir, conn) { dir.sayDeparting(getNominalTraveler()); }
<a name="231"></a>
<a name="232"></a>    /* arrival/departure via a ThroughPassage */
<a name="233"></a>    sayArrivingThroughPassage(conn)
<a name="234"></a>    {
<a name="235"></a>        gLibMessages.sayArrivingThroughPassage(getNominalTraveler(), conn);
<a name="236"></a>    }
<a name="237"></a>    sayDepartingThroughPassage(conn)
<a name="238"></a>    {
<a name="239"></a>        gLibMessages.sayDepartingThroughPassage(getNominalTraveler(), conn);
<a name="240"></a>    }
<a name="241"></a>
<a name="242"></a>    /* arrival/departure via a PathPassage */
<a name="243"></a>    sayArrivingViaPath(conn)
<a name="244"></a>        { gLibMessages.sayArrivingViaPath(getNominalTraveler(), conn); }
<a name="245"></a>    sayDepartingViaPath(conn)
<a name="246"></a>        { gLibMessages.sayDepartingViaPath(getNominalTraveler(), conn); }
<a name="247"></a>
<a name="248"></a>    /* arrival/departure up/down stairs */
<a name="249"></a>    sayArrivingUpStairs(conn)
<a name="250"></a>        { gLibMessages.sayArrivingUpStairs(getNominalTraveler(), conn); }
<a name="251"></a>    sayArrivingDownStairs(conn)
<a name="252"></a>        { gLibMessages.sayArrivingDownStairs(getNominalTraveler(), conn); }
<a name="253"></a>    sayDepartingUpStairs(conn)
<a name="254"></a>        { gLibMessages.sayDepartingUpStairs(getNominalTraveler(), conn); }
<a name="255"></a>    sayDepartingDownStairs(conn)
<a name="256"></a>        { gLibMessages.sayDepartingDownStairs(getNominalTraveler(), conn); }
<a name="257"></a>;
<a name="258"></a>
<a name="259"></a>/* ------------------------------------------------------------------------ */
<a name="260"></a>/*
<a name="261"></a> *   A Traveler is an object that can travel.  The two main kinds of
<a name="262"></a> *   travelers are Actors and Vehicles.  A vehicle can contain multiple
<a name="263"></a> *   actors, so a single vehicle travel operation could move several
<a name="264"></a> *   actors.
<a name="265"></a> *   
<a name="266"></a> *   This class is intended to be multiply inherited, since it is not based
<a name="267"></a> *   on any simulation object class.  
<a name="268"></a> */
<a name="269"></a>class Traveler: TravelMessageHandler
<a name="270"></a>    /*
<a name="271"></a>     *   Check, using pre-condition rules, that the traveler is directly
<a name="272"></a>     *   in the given room.  We'll attempt to implicitly remove the actor
<a name="273"></a>     *   from any nested rooms within the given room.  
<a name="274"></a>     */
<a name="275"></a>    checkDirectlyInRoom(dest, allowImplicit)
<a name="276"></a>    {
<a name="277"></a>        /* ask the destination to ensure the traveler is in it directly */
<a name="278"></a>        return dest.checkTravelerDirectlyInRoom(self, allowImplicit);
<a name="279"></a>    }
<a name="280"></a>
<a name="281"></a>    /*
<a name="282"></a>     *   Check, using pre-condition rules, that the traveler is in the
<a name="283"></a>     *   given room, moving the traveler to the room if possible. 
<a name="284"></a>     */
<a name="285"></a>    checkMovingTravelerInto(room, allowImplicit)
<a name="286"></a>    {
<a name="287"></a>        /* subclasses must override */
<a name="288"></a>    }
<a name="289"></a>
<a name="290"></a>    /*
<a name="291"></a>     *   Get the travel preconditions specific to the traveler, for the
<a name="292"></a>     *   given connector.  By default, we return no extra conditions.  
<a name="293"></a>     */
<a name="294"></a>    travelerPreCond(conn) { return []; }
<a name="295"></a>
<a name="296"></a>    /*
<a name="297"></a>     *   Can the traveler travel via the given connector to the given
<a name="298"></a>     *   destination?  Returns true if the travel is permitted, nil if not.
<a name="299"></a>     *   
<a name="300"></a>     *   By default, this simply returns true to indicate that the travel
<a name="301"></a>     *   is allowed.  Individual instances can override this to enforce
<a name="302"></a>     *   limitations on what kind of travel the traveler can perform.  
<a name="303"></a>     */
<a name="304"></a>    canTravelVia(connector, dest) { return true; }
<a name="305"></a>
<a name="306"></a>    /* 
<a name="307"></a>     *   Explain why the given travel is not possible.  This is called when
<a name="308"></a>     *   canTravelVia() returns nil, to display a report to the player
<a name="309"></a>     *   explaining why the travel was disallowed.
<a name="310"></a>     *   
<a name="311"></a>     *   By default, we do nothing, since our default canTravelVia() never
<a name="312"></a>     *   disallows any travel.  If canTravelVia() is overridden to disallow
<a name="313"></a>     *   travel under some conditions, this must be overridden to generate
<a name="314"></a>     *   an appropriate explanatory report.  
<a name="315"></a>     */
<a name="316"></a>    explainNoTravelVia(connector, dest) { }
<a name="317"></a>
<a name="318"></a>    /*
<a name="319"></a>     *   Show my departure message - this is shown when I'm leaving a room
<a name="320"></a>     *   where the player character can see me for another room where the
<a name="321"></a>     *   player character cannot see me.  
<a name="322"></a>     */
<a name="323"></a>    describeDeparture(dest, connector)
<a name="324"></a>    {
<a name="325"></a>        /* 
<a name="326"></a>         *   If we're visible to the player character, describe the
<a name="327"></a>         *   departure.  Ask the connector to describe the travel, since
<a name="328"></a>         *   it knows the direction of travel and can describe special
<a name="329"></a>         *   things like climbing stairs.
<a name="330"></a>         *   
<a name="331"></a>         *   Don't bother to describe the departure if the traveler is the
<a name="332"></a>         *   player character, or the player character is inside the
<a name="333"></a>         *   traveler.  The PC obviously can't leave the presence of
<a name="334"></a>         *   itself.
<a name="335"></a>         */
<a name="336"></a>        if (!isActorTraveling(gPlayerChar))
<a name="337"></a>        {
<a name="338"></a>            /* 
<a name="339"></a>             *   invoke the departure with a visual sense context for the
<a name="340"></a>             *   traveler 
<a name="341"></a>             */
<a name="342"></a>            callWithSenseContext(self, sight,
<a name="343"></a>                                 {: describeNpcDeparture(dest, connector)});
<a name="344"></a>        }
<a name="345"></a>    }
<a name="346"></a>
<a name="347"></a>    /*
<a name="348"></a>     *   Describe the departure of a non-player character, or any traveler
<a name="349"></a>     *   not involving the player character. 
<a name="350"></a>     */
<a name="351"></a>    describeNpcDeparture(dest, connector)
<a name="352"></a>    {
<a name="353"></a>        /*
<a name="354"></a>         *   If the PC can see our destination, we're doing "local travel"
<a name="355"></a>         *   - we're traveling from one top-level location to another, but
<a name="356"></a>         *   entirely in view of the PC.  In this case, the PC was already
<a name="357"></a>         *   aware of our presence, so we don't want to describe the
<a name="358"></a>         *   departure as though we're actually leaving; we're just moving
<a name="359"></a>         *   around.  If the destination isn't in sight, then we're truly
<a name="360"></a>         *   departing. 
<a name="361"></a>         */
<a name="362"></a>        if (gPlayerChar.canSee(dest))
<a name="363"></a>        {
<a name="364"></a>            /* 
<a name="365"></a>             *   We're moving from somewhere within the PC's sight to
<a name="366"></a>             *   another location within the PC's sight, so we're not
<a name="367"></a>             *   actually departing, from the PC's point of view: we're
<a name="368"></a>             *   just moving around a bit.
<a name="369"></a>             *   
<a name="370"></a>             *   - If we're moving further away from the PC - that is, if
<a name="371"></a>             *   we're moving out of the PC's own top-level location and
<a name="372"></a>             *   into a different top-level location, describe this as a
<a name="373"></a>             *   "local departure."
<a name="374"></a>             *   
<a name="375"></a>             *   - If we're moving closer to the PC - moving from a top
<a name="376"></a>             *   level location that doesn't contain the PC to the PC's
<a name="377"></a>             *   current top-level location - say nothing.  We'll leave it
<a name="378"></a>             *   to the "local arrival" message to mention it, because
<a name="379"></a>             *   that's the more relevant aspect of the travel from the
<a name="380"></a>             *   PC's POV: we're approaching the PC.
<a name="381"></a>             *   
<a name="382"></a>             *   - If we're moving from one top-level location to another,
<a name="383"></a>             *   say nothing.  We'll leave this to arrival time as well.
<a name="384"></a>             *   Whether we describe remote-to-remote travel as arrival or
<a name="385"></a>             *   departure is just arbitrary; we only want to generate one
<a name="386"></a>             *   message, but there's no general reason to prefer
<a name="387"></a>             *   generating the message at departure vs arrival.  
<a name="388"></a>             */
<a name="389"></a>            if (gPlayerChar.isIn(getOutermostRoom()))
<a name="390"></a>            {
<a name="391"></a>                /* 
<a name="392"></a>                 *   we're moving further away from the player - describe
<a name="393"></a>                 *   this as a local departure 
<a name="394"></a>                 */
<a name="395"></a>                connector.describeLocalDeparture(self, location, dest);
<a name="396"></a>            }
<a name="397"></a>        }
<a name="398"></a>        else
<a name="399"></a>        {
<a name="400"></a>            /* we're really departing - let the connector describe it */
<a name="401"></a>            connector.describeDeparture(self, location, dest);
<a name="402"></a>        }
<a name="403"></a>    }
<a name="404"></a>
<a name="405"></a>    /*
<a name="406"></a>     *   Show my arrival message - this is shown when I'm entering a room
<a name="407"></a>     *   in view of the player character from a location where the player
<a name="408"></a>     *   character could not see me.  'backConnector' is the connector in
<a name="409"></a>     *   the destination location from which we appear to be emerging.  
<a name="410"></a>     */
<a name="411"></a>    describeArrival(origin, backConnector)
<a name="412"></a>    {
<a name="413"></a>        /*
<a name="414"></a>         *   If the player character is participating in the travel,
<a name="415"></a>         *   describe the arrival from the point of view of the player
<a name="416"></a>         *   character by showing the "look around" description of the new
<a name="417"></a>         *   location.
<a name="418"></a>         *   
<a name="419"></a>         *   Otherwise, describe the NPC traveler's arrival.  Only
<a name="420"></a>         *   describe the arrival if the PC can see the traveler, for
<a name="421"></a>         *   obvious reasons.  
<a name="422"></a>         */
<a name="423"></a>        if (isActorTraveling(gPlayerChar))
<a name="424"></a>        {
<a name="425"></a>            /*
<a name="426"></a>             *   Add an intra-report separator, to visually separate the
<a name="427"></a>             *   description of the arrival from any result text that came
<a name="428"></a>             *   before.  (For example, if we performed an implied command
<a name="429"></a>             *   before we could begin travel, this will visually separate
<a name="430"></a>             *   the results of the implied command from the arrival
<a name="431"></a>             *   message.)  
<a name="432"></a>             */
<a name="433"></a>            say(gLibMessages.intraCommandSeparator);
<a name="434"></a>
<a name="435"></a>            /* 
<a name="436"></a>             *   The player character is traveling - show the travel from
<a name="437"></a>             *   the PC's perspective.  
<a name="438"></a>             */
<a name="439"></a>            gPlayerChar.lookAround(gameMain.verboseMode.isOn);
<a name="440"></a>        }
<a name="441"></a>        else if (travelerSeenBy(gPlayerChar))
<a name="442"></a>        {
<a name="443"></a>            /* 
<a name="444"></a>             *   The player character isn't traveling, but the PC can see
<a name="445"></a>             *   me now that I'm in my new location, so describe the
<a name="446"></a>             *   arrival of the traveler.  Do this within a visual sense
<a name="447"></a>             *   context for the traveler.  
<a name="448"></a>             */
<a name="449"></a>            callWithSenseContext(
<a name="450"></a>                self, sight, {: describeNpcArrival(origin, backConnector)});
<a name="451"></a>        }
<a name="452"></a>    }
<a name="453"></a>
<a name="454"></a>    /*
<a name="455"></a>     *   Describe the arrival of a non-player character or any other
<a name="456"></a>     *   traveler that doesn't involve the player character. 
<a name="457"></a>     */
<a name="458"></a>    describeNpcArrival(origin, backConnector)
<a name="459"></a>    {
<a name="460"></a>        /*  
<a name="461"></a>         *   If we know the connector back, use its arrival message;
<a name="462"></a>         *   otherwise, use a generic arrival message.  
<a name="463"></a>         */
<a name="464"></a>        if (backConnector != nil)
<a name="465"></a>        {
<a name="466"></a>            /*
<a name="467"></a>             *   If the PC can see the origin, we're not actually arriving
<a name="468"></a>             *   anew; instead, we're simply moving around within the PC's
<a name="469"></a>             *   field of view.  In these cases, we don't want to use the
<a name="470"></a>             *   normal arrival message, because we're not truly arriving;
<a name="471"></a>             *   we could be moving closer to the player, further away from
<a name="472"></a>             *   the player, or moving laterally from one remote location
<a name="473"></a>             *   to another.  If the PC can't see the origin, we're truly
<a name="474"></a>             *   arriving.  
<a name="475"></a>             */
<a name="476"></a>            if (gPlayerChar.canSee(origin))
<a name="477"></a>            {
<a name="478"></a>                /*
<a name="479"></a>                 *   We're not arriving anew, but just moving around within
<a name="480"></a>                 *   the PC's field of view.
<a name="481"></a>                 *   
<a name="482"></a>                 *   - If we're moving closer to the PC - moving from a
<a name="483"></a>                 *   top-level location that doesn't contain the PC to one
<a name="484"></a>                 *   that does - describe this as a "local arrival."
<a name="485"></a>                 *   
<a name="486"></a>                 *   - If we're moving further away from the PC - from
<a name="487"></a>                 *   within the PC's top-level location to a different
<a name="488"></a>                 *   top-level location - don't say anything.  We will have
<a name="489"></a>                 *   already described this as a "local departure" during
<a name="490"></a>                 *   the departure message phase, and from the PC's point
<a name="491"></a>                 *   of view, that fully covers it.
<a name="492"></a>                 *   
<a name="493"></a>                 *   - If we're moving laterally - from one remote
<a name="494"></a>                 *   top-level location to another ("remote" means "does
<a name="495"></a>                 *   not contain the PC") - it's arbitrary whether this
<a name="496"></a>                 *   should be described at arrival or departure time.  We
<a name="497"></a>                 *   arbitrarily pick arrival, so describe the lateral
<a name="498"></a>                 *   local travel now.  
<a name="499"></a>                 */
<a name="500"></a>                if (gPlayerChar.isIn(getOutermostRoom()))
<a name="501"></a>                {
<a name="502"></a>                    /* 
<a name="503"></a>                     *   We're now in the same top-level location as the
<a name="504"></a>                     *   PC, so we've moved closer to the PC, so describe
<a name="505"></a>                     *   this as a "local arrival."  
<a name="506"></a>                     */
<a name="507"></a>                    backConnector.describeLocalArrival(
<a name="508"></a>                        self, origin, location);
<a name="509"></a>                }
<a name="510"></a>                else if (!gPlayerChar.isIn(origin))
<a name="511"></a>                {
<a name="512"></a>                    /* 
<a name="513"></a>                     *   We're *not* in the same top-level location as the
<a name="514"></a>                     *   PC, and we weren't on departure either, so this is
<a name="515"></a>                     *   a lateral move - a move from one remote location
<a name="516"></a>                     *   to another.  Describe it as such now.  
<a name="517"></a>                     */
<a name="518"></a>                    backConnector.describeRemoteTravel(
<a name="519"></a>                        self, origin, location);
<a name="520"></a>                }
<a name="521"></a>            }
<a name="522"></a>            else
<a name="523"></a>            {
<a name="524"></a>                /* we're arriving anew - let the connector describe it */
<a name="525"></a>                backConnector.describeArrival(self, origin, location);
<a name="526"></a>            }
<a name="527"></a>        }
<a name="528"></a>        else
<a name="529"></a>        {
<a name="530"></a>            /* there's no back-connector, so use a generic arrival message */
<a name="531"></a>            gLibMessages.sayArriving(self);
<a name="532"></a>        }
<a name="533"></a>    }
<a name="534"></a>
<a name="535"></a>    /*
<a name="536"></a>     *   Travel to a new location.  Moves the traveler to a new location
<a name="537"></a>     *   via the given connector, triggering any side effects of the
<a name="538"></a>     *   travel.
<a name="539"></a>     *   
<a name="540"></a>     *   Note that this routine is not normally called directly; in most
<a name="541"></a>     *   cases, the actor's travelTo is called, and it in turn invokes
<a name="542"></a>     *   this method in the appropriate traveler.
<a name="543"></a>     *   
<a name="544"></a>     *   'dest' is the new location to which we're traveling.  'connector'
<a name="545"></a>     *   is the TravelConnector we're traversing from the source location
<a name="546"></a>     *   to reach the new destination; the connector is normally the
<a name="547"></a>     *   invoker of this routine.  'backConnector' is the connector in the
<a name="548"></a>     *   destination from which the actor will appear to emerge on the
<a name="549"></a>     *   other end of the travel.  
<a name="550"></a>     */
<a name="551"></a>    travelerTravelTo(dest, connector, backConnector)
<a name="552"></a>    {
<a name="553"></a>        local origin;
<a name="554"></a>        local isDescribed;
<a name="555"></a>        local actors;
<a name="556"></a>
<a name="557"></a>        /* 
<a name="558"></a>         *   Remember my departure original location - this is the
<a name="559"></a>         *   location where the traveler was before we moved. 
<a name="560"></a>         */
<a name="561"></a>        origin = location;
<a name="562"></a>
<a name="563"></a>        /*
<a name="564"></a>         *   Determine if we're describing the travel.  We'll describe it
<a name="565"></a>         *   if we're actually changing locations, or if the connector is
<a name="566"></a>         *   explicitly a "circular" passage, which means that it connects
<a name="567"></a>         *   back to the same location but involves a non-trivial passage,
<a name="568"></a>         *   as sometimes happens in settings like caves.  
<a name="569"></a>         */
<a name="570"></a>        isDescribed = (dest != origin || connector.isCircularPassage);
<a name="571"></a>
<a name="572"></a>        /* 
<a name="573"></a>         *   Send a before-departure notification to everyone connected to
<a name="574"></a>         *   by containment to the traveler. 
<a name="575"></a>         */
<a name="576"></a>        getNotifyTable().forEachAssoc(
<a name="577"></a>            {obj, val: obj.beforeTravel(self, connector)});
<a name="578"></a>
<a name="579"></a>        /* notify the actor initiating the travel */
<a name="580"></a>        if (gActor != nil)
<a name="581"></a>            gActor.actorTravel(self, connector);
<a name="582"></a>        
<a name="583"></a>        /* tell the old room we're leaving, if we changed locations */
<a name="584"></a>        if (origin != nil &amp;&amp; isDescribed)
<a name="585"></a>            origin.travelerLeaving(self, dest, connector);
<a name="586"></a>
<a name="587"></a>        /* notify the connector that we're traversing it */
<a name="588"></a>        connector.noteTraversal(self);
<a name="589"></a>
<a name="590"></a>        /* get the list of traveling actors */        
<a name="591"></a>        actors = getTravelerActors();
<a name="592"></a>
<a name="593"></a>        /* move to the destination */
<a name="594"></a>        moveIntoForTravel(dest);
<a name="595"></a>
<a name="596"></a>        /* 
<a name="597"></a>         *   We've successfully completed the travel, so remember it for
<a name="598"></a>         *   each actor involved in the travel.  Do this only if we
<a name="599"></a>         *   actually went somewhere, or if the connector is circular - if
<a name="600"></a>         *   we didn't end up going anywhere, and the connector isn't
<a name="601"></a>         *   circular, we must have turned back halfway without completing
<a name="602"></a>         *   the travel. 
<a name="603"></a>         */
<a name="604"></a>        if (dest != origin || connector.rememberCircularPassage)
<a name="605"></a>        {
<a name="606"></a>            foreach (local cur in actors)
<a name="607"></a>            {
<a name="608"></a>                /* ask the actor to remember the travel */
<a name="609"></a>                cur.rememberTravel(origin, dest, backConnector);
<a name="610"></a>                
<a name="611"></a>                /* remember the destination of the connector for this actor */
<a name="612"></a>                connector.rememberTravel(origin, cur, dest);
<a name="613"></a>                
<a name="614"></a>                /* 
<a name="615"></a>                 *   If there's a back-connector, also remember travel in
<a name="616"></a>                 *   the other direction.  The actor can reasonably be
<a name="617"></a>                 *   expected to assume that the connector through which
<a name="618"></a>                 *   it's arriving connects back to the source location, so
<a name="619"></a>                 *   remember the association.  
<a name="620"></a>                 */
<a name="621"></a>                if (backConnector != nil)
<a name="622"></a>                    backConnector.rememberTravel(dest, cur, origin);
<a name="623"></a>            }
<a name="624"></a>        }
<a name="625"></a>
<a name="626"></a>        /*
<a name="627"></a>         *   Recalculate the global sense context for message generation
<a name="628"></a>         *   purposes, since we've moved to a new location.  It's possible
<a name="629"></a>         *   that we've arrived at the player character's location, in
<a name="630"></a>         *   which case we might have been suppressing messages (due to
<a name="631"></a>         *   our being in a different room) but should now show messages
<a name="632"></a>         *   (because we're now near the player character).  
<a name="633"></a>         */
<a name="634"></a>        if (gAction != nil)
<a name="635"></a>            gAction.recalcSenseContext();
<a name="636"></a>
<a name="637"></a>        /* tell the new room we're arriving, if we changed locations */
<a name="638"></a>        if (location != nil &amp;&amp; isDescribed)
<a name="639"></a>            location.travelerArriving(self, origin, connector, backConnector);
<a name="640"></a>
<a name="641"></a>        /* notify objects now connected by containment of the arrival */
<a name="642"></a>        getNotifyTable().forEachAssoc(
<a name="643"></a>            {obj, val: obj.afterTravel(self, connector)});
<a name="644"></a>    }
<a name="645"></a>
<a name="646"></a>    /*
<a name="647"></a>     *   Perform "local" travel - that is, travel between nested rooms
<a name="648"></a>     *   within a single top-level location.  By default, we simply defer
<a name="649"></a>     *   to the actor to let it perform the local travel.  
<a name="650"></a>     */
<a name="651"></a>    travelerTravelWithin(actor, dest) 
<a name="652"></a>    {
<a name="653"></a>        actor.travelerTravelWithin(actor, dest);
<a name="654"></a>    }
<a name="655"></a>
<a name="656"></a>    /*
<a name="657"></a>     *   Get a lookup table giving the set of objects to be notified of a
<a name="658"></a>     *   beforeTravel/afterTravel event.  By default, we return a table
<a name="659"></a>     *   including every object connected to the traveler by containment.  
<a name="660"></a>     */
<a name="661"></a>    getNotifyTable()
<a name="662"></a>    {
<a name="663"></a>        /* return the table of objects connected by containment */
<a name="664"></a>        return connectionTable();
<a name="665"></a>    }
<a name="666"></a>
<a name="667"></a>    /*
<a name="668"></a>     *   Determine if the given actor can see this traveler.  By default,
<a name="669"></a>     *   we'll simply check to see if the actor can see 'self'.  
<a name="670"></a>     */
<a name="671"></a>    travelerSeenBy(actor) { return actor.canSee(self); }
<a name="672"></a>
<a name="673"></a>    /*
<a name="674"></a>     *   Is the given actor traveling with this traveler?  Returns true if
<a name="675"></a>     *   the actor is in my getTravelerActors list. 
<a name="676"></a>     */
<a name="677"></a>    isActorTraveling(actor)
<a name="678"></a>    {
<a name="679"></a>        /* check to see if the given actor is in my actor list */
<a name="680"></a>        return getTravelerActors.indexOf(actor) != nil;
<a name="681"></a>    }
<a name="682"></a>
<a name="683"></a>    /*
<a name="684"></a>     *   Is the given object being carried by the traveler?  Returns true
<a name="685"></a>     *   if the object is inside the traveler itself, or is inside any of
<a name="686"></a>     *   the actors traveling. 
<a name="687"></a>     */
<a name="688"></a>    isTravelerCarrying(obj)
<a name="689"></a>    {
<a name="690"></a>        /* if the object is inside the traveler, it's being carried */
<a name="691"></a>        if (obj.isIn(self))
<a name="692"></a>            return true;
<a name="693"></a>
<a name="694"></a>        /* if the object is inside any traveling actor, it's being carried */
<a name="695"></a>        foreach (local cur in getTravelerActors)
<a name="696"></a>        {
<a name="697"></a>            if (obj.isIn(cur))
<a name="698"></a>                return true;
<a name="699"></a>        }
<a name="700"></a>
<a name="701"></a>        /* the object isn't being carried */
<a name="702"></a>        return nil;
<a name="703"></a>    }
<a name="704"></a>
<a name="705"></a>    /* invoke a callback function for each traveling actor */
<a name="706"></a>    forEachTravelingActor(func)
<a name="707"></a>    {
<a name="708"></a>        /* by default, get the list, and invoke the callback per item */
<a name="709"></a>        getTravelerActors.forEach(func);
<a name="710"></a>    }
<a name="711"></a>
<a name="712"></a>    /*
<a name="713"></a>     *   Get the list of actors taking part in the travel.  When an actor
<a name="714"></a>     *   is the traveler, this list simply contains the actor itself; for
<a name="715"></a>     *   a vehicle or other composite traveler that moves more than one
<a name="716"></a>     *   actor at a time, this should return the list of all of the actors
<a name="717"></a>     *   involved in the travel.  
<a name="718"></a>     */
<a name="719"></a>    getTravelerActors = []
<a name="720"></a>
<a name="721"></a>    /*
<a name="722"></a>     *   Get the list of actors traveling undo their own power.  In the
<a name="723"></a>     *   case of an actor traveling directly, this is just the actor; in
<a name="724"></a>     *   the case of an actor pushing something, this is likewise the
<a name="725"></a>     *   actor; in the case of a group of actors traveling together, this
<a name="726"></a>     *   is the list of traveling actors; in the case of a vehicle, this
<a name="727"></a>     *   is an empty list, since anyone traveling with the vehicle is
<a name="728"></a>     *   traveling under the vehicle's power.  
<a name="729"></a>     */
<a name="730"></a>    getTravelerMotiveActors = []
<a name="731"></a>;
<a name="732"></a>
<a name="733"></a>/* ------------------------------------------------------------------------ */
<a name="734"></a>/*
<a name="735"></a> *   A Travel Connector is a special connection interface that allows for
<a name="736"></a> *   travel from one location to another.  Most actor movement, except for
<a name="737"></a> *   movement between locations related by containment (such as from a room
<a name="738"></a> *   to sitting in a chair within the room) are handled through travel
<a name="739"></a> *   connector objects.
<a name="740"></a> *   
<a name="741"></a> *   Travel connectors are used in the directional link properties in rooms
<a name="742"></a> *   - north, south, east, west, in, out, etc.  A room direction link
<a name="743"></a> *   property is always set to a travel connector - but note that a room is
<a name="744"></a> *   itself a travel connector, so a travel link in one room can simply be
<a name="745"></a> *   set to point directly to another room.  In many cases, rooms
<a name="746"></a> *   themselves serve as travel connectors, so that one room can point a
<a name="747"></a> *   direction link property directly to another room.
<a name="748"></a> *   
<a name="749"></a> *   Some travel connectors are physical objects in the simulation, such as
<a name="750"></a> *   doors or stairways; other connectors are just abstract objects that
<a name="751"></a> *   represent connections, but don't appear as manipulable objects in the
<a name="752"></a> *   game.
<a name="753"></a> *   
<a name="754"></a> *   A travel connector provides several types of information about travel
<a name="755"></a> *   through its connection:
<a name="756"></a> *   
<a name="757"></a> *   - For actors actually traveling, the connector provides a method that
<a name="758"></a> *   moves an actor through the connector.  This method can trigger any
<a name="759"></a> *   side effects of the travel.  
<a name="760"></a> *   
<a name="761"></a> *   - For automatic map builders, actor scripts, and other callers who
<a name="762"></a> *   want to learn what can be known about the link without actually
<a name="763"></a> *   traversing it, the connector provides an "apparent destination"
<a name="764"></a> *   method.  This method returns the destination of travel through the
<a name="765"></a> *   connector that a given actor would expect just by looking at the
<a name="766"></a> *   connector.  The important thing about this routine is that it doesn't
<a name="767"></a> *   trigger any side effects, but simply indicates whether travel is
<a name="768"></a> *   apparently possible, and if so what the destination of the travel
<a name="769"></a> *   would be.  
<a name="770"></a> */
<a name="771"></a>class TravelConnector: Thing
<a name="772"></a>    /*
<a name="773"></a>     *   Get any connector-specific pre-conditions for travel via this
<a name="774"></a>     *   connector.
<a name="775"></a>     */
<a name="776"></a>    connectorTravelPreCond()
<a name="777"></a>    {
<a name="778"></a>        local lst;
<a name="779"></a>
<a name="780"></a>        /* start with no conditions */
<a name="781"></a>        lst = [];
<a name="782"></a>        
<a name="783"></a>        /* if we have a staging location, require that we're in it */
<a name="784"></a>        if (connectorStagingLocation != nil)
<a name="785"></a>            lst = [new TravelerDirectlyInRoom(gActor, self,
<a name="786"></a>                                              connectorStagingLocation)];
<a name="787"></a>
<a name="788"></a>        /* 
<a name="789"></a>         *   If we're a physical Thing with a non-nil location, require
<a name="790"></a>         *   that we be touchable.  Only physical objects need to be
<a name="791"></a>         *   touchable; connectors are sometimes abstract objects, which
<a name="792"></a>         *   obviously can't be touched.  
<a name="793"></a>         */
<a name="794"></a>        if (ofKind(Thing) &amp;&amp; location != nil)
<a name="795"></a>        {
<a name="796"></a>            /* require that the traveler can touch the connector */
<a name="797"></a>            local cond = new TouchObjCondition(gActor.getTraveler(self));
<a name="798"></a>            lst += new ObjectPreCondition(self, cond);
<a name="799"></a>        }
<a name="800"></a>
<a name="801"></a>        /* return the result */
<a name="802"></a>        return lst;
<a name="803"></a>    }
<a name="804"></a>
<a name="805"></a>    /* 
<a name="806"></a>     *   The "staging location" for travel through this connector.  By
<a name="807"></a>     *   default, if we have a location, that's our staging location; if
<a name="808"></a>     *   we don't have a location (in which case we probably an outermost
<a name="809"></a>     *   room), we don't have a staging location.  
<a name="810"></a>     */
<a name="811"></a>    connectorStagingLocation = (location)
<a name="812"></a>
<a name="813"></a>    /*
<a name="814"></a>     *   Get the travel preconditions that this connector requires for
<a name="815"></a>     *   travel by the given actor.  In most cases, this won't depend on
<a name="816"></a>     *   the actor, but it's provided as a parameter anyway; in most cases,
<a name="817"></a>     *   this will just apply the conditions that are relevant to actors as
<a name="818"></a>     *   travelers.
<a name="819"></a>     *   
<a name="820"></a>     *   By default, we require actors to be "travel ready" before
<a name="821"></a>     *   traversing a connector.  The exact meaning of "travel ready" is
<a name="822"></a>     *   provided by the actor's immediate location, but it usually simply
<a name="823"></a>     *   means that the actor is standing.  This ensures that the actor
<a name="824"></a>     *   isn't sitting in a chair or lying down or something like that.
<a name="825"></a>     *   Some connectors might not require this, so this routine can be
<a name="826"></a>     *   overridden per connector.
<a name="827"></a>     *   
<a name="828"></a>     *   Note that this will only be called when an actor is the traveler.
<a name="829"></a>     *   When a vehicle or other kind of traveler is doing the travel, this
<a name="830"></a>     *   will not be invoked.  
<a name="831"></a>     */
<a name="832"></a>    actorTravelPreCond(actor)
<a name="833"></a>    {
<a name="834"></a>        /* 
<a name="835"></a>         *   create an object precondition ensuring that the actor is
<a name="836"></a>         *   "travel ready"; the object of this precondition is the
<a name="837"></a>         *   connector itself 
<a name="838"></a>         */
<a name="839"></a>        return [new ObjectPreCondition(self, actorTravelReady)];
<a name="840"></a>    }
<a name="841"></a>
<a name="842"></a>    /*
<a name="843"></a>     *   Barrier or barriers to travel.  This property can be set to a
<a name="844"></a>     *   single TravelBarrier object or to a list of TravelBarrier
<a name="845"></a>     *   objects.  checkTravelBarriers() checks each barrier specified
<a name="846"></a>     *   here.  
<a name="847"></a>     */
<a name="848"></a>    travelBarrier = []
<a name="849"></a>
<a name="850"></a>    /*
<a name="851"></a>     *   Check barriers.  The TravelVia check() routine must call this to
<a name="852"></a>     *   enforce barriers.  
<a name="853"></a>     */
<a name="854"></a>    checkTravelBarriers(dest)
<a name="855"></a>    {
<a name="856"></a>        local traveler;
<a name="857"></a>        local lst;
<a name="858"></a>
<a name="859"></a>        /* get the traveler */
<a name="860"></a>        traveler = gActor.getTraveler(self);
<a name="861"></a>
<a name="862"></a>        /* ask the traveler what it thinks of travel through this connector */
<a name="863"></a>        if (!traveler.canTravelVia(self, dest))
<a name="864"></a>        {
<a name="865"></a>            /* explain why the traveler can't pass */
<a name="866"></a>            traveler.explainNoTravelVia(self, dest);
<a name="867"></a>
<a name="868"></a>            /* terminate the command */
<a name="869"></a>            exit;
<a name="870"></a>        }
<a name="871"></a>
<a name="872"></a>        /* check any travel conditions we apply directly */
<a name="873"></a>        if (!canTravelerPass(traveler))
<a name="874"></a>        {
<a name="875"></a>            /* explain why the traveler can't pass */
<a name="876"></a>            explainTravelBarrier(traveler);
<a name="877"></a>
<a name="878"></a>            /* terminate the command */
<a name="879"></a>            exit;
<a name="880"></a>        }
<a name="881"></a>
<a name="882"></a>        /* get the barrier list */
<a name="883"></a>        lst = travelBarrier;
<a name="884"></a>
<a name="885"></a>        /* if it's just a single object, make it a list of one element */
<a name="886"></a>        if (!lst.ofKind(Collection))
<a name="887"></a>            lst = [lst];
<a name="888"></a>        
<a name="889"></a>        /* check each item in our barrier list */
<a name="890"></a>        foreach (local cur in lst)
<a name="891"></a>        {
<a name="892"></a>            /* if this barrier doesn't allow travel, we cannot travel */
<a name="893"></a>            if (!cur.canTravelerPass(traveler))
<a name="894"></a>            {
<a name="895"></a>                /* ask the barrier to explain why travel isn't possible */
<a name="896"></a>                cur.explainTravelBarrier(traveler);
<a name="897"></a>
<a name="898"></a>                /* terminate the command */
<a name="899"></a>                exit;
<a name="900"></a>            }
<a name="901"></a>        }
<a name="902"></a>    }
<a name="903"></a>
<a name="904"></a>    /*
<a name="905"></a>     *   Check to see if the Traveler object is allowed to travel through
<a name="906"></a>     *   this connector.  Returns true if travel is allowed, nil if not.
<a name="907"></a>     *   
<a name="908"></a>     *   This is called from checkTravelBarriers() to check any conditions
<a name="909"></a>     *   coded directly into the TravelConnector.  By default, we simply
<a name="910"></a>     *   return true; subclasses can override this to apply special
<a name="911"></a>     *   conditions.
<a name="912"></a>     *   
<a name="913"></a>     *   If an override wants to disallow travel, it should return nil
<a name="914"></a>     *   here, and then provide an override for explainTravelBarrier() to
<a name="915"></a>     *   provide a descriptive message explaining why the travel isn't
<a name="916"></a>     *   allowed.
<a name="917"></a>     *   
<a name="918"></a>     *   Conditions here serve essentially the same purpose as barrier
<a name="919"></a>     *   conditions.  The purpose of providing this additional place for
<a name="920"></a>     *   the same type of conditions is simply to improve the convenience
<a name="921"></a>     *   of defining travel conditions for cases where barriers are
<a name="922"></a>     *   unnecessary.  The main benefit of using a barrier is that the same
<a name="923"></a>     *   barrier object can be re-used with multiple connectors, so if the
<a name="924"></a>     *   same set of travel conditions apply to several different
<a name="925"></a>     *   connectors, barriers allow the logic to be defined once in a
<a name="926"></a>     *   single barrier object and then re-used easily in each place it's
<a name="927"></a>     *   needed.  However, when a particular condition is needed in only
<a name="928"></a>     *   one place, creating a barrier to represent the condition is a bit
<a name="929"></a>     *   verbose; in such cases, the condition can be placed in this method
<a name="930"></a>     *   more conveniently.  
<a name="931"></a>     */
<a name="932"></a>    canTravelerPass(traveler) { return true; }
<a name="933"></a>
<a name="934"></a>    /*
<a name="935"></a>     *   Explain why canTravelerPass() returned nil.  This is called to
<a name="936"></a>     *   display an explanation of why travel is not allowed by
<a name="937"></a>     *   self.canTravelerPass().
<a name="938"></a>     *   
<a name="939"></a>     *   Since the default canTravelerPass() always allows travel, the
<a name="940"></a>     *   default implementation of this method does nothing.  Whenever
<a name="941"></a>     *   canTravelerPass() is overridden to return nil, this should also be
<a name="942"></a>     *   overridden to provide an appropriate explanation.  
<a name="943"></a>     */
<a name="944"></a>    explainTravelBarrier(traveler) { }
<a name="945"></a>
<a name="946"></a>    /*
<a name="947"></a>     *   Is this connector listed?  This indicates whether or not the exit
<a name="948"></a>     *   is allowed to be displayed in lists of exits, such as in the
<a name="949"></a>     *   status line or in "you can't go that way" messages.  By default,
<a name="950"></a>     *   all exits are allowed to appear in listings.
<a name="951"></a>     *   
<a name="952"></a>     *   Note that this indicates if listing is ALLOWED - it doesn't
<a name="953"></a>     *   guarantee that listing actually occurs.  A connector can be
<a name="954"></a>     *   listed only if this is true, AND the point-of-view actor for the
<a name="955"></a>     *   listing can perceive the exit (which means that
<a name="956"></a>     *   isConnectorApparent must return true, and there must be
<a name="957"></a>     *   sufficient light to see the exit).  
<a name="958"></a>     */
<a name="959"></a>    isConnectorListed = true
<a name="960"></a>
<a name="961"></a>    /*
<a name="962"></a>     *   Get an unlisted proxy for this connector.  This is normally
<a name="963"></a>     *   called from the asExit() macro to set up one room exit direction
<a name="964"></a>     *   as an unlisted synonym for another.  
<a name="965"></a>     */
<a name="966"></a>    createUnlistedProxy() { return new UnlistedProxyConnector(self); }
<a name="967"></a>
<a name="968"></a>    /*
<a name="969"></a>     *   Determine if the travel connection is apparent - as a travel
<a name="970"></a>     *   connector - to the actor in the given origin location.  This
<a name="971"></a>     *   doesn't indicate whether or not travel is possible, or where
<a name="972"></a>     *   travel goes, or that the actor can tell where the passage goes;
<a name="973"></a>     *   this merely indicates whether or not the actor should realize
<a name="974"></a>     *   that the passage exists at all.
<a name="975"></a>     *   
<a name="976"></a>     *   A closed door, for example, would return true, because even a
<a name="977"></a>     *   closed door makes it clear that travel is possible in the
<a name="978"></a>     *   direction, even if it's not possible currently.  A secret door,
<a name="979"></a>     *   on the other hand, would return nil while closed, because it
<a name="980"></a>     *   would not be apparent to the actor that the object is a door at
<a name="981"></a>     *   all.  
<a name="982"></a>     */
<a name="983"></a>    isConnectorApparent(origin, actor)
<a name="984"></a>    {
<a name="985"></a>        /* by default, passages are apparent */
<a name="986"></a>        return true;
<a name="987"></a>    }
<a name="988"></a>
<a name="989"></a>    /*
<a name="990"></a>     *   Determine if the travel connection is passable by the given
<a name="991"></a>     *   traveler in the current state.  For example, a door would return
<a name="992"></a>     *   true when open, nil when closed.
<a name="993"></a>     *   
<a name="994"></a>     *   This information is intended to help game code probing the
<a name="995"></a>     *   structure of the map.  This information is NOT used in actor
<a name="996"></a>     *   travel; for actor travel, we rely on custom checks in the
<a name="997"></a>     *   connector's TravelVia handler to enforce the conditions of travel.
<a name="998"></a>     *   Actor travel uses TravelVia customizations rather than this method
<a name="999"></a>     *   because that allows better specificity in reporting failures.
<a name="1000"></a>     *   This method lets game code get at the same information, but in a
<a name="1001"></a>     *   more coarse-grained fashion.  
<a name="1002"></a>     */
<a name="1003"></a>    isConnectorPassable(origin, traveler)
<a name="1004"></a>    {
<a name="1005"></a>        /* by default, we're passable */
<a name="1006"></a>        return true;
<a name="1007"></a>    }
<a name="1008"></a>
<a name="1009"></a>    /*
<a name="1010"></a>     *   Get the apparent destination of travel by the actor to the given
<a name="1011"></a>     *   origin.  This returns the location to which the connector
<a name="1012"></a>     *   travels, AS FAR AS THE ACTOR KNOWS.  If the actor does not know
<a name="1013"></a>     *   and cannot tell where the connector leads, this should return nil.
<a name="1014"></a>     *   
<a name="1015"></a>     *   Note that this method does NOT necessarily return the actual
<a name="1016"></a>     *   destination, because we obviously can't know the destination for
<a name="1017"></a>     *   certain until we traverse the connection.  Rather, the point of
<a name="1018"></a>     *   this routine is to return as much information as the actor is
<a name="1019"></a>     *   supposed to have.  This can be used for purposes like
<a name="1020"></a>     *   auto-mapping, where we'd want to show what the player character
<a name="1021"></a>     *   knows of the map, and NPC goal-seeking, where an NPC tries to
<a name="1022"></a>     *   figure out how to get from one point to another based on the
<a name="1023"></a>     *   NPC's knowledge of the map.  In these sorts of applications, it's
<a name="1024"></a>     *   important to use only knowledge that the actor is supposed to
<a name="1025"></a>     *   have within the parameters of the simulation.
<a name="1026"></a>     *   
<a name="1027"></a>     *   Callers should always test isConnectorApparent() before calling
<a name="1028"></a>     *   this routine.  This routine does not check to ensure that the
<a name="1029"></a>     *   connector is apparent, so it could return misleading information
<a name="1030"></a>     *   if used independently of isConnectorApparent(); for example, if
<a name="1031"></a>     *   the connector *formerly* worked but has now disappeared, and the
<a name="1032"></a>     *   actor has a memory of the former destination, we'll return the
<a name="1033"></a>     *   remembered destination.
<a name="1034"></a>     *   
<a name="1035"></a>     *   The actor can know the destination by a number of means:
<a name="1036"></a>     *   
<a name="1037"></a>     *   1.  The location is familiar to the character.  For example, if
<a name="1038"></a>     *   the setting is the character's own house, the character would
<a name="1039"></a>     *   obviously know the house well, so would know where you'd end up
<a name="1040"></a>     *   going east from the living room or south from the kitchen.  We
<a name="1041"></a>     *   use the origin method actorKnowsDestination() to determine this.
<a name="1042"></a>     *   
<a name="1043"></a>     *   2.  The destination is readily visible from the origin location,
<a name="1044"></a>     *   or is clearly marked.  For example, in an outdoor setting, it
<a name="1045"></a>     *   might be clear that going east from the field takes you to the
<a name="1046"></a>     *   hilltop.  In an indoor setting, an open passage might make it
<a name="1047"></a>     *   clear that going east from the living room takes you to the
<a name="1048"></a>     *   dining room.  We use the origin method actorKnowsDestination() to
<a name="1049"></a>     *   determine this.
<a name="1050"></a>     *   
<a name="1051"></a>     *   3. The actor has been through the connector already in the course
<a name="1052"></a>     *   of the game, and so remembers the connection by virtue of recent
<a name="1053"></a>     *   experience.  If our travelMemory class property is set to a
<a name="1054"></a>     *   non-nil lookup table object, then we'll automatically use the
<a name="1055"></a>     *   lookup table to remember the destination each time an actor
<a name="1056"></a>     *   travels via a connector, and use this information by default to
<a name="1057"></a>     *   provide apparent destination information.  
<a name="1058"></a>     */
<a name="1059"></a>    getApparentDestination(origin, actor)
<a name="1060"></a>    {
<a name="1061"></a>        local dest;
<a name="1062"></a>        
<a name="1063"></a>        /* 
<a name="1064"></a>         *   Ask the origin if the actor knows the destination for the
<a name="1065"></a>         *   given connector.  If so, and we can determine our
<a name="1066"></a>         *   destination, then return the destination.  
<a name="1067"></a>         */
<a name="1068"></a>        if (origin.actorKnowsDestination(actor, self)
<a name="1069"></a>            &amp;&amp; (dest = getDestination(origin,
<a name="1070"></a>                                      actor.getTraveler(self))) != nil)
<a name="1071"></a>            return dest;
<a name="1072"></a>
<a name="1073"></a>        /*
<a name="1074"></a>         *   If we have a travelMemory table, look to see if the traversal
<a name="1075"></a>         *   of this actor via this connector from this origin is recorded
<a name="1076"></a>         *   in the table, and if so, assume that the destination is the
<a name="1077"></a>         *   same as it was last time.
<a name="1078"></a>         *   
<a name="1079"></a>         *   Note that we ignore our memory of travel if we never saw the
<a name="1080"></a>         *   destination of the travel (which would be the case if the
<a name="1081"></a>         *   destination was dark every time we've been there, so we've
<a name="1082"></a>         *   never seen any details about the location).  
<a name="1083"></a>         */
<a name="1084"></a>        if (travelMemory != nil
<a name="1085"></a>            &amp;&amp; (dest = travelMemory[[actor, origin, self]]) != nil
<a name="1086"></a>            &amp;&amp; actor.hasSeen(dest))
<a name="1087"></a>        {
<a name="1088"></a>            /* we know the destination from past experience */
<a name="1089"></a>            return dest;
<a name="1090"></a>        }
<a name="1091"></a>
<a name="1092"></a>        /* we don't know the destination */
<a name="1093"></a>        return nil;
<a name="1094"></a>    }
<a name="1095"></a>
<a name="1096"></a>    /*
<a name="1097"></a>     *   Get our destination, given the traveler and the origin location.
<a name="1098"></a>     *   
<a name="1099"></a>     *   This method is required to return the current destination for the
<a name="1100"></a>     *   travel.  If the connector doesn't go anywhere, this should return
<a name="1101"></a>     *   nil.  The results of this method must be stable for the extent of
<a name="1102"></a>     *   a turn, up until the time travel actually occurs; in other words,
<a name="1103"></a>     *   it must be possible to call this routine simply for information
<a name="1104"></a>     *   purposes, to determine where the travel will end up.
<a name="1105"></a>     *   
<a name="1106"></a>     *   This method should not trigger any side effects, since it's
<a name="1107"></a>     *   necessary to be able to call this method more than once in the
<a name="1108"></a>     *   course of a given travel command.  If it's necessary to trigger
<a name="1109"></a>     *   side effects when the connector is actually traversed, apply the
<a name="1110"></a>     *   side effects in noteTraversal().
<a name="1111"></a>     *   
<a name="1112"></a>     *   For auto-mapping and the like, note that getApparentDestination()
<a name="1113"></a>     *   is a better choice, since this method has internal information
<a name="1114"></a>     *   that might not be apparent to the characters in the game and thus
<a name="1115"></a>     *   shouldn't be revealed through something like an auto-map.  This
<a name="1116"></a>     *   method is intended for internal use in the course of processing a
<a name="1117"></a>     *   travel action, since it knows the true destination of the travel.
<a name="1118"></a>     */
<a name="1119"></a>    getDestination(origin, traveler) { return nil; }
<a name="1120"></a>
<a name="1121"></a>    /*
<a name="1122"></a>     *   Get the travel connector leading to the given destination from the
<a name="1123"></a>     *   given origin and for the given travel.  Return nil if we don't
<a name="1124"></a>     *   know a connector leading there.
<a name="1125"></a>     *   
<a name="1126"></a>     *   By default, we simply return 'self' if our destination is the
<a name="1127"></a>     *   given destination, or nil if not.
<a name="1128"></a>     *   
<a name="1129"></a>     *   Some subclasses might encapsulate one or more "secondary"
<a name="1130"></a>     *   connectors - that is, the main connector might choose among
<a name="1131"></a>     *   multiple other connectors.  In these cases, the secondary
<a name="1132"></a>     *   connectors typically won't be linked to directions on their own,
<a name="1133"></a>     *   so the room can't see them directly - it can only find them
<a name="1134"></a>     *   through us, since we're effectively a wrapper for the secondary
<a name="1135"></a>     *   connectors.  In these cases, we won't have any single destination
<a name="1136"></a>     *   ourself, so getDestination() will have to return nil.  But we
<a name="1137"></a>     *   *can* work backwards: given a destination, we can find the
<a name="1138"></a>     *   secondary connector that points to that destination.  That's what
<a name="1139"></a>     *   this routine is for.  
<a name="1140"></a>     */
<a name="1141"></a>    connectorGetConnectorTo(origin, traveler, dest)
<a name="1142"></a>    {
<a name="1143"></a>        /* if we go there, return 'self', else return nil */
<a name="1144"></a>        return (getDestination(origin, traveler) == dest ? self : nil);
<a name="1145"></a>    }
<a name="1146"></a>
<a name="1147"></a>    /* 
<a name="1148"></a>     *   Note that the connector is being traversed.  This is invoked just
<a name="1149"></a>     *   before the traveler is moved; this notification is fired after the
<a name="1150"></a>     *   other travel-related notifications (beforeTravel, actorTravel,
<a name="1151"></a>     *   travelerLeaving).  This is a good place to display any special
<a name="1152"></a>     *   messages describing what happens during the travel, because any
<a name="1153"></a>     *   messages displayed here will come after any messages related to
<a name="1154"></a>     *   reactions from other objects.  
<a name="1155"></a>     */
<a name="1156"></a>    noteTraversal(traveler)
<a name="1157"></a>    {
<a name="1158"></a>        /* do nothing by default */
<a name="1159"></a>    }
<a name="1160"></a>
<a name="1161"></a>    /*
<a name="1162"></a>     *   Service routine: add a memory of a successful traversal of a
<a name="1163"></a>     *   travel connector.  If we have a travel memory table, we'll add
<a name="1164"></a>     *   the traversal to the table, so that we can find it later.
<a name="1165"></a>     *   
<a name="1166"></a>     *   This is called from Traveler.travelerTravelTo() on successful
<a name="1167"></a>     *   travel.  We're called for each actor participating in the travel.
<a name="1168"></a>     */
<a name="1169"></a>    rememberTravel(origin, actor, dest)
<a name="1170"></a>    {
<a name="1171"></a>        /* 
<a name="1172"></a>         *   If we have a travelMemory table, add this traversal.  Store
<a name="1173"></a>         *   the destination, keyed by the combination of the actor,
<a name="1174"></a>         *   origin, and connector object (i.e., self) - this will allow
<a name="1175"></a>         *   us to remember the destination we reached last time if we
<a name="1176"></a>         *   want to know where the same route goes in the future.  
<a name="1177"></a>         */
<a name="1178"></a>        if (TravelConnector.travelMemory != nil)
<a name="1179"></a>            TravelConnector.travelMemory[[actor, origin, self]] = dest;
<a name="1180"></a>    }
<a name="1181"></a>
<a name="1182"></a>    /*
<a name="1183"></a>     *   Our "travel memory" table.  If this contains a non-nil lookup
<a name="1184"></a>     *   table object, we'll store a record of each successful traversal
<a name="1185"></a>     *   of a travel connector here - we'll record the destination keyed
<a name="1186"></a>     *   by the combination of actor, origin, and connector, so that we
<a name="1187"></a>     *   can later check to see if the actor has any memory of where a
<a name="1188"></a>     *   given connector goes from a given origin.
<a name="1189"></a>     *   
<a name="1190"></a>     *   We keep this information by default, which is why we statically
<a name="1191"></a>     *   create the table here.  Keeping this information does involve
<a name="1192"></a>     *   some overhead, so some authors might want to get rid of this
<a name="1193"></a>     *   table (by setting the property to nil) if the game doesn't make
<a name="1194"></a>     *   any use of the information.  Note that this table is stored just
<a name="1195"></a>     *   once, in the TravelConnector class itself - there's not a
<a name="1196"></a>     *   separate table per connector.  
<a name="1197"></a>     */
<a name="1198"></a>    travelMemory = static new LookupTable(256, 512)
<a name="1199"></a>
<a name="1200"></a>    /*
<a name="1201"></a>     *   Is this a "circular" passage?  A circular passage is one that
<a name="1202"></a>     *   explicitly connects back to its origin, so that traveling through
<a name="1203"></a>     *   the connector leaves us where we started.  When a passage is
<a name="1204"></a>     *   marked as circular, we'll describe travel through the passage
<a name="1205"></a>     *   exactly as though we had actually gone somewhere.  By default, if
<a name="1206"></a>     *   traveling through a passage leaves us where we started, we assume
<a name="1207"></a>     *   that nothing happened, so we don't describe any travel.
<a name="1208"></a>     *   
<a name="1209"></a>     *   Circular passages don't often occur in ordinary settings; these
<a name="1210"></a>     *   are mostly useful in disorienting environments, such as twisty
<a name="1211"></a>     *   cave networks, where a passage between locations can change
<a name="1212"></a>     *   direction and even loop back on itself.  
<a name="1213"></a>     */
<a name="1214"></a>    isCircularPassage = nil
<a name="1215"></a>
<a name="1216"></a>    /*
<a name="1217"></a>     *   Should we remember a circular trip through this passage?  By
<a name="1218"></a>     *   default, we remember the destination of a passage that takes us
<a name="1219"></a>     *   back to our origin only if we're explicitly marked as a circular
<a name="1220"></a>     *   passage; in other cases, we assume that the travel was blocked
<a name="1221"></a>     *   somehow instead.  
<a name="1222"></a>     */
<a name="1223"></a>    rememberCircularPassage = (isCircularPassage)
<a name="1224"></a>
<a name="1225"></a>    /*
<a name="1226"></a>     *   Describe an actor's departure through the connector from the
<a name="1227"></a>     *   given origin to the given destination.  This description is from
<a name="1228"></a>     *   the point of view of another actor in the origin location.  
<a name="1229"></a>     */
<a name="1230"></a>    describeDeparture(traveler, origin, dest)
<a name="1231"></a>    {
<a name="1232"></a>        local dir;
<a name="1233"></a>        
<a name="1234"></a>        /* 
<a name="1235"></a>         *   See if we can find a direction linked to this connector from
<a name="1236"></a>         *   the origin location.  If so, describe the departure using the
<a name="1237"></a>         *   direction; otherwise, describe it using the generic departure
<a name="1238"></a>         *   message.
<a name="1239"></a>         *   
<a name="1240"></a>         *   Find the connector from the player character's perspective,
<a name="1241"></a>         *   because the description we're generating is for the player's
<a name="1242"></a>         *   benefit and thus should be from the PC's perspective.  
<a name="1243"></a>         */
<a name="1244"></a>        if ((dir = origin.directionForConnector(self, gPlayerChar)) != nil)
<a name="1245"></a>        {
<a name="1246"></a>            /*
<a name="1247"></a>             *   We found a direction linked to the connector, so this
<a name="1248"></a>             *   must have been the way they traveled.  Describe the
<a name="1249"></a>             *   departure as being in that direction.
<a name="1250"></a>             *   
<a name="1251"></a>             *   Note that it's possible that more than one direction is
<a name="1252"></a>             *   linked to the same connector.  In such cases, we'll just
<a name="1253"></a>             *   take the first link we find, because it's equally
<a name="1254"></a>             *   accurate to say that the actor went in any of the
<a name="1255"></a>             *   directions linked to the same connector.  
<a name="1256"></a>             */
<a name="1257"></a>            traveler.sayDepartingDir(dir, self);
<a name="1258"></a>        }
<a name="1259"></a>        else
<a name="1260"></a>        {
<a name="1261"></a>            /*
<a name="1262"></a>             *   We didn't find any direction out of the origin linking to
<a name="1263"></a>             *   this connector, so we don't know how what direction they
<a name="1264"></a>             *   went.  Show the generic departure message.  
<a name="1265"></a>             */
<a name="1266"></a>            traveler.sayDeparting(self);
<a name="1267"></a>        }
<a name="1268"></a>    }
<a name="1269"></a>
<a name="1270"></a>    /*
<a name="1271"></a>     *   Describe an actor's arrival through the connector from the given
<a name="1272"></a>     *   origin into the given destination.  This description is from the
<a name="1273"></a>     *   point of view of another actor in the destination.
<a name="1274"></a>     *   
<a name="1275"></a>     *   Note that this is called on the connector that reverses the
<a name="1276"></a>     *   travel, NOT on the connector the actor is actually traversing -
<a name="1277"></a>     *   that is, 'self' is the backwards connector, leading from the
<a name="1278"></a>     *   destination back to the origin location.  So, if we have two
<a name="1279"></a>     *   sides to a door, and the actor traverses the first side, this
<a name="1280"></a>     *   will be called on the second side - the one that links the
<a name="1281"></a>     *   destination back to the origin.  
<a name="1282"></a>     */
<a name="1283"></a>    describeArrival(traveler, origin, dest)
<a name="1284"></a>    {
<a name="1285"></a>        local dir;
<a name="1286"></a>        
<a name="1287"></a>        /*
<a name="1288"></a>         *   See if we can find a direction linked to this connector in
<a name="1289"></a>         *   the destination location.  If so, describe the arrival using
<a name="1290"></a>         *   the direction; otherwise, describe it using a generic arrival
<a name="1291"></a>         *   message.  
<a name="1292"></a>         *   
<a name="1293"></a>         *   Find the connector from the player character's perspective,
<a name="1294"></a>         *   because the description we're generating is for the player's
<a name="1295"></a>         *   benefit and thus should be from the PC's perspective.  
<a name="1296"></a>         */
<a name="1297"></a>        if ((dir = dest.directionForConnector(self, gPlayerChar)) != nil)
<a name="1298"></a>        {
<a name="1299"></a>            /* 
<a name="1300"></a>             *   we found a direction linked to this back connector, so
<a name="1301"></a>             *   describe the arrival as coming from the direction we
<a name="1302"></a>             *   found 
<a name="1303"></a>             */
<a name="1304"></a>            traveler.sayArrivingDir(dir, self);
<a name="1305"></a>        }
<a name="1306"></a>        else
<a name="1307"></a>        {
<a name="1308"></a>            /* 
<a name="1309"></a>             *   we didn't find any direction links, so use a generic
<a name="1310"></a>             *   arrival message 
<a name="1311"></a>             */
<a name="1312"></a>            traveler.sayArriving(self);
<a name="1313"></a>        }
<a name="1314"></a>    }
<a name="1315"></a>
<a name="1316"></a>    /*
<a name="1317"></a>     *   Describe a "local departure" via this connector.  This is called
<a name="1318"></a>     *   when a traveler moves around entirely within the field of view of
<a name="1319"></a>     *   the player character, and move *further away* from the PC - that
<a name="1320"></a>     *   is, the traveler's destination is visible to the PC when we're
<a name="1321"></a>     *   leaving our origin, AND the origin's top-level location contains
<a name="1322"></a>     *   the PC.  We'll describe the travel not in terms of truly
<a name="1323"></a>     *   departing, but simply in terms of moving away. 
<a name="1324"></a>     */
<a name="1325"></a>    describeLocalDeparture(traveler, origin, dest)
<a name="1326"></a>    {
<a name="1327"></a>        /* say that we're departing locally */
<a name="1328"></a>        traveler.sayDepartingLocally(dest, self);
<a name="1329"></a>    }
<a name="1330"></a>
<a name="1331"></a>    /*
<a name="1332"></a>     *   Describe a "local arrival" via this connector.  This is called
<a name="1333"></a>     *   when the traveler moves around entirely within the field of view
<a name="1334"></a>     *   of the player character, and comes *closer* to the PC - that is,
<a name="1335"></a>     *   the traveler's origin is visible to the player character when we
<a name="1336"></a>     *   arrive in our destination, AND the destination's top-level
<a name="1337"></a>     *   location contains the PC.  We'll describe the travel not in terms
<a name="1338"></a>     *   of truly arriving, since the traveler was already here to start
<a name="1339"></a>     *   with, but rather as entering the destination, but just in terms of
<a name="1340"></a>     *   moving closer.  
<a name="1341"></a>     */
<a name="1342"></a>    describeLocalArrival(traveler, origin, dest)
<a name="1343"></a>    {
<a name="1344"></a>        /* say that we're arriving locally */
<a name="1345"></a>        traveler.sayArrivingLocally(dest, self);
<a name="1346"></a>    }
<a name="1347"></a>
<a name="1348"></a>    /*
<a name="1349"></a>     *   Describe "remote travel" via this connector.  This is called when
<a name="1350"></a>     *   the traveler moves around entirely within the field of view of the
<a name="1351"></a>     *   PC, but between two "remote" top-level locations - "remote" means
<a name="1352"></a>     *   "does not contain the PC."  In this case, the traveler isn't
<a name="1353"></a>     *   arriving or departing, exactly; it's just moving laterally from
<a name="1354"></a>     *   one top-level location to another.  
<a name="1355"></a>     */
<a name="1356"></a>    describeRemoteTravel(traveler, origin, dest)
<a name="1357"></a>    {
<a name="1358"></a>        /* say that we're traveling laterally */
<a name="1359"></a>        traveler.sayTravelingRemotely(dest, self);
<a name="1360"></a>    }
<a name="1361"></a>
<a name="1362"></a>    /*
<a name="1363"></a>     *   Find a connector in the destination location that connects back as
<a name="1364"></a>     *   the source of travel from the given connector when traversed from
<a name="1365"></a>     *   the source location.  Returns nil if there is no such connector.
<a name="1366"></a>     *   This must be called while the traveler is still in the source
<a name="1367"></a>     *   location; we'll attempt to find the connector back to the
<a name="1368"></a>     *   traveler's current location.
<a name="1369"></a>     *   
<a name="1370"></a>     *   The purpose of this routine is to identify the connector by which
<a name="1371"></a>     *   the traveler arrives in the new location.  This can be used, for
<a name="1372"></a>     *   example, to generate a connector-specific message describing the
<a name="1373"></a>     *   traveler's emergence from the connector (so we can say one thing
<a name="1374"></a>     *   if the traveler arrives via a door, and another if the traveler
<a name="1375"></a>     *   arrives by climing up a ladder).
<a name="1376"></a>     *   
<a name="1377"></a>     *   By default, we'll try to find a travel link in the destination
<a name="1378"></a>     *   that links us back to this same connector, in which case we'll
<a name="1379"></a>     *   return 'self' as the connector from which the traveler emerges in
<a name="1380"></a>     *   the new location.  Failing that, we'll look for a travel link
<a name="1381"></a>     *   whose apparent source is the origin location.
<a name="1382"></a>     *   
<a name="1383"></a>     *   This should be overridden for any connector with an explicit
<a name="1384"></a>     *   complementary connector.  For example, it is common to implement a
<a name="1385"></a>     *   door using a pair of objects, one representing each side of the
<a name="1386"></a>     *   door; in such cases, each door object would simply return its twin
<a name="1387"></a>     *   here.  Note that a complementary connector doesn't actually have
<a name="1388"></a>     *   to go anywhere, since it's still useful to have a connector back
<a name="1389"></a>     *   simply for describing travelers arriving on the connector.
<a name="1390"></a>     *   
<a name="1391"></a>     *   This *must* be overridden when the destination location doesn't
<a name="1392"></a>     *   have a simple connector whose apparent source is this connector,
<a name="1393"></a>     *   because in such cases we won't be able to find the reverse
<a name="1394"></a>     *   connector with our direction search.  
<a name="1395"></a>     */
<a name="1396"></a>    connectorBack(traveler, dest)
<a name="1397"></a>    {
<a name="1398"></a>        local origin;
<a name="1399"></a>
<a name="1400"></a>        /* if there's no destination, there's obviously no connector */
<a name="1401"></a>        if (dest == nil)
<a name="1402"></a>            return nil;
<a name="1403"></a>
<a name="1404"></a>        /* 
<a name="1405"></a>         *   get the origin location - this the traveler's current
<a name="1406"></a>         *   immediate container 
<a name="1407"></a>         */
<a name="1408"></a>        origin = traveler.location;
<a name="1409"></a>        
<a name="1410"></a>        /* 
<a name="1411"></a>         *   First, try to find a link back to this same connector - this
<a name="1412"></a>         *   will handle simple symmetrical links with the same connector
<a name="1413"></a>         *   object shared between two rooms.
<a name="1414"></a>         *   
<a name="1415"></a>         *   We try to find the actual connector before looking for a
<a name="1416"></a>         *   connector back to the origin - it's possible that there are
<a name="1417"></a>         *   several ways back to the starting point, and we want to make
<a name="1418"></a>         *   sure we pick the one that was actually traversed if possible.
<a name="1419"></a>         */
<a name="1420"></a>        foreach (local dir in Direction.allDirections)
<a name="1421"></a>        {
<a name="1422"></a>            /* 
<a name="1423"></a>             *   If this direction link from the destination is linked back
<a name="1424"></a>             *   to this same connector, we have a symmetrical connection,
<a name="1425"></a>             *   so we're the connector back.  Note that we're interested
<a name="1426"></a>             *   only in map structure here, so we don't pass an actor; the
<a name="1427"></a>             *   actor isn't actually in the new location, so what the
<a name="1428"></a>             *   actor can see is irrelevant to us here.  
<a name="1429"></a>             */
<a name="1430"></a>            if (dest.getTravelConnector(dir, nil) == self)
<a name="1431"></a>            {
<a name="1432"></a>                /* the same connector goes in both directions */
<a name="1433"></a>                return self;
<a name="1434"></a>            }
<a name="1435"></a>        }
<a name="1436"></a>
<a name="1437"></a>        /*
<a name="1438"></a>         *   we didn't find a link back to the same connector, so try to
<a name="1439"></a>         *   find a link from the destination whose apparent source is the
<a name="1440"></a>         *   origin 
<a name="1441"></a>         */
<a name="1442"></a>        foreach (local dir in Direction.allDirections)
<a name="1443"></a>        {
<a name="1444"></a>            local conn;
<a name="1445"></a>            
<a name="1446"></a>            /* 
<a name="1447"></a>             *   if this link from the destination has an apparent source
<a name="1448"></a>             *   of our origin, the traveler appears to be arriving from
<a name="1449"></a>             *   this link 
<a name="1450"></a>             */
<a name="1451"></a>            if ((conn = dest.getTravelConnector(dir, nil)) != nil
<a name="1452"></a>                &amp;&amp; conn.fixedSource(dest, traveler) == origin)
<a name="1453"></a>            {
<a name="1454"></a>                /* 
<a name="1455"></a>                 *   this direction has an apparent source of the origin
<a name="1456"></a>                 *   room - it's not necessarily the same link they
<a name="1457"></a>                 *   traversed, but at least it appears to come from the
<a name="1458"></a>                 *   same place they came from, so it'll have to do 
<a name="1459"></a>                 */
<a name="1460"></a>                return conn;
<a name="1461"></a>            }
<a name="1462"></a>        }
<a name="1463"></a>
<a name="1464"></a>        /* we couldn't find any link back to the origin */
<a name="1465"></a>        return nil;
<a name="1466"></a>    }
<a name="1467"></a>
<a name="1468"></a>    /*
<a name="1469"></a>     *   Get the "fixed" source for travelers emerging from this connector,
<a name="1470"></a>     *   if possible.  This can return nil if the connector does not have a
<a name="1471"></a>     *   fixed relationship with another connector.
<a name="1472"></a>     *   
<a name="1473"></a>     *   The purpose of this routine is to find complementary connectors
<a name="1474"></a>     *   for simple static map connections.  This is especially useful for
<a name="1475"></a>     *   direct room-to-room connections.
<a name="1476"></a>     *   
<a name="1477"></a>     *   When a connector relationship other than a simple static mapping
<a name="1478"></a>     *   exists, the connectors must generally override connectorBack(), in
<a name="1479"></a>     *   which case this routine will not be needed (at least, this routine
<a name="1480"></a>     *   won't be needed as long as the overridden connectorBack() doesn't
<a name="1481"></a>     *   call it).  Whenever it is not clear how to implement this routine,
<a name="1482"></a>     *   don't - implement connectorBack() instead.  
<a name="1483"></a>     */
<a name="1484"></a>    fixedSource(dest, traveler)
<a name="1485"></a>    {
<a name="1486"></a>        /* by default, return nothing */
<a name="1487"></a>        return nil;
<a name="1488"></a>    }
<a name="1489"></a>
<a name="1490"></a>    /*
<a name="1491"></a>     *   Can the given actor see this connector in the dark, looking from
<a name="1492"></a>     *   the given origin?  Returns true if so, nil if not.
<a name="1493"></a>     *   
<a name="1494"></a>     *   This is used to determine if the actor can travel from the given
<a name="1495"></a>     *   origin via this connector when the actor (in the origin location)
<a name="1496"></a>     *   is in darkness.
<a name="1497"></a>     *   
<a name="1498"></a>     *   By default, we implement the usual convention, which is that
<a name="1499"></a>     *   travel from a dark room is possible only when the destination is
<a name="1500"></a>     *   lit.  If we can't determine our destination, we will assume that
<a name="1501"></a>     *   the connector is not visible.
<a name="1502"></a>     */
<a name="1503"></a>    isConnectorVisibleInDark(origin, actor)
<a name="1504"></a>    {
<a name="1505"></a>        local dest;
<a name="1506"></a>        
<a name="1507"></a>        /* 
<a name="1508"></a>         *   Get my destination - if we can't determine our destination,
<a name="1509"></a>         *   then assume we're not visible. 
<a name="1510"></a>         */
<a name="1511"></a>        if ((dest = getDestination(origin, actor.getTraveler(self))) == nil)
<a name="1512"></a>            return nil;
<a name="1513"></a>
<a name="1514"></a>        /*
<a name="1515"></a>         *   Check the ambient illumination level in the destination.  If
<a name="1516"></a>         *   it's 2 or higher, then it's lit; otherwise, it's dark.  If
<a name="1517"></a>         *   the destination is lit, consider the connector to be visible,
<a name="1518"></a>         *   on the theory that the connector lets a little bit of the
<a name="1519"></a>         *   light from the destination leak into the origin room - just
<a name="1520"></a>         *   enough to make the connection itself visible without making
<a name="1521"></a>         *   anything else in the origin room visible.  
<a name="1522"></a>         */
<a name="1523"></a>        return (dest.wouldBeLitFor(actor));
<a name="1524"></a>    }
<a name="1525"></a>
<a name="1526"></a>    /*
<a name="1527"></a>     *   Handle travel in the dark.  Specifically, this is called when an
<a name="1528"></a>     *   actor attempts travel from one dark location to another dark
<a name="1529"></a>     *   location.  (We don't invoke this in any other case:
<a name="1530"></a>     *   light-to-light, light-to-dark, and dark-to-light travel are all
<a name="1531"></a>     *   allowed without any special checks.)
<a name="1532"></a>     *   
<a name="1533"></a>     *   By default, we will prohibit dark-to-dark travel by calling the
<a name="1534"></a>     *   location's darkTravel handler.  Individual connectors can
<a name="1535"></a>     *   override this to allow such travel or apply different handling.  
<a name="1536"></a>     */
<a name="1537"></a>    darkTravel(actor, dest)
<a name="1538"></a>    {
<a name="1539"></a>        /* 
<a name="1540"></a>         *   by default, simply call the actor's location's darkTravel
<a name="1541"></a>         *   handler 
<a name="1542"></a>         */
<a name="1543"></a>        actor.location.roomDarkTravel(actor);
<a name="1544"></a>    }
<a name="1545"></a>
<a name="1546"></a>    /*
<a name="1547"></a>     *   Action handler for the internal "TravelVia" action.  This is not a
<a name="1548"></a>     *   real action, but is instead a pseudo-action that we implement
<a name="1549"></a>     *   generically for travel via the connector.  Subclasses that want to
<a name="1550"></a>     *   handle real actions by traveling via the connector can use
<a name="1551"></a>     *   remapTo(TravelVia) to implement the real action handlers.  Note
<a name="1552"></a>     *   that remapTo should be used (rather than, say, asDobjFor), since
<a name="1553"></a>     *   this will ensure that every type of travel through the connector
<a name="1554"></a>     *   actually looks like a TravelVia action, which is useful for
<a name="1555"></a>     *   intercepting travel actions generically in other code.  
<a name="1556"></a>     */
<a name="1557"></a>    dobjFor(TravelVia)
<a name="1558"></a>    {
<a name="1559"></a>        preCond()
<a name="1560"></a>        {
<a name="1561"></a>            /* 
<a name="1562"></a>             *   For our preconditions, use the traveler's preconditions,
<a name="1563"></a>             *   plus the location's preconditions, plus any special
<a name="1564"></a>             *   connector-specific preconditions we supply. 
<a name="1565"></a>             */
<a name="1566"></a>            return gActor.getTraveler(self).travelerPreCond(self)
<a name="1567"></a>                + gActor.location.roomTravelPreCond()
<a name="1568"></a>                + connectorTravelPreCond();
<a name="1569"></a>        }
<a name="1570"></a>        verify()
<a name="1571"></a>        {
<a name="1572"></a>            /*
<a name="1573"></a>             *   Verify travel for the current command's actor through this
<a name="1574"></a>             *   connector.  This performs normal action verify processing.
<a name="1575"></a>             *   
<a name="1576"></a>             *   The main purpose of this routine is to allow the connector
<a name="1577"></a>             *   to flag obviously dangerous travel to allow a caller to
<a name="1578"></a>             *   avoid such travel as an implicit or scripted action.  In
<a name="1579"></a>             *   most cases, there's no need to make travel illogical
<a name="1580"></a>             *   because there's generally no potential ambiguity involved
<a name="1581"></a>             *   in analyzing a travel verb.
<a name="1582"></a>             *   
<a name="1583"></a>             *   Note that this routine must check with the actor to
<a name="1584"></a>             *   determine if the actor or a vehicle will actually be
<a name="1585"></a>             *   performing the travel, by calling gActor.getTraveler(), if
<a name="1586"></a>             *   the routine cares about the difference.  
<a name="1587"></a>             */
<a name="1588"></a>        }
<a name="1589"></a>        check()
<a name="1590"></a>        {
<a name="1591"></a>            local t = gActor.getTraveler(self);
<a name="1592"></a>            local dest;
<a name="1593"></a>
<a name="1594"></a>            /*
<a name="1595"></a>             *   Check the travel. 
<a name="1596"></a>             *   
<a name="1597"></a>             *   This routine should take into account the light levels at
<a name="1598"></a>             *   the source and destination locations, if travel between
<a name="1599"></a>             *   dark rooms is to be disallowed.  
<a name="1600"></a>             */
<a name="1601"></a>            
<a name="1602"></a>            /* get my destination */
<a name="1603"></a>            dest = getDestination(t.location, t);
<a name="1604"></a>            
<a name="1605"></a>            /* check dark-to-dark travel */
<a name="1606"></a>            gActor.checkDarkTravel(dest, self);
<a name="1607"></a>
<a name="1608"></a>            /* enforce barriers */
<a name="1609"></a>            checkTravelBarriers(dest);
<a name="1610"></a>        }
<a name="1611"></a>        
<a name="1612"></a>        action()
<a name="1613"></a>        {
<a name="1614"></a>            local t = gActor.getTraveler(self);
<a name="1615"></a>            local dest;
<a name="1616"></a>
<a name="1617"></a>            /*
<a name="1618"></a>             *   Execute the travel, moving the command's actor through the
<a name="1619"></a>             *   travel connection: we carry out any side effects of the
<a name="1620"></a>             *   travel and deliver the actor (if appropriate) to the
<a name="1621"></a>             *   destination of the connector.
<a name="1622"></a>             *   
<a name="1623"></a>             *   Note that this routine must check with the actor to
<a name="1624"></a>             *   determine if the actor or a vehicle will actually be
<a name="1625"></a>             *   performing the travel, by calling gActor.getTraveler(), if
<a name="1626"></a>             *   the routine cares about the difference.  In most cases,
<a name="1627"></a>             *   the routine won't care: most implementations of this
<a name="1628"></a>             *   routine will (if they effect any travel at all) eventually
<a name="1629"></a>             *   call gActor.travelTo() to carry out the travel, and that
<a name="1630"></a>             *   routine will always route the actual movement to the
<a name="1631"></a>             *   vehicle if necessary.  
<a name="1632"></a>             */
<a name="1633"></a>            
<a name="1634"></a>            /* get my destination */
<a name="1635"></a>            dest = getDestination(t.location, t);
<a name="1636"></a>
<a name="1637"></a>            /* travel to my destination */
<a name="1638"></a>            gActor.travelTo(dest, self, connectorBack(t, dest));
<a name="1639"></a>        }
<a name="1640"></a>    }
<a name="1641"></a>;
<a name="1642"></a>
<a name="1643"></a>/*
<a name="1644"></a> *   A "probe" object, for testing light levels in rooms.  This is a dummy
<a name="1645"></a> *   object that we use for what-if testing - it's not actually part of
<a name="1646"></a> *   the simulation.  
<a name="1647"></a> */
<a name="1648"></a>lightProbe: Thing;
<a name="1649"></a>
<a name="1650"></a>/*
<a name="1651"></a> *   A TravelBarrier can be attached to a TravelConnector, via the
<a name="1652"></a> *   travelBarrier property, to form a conditional barrier to travel.
<a name="1653"></a> */
<a name="1654"></a>class TravelBarrier: object
<a name="1655"></a>    /*
<a name="1656"></a>     *   Determine if this barrier blocks the given traveler.  By default,
<a name="1657"></a>     *   we don't block anyone.  This doesn't make us much of a barrier, so
<a name="1658"></a>     *   subclasses should override this with a more specific condition.  
<a name="1659"></a>     */
<a name="1660"></a>    canTravelerPass(traveler) { return true; }
<a name="1661"></a>
<a name="1662"></a>    /*
<a name="1663"></a>     *   Explain why travel isn't allowed.  This should generate an
<a name="1664"></a>     *   appropriate failure report explaining the problem.  This is
<a name="1665"></a>     *   invoked when travel is attempted and canTravelerPass returns nil.
<a name="1666"></a>     *   Subclasses must override this.  
<a name="1667"></a>     */
<a name="1668"></a>    explainTravelBarrier(traveler) { }
<a name="1669"></a>;
<a name="1670"></a>
<a name="1671"></a>/*
<a name="1672"></a> *   An "unlisted proxy" connector acts as a proxy for another connector.
<a name="1673"></a> *   We act exactly like the underlying connector, except that we suppress
<a name="1674"></a> *   the connector from automatic exit lists.  This can be used for cases
<a name="1675"></a> *   where an otherwise normal connector is needed but the connector is
<a name="1676"></a> *   not to appear in automatic exit lists (such as the status line).
<a name="1677"></a> *   
<a name="1678"></a> *   The most common situation where this kind of connector is useful is
<a name="1679"></a> *   where multiple directions in a given room all go to the same
<a name="1680"></a> *   destination.  In these cases, it's often desirable for some of the
<a name="1681"></a> *   directions to be unlisted alternatives.  The asExit() macro can be
<a name="1682"></a> *   used for convenience to set up these direction synonyms.  
<a name="1683"></a> */
<a name="1684"></a>class UnlistedProxyConnector: object
<a name="1685"></a>    construct(pri)
<a name="1686"></a>    {
<a name="1687"></a>        /* remember my underlying primary connector */
<a name="1688"></a>        primaryConn = pri;
<a name="1689"></a>    }
<a name="1690"></a>
<a name="1691"></a>    /* 
<a name="1692"></a>     *   Our underlying connector.  Start out with a default TadsObject
<a name="1693"></a>     *   rather than nil in case anyone wants to call a property or test
<a name="1694"></a>     *   inheritance before we're finished with our constructor - this will
<a name="1695"></a>     *   produce reasonable default behavior without having to test for nil
<a name="1696"></a>     *   everywhere.  
<a name="1697"></a>     */
<a name="1698"></a>    primaryConn = TadsObject
<a name="1699"></a>
<a name="1700"></a>    /* we're not listed */
<a name="1701"></a>    isConnectorListed = nil
<a name="1702"></a>
<a name="1703"></a>    /* map any TravelVia action to our underlying connector */
<a name="1704"></a>    dobjFor(TravelVia) remapTo(TravelVia, primaryConn)
<a name="1705"></a>
<a name="1706"></a>    /* redirect everything we don't handle to the underlying connector */
<a name="1707"></a>    propNotDefined(prop, [args]) { return primaryConn.(prop)(args...); }
<a name="1708"></a>
<a name="1709"></a>    /* 
<a name="1710"></a>     *   As a proxy, we don't want to disguise the fact that we're a proxy,
<a name="1711"></a>     *   if someone specifically asks, so admist to being of our own true
<a name="1712"></a>     *   kind; but we also act mostly like our underlying connector, so if
<a name="1713"></a>     *   someone wants to know if we're one of those, say yes to that as
<a name="1714"></a>     *   well.  So, return true if the inherited version returns true, and
<a name="1715"></a>     *   also return true if our primary connector would return true.  
<a name="1716"></a>     */
<a name="1717"></a>    ofKind(cls) { return inherited(cls) || primaryConn.ofKind(cls); }
<a name="1718"></a>;
<a name="1719"></a>
<a name="1720"></a>
<a name="1721"></a>/*
<a name="1722"></a> *   A travel connector that doesn't allow any travel - if travel is
<a name="1723"></a> *   attempted, we simply use the origin's cannotTravel method to display
<a name="1724"></a> *   an appropriate message.  
<a name="1725"></a> */
<a name="1726"></a>noTravel: TravelConnector
<a name="1727"></a>    /* it is obvious that is no passage this way */
<a name="1728"></a>    isConnectorApparent(origin, actor) { return nil; }
<a name="1729"></a>
<a name="1730"></a>    /* this is not a passable connector */
<a name="1731"></a>    isConnectorPassable(origin, traveler) { return nil; }
<a name="1732"></a>
<a name="1733"></a>    dobjFor(TravelVia)
<a name="1734"></a>    {
<a name="1735"></a>        /* 
<a name="1736"></a>         *   we know that no travel will occur, so we don't need to satisfy
<a name="1737"></a>         *   any preconditions 
<a name="1738"></a>         */
<a name="1739"></a>        preCond = []
<a name="1740"></a>
<a name="1741"></a>        action()
<a name="1742"></a>        {
<a name="1743"></a>            /* we can't go this way - use the origin's default message */
<a name="1744"></a>            gActor.location.cannotTravel();
<a name="1745"></a>        }
<a name="1746"></a>    }
<a name="1747"></a>;
<a name="1748"></a>
<a name="1749"></a>/*
<a name="1750"></a> *   An "ask which" travel connector.  Rather than just traversing a
<a name="1751"></a> *   connector, we ask for a direct object for a specified travel verb; if
<a name="1752"></a> *   the player supplies the missing indirect object (or if the parser can
<a name="1753"></a> *   automatically choose a default), we'll perform the travel verb using
<a name="1754"></a> *   that direct object.
<a name="1755"></a> *   
<a name="1756"></a> *   This type of connector has two uses.
<a name="1757"></a> *   
<a name="1758"></a> *   First, the library various instances, with appropriate specified
<a name="1759"></a> *   travel verbs, as the default connector for certain directions that
<a name="1760"></a> *   frequently end up mapping to in-scenario objects.  Specifically,
<a name="1761"></a> *   noTravelIn, noTravelDown, and noTravelOut are used as the default in,
<a name="1762"></a> *   down, and out connectors.  If the player types DOWN, for example, and
<a name="1763"></a> *   there's no override for 'down' in a given room, then we'll invoke
<a name="1764"></a> *   noTravelDown; this will in turn ask for a missing direct object for
<a name="1765"></a> *   the GetOffOf action, since DOWN can mean getting off of a platform or
<a name="1766"></a> *   other nested room when on such a thing.  When there's an obvious
<a name="1767"></a> *   thing to get down from, the parser will provide the default
<a name="1768"></a> *   automatically, which will make DOWN into a simple synonym for GET OFF
<a name="1769"></a> *   OF &lt;whatever&gt;.
<a name="1770"></a> *   
<a name="1771"></a> *   Second, games can use this kind of connector for a given direction
<a name="1772"></a> *   when the direction is ambiguous.  For example, you can use this as
<a name="1773"></a> *   the 'north' connector when there are two doors leading north from the
<a name="1774"></a> *   location.  When the player types NORTH, the parser will ask which
<a name="1775"></a> *   door the player wants to go through.  
<a name="1776"></a> */
<a name="1777"></a>class AskConnector: TravelConnector, ResolveAsker
<a name="1778"></a>    /* 
<a name="1779"></a>     *   The specific travel action to attempt.  This must be a TAction -
<a name="1780"></a>     *   an action that takes a direct object (and only a direct object).
<a name="1781"></a>     *   The default is TravelVia, but this should usually be customized
<a name="1782"></a>     *   in each instance to the type of travel appropriate for the
<a name="1783"></a>     *   possible connectors.  
<a name="1784"></a>     */
<a name="1785"></a>    travelAction = TravelViaAction
<a name="1786"></a>
<a name="1787"></a>    /*
<a name="1788"></a>     *   The list of possible direct objects for the travel action.  If
<a name="1789"></a>     *   this is nil, we'll simply treat the direct object of the
<a name="1790"></a>     *   travelAction as completely missing, forcing the parser to either
<a name="1791"></a>     *   find a default or ask the player for the missing object.  If the
<a name="1792"></a>     *   travel is limited to a specific set of objects (for example, if
<a name="1793"></a>     *   there are two doors leading north, and we want to ask which one
<a name="1794"></a>     *   to use), this should be set to the list of possible objects; the
<a name="1795"></a>     *   parser will then use the ambiguous noun phrase rules instead of
<a name="1796"></a>     *   the missing noun phrase rules to ask the player for more
<a name="1797"></a>     *   information. 
<a name="1798"></a>     */
<a name="1799"></a>    travelObjs = nil
<a name="1800"></a>
<a name="1801"></a>    /*
<a name="1802"></a>     *   The phrase to use in the disambiguation question to ask which of
<a name="1803"></a>     *   the travelObjs entries is to be used.  The language-specific
<a name="1804"></a>     *   module provides a suitable default, but this should usually be
<a name="1805"></a>     *   overridden if travelObjs is overridden.  
<a name="1806"></a>     */
<a name="1807"></a>    travelObjsPhrase = nil
<a name="1808"></a>
<a name="1809"></a>    /*
<a name="1810"></a>     *   An extra prompt message to show before the normal parser prompt
<a name="1811"></a>     *   for a missing or ambiguous object.  We'll show this just before
<a name="1812"></a>     *   the normal parser message, if it's specified.
<a name="1813"></a>     *   
<a name="1814"></a>     *   If you want to customize the messages more completely, you can
<a name="1815"></a>     *   override askDisambig() or askMissingObject().  The parser will
<a name="1816"></a>     *   invoke these to generate the prompt, so you can customize the
<a name="1817"></a>     *   entire messages by overriding these.  
<a name="1818"></a>     */
<a name="1819"></a>    promptMessage = nil
<a name="1820"></a>
<a name="1821"></a>    /*
<a name="1822"></a>     *   For each of the ResolveAsker methods that might be invoked, add
<a name="1823"></a>     *   the promptMessage text before the normal parser question. 
<a name="1824"></a>     */
<a name="1825"></a>    askDisambig(targetActor, promptTxt, curMatchList, fullMatchList,
<a name="1826"></a>                requiredNum, askingAgain, dist)
<a name="1827"></a>    {
<a name="1828"></a>        promptMessage;
<a name="1829"></a>        inherited(targetActor, promptTxt, curMatchList, fullMatchList,
<a name="1830"></a>                  requiredNum, askingAgain, dist);
<a name="1831"></a>    }
<a name="1832"></a>
<a name="1833"></a>    askMissingObject(targetActor, action, which)
<a name="1834"></a>    {
<a name="1835"></a>        promptMessage;
<a name="1836"></a>        inherited(targetActor, action, which);
<a name="1837"></a>    }
<a name="1838"></a>    
<a name="1839"></a>    /* handle travel via this connector */
<a name="1840"></a>    dobjFor(TravelVia)
<a name="1841"></a>    {
<a name="1842"></a>        /* 
<a name="1843"></a>         *   No preconditions or checks are necessary, since we don't
<a name="1844"></a>         *   actually perform any travel on our own; we simply recast the
<a name="1845"></a>         *   command as a new action, hence we want to delegate the
<a name="1846"></a>         *   preconditions and check() handling to the replacement action.
<a name="1847"></a>         *   Note that this means that you can't put a travel barrier
<a name="1848"></a>         *   directly on an AskConnector - you have to put any barriers on
<a name="1849"></a>         *   the underlying real connectors instead.  
<a name="1850"></a>         */
<a name="1851"></a>        preCond = []
<a name="1852"></a>        check() { }
<a name="1853"></a>
<a name="1854"></a>        /* 
<a name="1855"></a>         *   Recast the travel into our specified action, asking for the
<a name="1856"></a>         *   direct object we need for that action.  
<a name="1857"></a>         */
<a name="1858"></a>        action()
<a name="1859"></a>        {
<a name="1860"></a>            /* 
<a name="1861"></a>             *   if we have a set of possible direct objects, retry this
<a name="1862"></a>             *   with the ambiguous object set; otherwise, retry with a
<a name="1863"></a>             *   completely missing direct object 
<a name="1864"></a>             */
<a name="1865"></a>            if (travelObjs != nil)
<a name="1866"></a>                travelAction.retryWithAmbiguousDobj(
<a name="1867"></a>                    gAction, travelObjs, self, travelObjsPhrase);
<a name="1868"></a>            else
<a name="1869"></a>                travelAction.retryWithMissingDobj(gAction, self);
<a name="1870"></a>        }
<a name="1871"></a>    }
<a name="1872"></a>
<a name="1873"></a>    /*
<a name="1874"></a>     *   Get a connector leading to the given destination.  We'll scan our
<a name="1875"></a>     *   travel objects; for each one that's a TravelConnector, we'll ask
<a name="1876"></a>     *   it to find the connector, and return the result if we get one.  
<a name="1877"></a>     */
<a name="1878"></a>    connectorGetConnectorTo(origin, traveler, dest)
<a name="1879"></a>    {
<a name="1880"></a>        /* if we have no travel objects, there's nothing to check */
<a name="1881"></a>        if (travelObjs == nil)
<a name="1882"></a>            return nil;
<a name="1883"></a>        
<a name="1884"></a>        /* scan our secondary connectors */
<a name="1885"></a>        foreach (local cur in travelObjs)
<a name="1886"></a>        {
<a name="1887"></a>            /* if this is a travel connector, ask it what it thinks */
<a name="1888"></a>            if (cur.ofKind(TravelConnector))
<a name="1889"></a>            {
<a name="1890"></a>                local conn;
<a name="1891"></a>                
<a name="1892"></a>                /* 
<a name="1893"></a>                 *   if this secondary connector can give us a connector to
<a name="1894"></a>                 *   the destination, use that connector 
<a name="1895"></a>                 */
<a name="1896"></a>                conn = cur.connectorGetConnectorTo(origin, traveler, dest);
<a name="1897"></a>                if (conn != nil)
<a name="1898"></a>                    return conn;
<a name="1899"></a>            }
<a name="1900"></a>        }
<a name="1901"></a>
<a name="1902"></a>        /* didn't find a match */
<a name="1903"></a>        return nil;
<a name="1904"></a>    }
<a name="1905"></a>;
<a name="1906"></a>
<a name="1907"></a>/*
<a name="1908"></a> *   A "default ask connector" is an AskConnector that we use for certain
<a name="1909"></a> *   directions (down, in, out) as the library default connector for the
<a name="1910"></a> *   directions.
<a name="1911"></a> */
<a name="1912"></a>class DefaultAskConnector: AskConnector
<a name="1913"></a>    /* 
<a name="1914"></a>     *   since this is a default connector for all locations, indicate that
<a name="1915"></a>     *   no travel is apparently possible in this direction 
<a name="1916"></a>     */
<a name="1917"></a>    isConnectorApparent(origin, actor) { return nil; }
<a name="1918"></a>
<a name="1919"></a>    /* this is not a passable connector */
<a name="1920"></a>    isConnectorPassable(origin, traveler) { return nil; }
<a name="1921"></a>;
<a name="1922"></a>
<a name="1923"></a>/*
<a name="1924"></a> *   A default travel connector for going in.  When travel in the relative
<a name="1925"></a> *   direction "in" isn't allowed, we'll try recasting the command as an
<a name="1926"></a> *   "enter" command with an unknown direct object. 
<a name="1927"></a> */
<a name="1928"></a>noTravelIn: DefaultAskConnector
<a name="1929"></a>    /* when we go 'in', we'll try to ENTER something */
<a name="1930"></a>    travelAction = EnterAction
<a name="1931"></a>;
<a name="1932"></a>
<a name="1933"></a>/*
<a name="1934"></a> *   A default travel connector for going out.  When travel in the
<a name="1935"></a> *   relative direction "out" isn't allowed, we'll try recasting the
<a name="1936"></a> *   command as an "get out of" command with an unknown direct object. 
<a name="1937"></a> */
<a name="1938"></a>noTravelOut: DefaultAskConnector
<a name="1939"></a>    /* when we go 'out', we'll try to GET OUT OF something */
<a name="1940"></a>    travelAction = GetOutOfAction
<a name="1941"></a>;
<a name="1942"></a>
<a name="1943"></a>/*
<a name="1944"></a> *   A default travel connector for going out from a nested room.  This
<a name="1945"></a> *   works the same way as noTravelOut, except that we'll show OUT as a
<a name="1946"></a> *   listed exit.  
<a name="1947"></a> */
<a name="1948"></a>nestedRoomOut: noTravelOut
<a name="1949"></a>    isConnectorApparent(origin, actor) { return true; }
<a name="1950"></a>;
<a name="1951"></a>
<a name="1952"></a>/*
<a name="1953"></a> *   A special travel connector for 'down' that recasts the command as a
<a name="1954"></a> *   "get off of" command.  This can be used for platforms and the like,
<a name="1955"></a> *   where a 'down' command should usually be taken to mean "get off
<a name="1956"></a> *   platform" rather than "down from enclosing room". 
<a name="1957"></a> */
<a name="1958"></a>noTravelDown: DefaultAskConnector
<a name="1959"></a>    /* when we go 'down', we'll try to GET OFF OF something */
<a name="1960"></a>    travelAction = GetOffOfAction
<a name="1961"></a>;
<a name="1962"></a>
<a name="1963"></a>/*
<a name="1964"></a> *   A travel connector for going in that explicitly redirects the command
<a name="1965"></a> *   to "enter" and asks for the missing direct object.  This behaves the
<a name="1966"></a> *   same way as noTravelIn, but explicitly makes the inward travel
<a name="1967"></a> *   apparent; this can be used to override the noTravelIn default for
<a name="1968"></a> *   locations where travel in is explicitly allowed.  
<a name="1969"></a> */
<a name="1970"></a>askTravelIn: AskConnector
<a name="1971"></a>    travelAction = EnterAction
<a name="1972"></a>;
<a name="1973"></a>
<a name="1974"></a>/* explicitly redirect travel out to "get out of" */
<a name="1975"></a>askTravelOut: AskConnector
<a name="1976"></a>    travelAction = GetOutOfAction
<a name="1977"></a>;
<a name="1978"></a>
<a name="1979"></a>/* explicitly redirect travel down to "get off of" */
<a name="1980"></a>askTravelDown: AskConnector
<a name="1981"></a>    travelAction = GetOffOfAction
<a name="1982"></a>;
<a name="1983"></a>
<a name="1984"></a>/*
<a name="1985"></a> *   "No Shipboard Directions" travel connector.  This is used as the
<a name="1986"></a> *   default connector for the shipboard directions for the base Room
<a name="1987"></a> *   class.  This connector displays a special message indicating that the
<a name="1988"></a> *   room is not a boat hence the shipboard directions don't work here.  
<a name="1989"></a> */
<a name="1990"></a>noShipTravel: noTravel
<a name="1991"></a>    dobjFor(TravelVia)
<a name="1992"></a>    {
<a name="1993"></a>        action()
<a name="1994"></a>        {
<a name="1995"></a>            /* simply indicate that this direction isn't applicable here */
<a name="1996"></a>            gLibMessages.notOnboardShip();
<a name="1997"></a>        }
<a name="1998"></a>    }
<a name="1999"></a>;
<a name="2000"></a>
<a name="2001"></a>/* ------------------------------------------------------------------------ */
<a name="2002"></a>/*
<a name="2003"></a> *   A mix-in class that can be added to objects that also inherit from
<a name="2004"></a> *   TravelConnector to add a message as the connector is traversed.
<a name="2005"></a> *   
<a name="2006"></a> *   Note that this isn't itself a travel connector; it's just a class
<a name="2007"></a> *   that should be combined with TravelConnector or one of its
<a name="2008"></a> *   subclasses.  This class should be in the superclass list before the
<a name="2009"></a> *   TravelConnector-derived superclass.  
<a name="2010"></a> */
<a name="2011"></a>class TravelWithMessage: object
<a name="2012"></a>    /*
<a name="2013"></a>     *   My message to display when the player character traverses the
<a name="2014"></a>     *   connector.  This should be overridden with the custom message for
<a name="2015"></a>     *   the connector.  By default, if we're a Script, we'll invoke the
<a name="2016"></a>     *   script to show the next message.  
<a name="2017"></a>     */
<a name="2018"></a>    travelDesc()
<a name="2019"></a>    {
<a name="2020"></a>        if (ofKind(Script))
<a name="2021"></a>            doScript();
<a name="2022"></a>    }
<a name="2023"></a>
<a name="2024"></a>    /*
<a name="2025"></a>     *   My message to display when any non-player character traverses the
<a name="2026"></a>     *   connector.  If this is not overridden, no message will be
<a name="2027"></a>     *   displayed when an NPC travels through the connector.  
<a name="2028"></a>     */
<a name="2029"></a>    npcTravelDesc = ""
<a name="2030"></a>
<a name="2031"></a>    /*
<a name="2032"></a>     *   Display my message.  By default, we show one message for the
<a name="2033"></a>     *   player character and another message for NPC's.  
<a name="2034"></a>     */
<a name="2035"></a>    showTravelDesc()
<a name="2036"></a>    {
<a name="2037"></a>        if (gActor.isPlayerChar())
<a name="2038"></a>            travelDesc;
<a name="2039"></a>        else
<a name="2040"></a>            npcTravelDesc;
<a name="2041"></a>    }
<a name="2042"></a>
<a name="2043"></a>    /* on traversing the connector, show our message */
<a name="2044"></a>    noteTraversal(traveler)
<a name="2045"></a>    {
<a name="2046"></a>        /* display my message */
<a name="2047"></a>        showTravelDesc();
<a name="2048"></a>
<a name="2049"></a>        /* inherit any other superclass handling as well */
<a name="2050"></a>        inherited(traveler);
<a name="2051"></a>    }
<a name="2052"></a>;
<a name="2053"></a>
<a name="2054"></a>/*
<a name="2055"></a> *   A simple connector that displays a message when the connector is
<a name="2056"></a> *   traversed.
<a name="2057"></a> */
<a name="2058"></a>class TravelMessage: TravelWithMessage, TravelConnector
<a name="2059"></a>    /* my destination location */
<a name="2060"></a>    destination = nil
<a name="2061"></a>
<a name="2062"></a>    /* get my destination */
<a name="2063"></a>    getDestination(origin, traveler) { return destination; }
<a name="2064"></a>
<a name="2065"></a>    /* our source is the same as our destination */
<a name="2066"></a>    fixedSource(dest, traveler) { return destination; }
<a name="2067"></a>;
<a name="2068"></a>
<a name="2069"></a>/*
<a name="2070"></a> *   A travel connector that can't be traversed, and which shows a custom
<a name="2071"></a> *   failure message when traversal is attempted.  Instances should define
<a name="2072"></a> *   travelDesc to the message to display when travel is attempted.
<a name="2073"></a> *   
<a name="2074"></a> *   Travel is not apparently possible in this direction, so this type of
<a name="2075"></a> *   connector will not show up in automatic exit lists or maps.  This
<a name="2076"></a> *   class is designed for connections that are essentially the same as no
<a name="2077"></a> *   connection at all, but where it's desirable to use a special message
<a name="2078"></a> *   to describe why travel can't be accomplished.  
<a name="2079"></a> */
<a name="2080"></a>class NoTravelMessage: TravelMessage
<a name="2081"></a>    dobjFor(TravelVia)
<a name="2082"></a>    {
<a name="2083"></a>        /* as in noTravel, we need no preconditions or checks */
<a name="2084"></a>        preCond = []
<a name="2085"></a>        action()
<a name="2086"></a>        {
<a name="2087"></a>            /* simply show my message - that's all we do */
<a name="2088"></a>            showTravelDesc();
<a name="2089"></a>        }
<a name="2090"></a>    }
<a name="2091"></a>
<a name="2092"></a>    /* 
<a name="2093"></a>     *   Because no travel is possible, we want a non-empty message for
<a name="2094"></a>     *   NPC's as well as for the PC; by default, use the same message for
<a name="2095"></a>     *   all actors by using travelDesc for NPC's.  
<a name="2096"></a>     */
<a name="2097"></a>    npcTravelDesc = (travelDesc)
<a name="2098"></a>
<a name="2099"></a>    /* travel is not apparently possible in this direction */
<a name="2100"></a>    isConnectorApparent(origin, actor) { return nil; }
<a name="2101"></a>    isConnectorPassable(origin, traveler) { return nil; }
<a name="2102"></a>;
<a name="2103"></a>
<a name="2104"></a>/*
<a name="2105"></a> *   A "fake" connector.  This is a connector that doesn't actually allow
<a name="2106"></a> *   travel, but acts like it *could*.  We simply show a special message
<a name="2107"></a> *   when travel is attempted, but we don't move the actor.
<a name="2108"></a> *   
<a name="2109"></a> *   This is a subclass of NoTravelMessage, so instances should customize
<a name="2110"></a> *   travelDes with the special failure message when travel is attempted.
<a name="2111"></a> *   
<a name="2112"></a> *   Note that this type of connector is by default *apparently* an exit,
<a name="2113"></a> *   even though it doesn't actually go anywhere.  This is useful for "soft
<a name="2114"></a> *   boundaries," where the game's map is meant to appear to the player to
<a name="2115"></a> *   continue but beyond which no more locations actually exist in the map.
<a name="2116"></a> *   This is an oft-used device meant to create an illusion that the game's
<a name="2117"></a> *   map exists in a larger world even though the larger world is not
<a name="2118"></a> *   modeled.  The message we display should in such cases attribute the
<a name="2119"></a> *   actor's inability to traverse the connector to a suitable constraint
<a name="2120"></a> *   within the context of the game world; for example, the actor could be
<a name="2121"></a> *   said to be unwilling to go beyond this point because the actor knows
<a name="2122"></a> *   or suspects there's nothing for a long way in this direction, or
<a name="2123"></a> *   because the actor's goals require staying within the modeled map, or
<a name="2124"></a> *   because the actor is afraid of what lies beyond.
<a name="2125"></a> *   
<a name="2126"></a> *   Note that FakeConnector should only be used when the reason for
<a name="2127"></a> *   blocking the travel is apparent before we even try travel.  In
<a name="2128"></a> *   particular, FakeConnector is good for motivational reasons not to
<a name="2129"></a> *   travel, where the actor decides for reasons of its own not to even
<a name="2130"></a> *   attempt the travel.  It's especially important not to use
<a name="2131"></a> *   FakeConnector in cases where the travel is described as attempted but
<a name="2132"></a> *   aborted halfway in - things like encountering a blocked tunnel.  This
<a name="2133"></a> *   is important because FakeConnector aborts the travel immediately,
<a name="2134"></a> *   before sending out any of the notifications that would accompany
<a name="2135"></a> *   ordinary travel, which means that physical barriers (trolls blocking
<a name="2136"></a> *   the way, being tied to a chair) that would otherwise block ordinary
<a name="2137"></a> *   travel will be bypassed.  For cases where travel is attempted, but
<a name="2138"></a> *   something turns you back halfway in, use DeadEndConnector.  
<a name="2139"></a> */
<a name="2140"></a>class FakeConnector: NoTravelMessage
<a name="2141"></a>    /* 
<a name="2142"></a>     *   travel is *apparently* possible in this direction (even though
<a name="2143"></a>     *   it's not *actually* possible) 
<a name="2144"></a>     */
<a name="2145"></a>    isConnectorApparent(origin, actor) { return true; }
<a name="2146"></a>    isConnectorPassable(origin, traveler) { return nil; }
<a name="2147"></a>;
<a name="2148"></a>
<a name="2149"></a>/* ------------------------------------------------------------------------ */
<a name="2150"></a>/*
<a name="2151"></a> *   A Dead End Connector is a connector that appears to lead somewhere,
<a name="2152"></a> *   but which turns out to be impassable for reasons that aren't apparent
<a name="2153"></a> *   until we get some distance into the passage.
<a name="2154"></a> *   
<a name="2155"></a> *   The Dead End Connector might look a lot like the Fake Connector, but
<a name="2156"></a> *   there's an important difference.  A Fake Connector is a connector that
<a name="2157"></a> *   can't even be physically attempted: the reason not to take a fake
<a name="2158"></a> *   connector is something that shows up before we even start moving,
<a name="2159"></a> *   usually a motivational reason ("You really can't leave town until you
<a name="2160"></a> *   find your missing brother").  A Dead End Connector, on the other hand,
<a name="2161"></a> *   is meant to model a physical attempt to travel that's blocked by some
<a name="2162"></a> *   problem halfway along, such as travel down a tunnel that turns out to
<a name="2163"></a> *   have caved in.  
<a name="2164"></a> */
<a name="2165"></a>class DeadEndConnector: TravelMessage
<a name="2166"></a>    /* 
<a name="2167"></a>     *   The apparent destination name.  If the actor is meant to know the
<a name="2168"></a>     *   apparent destination from the outset, or if traversing the
<a name="2169"></a>     *   connector gives the actor an idea of where the connector
<a name="2170"></a>     *   supposedly goes, this can be used to give the name of that
<a name="2171"></a>     *   destination.  This name will show up in exit listings, for
<a name="2172"></a>     *   example, once the PC knows where the connector supposedly goes.
<a name="2173"></a>     *   
<a name="2174"></a>     *   Note that this isn't the actual destination of the connector,
<a name="2175"></a>     *   since the actual destination is simply back to the origin (that's
<a name="2176"></a>     *   the whole point of the dead end, after all).  This is simply where
<a name="2177"></a>     *   the connector *appears* to go.  If an attempted traversal doesn't
<a name="2178"></a>     *   even reveal that much, then you should just leave this nil, since
<a name="2179"></a>     *   the destination will never become apparent to the PC.  
<a name="2180"></a>     */
<a name="2181"></a>    apparentDestName = nil
<a name="2182"></a>
<a name="2183"></a>    /*
<a name="2184"></a>     *   Our apparent destination.  By default, we create a FakeDestination
<a name="2185"></a>     *   object to represent our apparent destination if we have a non-nil
<a name="2186"></a>     *   name for the apparent destination.
<a name="2187"></a>     *   
<a name="2188"></a>     *   If the supposed-but-unreachable destination of the connector is in
<a name="2189"></a>     *   fact a real location in the game, you can override this to point
<a name="2190"></a>     *   directly to that actual location.  This default is for the typical
<a name="2191"></a>     *   case where the supposed destination doesn't actually exist on the
<a name="2192"></a>     *   game map as a real room.  
<a name="2193"></a>     */
<a name="2194"></a>    apparentDest()
<a name="2195"></a>    {
<a name="2196"></a>        /* 
<a name="2197"></a>         *   if we have an apparent destination name, create a
<a name="2198"></a>         *   FakeDestination to represent the apparent destination, and
<a name="2199"></a>         *   plug that in as our apparent destination for future reference 
<a name="2200"></a>         */
<a name="2201"></a>        if (apparentDestName != nil)
<a name="2202"></a>        {
<a name="2203"></a>            local fake;
<a name="2204"></a>            
<a name="2205"></a>            /* create a fake destination */
<a name="2206"></a>            fake = new FakeDestination(self);
<a name="2207"></a>
<a name="2208"></a>            /* plug it in as our new apparentDest for future calls */
<a name="2209"></a>            apparentDest = fake;
<a name="2210"></a>
<a name="2211"></a>            /* return the new object as the result */
<a name="2212"></a>            return fake;
<a name="2213"></a>        }
<a name="2214"></a>
<a name="2215"></a>        /* our apparent destination is unknown */
<a name="2216"></a>        return nil;
<a name="2217"></a>    }
<a name="2218"></a>
<a name="2219"></a>    /* get our apparent destination */
<a name="2220"></a>    getApparentDestination(origin, actor)
<a name="2221"></a>    {
<a name="2222"></a>        /* 
<a name="2223"></a>         *   If the actor knows the destination for the given connector (as
<a name="2224"></a>         *   determined by the origin room), or we have a memory of this
<a name="2225"></a>         *   traversal, return our fake destination object to represent the
<a name="2226"></a>         *   destination.  We can only return our fake destination if we
<a name="2227"></a>         *   have an explicit apparent destination, since it's only in this
<a name="2228"></a>         *   case that our apparent destination ever actually becomes
<a name="2229"></a>         *   known, even after an attempted traversal.
<a name="2230"></a>         *   
<a name="2231"></a>         *   Our actual destination is always just the origin, but we
<a name="2232"></a>         *   *appear* to have some other destination.  Even though we can
<a name="2233"></a>         *   never actually reach that other, apparent destination, we at
<a name="2234"></a>         *   least want to give the appearance of going there, which we
<a name="2235"></a>         *   provide through our fake destination object.  
<a name="2236"></a>         */
<a name="2237"></a>        if (apparentDest != nil
<a name="2238"></a>            &amp;&amp; (origin.actorKnowsDestination(actor, self)
<a name="2239"></a>                || travelMemory[[actor, origin, self]] != nil))
<a name="2240"></a>            return apparentDest;
<a name="2241"></a>
<a name="2242"></a>        /* our unreachable destination is not apparent */
<a name="2243"></a>        return nil;
<a name="2244"></a>    }
<a name="2245"></a>
<a name="2246"></a>    /* there's no corresponding connector back for a dead end */
<a name="2247"></a>    connectorBack(traveler, dest) { return nil; }
<a name="2248"></a>
<a name="2249"></a>    /* our actual destination is always our origin */
<a name="2250"></a>    getDestination(origin, traveler) { return origin; }
<a name="2251"></a>
<a name="2252"></a>    /* do remember circular trips, since that's the only kind we make */
<a name="2253"></a>    rememberCircularPassage = true
<a name="2254"></a>;
<a name="2255"></a>
<a name="2256"></a>/*
<a name="2257"></a> *   A fake apparent destination, for dead-end connectors.  The dead-end
<a name="2258"></a> *   connector will create an object of this class to represent its
<a name="2259"></a> *   apparent but actually unreachable destination, if it has an apparent
<a name="2260"></a> *   destination name. 
<a name="2261"></a> */
<a name="2262"></a>class FakeDestination: object
<a name="2263"></a>    /* construct - remember our associated connector */
<a name="2264"></a>    construct(conn) { connector = conn; }
<a name="2265"></a>    
<a name="2266"></a>    /* get our destination name - this is the name from our connector */
<a name="2267"></a>    getDestName(actor, origin) { return connector.apparentDestName; }
<a name="2268"></a>
<a name="2269"></a>    /* our underlying connector (usually a DeadEndConnector) */
<a name="2270"></a>    connector = nil
<a name="2271"></a>;
<a name="2272"></a>
<a name="2273"></a>/* ------------------------------------------------------------------------ */
<a name="2274"></a>/*
<a name="2275"></a> *   A direct room-to-room connector.  In most cases, it is not necessary
<a name="2276"></a> *   to create one of these objects, because rooms can serve as their own
<a name="2277"></a> *   connectors.  These objects are needed in certain cases, though, such
<a name="2278"></a> *   as when a room-to-room connection requires a travel barrier.  
<a name="2279"></a> */
<a name="2280"></a>class RoomConnector: TravelConnector
<a name="2281"></a>    /* the two rooms we link */
<a name="2282"></a>    room1 = nil
<a name="2283"></a>    room2 = nil
<a name="2284"></a>
<a name="2285"></a>    /* 
<a name="2286"></a>     *   get the destination, given the origin: this is the one of the two
<a name="2287"></a>     *   rooms we link that we're not in now 
<a name="2288"></a>     */
<a name="2289"></a>    getDestination(origin, traveler)
<a name="2290"></a>    {
<a name="2291"></a>        if (origin == room1)
<a name="2292"></a>            return room2;
<a name="2293"></a>        else if (origin == room2)
<a name="2294"></a>            return room1;
<a name="2295"></a>        else
<a name="2296"></a>            return nil;
<a name="2297"></a>    }
<a name="2298"></a>
<a name="2299"></a>    fixedSource(origin, traveler)
<a name="2300"></a>    {
<a name="2301"></a>        /* 
<a name="2302"></a>         *   we're a symmetrical two-way connector, so our source from the
<a name="2303"></a>         *   perspective of one room is the same as the destination from
<a name="2304"></a>         *   that same perspective 
<a name="2305"></a>         */
<a name="2306"></a>        return getDestination(origin, traveler);
<a name="2307"></a>    }
<a name="2308"></a>
<a name="2309"></a>    /*
<a name="2310"></a>     *   Get the precondition for this connector.  The normal
<a name="2311"></a>     *   TravelConnector rule that the traveler must be in the outbound
<a name="2312"></a>     *   connector's location is not meaningful for an abstract room
<a name="2313"></a>     *   connector, because this type of connection itself isn't
<a name="2314"></a>     *   represented as a physical game object with a location; it's just
<a name="2315"></a>     *   an abstract data structure.  This means that we must have a
<a name="2316"></a>     *   directional property in the *source* location that points directly
<a name="2317"></a>     *   to the destination (i.e., self).
<a name="2318"></a>     *   
<a name="2319"></a>     *   So, the appropriate starting point for room connectors is the
<a name="2320"></a>     *   object that contains the connection.  In other words, we must
<a name="2321"></a>     *   search for the nearest object enclosing the *traveler* that has a
<a name="2322"></a>     *   direction property directly linked to 'self'; that enclosing
<a name="2323"></a>     *   container is the required starting location for the travel.  
<a name="2324"></a>     */
<a name="2325"></a>    connectorTravelPreCond()
<a name="2326"></a>    {
<a name="2327"></a>        /* 
<a name="2328"></a>         *   Scan upwards from the traveler's location, looking for an
<a name="2329"></a>         *   object that has a directional property linked to self.  Only
<a name="2330"></a>         *   scan into locations that the actor can see.  
<a name="2331"></a>         */
<a name="2332"></a>        for (local loc = gActor.getTraveler(self).location ;
<a name="2333"></a>             loc != nil &amp;&amp; gActor.canSee(loc) ; loc = loc.location)
<a name="2334"></a>        {
<a name="2335"></a>            /* look for a directional connector directly from 'loc' to us */
<a name="2336"></a>            if (loc.localDirectionLinkForConnector(self) != nil)
<a name="2337"></a>            {
<a name="2338"></a>                /* 
<a name="2339"></a>                 *   we're linked from this enclosing location, so this is
<a name="2340"></a>                 *   where we have to be before travel 
<a name="2341"></a>                 */
<a name="2342"></a>                return [new TravelerDirectlyInRoom(gActor, self, loc)];
<a name="2343"></a>            }
<a name="2344"></a>        }
<a name="2345"></a>
<a name="2346"></a>        /* we couldn't find a link, so apply no condition */
<a name="2347"></a>        return [];
<a name="2348"></a>    }
<a name="2349"></a>;
<a name="2350"></a>
<a name="2351"></a>/*
<a name="2352"></a> *   A one-way room connector.  This works like an ordinary room
<a name="2353"></a> *   connector, but connects only in one direction.  To use this class,
<a name="2354"></a> *   simply define the 'destination' property to point to the room we
<a name="2355"></a> *   connect to.
<a name="2356"></a> */
<a name="2357"></a>class OneWayRoomConnector: RoomConnector
<a name="2358"></a>    /* my destination - instances must define this */
<a name="2359"></a>    destination = nil
<a name="2360"></a>
<a name="2361"></a>    /* we always have a fixed destination */
<a name="2362"></a>    getDestination(origin, traveler) { return destination; }
<a name="2363"></a>;
<a name="2364"></a>
<a name="2365"></a>/*
<a name="2366"></a> *   A room "auto-connector".  This is a special subclass of RoomConnector
<a name="2367"></a> *   that can be mixed in to any BasicLocation subclass to make the room
<a name="2368"></a> *   usable as the direct target of a directional property in another room
<a name="2369"></a> *   - so you could say "east = myRoom", for example, without creating any
<a name="2370"></a> *   intermediate connector. 
<a name="2371"></a> */
<a name="2372"></a>class RoomAutoConnector: RoomConnector
<a name="2373"></a>    /*   
<a name="2374"></a>     *   Suppose that roomA.north = roomB.  This means that if an actor is
<a name="2375"></a>     *   in roomA, and executes a "north" command, we'll execute a
<a name="2376"></a>     *   TravelVia action on room B, because the "connector" will be
<a name="2377"></a>     *   roomB.  In these cases, the destination of the travel and the
<a name="2378"></a>     *   travel connector are one and the same.  So, when the connector is
<a name="2379"></a>     *   roomB, the destination of travel is also simply roomB.  
<a name="2380"></a>     */
<a name="2381"></a>    getDestination(origin, traveler)
<a name="2382"></a>    {
<a name="2383"></a>        /* we are our own destination */
<a name="2384"></a>        return self;
<a name="2385"></a>    }
<a name="2386"></a>;
<a name="2387"></a>
<a name="2388"></a>/* ------------------------------------------------------------------------ */
<a name="2389"></a>/*
<a name="2390"></a> *   Base class for passages between rooms.  This can be used for a
<a name="2391"></a> *   passage that not only connects the rooms but also exists as an object
<a name="2392"></a> *   in its own right within the rooms it connects.
<a name="2393"></a> *   
<a name="2394"></a> *   In most cases, two passage objects will exist - one on each side of
<a name="2395"></a> *   the passage, so one object in each room connected.  One of the
<a name="2396"></a> *   objects should be designated as the "master"; the other is the
<a name="2397"></a> *   "slave."  The master object is the one which should implement all
<a name="2398"></a> *   special behavior involving state changes (such as opening or closing
<a name="2399"></a> *   a door).
<a name="2400"></a> *   
<a name="2401"></a> *   This basic passage is not designed to be opened and closed; use Door
<a name="2402"></a> *   for a passage that can be opened and closed.  
<a name="2403"></a> */
<a name="2404"></a>class Passage: Linkable, Fixture, TravelConnector
<a name="2405"></a>    /*
<a name="2406"></a>     *   Our destination - this is where the actor ends up when traveling
<a name="2407"></a>     *   through the passage (assuming the passage is open).  By default,
<a name="2408"></a>     *   we return the "room location" of our other side's container; in
<a name="2409"></a>     *   cases where our other side is not directly in our destination
<a name="2410"></a>     *   room (for example, the other side is part of some larger object
<a name="2411"></a>     *   structure), this property should be overridden to specify the
<a name="2412"></a>     *   actual destination.
<a name="2413"></a>     *   
<a name="2414"></a>     *   If our otherSide is nil, the passage doesn't go anywhere.  This
<a name="2415"></a>     *   can be useful to create things that look and act like passages,
<a name="2416"></a>     *   but which don't actually go anywhere - in other words,
<a name="2417"></a>     *   passage-like decorations.  
<a name="2418"></a>     */
<a name="2419"></a>    destination = (otherSide != nil ? otherSide.location.roomLocation : nil)
<a name="2420"></a>
<a name="2421"></a>    /* get my destination - just return my 'destination' property */
<a name="2422"></a>    getDestination(origin, traveler) { return destination; }
<a name="2423"></a>
<a name="2424"></a>    /* get our open/closed status */
<a name="2425"></a>    isOpen()
<a name="2426"></a>    {
<a name="2427"></a>        /* 
<a name="2428"></a>         *   if we have a separate master object, defer to it; otherwise,
<a name="2429"></a>         *   use our own status 
<a name="2430"></a>         */
<a name="2431"></a>        return (masterObject == self ? isOpen_ : masterObject.isOpen);
<a name="2432"></a>    }
<a name="2433"></a>
<a name="2434"></a>    /* internal open/closed status - open by default */
<a name="2435"></a>    isOpen_ = true
<a name="2436"></a>
<a name="2437"></a>    /* 
<a name="2438"></a>     *   We're not visible in the dark if we're closed.  If we're open,
<a name="2439"></a>     *   the normal rules apply.
<a name="2440"></a>     *   
<a name="2441"></a>     *   Normally, a passage is visible in the dark if there's light in
<a name="2442"></a>     *   the adjoining location: our model is that enough light is leaking
<a name="2443"></a>     *   in through the passage to make the passage itself visible, but
<a name="2444"></a>     *   not enough to light anything else in the current room.  In the
<a name="2445"></a>     *   case of a closed passage, though, we assume that it completely
<a name="2446"></a>     *   blocks any light from the other room, eliminating any indication
<a name="2447"></a>     *   of a passage.
<a name="2448"></a>     *   
<a name="2449"></a>     *   If you do want an openable passage to be visible in the dark even
<a name="2450"></a>     *   when it's closed, it's probably better to make the passage
<a name="2451"></a>     *   self-illuminating (i.e., with brightness 1), because this will
<a name="2452"></a>     *   put the passage in scope and thus allow it to be manipulated.  
<a name="2453"></a>     */
<a name="2454"></a>    isConnectorVisibleInDark(origin, actor)
<a name="2455"></a>        { return isOpen() &amp;&amp; inherited(origin, actor); }
<a name="2456"></a>
<a name="2457"></a>    /* a passage is passable when it's open */
<a name="2458"></a>    isConnectorPassable(origin, traveler) { return isOpen(); }
<a name="2459"></a>
<a name="2460"></a>    /*
<a name="2461"></a>     *   Initialize.  If we're a slave, we'll set up the otherSide
<a name="2462"></a>     *   relationship between this passage and our master passage.  
<a name="2463"></a>     */
<a name="2464"></a>    initializeThing()
<a name="2465"></a>    {
<a name="2466"></a>        /* inherit default handling */
<a name="2467"></a>        inherited();
<a name="2468"></a>
<a name="2469"></a>        /* 
<a name="2470"></a>         *   if we have a master side, initialize our relationship with
<a name="2471"></a>         *   the master side
<a name="2472"></a>         */
<a name="2473"></a>        if (masterObject != self)
<a name="2474"></a>        {
<a name="2475"></a>            /* set our otherSide to point to the master */
<a name="2476"></a>            otherSide = masterObject;
<a name="2477"></a>
<a name="2478"></a>            /* set the master's otherSide to point to us */
<a name="2479"></a>            masterObject.initMasterObject(self);
<a name="2480"></a>        }
<a name="2481"></a>    }
<a name="2482"></a>
<a name="2483"></a>    /* 
<a name="2484"></a>     *   Initialize the master object.  The other side of a two-sided door
<a name="2485"></a>     *   will call this on the master object to let the master object know
<a name="2486"></a>     *   about the other side.  'other' is the other-side object.  By
<a name="2487"></a>     *   default, we'll simply remember the other object in our own
<a name="2488"></a>     *   'otherSide' property.  
<a name="2489"></a>     */
<a name="2490"></a>    initMasterObject(other) { otherSide = other; }
<a name="2491"></a>    
<a name="2492"></a>    /*
<a name="2493"></a>     *   Our corresponding passage object on the other side of the
<a name="2494"></a>     *   passage.  This will be set automatically during initialization
<a name="2495"></a>     *   based on the masterObject property of the slave - it is not
<a name="2496"></a>     *   generally necessary to set this manually.  
<a name="2497"></a>     */
<a name="2498"></a>    otherSide = nil
<a name="2499"></a>
<a name="2500"></a>    /* our other side is the other facet of the passage */
<a name="2501"></a>    getFacets() { return otherSide != nil ? [otherSide] : inherited(); }
<a name="2502"></a>
<a name="2503"></a>    /* 
<a name="2504"></a>     *   our source is always our destination, since we have a one-to-one
<a name="2505"></a>     *   relationship with our comlementary passage in the destination
<a name="2506"></a>     *   location (we point to it, it points to us) 
<a name="2507"></a>     */
<a name="2508"></a>    fixedSource(origin, traveler) { return destination; }
<a name="2509"></a>
<a name="2510"></a>    /* the connector back is our complementary side, if we have one */
<a name="2511"></a>    connectorBack(traveler, dest)
<a name="2512"></a>    {
<a name="2513"></a>        /* if we have a complementary side, it's the connector back */
<a name="2514"></a>        if (otherSide != nil)
<a name="2515"></a>            return otherSide;
<a name="2516"></a>
<a name="2517"></a>        /* we don't have a complementary side, so use the default handling */
<a name="2518"></a>        return inherited(traveler, dest);
<a name="2519"></a>    }
<a name="2520"></a>
<a name="2521"></a>    /* can the given actor travel through this passage? */
<a name="2522"></a>    canActorTravel(actor)
<a name="2523"></a>    {
<a name="2524"></a>        /* 
<a name="2525"></a>         *   by default, the actor can travel through the passage if and
<a name="2526"></a>         *   only if the passage is open 
<a name="2527"></a>         */
<a name="2528"></a>        return isOpen;
<a name="2529"></a>    }
<a name="2530"></a>
<a name="2531"></a>    /*
<a name="2532"></a>     *   Display our message when we don't allow the actor to travel
<a name="2533"></a>     *   through the passage because the passage is closed.  By default,
<a name="2534"></a>     *   we'll simply display the default cannotTravel message for the
<a name="2535"></a>     *   actor's location, but this can be overridden to provide a more
<a name="2536"></a>     *   specific report of the problem.  
<a name="2537"></a>     */
<a name="2538"></a>    cannotTravel()
<a name="2539"></a>    {
<a name="2540"></a>        /* use the actor's location's cannotTravel handling */
<a name="2541"></a>        gActor.location.cannotTravel();
<a name="2542"></a>    }
<a name="2543"></a>
<a name="2544"></a>    /* carry out travel via this connector */
<a name="2545"></a>    dobjFor(TravelVia)
<a name="2546"></a>    {
<a name="2547"></a>        /* check travel */
<a name="2548"></a>        check()
<a name="2549"></a>        {
<a name="2550"></a>            /* 
<a name="2551"></a>             *   Move the actor only if we're open; if we're not, use the
<a name="2552"></a>             *   standard no-travel handling for the actor's location.
<a name="2553"></a>             *   Note that we don't try to implicitly open the passage,
<a name="2554"></a>             *   because the basic passage is not openable; if we're
<a name="2555"></a>             *   closed, it means we're impassable for some reason that
<a name="2556"></a>             *   presumably cannot be remedied by a simple "open" command.
<a name="2557"></a>             */
<a name="2558"></a>            if (!canActorTravel(gActor))
<a name="2559"></a>            {
<a name="2560"></a>                /* we're closed, so use our no-travel handling */
<a name="2561"></a>                cannotTravel();
<a name="2562"></a>                exit;
<a name="2563"></a>            }
<a name="2564"></a>            else
<a name="2565"></a>            {
<a name="2566"></a>                /* inherit the default checks */
<a name="2567"></a>                inherited();
<a name="2568"></a>            }
<a name="2569"></a>        }
<a name="2570"></a>    }
<a name="2571"></a>
<a name="2572"></a>    dobjFor(LookThrough)
<a name="2573"></a>    {
<a name="2574"></a>        action()
<a name="2575"></a>        {
<a name="2576"></a>            /* 
<a name="2577"></a>             *   if we're open, we simply "can't see much from here";
<a name="2578"></a>             *   otherwise, we can't see through it at all 
<a name="2579"></a>             */
<a name="2580"></a>            if (isOpen)
<a name="2581"></a>                mainReport(&amp;nothingThroughPassageMsg);
<a name="2582"></a>            else
<a name="2583"></a>                inherited();
<a name="2584"></a>        }
<a name="2585"></a>    }
<a name="2586"></a>;
<a name="2587"></a>
<a name="2588"></a>/*
<a name="2589"></a> *   A passage that an actor can travel through (with a "go through" or
<a name="2590"></a> *   "enter" command).  A "go through" command applied to the passage
<a name="2591"></a> *   simply makes the actor travel through the passage as though using the
<a name="2592"></a> *   appropriate directional command.
<a name="2593"></a> *   
<a name="2594"></a> *   We describe actors arriving or departing via the passage using
<a name="2595"></a> *   "through" descriptions ("Bob arrives through the door," etc).  
<a name="2596"></a> */
<a name="2597"></a>class ThroughPassage: Passage
<a name="2598"></a>    describeDeparture(traveler, origin, dest)
<a name="2599"></a>    {
<a name="2600"></a>        /* describe the traveler departing through this passage */
<a name="2601"></a>        traveler.sayDepartingThroughPassage(self);
<a name="2602"></a>    }
<a name="2603"></a>
<a name="2604"></a>    describeArrival(traveler, origin, dest)
<a name="2605"></a>    {
<a name="2606"></a>        /* describe the traveler arriving through this passage */
<a name="2607"></a>        traveler.sayArrivingThroughPassage(self);
<a name="2608"></a>    }
<a name="2609"></a>
<a name="2610"></a>    /* treat "go through self" as travel through the passage */
<a name="2611"></a>    dobjFor(GoThrough) remapTo(TravelVia, self)
<a name="2612"></a>
<a name="2613"></a>    /* "enter" is the same as "go through" for this type of passage */
<a name="2614"></a>    dobjFor(Enter) asDobjFor(GoThrough)
<a name="2615"></a>
<a name="2616"></a>    /* 
<a name="2617"></a>     *   Explicitly map the indirect object 'verify' handlers for the
<a name="2618"></a>     *   push-travel commands corresponding to the regular travel commands
<a name="2619"></a>     *   we provide.  This isn't strictly necessary except when we're mixed
<a name="2620"></a>     *   in to something like a Decoration, in which case explicitly
<a name="2621"></a>     *   defining the mapping here is important because it will give the
<a name="2622"></a>     *   mapping higher precedence than a catch-all handlers overriding the
<a name="2623"></a>     *   same mapping we inherit from Thing.  We use the same mapping that
<a name="2624"></a>     *   Thing provides by default.  
<a name="2625"></a>     */
<a name="2626"></a>    mapPushTravelIobj(PushTravelThrough, TravelVia)
<a name="2627"></a>    mapPushTravelIobj(PushTravelEnter, TravelVia)
<a name="2628"></a>;
<a name="2629"></a>
<a name="2630"></a>/*
<a name="2631"></a> *   A Path Passage is a specialization of through passage that's more
<a name="2632"></a> *   suitable for outdoor locations.  This type of passage is good for
<a name="2633"></a> *   things like outdoor walkways, paths, and streets, where travelers walk
<a name="2634"></a> *   along the connector but aren't enclosed by it.  The main practical
<a name="2635"></a> *   difference is how we describe departures and arrivals; in English, we
<a name="2636"></a> *   describe these as being "via" the path rather than "through" the path,
<a name="2637"></a> *   since there's no enclosure involved in these connections.  
<a name="2638"></a> */
<a name="2639"></a>class PathPassage: ThroughPassage
<a name="2640"></a>    describeDeparture(traveler, origin, dest)
<a name="2641"></a>    {
<a name="2642"></a>        traveler.sayDepartingViaPath(self);
<a name="2643"></a>    }
<a name="2644"></a>
<a name="2645"></a>    describeArrival(traveler, origin, dest)
<a name="2646"></a>    {
<a name="2647"></a>        /* describe the traveler arriving through this passage */
<a name="2648"></a>        traveler.sayArrivingViaPath(self);
<a name="2649"></a>    }
<a name="2650"></a>
<a name="2651"></a>    /* putting something on a path is the same as dropping it */
<a name="2652"></a>    iobjFor(PutOn) remapTo(Drop, DirectObject)
<a name="2653"></a>
<a name="2654"></a>    /* use a special message for standing on a path */
<a name="2655"></a>    cannotStandOnMsg = &amp;cannotStandOnPathMsg
<a name="2656"></a>
<a name="2657"></a>    /* FOLLOW PATH -&gt; travel via the path */
<a name="2658"></a>    dobjFor(Follow) remapTo(TravelVia, DirectObject)
<a name="2659"></a>;
<a name="2660"></a>
<a name="2661"></a>
<a name="2662"></a>/* ------------------------------------------------------------------------ */
<a name="2663"></a>/*
<a name="2664"></a> *   The exit portal of a one-way passage.  This isn't a fully functional
<a name="2665"></a> *   passage, but rather an object that acts as the receiving end of a
<a name="2666"></a> *   passage that can only be traversed in one direction.
<a name="2667"></a> *   
<a name="2668"></a> *   This can be used for various purposes: the underside of a trap door,
<a name="2669"></a> *   the bottom of a chute, the exit of a wormhole.  
<a name="2670"></a> */
<a name="2671"></a>class ExitOnlyPassage: ThroughPassage
<a name="2672"></a>    dobjFor(TravelVia)
<a name="2673"></a>    {
<a name="2674"></a>        action()
<a name="2675"></a>        {
<a name="2676"></a>            /* 
<a name="2677"></a>             *   Show our default failure message.  This can be overridden
<a name="2678"></a>             *   to provide a more customized description of why the
<a name="2679"></a>             *   passage cannot be entered from this side.  
<a name="2680"></a>             */
<a name="2681"></a>            reportFailure(&amp;cannotEnterExitOnlyMsg, self);
<a name="2682"></a>        }
<a name="2683"></a>    }
<a name="2684"></a>;
<a name="2685"></a>
<a name="2686"></a>/* ------------------------------------------------------------------------ */
<a name="2687"></a>/*
<a name="2688"></a> *   Stairway - this is a special kind of passage that is used for
<a name="2689"></a> *   vertical connections, such as stairways and ladders.  This type of
<a name="2690"></a> *   passage doesn't allow "enter" or "go through," but does allow "climb".
<a name="2691"></a> *   
<a name="2692"></a> *   The basic Stairway should generally not be used, as it doesn't know
<a name="2693"></a> *   where it is relative to connected stairs.  Instead, the more specific
<a name="2694"></a> *   StairwayUp and StairwayDown should be used in most cases.
<a name="2695"></a> *   
<a name="2696"></a> *   Note that at midpoints along long stairways (landings, for example),
<a name="2697"></a> *   separate stairway objects should normally be used: one going up and
<a name="2698"></a> *   one going down.  
<a name="2699"></a> */
<a name="2700"></a>class Stairway: Passage
<a name="2701"></a>    /*
<a name="2702"></a>     *   Treat "climb self" as travel through the passage 
<a name="2703"></a>     */
<a name="2704"></a>    dobjFor(Climb) remapTo(TravelVia, self)
<a name="2705"></a>;
<a name="2706"></a>
<a name="2707"></a>/*
<a name="2708"></a> *   A stairway going up from here. 
<a name="2709"></a> */
<a name="2710"></a>class StairwayUp: Stairway
<a name="2711"></a>    describeArrival(traveler, origin, dest)
<a name="2712"></a>    {
<a name="2713"></a>        /* 
<a name="2714"></a>         *   describe the actor arriving by coming down these stairs (they
<a name="2715"></a>         *   leave up, so they arrive down) 
<a name="2716"></a>         */
<a name="2717"></a>        traveler.sayArrivingDownStairs(self);
<a name="2718"></a>    }
<a name="2719"></a>
<a name="2720"></a>    describeDeparture(traveler, origin, dest)
<a name="2721"></a>    {
<a name="2722"></a>        /* describe the actor leaving up these stairs */
<a name="2723"></a>        traveler.sayDepartingUpStairs(self);
<a name="2724"></a>    }
<a name="2725"></a>
<a name="2726"></a>    /* "climb up" is the specific direction for "climb" here */
<a name="2727"></a>    dobjFor(ClimbUp) asDobjFor(Climb)
<a name="2728"></a>
<a name="2729"></a>    /* cannot climb down from here */
<a name="2730"></a>    dobjFor(ClimbDown)
<a name="2731"></a>    {
<a name="2732"></a>        verify() { illogical(&amp;stairwayNotDownMsg); }
<a name="2733"></a>    }
<a name="2734"></a>;
<a name="2735"></a>
<a name="2736"></a>/*
<a name="2737"></a> *   A stairway going down from here. 
<a name="2738"></a> */
<a name="2739"></a>class StairwayDown: Stairway
<a name="2740"></a>    /* "climb down" is the specific direction for "climb" here */
<a name="2741"></a>    dobjFor(ClimbDown) asDobjFor(Climb)
<a name="2742"></a>
<a name="2743"></a>    describeArrival(traveler, origin, dest)
<a name="2744"></a>    {
<a name="2745"></a>        /* 
<a name="2746"></a>         *   describe the actor arriving by coming up these stairs (they
<a name="2747"></a>         *   leave down, so they arrive up) 
<a name="2748"></a>         */
<a name="2749"></a>        traveler.sayArrivingUpStairs(self);
<a name="2750"></a>    }
<a name="2751"></a>
<a name="2752"></a>    describeDeparture(traveler, origin, dest)
<a name="2753"></a>    {
<a name="2754"></a>        /* describe the actor traveling down these stairs */
<a name="2755"></a>        traveler.sayDepartingDownStairs(self);
<a name="2756"></a>    }
<a name="2757"></a>
<a name="2758"></a>    /* cannot climb up from here */
<a name="2759"></a>    dobjFor(ClimbUp)
<a name="2760"></a>    {
<a name="2761"></a>        verify() { illogical(&amp;stairwayNotUpMsg); }
<a name="2762"></a>    }
<a name="2763"></a>;
<a name="2764"></a>
<a name="2765"></a>/* ------------------------------------------------------------------------ */
<a name="2766"></a>/*
<a name="2767"></a> *   Basic Door class.  This is the base class for door-like objects: a
<a name="2768"></a> *   travel connector with two sides, and which can be opened and closed.
<a name="2769"></a> *   Each side of the door is linked to the other, so that opening or
<a name="2770"></a> *   closing one side makes the same change to the other side.  
<a name="2771"></a> *   
<a name="2772"></a> *   A basic door has the internal functionality of a door, but doesn't
<a name="2773"></a> *   provide handling for player commands that manipulate the open/closed
<a name="2774"></a> *   status.  
<a name="2775"></a> */
<a name="2776"></a>class BasicDoor: BasicOpenable, ThroughPassage
<a name="2777"></a>    /* 
<a name="2778"></a>     *   Open/close the door.  If we have a complementary door object
<a name="2779"></a>     *   representing the other side, we'll remark in the sensory context
<a name="2780"></a>     *   of its location that it's also opening or closing. 
<a name="2781"></a>     */
<a name="2782"></a>    makeOpen(stat)
<a name="2783"></a>    {
<a name="2784"></a>        /* inherit the default behavior */
<a name="2785"></a>        inherited(stat);
<a name="2786"></a>
<a name="2787"></a>        /* 
<a name="2788"></a>         *   if our new status is in effect, notify the other side so that
<a name="2789"></a>         *   it can generate a message in its location 
<a name="2790"></a>         */
<a name="2791"></a>        if (isOpen == stat &amp;&amp; otherSide != nil)
<a name="2792"></a>            otherSide.noteRemoteOpen(stat);
<a name="2793"></a>    }
<a name="2794"></a>
<a name="2795"></a>    /*
<a name="2796"></a>     *   Note a "remote" change to our open/close status.  This is an
<a name="2797"></a>     *   open/close operation performed on our complementary object
<a name="2798"></a>     *   representing the other side of the door.  We'll remark on the
<a name="2799"></a>     *   change in the sensory context of this side, but only if we're
<a name="2800"></a>     *   suppressing output in the current context - if we're not, then
<a name="2801"></a>     *   the player will see the message generated by the side that we
<a name="2802"></a>     *   directly acted upon, so we don't need a separate report for the
<a name="2803"></a>     *   other side.  
<a name="2804"></a>     */
<a name="2805"></a>    noteRemoteOpen(stat)
<a name="2806"></a>    {
<a name="2807"></a>        /* 
<a name="2808"></a>         *   If I'm not visible to the player character in the current
<a name="2809"></a>         *   sense context, where the action is actually taking place,
<a name="2810"></a>         *   switch to my own sensory context and display a report.  This
<a name="2811"></a>         *   way, if the player can see this door but not the other side,
<a name="2812"></a>         *   and the action is taking place on the other side, we'll still
<a name="2813"></a>         *   see a note about the change.  We only need to do this if
<a name="2814"></a>         *   we're not already visible to the player, because if we are,
<a name="2815"></a>         *   we'll generate an ordinary report of the door opening in the
<a name="2816"></a>         *   action's context.  
<a name="2817"></a>         */
<a name="2818"></a>        if (senseContext.isBlocking)
<a name="2819"></a>        {
<a name="2820"></a>            /* show a message in my own sensory context */
<a name="2821"></a>            callWithSenseContext(self, sight, {: describeRemoteOpen(stat) });
<a name="2822"></a>        }
<a name="2823"></a>    }
<a name="2824"></a>
<a name="2825"></a>    /* 
<a name="2826"></a>     *   Describe the door being opened remotely (that is, by someone on
<a name="2827"></a>     *   the other side).  This is called from noteRemoteOpen to actually
<a name="2828"></a>     *   display the message.  
<a name="2829"></a>     */
<a name="2830"></a>    describeRemoteOpen(stat)
<a name="2831"></a>    {
<a name="2832"></a>        /* show the default library message for opening the door remotely */
<a name="2833"></a>        gLibMessages.sayOpenDoorRemotely(self, stat);
<a name="2834"></a>    }
<a name="2835"></a>
<a name="2836"></a>    /* carry out travel through the door */
<a name="2837"></a>    dobjFor(TravelVia)
<a name="2838"></a>    {
<a name="2839"></a>        action()
<a name="2840"></a>        {
<a name="2841"></a>            /* move the actor to our destination */
<a name="2842"></a>            inherited();
<a name="2843"></a>
<a name="2844"></a>            /* remember that this is the last door the actor traversed */
<a name="2845"></a>            gActor.rememberLastDoor(self);
<a name="2846"></a>        }
<a name="2847"></a>    }
<a name="2848"></a>
<a name="2849"></a>    /*
<a name="2850"></a>     *   Boost the likelihood that a command is referring to us if we just
<a name="2851"></a>     *   traveled through the door; this is meant to be called from
<a name="2852"></a>     *   verify() routines.  For a few commands (close, lock), the most
<a name="2853"></a>     *   likely door being referred to is the door just traversed.  
<a name="2854"></a>     */
<a name="2855"></a>    boostLikelihoodOnTravel()
<a name="2856"></a>    {
<a name="2857"></a>        /* 
<a name="2858"></a>         *   if this (or our other side) is the last door the actor
<a name="2859"></a>         *   traversed, boost the likelihood that they're referring to us 
<a name="2860"></a>         */
<a name="2861"></a>        if (gActor.lastDoorTraversed == self
<a name="2862"></a>            || (otherSide != nil &amp;&amp; gActor.lastDoorTraversed == otherSide))
<a name="2863"></a>            logicalRank(120, 'last door traversed');
<a name="2864"></a>    }
<a name="2865"></a>;
<a name="2866"></a>
<a name="2867"></a>/* ------------------------------------------------------------------------ */
<a name="2868"></a>/*
<a name="2869"></a> *   Door.  This is a travel connector that can be opened and closed with
<a name="2870"></a> *   player commands.  This is a simple subclass of BasicDoor that adds
<a name="2871"></a> *   support for player commands to manipulate the door.  
<a name="2872"></a> */
<a name="2873"></a>class Door: Openable, BasicDoor
<a name="2874"></a>    /* make us initially closed */
<a name="2875"></a>    initiallyOpen = nil
<a name="2876"></a>
<a name="2877"></a>    /* if we can't travel because the door is closed, say so */
<a name="2878"></a>    cannotTravel()
<a name="2879"></a>    {
<a name="2880"></a>        if (gActor.canSee(self) &amp;&amp; !isOpen)
<a name="2881"></a>            reportFailure(&amp;cannotGoThroughClosedDoorMsg, self);
<a name="2882"></a>        else
<a name="2883"></a>            inherited();
<a name="2884"></a>    }
<a name="2885"></a>
<a name="2886"></a>    /* 
<a name="2887"></a>     *   get the 'door open' precondition - by default, we create a
<a name="2888"></a>     *   standard doorOpen precondition for this object, but this can be
<a name="2889"></a>     *   overridden if desired to create custom doorOpen variations 
<a name="2890"></a>     */
<a name="2891"></a>    getDoorOpenPreCond() { return new ObjectPreCondition(self, doorOpen); }
<a name="2892"></a>
<a name="2893"></a>    /* the door must be open before we can travel this way */
<a name="2894"></a>    connectorTravelPreCond()
<a name="2895"></a>    {
<a name="2896"></a>        local ret;
<a name="2897"></a>        local doorCond;
<a name="2898"></a>
<a name="2899"></a>        /* start with the inherited conditions */
<a name="2900"></a>        ret = inherited();
<a name="2901"></a>
<a name="2902"></a>        /* if there's a door-open condition, add it as well */
<a name="2903"></a>        if ((doorCond = getDoorOpenPreCond()) != nil)
<a name="2904"></a>            ret += doorCond;
<a name="2905"></a>
<a name="2906"></a>        /* return the result */
<a name="2907"></a>        return ret;
<a name="2908"></a>    }
<a name="2909"></a>
<a name="2910"></a>    dobjFor(Close)
<a name="2911"></a>    {
<a name="2912"></a>        verify()
<a name="2913"></a>        {
<a name="2914"></a>            /* inherit default handling */
<a name="2915"></a>            inherited();
<a name="2916"></a>
<a name="2917"></a>            /* boost the likelihood if they just traveled through us */
<a name="2918"></a>            boostLikelihoodOnTravel();
<a name="2919"></a>        }
<a name="2920"></a>    }
<a name="2921"></a>
<a name="2922"></a>    dobjFor(Lock)
<a name="2923"></a>    {
<a name="2924"></a>        verify()
<a name="2925"></a>        {
<a name="2926"></a>            /* inherit default handling */
<a name="2927"></a>            inherited();
<a name="2928"></a>
<a name="2929"></a>            /* boost the likelihood if they just traveled through us */
<a name="2930"></a>            boostLikelihoodOnTravel();
<a name="2931"></a>        }
<a name="2932"></a>    }
<a name="2933"></a>
<a name="2934"></a>    /* 
<a name="2935"></a>     *   looking behind a door implies opening it to see what's on the
<a name="2936"></a>     *   other side 
<a name="2937"></a>     */
<a name="2938"></a>    dobjFor(LookBehind)
<a name="2939"></a>    {
<a name="2940"></a>        preCond = (inherited + objOpen)
<a name="2941"></a>        action()
<a name="2942"></a>        {
<a name="2943"></a>            /* 
<a name="2944"></a>             *   If the door is open, AND we implicitly opened the door to
<a name="2945"></a>             *   carry out this action, use a special report that takes
<a name="2946"></a>             *   into account that we were specifically looking to see what
<a name="2947"></a>             *   was on the other side of the door; otherwise, use the
<a name="2948"></a>             *   default behavior 
<a name="2949"></a>             */
<a name="2950"></a>            if (isOpen
<a name="2951"></a>                &amp;&amp; gTranscript.currentActionHasReport(
<a name="2952"></a>                    {x: (x.action_.ofKind(OpenAction)
<a name="2953"></a>                         &amp;&amp; x.isActionImplicit())}))
<a name="2954"></a>                mainReport(&amp;nothingBeyondDoorMsg);
<a name="2955"></a>            else
<a name="2956"></a>                inherited();
<a name="2957"></a>        }
<a name="2958"></a>    }
<a name="2959"></a>
<a name="2960"></a>    /* looking through a door requires it to be open */
<a name="2961"></a>    dobjFor(LookThrough)
<a name="2962"></a>    {
<a name="2963"></a>        preCond = (nilToList(inherited) + objOpen)
<a name="2964"></a>    }
<a name="2965"></a>
<a name="2966"></a>;
<a name="2967"></a>
<a name="2968"></a>/* ------------------------------------------------------------------------ */
<a name="2969"></a>/*
<a name="2970"></a> *   Secret Door.  This is a special kind of door that gives no hint of
<a name="2971"></a> *   its being a door when it's closed.  This can be used for objects that
<a name="2972"></a> *   serve as a secret passage but are otherwise normal objects, such as a
<a name="2973"></a> *   bookcase that conceals a passage.  
<a name="2974"></a> */
<a name="2975"></a>class SecretDoor: BasicDoor
<a name="2976"></a>    /* a secret passage usually starts off secret (i.e., closed) */
<a name="2977"></a>    initiallyOpen = nil
<a name="2978"></a>
<a name="2979"></a>    isConnectorApparent(origin, actor)
<a name="2980"></a>    {
<a name="2981"></a>        /* 
<a name="2982"></a>         *   A secret passage is not apparent as a pasage unless it's
<a name="2983"></a>         *   open. 
<a name="2984"></a>         */
<a name="2985"></a>        if (isOpen)
<a name="2986"></a>        {
<a name="2987"></a>            /* the passage is open - use the inherited handling */
<a name="2988"></a>            return inherited(origin, actor);
<a name="2989"></a>        }
<a name="2990"></a>        else
<a name="2991"></a>        {
<a name="2992"></a>            /* 
<a name="2993"></a>             *   the passage is closed, so it's not apparently a passage
<a name="2994"></a>             *   at all 
<a name="2995"></a>             */
<a name="2996"></a>            return nil;
<a name="2997"></a>        }
<a name="2998"></a>    }
<a name="2999"></a>;
<a name="3000"></a>
<a name="3001"></a>/*
<a name="3002"></a> *   Hidden Door.  This is a secret door that is invisible when closed.
<a name="3003"></a> *   This can be used when the passage isn't even visible when it's
<a name="3004"></a> *   closed, such as a door that seamlessly melds into the wall. 
<a name="3005"></a> */
<a name="3006"></a>class HiddenDoor: SecretDoor
<a name="3007"></a>    /*
<a name="3008"></a>     *   When we're closed, we're completely invisible, so we have no
<a name="3009"></a>     *   sight presence.  When we're open, we have our normal visual
<a name="3010"></a>     *   presence.  
<a name="3011"></a>     */
<a name="3012"></a>    sightPresence = (isOpen)
<a name="3013"></a>;
<a name="3014"></a>
<a name="3015"></a>/* ------------------------------------------------------------------------ */
<a name="3016"></a>/*
<a name="3017"></a> *   Automatically closing door.  This type of door closes behind an actor
<a name="3018"></a> *   as the actor traverses the connector. 
<a name="3019"></a> */
<a name="3020"></a>class AutoClosingDoor: Door
<a name="3021"></a>    dobjFor(TravelVia)
<a name="3022"></a>    {
<a name="3023"></a>        action()
<a name="3024"></a>        {
<a name="3025"></a>            /* inherit the default handling */
<a name="3026"></a>            inherited();
<a name="3027"></a>
<a name="3028"></a>            /* 
<a name="3029"></a>             *   Only close the door if the actor performing the travel
<a name="3030"></a>             *   isn't accompanying another actor.  If the actor is
<a name="3031"></a>             *   accompanying someone, we essentially want them to hold the
<a name="3032"></a>             *   door for the other actor - at the very least, we don't
<a name="3033"></a>             *   want to slam it in the other actor's face! 
<a name="3034"></a>             */
<a name="3035"></a>            if (!gActor.curState.ofKind(AccompanyingInTravelState))
<a name="3036"></a>            {
<a name="3037"></a>                /* close the door */
<a name="3038"></a>                makeOpen(nil);
<a name="3039"></a>
<a name="3040"></a>                /* mention that the automatic closing */
<a name="3041"></a>                reportAutoClose();
<a name="3042"></a>            }
<a name="3043"></a>        }
<a name="3044"></a>    }
<a name="3045"></a>
<a name="3046"></a>    /* 
<a name="3047"></a>     *   Report the automatic closure.  The TravelVia action() calls this
<a name="3048"></a>     *   after closing the door to generate a message mentioning that the
<a name="3049"></a>     *   door was closed.  By default, we just show the standard
<a name="3050"></a>     *   doorClosesBehindMsg library message.  
<a name="3051"></a>     */
<a name="3052"></a>    reportAutoClose() { mainReport(&amp;doorClosesBehindMsg, self); }
<a name="3053"></a>;
<a name="3054"></a>
<a name="3055"></a>/* ------------------------------------------------------------------------ */
<a name="3056"></a>/*
<a name="3057"></a> *   The base class for Enterables and Exitables.  These are physical
<a name="3058"></a> *   objects associated with travel connectors.  For example, the object
<a name="3059"></a> *   representing the exterior of a building in the location containing
<a name="3060"></a> *   the building could be an Enterable, so that typing ENTER BUILDING
<a name="3061"></a> *   takes us into the building via the travel connector that leads inside.
<a name="3062"></a> *   
<a name="3063"></a> *   Enterables and Exitables are physical covers for travel connectors.
<a name="3064"></a> *   These objects aren't travel connectors themselves, and they don't
<a name="3065"></a> *   specify the destination; instead, these just point to travel
<a name="3066"></a> *   connectors.  
<a name="3067"></a> */
<a name="3068"></a>class TravelConnectorLink: object
<a name="3069"></a>    /* the underlying travel connector */
<a name="3070"></a>    connector = nil
<a name="3071"></a>
<a name="3072"></a>    /* 
<a name="3073"></a>     *   The internal "TravelVia" action just maps to travel via the
<a name="3074"></a>     *   underlying connector.  However, we want to apply our own
<a name="3075"></a>     *   preconditions, so we don't directly remap to the underlying
<a name="3076"></a>     *   connector.  Instead, we provide our own full TravelVia
<a name="3077"></a>     *   implementation, and then we perform the travel on the underlying
<a name="3078"></a>     *   connector via a replacement action in our own action() handler.  
<a name="3079"></a>     */
<a name="3080"></a>    dobjFor(TravelVia)
<a name="3081"></a>    {
<a name="3082"></a>        /* the physical link object has to be touchable */
<a name="3083"></a>        preCond = [touchObj]
<a name="3084"></a>        
<a name="3085"></a>        verify() { }
<a name="3086"></a>        action()
<a name="3087"></a>        {
<a name="3088"></a>            /* carry out the action by traveling via our connector */
<a name="3089"></a>            replaceAction(TravelVia, connector);
<a name="3090"></a>        }
<a name="3091"></a>    }
<a name="3092"></a>
<a name="3093"></a>    /*
<a name="3094"></a>     *   These objects are generally things like buildings (exterior or
<a name="3095"></a>     *   interior), which tend to be large enough that their details can be
<a name="3096"></a>     *   seen at a distance.  
<a name="3097"></a>     */
<a name="3098"></a>    sightSize = large
<a name="3099"></a>;
<a name="3100"></a>
<a name="3101"></a>/*
<a name="3102"></a> *   An Enterable is an object that exists in one location, and which can
<a name="3103"></a> *   be entered to take an actor to another location.  Enterables are used
<a name="3104"></a> *   for things such as the outsides of buildings, so that the building
<a name="3105"></a> *   can have a presence on its outside and can be entered via a command
<a name="3106"></a> *   like "go into building".
<a name="3107"></a> *   
<a name="3108"></a> *   An Enterable isn't a connector, but points to a connector.  This type
<a name="3109"></a> *   of object is most useful when there's already a connector that exists
<a name="3110"></a> *   as a separate object, such as the door to a house: the house object
<a name="3111"></a> *   can be made an Enterable that simply points to the door object.  
<a name="3112"></a> */
<a name="3113"></a>class Enterable: TravelConnectorLink, Fixture
<a name="3114"></a>    /*
<a name="3115"></a>     *   "Enter" action this simply causes the actor to travel via the
<a name="3116"></a>     *   connector.  
<a name="3117"></a>     */
<a name="3118"></a>    dobjFor(Enter) remapTo(TravelVia, self)
<a name="3119"></a>
<a name="3120"></a>    /* explicitly define the push-travel indirect object mapping */
<a name="3121"></a>    mapPushTravelIobj(PushTravelEnter, TravelVia)
<a name="3122"></a>;
<a name="3123"></a>
<a name="3124"></a>/*
<a name="3125"></a> *   An Exitable is like an Enterable, except that you exit it rather than
<a name="3126"></a> *   enter it.  This can be used for objects representing the current
<a name="3127"></a> *   location as an enclosure (a jail cell), or an exit door. 
<a name="3128"></a> */
<a name="3129"></a>class Exitable: TravelConnectorLink, Fixture
<a name="3130"></a>    /* 
<a name="3131"></a>     *   "Exit" action - this simply maps to travel via the connector.  
<a name="3132"></a>     */
<a name="3133"></a>    dobjFor(GetOutOf) remapTo(TravelVia, self)
<a name="3134"></a>
<a name="3135"></a>    /* explicitly define the push-travel indirect object mapping */
<a name="3136"></a>    mapPushTravelIobj(PushTravelExit, TravelVia)
<a name="3137"></a>;
<a name="3138"></a>
<a name="3139"></a>/*
<a name="3140"></a> *   An EntryPortal is just like an Enterable, except that "go through"
<a name="3141"></a> *   also works on it.  Likewise, an ExitPortal is just like an Exitable
<a name="3142"></a> *   but accepts "go through" as well.  
<a name="3143"></a> */
<a name="3144"></a>class EntryPortal: Enterable
<a name="3145"></a>    dobjFor(GoThrough) remapTo(TravelVia, self)
<a name="3146"></a>;
<a name="3147"></a>class ExitPortal: Exitable
<a name="3148"></a>    dobjFor(GoThrough) remapTo(TravelVia, self)
<a name="3149"></a>;
<a name="3150"></a>
<a name="3151"></a>/* ------------------------------------------------------------------------ */
<a name="3152"></a>/*
<a name="3153"></a> *   A "TravelPushable" is an object that can't be taken, but can be moved
<a name="3154"></a> *   from one location to another via commands of the form "push obj dir,"
<a name="3155"></a> *   "push obj through passage," and the like.
<a name="3156"></a> *   
<a name="3157"></a> *   TravelPushables tend to be rather rare, and we expect that instances
<a name="3158"></a> *   will almost always be special cases that require additional
<a name="3159"></a> *   specialized code.  This is therefore only a general framework for
<a name="3160"></a> *   pushability.  
<a name="3161"></a> */
<a name="3162"></a>class TravelPushable: Immovable
<a name="3163"></a>    cannotTakeMsg = &amp;cannotTakePushableMsg
<a name="3164"></a>    cannotMoveMsg = &amp;cannotMovePushableMsg
<a name="3165"></a>    cannotPutMsg = &amp;cannotPutPushableMsg
<a name="3166"></a>
<a name="3167"></a>    /* can we be pushed via the given travel connector? */
<a name="3168"></a>    canPushTravelVia(connector, dest) { return true; }
<a name="3169"></a>
<a name="3170"></a>    /* explain why canPushTravelVia said we can't be pushed this way */
<a name="3171"></a>    explainNoPushTravelVia(connector, dest) { }
<a name="3172"></a>
<a name="3173"></a>    /*
<a name="3174"></a>     *   Receive notification that we're about to be pushed somewhere.
<a name="3175"></a>     *   This is called just before the underlying traveler performs the
<a name="3176"></a>     *   actual travel.  (By default, we don't even define this method, to
<a name="3177"></a>     *   ensure that if we're combined with another base class that
<a name="3178"></a>     *   overrides the method, the overrider will be called.)  
<a name="3179"></a>     */
<a name="3180"></a>    // beforeMovePushable(traveler, connector, dest) { }
<a name="3181"></a>
<a name="3182"></a>    /*
<a name="3183"></a>     *   Move the object to a new location as part of a push-travel
<a name="3184"></a>     *   operation.  By default, this simply uses moveInto to move the
<a name="3185"></a>     *   object, but subclasses can override this to apply conditions to
<a name="3186"></a>     *   the pushing, put the object somewhere else in some cases, display
<a name="3187"></a>     *   extra messages, or do anything else that's necessary.
<a name="3188"></a>     *   
<a name="3189"></a>     *   Our special PushTraveler calls this routine after the underlying
<a name="3190"></a>     *   real traveler has finished its travel to the new location, so the
<a name="3191"></a>     *   traveler's location will indicate the destination of the travel.
<a name="3192"></a>     *   Note that this routine is never called if the traveler ends up in
<a name="3193"></a>     *   its original location after the travel, so this routine isn't
<a name="3194"></a>     *   called when travel isn't allowed for the underlying traveler.  
<a name="3195"></a>     */
<a name="3196"></a>    movePushable(traveler, connector)
<a name="3197"></a>    {
<a name="3198"></a>        /* move me to the traveler's new location */
<a name="3199"></a>        moveIntoForTravel(traveler.location);
<a name="3200"></a>
<a name="3201"></a>        /* describe what we're doing */
<a name="3202"></a>        describeMovePushable(traveler, connector);
<a name="3203"></a>    }
<a name="3204"></a>
<a name="3205"></a>    /*
<a name="3206"></a>     *   Describe the actor pushing the object into the new location.
<a name="3207"></a>     *   This is called from movePushable; we pull this out as a separate
<a name="3208"></a>     *   routine so that the description of the pushing can be overridden
<a name="3209"></a>     *   without having to override all of movePushable.  
<a name="3210"></a>     */
<a name="3211"></a>    describeMovePushable(traveler, connector)
<a name="3212"></a>    {
<a name="3213"></a>        /* 
<a name="3214"></a>         *   If the actor is the player character, mention that we're
<a name="3215"></a>         *   pushing the object with us.  For an NPC, show nothing,
<a name="3216"></a>         *   because the normal travel message will mention that the NPC
<a name="3217"></a>         *   is pushing the object as part of the normal travel report
<a name="3218"></a>         *   (thanks to PushTraveler's name override). 
<a name="3219"></a>         */
<a name="3220"></a>        if (gActor.isPlayerChar)
<a name="3221"></a>            mainReport(&amp;okayPushTravelMsg, self);
<a name="3222"></a>    }
<a name="3223"></a>
<a name="3224"></a>    dobjFor(PushTravel)
<a name="3225"></a>    {
<a name="3226"></a>        verify() { }
<a name="3227"></a>        action()
<a name="3228"></a>        {
<a name="3229"></a>            local newTrav;
<a name="3230"></a>            local oldTrav;
<a name="3231"></a>            local wasExcluded;
<a name="3232"></a>            
<a name="3233"></a>            /*
<a name="3234"></a>             *   Create a push traveler to coordinate the travel.  The
<a name="3235"></a>             *   push traveler performs the normal travel, and also moves
<a name="3236"></a>             *   the object being pushed.  
<a name="3237"></a>             */
<a name="3238"></a>            newTrav = pushTravelerClass.createInstance(
<a name="3239"></a>                self, gActor.getPushTraveler(self));
<a name="3240"></a>            
<a name="3241"></a>            /* set the actor's special traveler to our push traveler */
<a name="3242"></a>            oldTrav = gActor.setSpecialTraveler(newTrav);
<a name="3243"></a>
<a name="3244"></a>            /* 
<a name="3245"></a>             *   Add myself to the actor's look-around exclusion list -
<a name="3246"></a>             *   this ensures that we won't be listed among the objects in
<a name="3247"></a>             *   the new location when we show the description on arrival.
<a name="3248"></a>             *   This is desirable because of how we describe the travel:
<a name="3249"></a>             *   we first want to show the new location's description, then
<a name="3250"></a>             *   describe pushing this object into the new location.  But
<a name="3251"></a>             *   we actually have to move the object first, to make sure
<a name="3252"></a>             *   any side effects of its presence in the new location are
<a name="3253"></a>             *   taken into account when we describe the location - because
<a name="3254"></a>             *   by the time we're in the room enough to have a look
<a name="3255"></a>             *   around, the pushable will be in the room with us.  Even
<a name="3256"></a>             *   so, we don't actually want to describe the pushable as in
<a name="3257"></a>             *   the room at this stage, because from the player's
<a name="3258"></a>             *   perspective we're really still in the process of pushing
<a name="3259"></a>             *   it; describing it as already settled into the new location
<a name="3260"></a>             *   sounds weird because it makes it seem like the object was
<a name="3261"></a>             *   already in place when we arrived.  To avoid this
<a name="3262"></a>             *   weirdness, suppress it from the new location's initial
<a name="3263"></a>             *   description on arrival.  
<a name="3264"></a>             */
<a name="3265"></a>            wasExcluded = gActor.excludeFromLookAround(self);
<a name="3266"></a>
<a name="3267"></a>            /* make sure we undo our global changes when we're done */
<a name="3268"></a>            try
<a name="3269"></a>            {
<a name="3270"></a>                /* 
<a name="3271"></a>                 *   Now that we've activated our special push traveler
<a name="3272"></a>                 *   for the actor, simply perform the ordinary travel
<a name="3273"></a>                 *   command.  The travel command we perform depends on
<a name="3274"></a>                 *   the kind of push-travel command we attempted, so
<a name="3275"></a>                 *   simply let the current action carry out the action.
<a name="3276"></a>                 */
<a name="3277"></a>                gAction.performTravel();
<a name="3278"></a>            }
<a name="3279"></a>            finally
<a name="3280"></a>            {
<a name="3281"></a>                /* restore the actor's old special traveler on the way out */
<a name="3282"></a>                gActor.setSpecialTraveler(oldTrav);
<a name="3283"></a>
<a name="3284"></a>                /* 
<a name="3285"></a>                 *   if we weren't in the actor's 'look around' exclusion
<a name="3286"></a>                 *   list before, remove us from the list
<a name="3287"></a>                 */
<a name="3288"></a>                if (!wasExcluded)
<a name="3289"></a>                    gActor.unexcludeFromLookAround(self);
<a name="3290"></a>            }
<a name="3291"></a>        }
<a name="3292"></a>    }
<a name="3293"></a>
<a name="3294"></a>    /* 
<a name="3295"></a>     *   The class we create for our special push traveler - by default,
<a name="3296"></a>     *   this is PushTraveler, but we parameterize this via this property
<a name="3297"></a>     *   to allow special PushTraveler subclasses to be created; this
<a name="3298"></a>     *   could be useful, for example, to customize the traveler name
<a name="3299"></a>     *   messages. 
<a name="3300"></a>     */
<a name="3301"></a>    pushTravelerClass = PushTraveler
<a name="3302"></a>;
<a name="3303"></a>
<a name="3304"></a>/*
<a name="3305"></a> *   A special Traveler class for travel involving pushing an object from
<a name="3306"></a> *   one room to another.  This class encapsulates the object being pushed
<a name="3307"></a> *   and the actual Traveler performing the travel.
<a name="3308"></a> *   
<a name="3309"></a> *   For the most part, we refer Traveler methods to the underlying
<a name="3310"></a> *   Traveler.  We override a few methods to provide special handling.  
<a name="3311"></a> */
<a name="3312"></a>class PushTraveler: object
<a name="3313"></a>    construct(obj, traveler)
<a name="3314"></a>    {
<a name="3315"></a>        /* remember the object being pushed and the real traveler */
<a name="3316"></a>        obj_ = obj;
<a name="3317"></a>        traveler_ = traveler;
<a name="3318"></a>    }
<a name="3319"></a>
<a name="3320"></a>    /* the object being pushed */
<a name="3321"></a>    obj_ = nil
<a name="3322"></a>
<a name="3323"></a>    /* 
<a name="3324"></a>     *   the underlying Traveler - this is the real Traveler that will
<a name="3325"></a>     *   move to a new location 
<a name="3326"></a>     */
<a name="3327"></a>    traveler_ = nil
<a name="3328"></a>
<a name="3329"></a>    /*
<a name="3330"></a>     *   Travel to a new location.  We'll run the normal travel routine
<a name="3331"></a>     *   for the underlying real traveler; then, if we ended up in a new
<a name="3332"></a>     *   location, we'll move the object being pushed to the traveler's
<a name="3333"></a>     *   new location.  
<a name="3334"></a>     */
<a name="3335"></a>    travelerTravelTo(dest, connector, backConnector)
<a name="3336"></a>    {
<a name="3337"></a>        local oldLoc;
<a name="3338"></a>        local origin;
<a name="3339"></a>        
<a name="3340"></a>        /* remember the traveler's origin, so we can tell if we moved */
<a name="3341"></a>        origin = traveler_.location;
<a name="3342"></a>
<a name="3343"></a>        /* let the object being pushed describe the departure */
<a name="3344"></a>        obj_.beforeMovePushable(traveler_, connector, dest);
<a name="3345"></a>
<a name="3346"></a>        /* 
<a name="3347"></a>         *   *Tentatively* move the pushable to its new location.  Just do
<a name="3348"></a>         *   the basic move-into for this, since it's only tentative - this
<a name="3349"></a>         *   is just so that we get any side effects of its presence in the
<a name="3350"></a>         *   new location for the purposes of describing the new location.
<a name="3351"></a>         */
<a name="3352"></a>        oldLoc = location;
<a name="3353"></a>        obj_.baseMoveInto(dest);
<a name="3354"></a>
<a name="3355"></a>        /* 
<a name="3356"></a>         *   Call the traveler's normal travel routine, to perform the
<a name="3357"></a>         *   actual movement of the underlying traveler.  
<a name="3358"></a>         */
<a name="3359"></a>        traveler_.travelerTravelTo(dest, connector, backConnector);
<a name="3360"></a>
<a name="3361"></a>        /* undo the tentative move of the pushable */
<a name="3362"></a>        obj_.baseMoveInto(oldLoc);
<a name="3363"></a>
<a name="3364"></a>        /* 
<a name="3365"></a>         *   If we moved to a new location, we can now actually move the
<a name="3366"></a>         *   pushable object to the new location.  
<a name="3367"></a>         */
<a name="3368"></a>        if (traveler_.location != origin)
<a name="3369"></a>            obj_.movePushable(traveler_, connector);
<a name="3370"></a>    }
<a name="3371"></a>
<a name="3372"></a>    /*
<a name="3373"></a>     *   Perform local travel, between nested rooms within a top-level
<a name="3374"></a>     *   location.  By default, we simply don't allow pushing objects
<a name="3375"></a>     *   between nested rooms.
<a name="3376"></a>     *   
<a name="3377"></a>     *   To allow pushing an object between nested rooms, override this in
<a name="3378"></a>     *   parallel with travelerTravelTo().  Note that you'll have to call
<a name="3379"></a>     *   travelerTravelWithin() on the underlying traveler (which will
<a name="3380"></a>     *   generally be the actor), and you'll probably want to set up a new
<a name="3381"></a>     *   set of notifiers parallel to beforeMovePushable() and
<a name="3382"></a>     *   movePushable().  You'll probably particularly need to customize
<a name="3383"></a>     *   the report in your parallel for movePushable() - the default ("you
<a name="3384"></a>     *   push x into the area") isn't very good when nested rooms are
<a name="3385"></a>     *   involved, and you'll probably want something more specific.  
<a name="3386"></a>     */
<a name="3387"></a>    travelerTravelWithin(actor, dest)
<a name="3388"></a>    {
<a name="3389"></a>        reportFailure(&amp;cannotPushObjectNestedMsg, obj_);
<a name="3390"></a>        exit;
<a name="3391"></a>    }
<a name="3392"></a>
<a name="3393"></a>    /*
<a name="3394"></a>     *   Can we travel via the given connector?  We'll ask our underlying
<a name="3395"></a>     *   traveler first, and if that succeeds, we'll ask the object we're
<a name="3396"></a>     *   pushing. 
<a name="3397"></a>     */
<a name="3398"></a>    canTravelVia(connector, dest)
<a name="3399"></a>    {
<a name="3400"></a>        /* ask the underlying traveler first, then our pushed object */
<a name="3401"></a>        return (traveler_.canTravelVia(connector, dest)
<a name="3402"></a>                &amp;&amp; obj_.canPushTravelVia(connector, dest));
<a name="3403"></a>    }
<a name="3404"></a>
<a name="3405"></a>    /*
<a name="3406"></a>     *   Explain why the given travel is not possible.  If our underlying
<a name="3407"></a>     *   traveler raised the objection, let it explain; otherwise, let our
<a name="3408"></a>     *   pushed object explain. 
<a name="3409"></a>     */
<a name="3410"></a>    explainNoTravelVia(connector, dest)
<a name="3411"></a>    {
<a name="3412"></a>        if (!traveler_.canTravelVia(connector, dest))
<a name="3413"></a>            traveler_.explainNoTravelVia(connector, dest);
<a name="3414"></a>        else
<a name="3415"></a>            obj_.explainNoPushTravelVia(connector, dest);
<a name="3416"></a>    }
<a name="3417"></a>
<a name="3418"></a>    /* by default, send everything to the underlying Traveler */
<a name="3419"></a>    propNotDefined(prop, [args]) { return traveler_.(prop)(args...); }
<a name="3420"></a>;
<a name="3421"></a>
<a name="3422"></a>/*
<a name="3423"></a> *   A PushTravelBarrier is a TravelConnector that allows regular travel,
<a name="3424"></a> *   but not travel that involves pushing something.  By default, we block
<a name="3425"></a> *   all push travel, but subclasses can customize this so that we block
<a name="3426"></a> *   only specific objects.  
<a name="3427"></a> */
<a name="3428"></a>class PushTravelBarrier: TravelBarrier
<a name="3429"></a>    /*
<a name="3430"></a>     *   Determine if the given pushed object is allowed to pass.  Returns
<a name="3431"></a>     *   true if so, nil if not.  By default, we'll return nil for every
<a name="3432"></a>     *   object; subclasses can override this to allow some objects to be
<a name="3433"></a>     *   pushed through the barrier but not others. 
<a name="3434"></a>     */
<a name="3435"></a>    canPushedObjectPass(obj) { return nil; }
<a name="3436"></a>
<a name="3437"></a>    /* explain why an object can't pass */
<a name="3438"></a>    explainTravelBarrier(traveler)
<a name="3439"></a>    {
<a name="3440"></a>        reportFailure(&amp;cannotPushObjectThatWayMsg, traveler.obj_);
<a name="3441"></a>    }
<a name="3442"></a>
<a name="3443"></a>    /*
<a name="3444"></a>     *   Determine if the given traveler can pass through this connector.
<a name="3445"></a>     *   If the traveler isn't a push traveler, we'll allow the travel;
<a name="3446"></a>     *   otherwise, we'll block the travel if our canPushedObjectPass
<a name="3447"></a>     *   routine says the object being pushed can pass. 
<a name="3448"></a>     */
<a name="3449"></a>    canTravelerPass(traveler)
<a name="3450"></a>    {
<a name="3451"></a>        /* if it's not a push traveler, it can pass */
<a name="3452"></a>        if (!traveler.ofKind(PushTraveler))
<a name="3453"></a>            return true;
<a name="3454"></a>
<a name="3455"></a>        /* it can pass if we can pass the object being pushed */
<a name="3456"></a>        return canPushedObjectPass(traveler.obj_);
<a name="3457"></a>    }
<a name="3458"></a>;
<a name="3459"></a>
<a name="3460"></a>
<a name="3461"></a>/* ------------------------------------------------------------------------ */
<a name="3462"></a>/*
<a name="3463"></a> *   A basic location - this is the base class for locations that can
<a name="3464"></a> *   contain actors.
<a name="3465"></a> */
<a name="3466"></a>class BasicLocation: Thing
<a name="3467"></a>    /*
<a name="3468"></a>     *   Get the nested room list grouper for an actor in the given
<a name="3469"></a>     *   posture directly in this room.  This is used when we're listing
<a name="3470"></a>     *   the actors within the nested room as 
<a name="3471"></a>     *   
<a name="3472"></a>     *   By default, we maintain a lookup table, and store one nested
<a name="3473"></a>     *   actor grouper object for each posture.  This makes it so that we
<a name="3474"></a>     *   show one group per posture in this room; for example, if we
<a name="3475"></a>     *   contain two sitting actors and three standing actors, we'll say
<a name="3476"></a>     *   something like "bill and bob are sitting on the stage, and jill,
<a name="3477"></a>     *   jane, and jack are standing on the stage."  This can be
<a name="3478"></a>     *   overridden if a different arrangement of groups is desired; for
<a name="3479"></a>     *   example, an override could simply return a single grouper to list
<a name="3480"></a>     *   everyone in the room together, regardless of posture.  
<a name="3481"></a>     */
<a name="3482"></a>    listWithActorIn(posture)
<a name="3483"></a>    {
<a name="3484"></a>        /* if we don't have a lookup table for this yet, create one */
<a name="3485"></a>        if (listWithActorInTable == nil)
<a name="3486"></a>            listWithActorInTable = new LookupTable(5, 5);
<a name="3487"></a>
<a name="3488"></a>        /* if this posture isn't in the table yet, create a grouper for it */
<a name="3489"></a>        if (listWithActorInTable[posture] == nil)
<a name="3490"></a>            listWithActorInTable[posture] =
<a name="3491"></a>                new RoomActorGrouper(self, posture);
<a name="3492"></a>
<a name="3493"></a>        /* return the grouper for this posture */
<a name="3494"></a>        return listWithActorInTable[posture];
<a name="3495"></a>    }
<a name="3496"></a>
<a name="3497"></a>    /* 
<a name="3498"></a>     *   our listWithActorIn table - this gets initialized to a
<a name="3499"></a>     *   LookupTable as soon as we need one (in listWithActorIn) 
<a name="3500"></a>     */
<a name="3501"></a>    listWithActorInTable = nil
<a name="3502"></a>
<a name="3503"></a>    /*
<a name="3504"></a>     *   Check the ambient illumination level in the room for the given
<a name="3505"></a>     *   actor's senses to determine if the actor would be able to see if
<a name="3506"></a>     *   the actor were in this room without any additional light sources.
<a name="3507"></a>     *   Returns true if the room is lit for the purposes of the actor's
<a name="3508"></a>     *   visual senses, nil if not.
<a name="3509"></a>     *   
<a name="3510"></a>     *   Note that if the actor is already in this location, there's no
<a name="3511"></a>     *   need to run this test, since we could get the information from
<a name="3512"></a>     *   the actor directly.  The point of this test is to determine the
<a name="3513"></a>     *   light level in this location without the actor having to be
<a name="3514"></a>     *   present.  
<a name="3515"></a>     */
<a name="3516"></a>    wouldBeLitFor(actor)
<a name="3517"></a>    {
<a name="3518"></a>        /*
<a name="3519"></a>         *   Check for a simple, common case before running the more
<a name="3520"></a>         *   expensive full what-if test.  Most rooms provide their own
<a name="3521"></a>         *   illumination in the actor's 'sight' sense; if this room does
<a name="3522"></a>         *   provide its own interior 'brightness' of at least 2, and the
<a name="3523"></a>         *   actor has 'sight' among its visual senses, then the room is
<a name="3524"></a>         *   lit.  Note that we must use transSensingOut() to determine
<a name="3525"></a>         *   how we transmit our own brightness to our interior, since
<a name="3526"></a>         *   that gives the transparency for looking from within this room
<a name="3527"></a>         *   at objects outside the room; our own intrinsic brightness is
<a name="3528"></a>         *   defined as the brightness of our exterior surface.  
<a name="3529"></a>         */
<a name="3530"></a>        if (actor.sightlikeSenses.indexOf(sight) != nil
<a name="3531"></a>            &amp;&amp; brightness &gt; 1
<a name="3532"></a>            &amp;&amp; transSensingOut(sight) == transparent)
<a name="3533"></a>            return true;
<a name="3534"></a>
<a name="3535"></a>        /*
<a name="3536"></a>         *   We can't determine for sure that the location is lit with a
<a name="3537"></a>         *   simple test, so run a full what-if test, checking what
<a name="3538"></a>         *   ambient light level our "probe" object would see if it were
<a name="3539"></a>         *   moved to this location.  Return true if the ambient light
<a name="3540"></a>         *   level is higher than the "self-lit" value of 1, nil if not.  
<a name="3541"></a>         */
<a name="3542"></a>        return (lightProbe.whatIf(
<a name="3543"></a>            {: senseAmbientMax(actor.sightlikeSenses) },
<a name="3544"></a>            &amp;moveInto, self) &gt; 1);
<a name="3545"></a>    }
<a name="3546"></a>
<a name="3547"></a>    /*
<a name="3548"></a>     *   Show our room description: this is the interior description of
<a name="3549"></a>     *   the room, for use when the room is viewed by an actor within the
<a name="3550"></a>     *   room.  By default, we show our ordinary 'desc'.  
<a name="3551"></a>     */
<a name="3552"></a>    roomDesc { desc; }
<a name="3553"></a>
<a name="3554"></a>    /* as part of a room description, mention an actor in this room */
<a name="3555"></a>    roomActorHereDesc(actor) { gLibMessages.actorInRoom(actor, self); }
<a name="3556"></a>
<a name="3557"></a>    /*
<a name="3558"></a>     *   Provide a default description for an actor in this location, as
<a name="3559"></a>     *   seen from a remote location (i.e., from a separate top-level room
<a name="3560"></a>     *   that's linked to our top-level room by a sense connector of some
<a name="3561"></a>     *   kind).  By default, we'll describe the actor as being in this
<a name="3562"></a>     *   nested room.  
<a name="3563"></a>     */
<a name="3564"></a>    roomActorThereDesc(actor)
<a name="3565"></a>    {
<a name="3566"></a>        local pov = getPOV();
<a name="3567"></a>        local outer;
<a name="3568"></a>        
<a name="3569"></a>        /* get the outermost visible enclosing room */
<a name="3570"></a>        outer = getOutermostVisibleRoom(pov);
<a name="3571"></a>
<a name="3572"></a>        /* 
<a name="3573"></a>         *   If we found a room, and it's not us (i.e., we found something
<a name="3574"></a>         *   outside this room that can be seen from the current point of
<a name="3575"></a>         *   view), use the three-part description: actor in nested room
<a name="3576"></a>         *   (self) in outer room.  If we didn't find a room, or it's the
<a name="3577"></a>         *   same as us, all we can say is that the actor is in the nested
<a name="3578"></a>         *   room. 
<a name="3579"></a>         */
<a name="3580"></a>        if (outer not in (nil, self))
<a name="3581"></a>        {
<a name="3582"></a>            /* use the three-part description: actor in self in outer */
<a name="3583"></a>            gLibMessages.actorInRemoteNestedRoom(actor, self, outer, pov);
<a name="3584"></a>        }
<a name="3585"></a>        else
<a name="3586"></a>        {
<a name="3587"></a>            /* we're as far out as we can see: just say actor is in self */
<a name="3588"></a>            gLibMessages.actorInRemoteRoom(actor, self, pov);
<a name="3589"></a>        }
<a name="3590"></a>    }
<a name="3591"></a>
<a name="3592"></a>    /* show the status addendum for an actor in this location */
<a name="3593"></a>    roomActorStatus(actor) { gLibMessages.actorInRoomStatus(actor, self); }
<a name="3594"></a>
<a name="3595"></a>    /* describe the actor's posture while in this location */
<a name="3596"></a>    roomActorPostureDesc(actor)
<a name="3597"></a>        { gLibMessages.actorInRoomPosture(actor, self); }
<a name="3598"></a>
<a name="3599"></a>    /* acknowledge a posture change while in this location */
<a name="3600"></a>    roomOkayPostureChange(actor)
<a name="3601"></a>        { defaultReport(&amp;roomOkayPostureChangeMsg, actor.posture, self); }
<a name="3602"></a>
<a name="3603"></a>    /* 
<a name="3604"></a>     *   describe the actor's posture as part of the EXAMINE description of
<a name="3605"></a>     *   the nested room 
<a name="3606"></a>     */
<a name="3607"></a>    roomListActorPosture(actor)
<a name="3608"></a>        { gLibMessages.actorInRoom(actor, self); }
<a name="3609"></a>    
<a name="3610"></a>    /*
<a name="3611"></a>     *   Prefix and suffix messages for listing a group of actors
<a name="3612"></a>     *   nominally in this location.  'posture' is the posture of the
<a name="3613"></a>     *   actors.  'remote' is the outermost visible room containing the
<a name="3614"></a>     *   actors, but only if that room is remote from the point-of-view
<a name="3615"></a>     *   actor; if everything is local, this will be nil.  'lst' is the
<a name="3616"></a>     *   list of actors being listed.  By default, we'll just show the
<a name="3617"></a>     *   standard library messages.  
<a name="3618"></a>     */
<a name="3619"></a>    actorInGroupPrefix(pov, posture, remote, lst)
<a name="3620"></a>    {
<a name="3621"></a>        if (remote == nil)
<a name="3622"></a>            gLibMessages.actorInGroupPrefix(posture, self, lst);
<a name="3623"></a>        else
<a name="3624"></a>            gLibMessages.actorInRemoteGroupPrefix(
<a name="3625"></a>                pov, posture, self, remote, lst);
<a name="3626"></a>    }
<a name="3627"></a>    actorInGroupSuffix(pov, posture, remote, lst)
<a name="3628"></a>    {
<a name="3629"></a>        if (remote == nil)
<a name="3630"></a>            gLibMessages.actorInGroupSuffix(posture, self, lst);
<a name="3631"></a>        else
<a name="3632"></a>            gLibMessages.actorInRemoteGroupSuffix(
<a name="3633"></a>                pov, posture, self, remote, lst);
<a name="3634"></a>    }
<a name="3635"></a>
<a name="3636"></a>    /*
<a name="3637"></a>     *   Show a list of exits from this room as part of failed travel
<a name="3638"></a>     *   ("you can't go that way"). 
<a name="3639"></a>     */
<a name="3640"></a>    cannotGoShowExits(actor)
<a name="3641"></a>    {
<a name="3642"></a>        /* if we have an exit lister, ask it to show exits */
<a name="3643"></a>        if (gExitLister != nil)
<a name="3644"></a>            gExitLister.cannotGoShowExits(actor, self);
<a name="3645"></a>    }
<a name="3646"></a>
<a name="3647"></a>    /* show the exit list in the status line */
<a name="3648"></a>    showStatuslineExits()
<a name="3649"></a>    {
<a name="3650"></a>        /* if we have a global exit lister, ask it to show the exits */
<a name="3651"></a>        if (gExitLister != nil)
<a name="3652"></a>            gExitLister.showStatuslineExits();
<a name="3653"></a>    }
<a name="3654"></a>
<a name="3655"></a>    /* 
<a name="3656"></a>     *   Get the estimated height, in lines of text, of the exits display's
<a name="3657"></a>     *   contribution to the status line.  This is used to calculate the
<a name="3658"></a>     *   extra height we need in the status line, if any, to display the
<a name="3659"></a>     *   exit list.  If we're not configured to display exits in the status
<a name="3660"></a>     *   line, this should return zero. 
<a name="3661"></a>     */
<a name="3662"></a>    getStatuslineExitsHeight()
<a name="3663"></a>    {
<a name="3664"></a>        if (gExitLister != nil)
<a name="3665"></a>            return gExitLister.getStatuslineExitsHeight();
<a name="3666"></a>        else
<a name="3667"></a>            return 0;
<a name="3668"></a>    }
<a name="3669"></a>
<a name="3670"></a>    /*
<a name="3671"></a>     *   Make the actor stand up from this location.  By default, we'll
<a name="3672"></a>     *   simply change the actor's posture to "standing," and show a
<a name="3673"></a>     *   default success report.
<a name="3674"></a>     *   
<a name="3675"></a>     *   Subclasses might need to override this.  For example, a chair
<a name="3676"></a>     *   will set the actor's location to the room containing the chair
<a name="3677"></a>     *   when the actor stands up from the chair.  
<a name="3678"></a>     */
<a name="3679"></a>    makeStandingUp()
<a name="3680"></a>    {
<a name="3681"></a>        /* simply set the actor's new posture */
<a name="3682"></a>        gActor.makePosture(standing);
<a name="3683"></a>
<a name="3684"></a>        /* issue a default report of the change */
<a name="3685"></a>        defaultReport(&amp;okayPostureChangeMsg, standing);
<a name="3686"></a>    }
<a name="3687"></a>
<a name="3688"></a>    /* 
<a name="3689"></a>     *   Default posture for an actor in the location.  This is the
<a name="3690"></a>     *   posture assumed by an actor when moving out of a nested room
<a name="3691"></a>     *   within this location. 
<a name="3692"></a>     */
<a name="3693"></a>    defaultPosture = standing
<a name="3694"></a>
<a name="3695"></a>    /* failure report we issue when we can't return to default posture */
<a name="3696"></a>    mustDefaultPostureProp = &amp;mustBeStandingMsg
<a name="3697"></a>
<a name="3698"></a>    /* run the appropriate implied command to achieve our default posture */
<a name="3699"></a>    tryMakingDefaultPosture()
<a name="3700"></a>    {
<a name="3701"></a>        return defaultPosture.tryMakingPosture(self);
<a name="3702"></a>    }
<a name="3703"></a>
<a name="3704"></a>    /*
<a name="3705"></a>     *   Check this object as a staging location.  We're a valid location,
<a name="3706"></a>     *   so we allow this. 
<a name="3707"></a>     */
<a name="3708"></a>    checkStagingLocation(dest)
<a name="3709"></a>    {
<a name="3710"></a>        /* we've valid, so we don't need to do anything */
<a name="3711"></a>    }
<a name="3712"></a>
<a name="3713"></a>    /*
<a name="3714"></a>     *   Try moving the actor into this location.
<a name="3715"></a>     */
<a name="3716"></a>    checkMovingActorInto(allowImplicit)
<a name="3717"></a>    {
<a name="3718"></a>        /* 
<a name="3719"></a>         *   If the actor isn't somewhere within us, we can't move the
<a name="3720"></a>         *   actor here implicitly - we have no generic way of causing
<a name="3721"></a>         *   implicit travel between top-level locations.  Note that some
<a name="3722"></a>         *   rooms might want to override this when travel between
<a name="3723"></a>         *   adjacent locations makes sense as an implicit action; we
<a name="3724"></a>         *   expect that such cases will be rare, so we don't attempt to
<a name="3725"></a>         *   generalize this possibility.  
<a name="3726"></a>         */
<a name="3727"></a>        if (!gActor.isIn(self))
<a name="3728"></a>        {
<a name="3729"></a>            reportFailure(&amp;cannotDoFromHereMsg);
<a name="3730"></a>            exit;
<a name="3731"></a>        }
<a name="3732"></a>
<a name="3733"></a>        /*
<a name="3734"></a>         *   if the actor is already directly in me, simply check to make
<a name="3735"></a>         *   sure the actor is in the default posture for the room - if
<a name="3736"></a>         *   not, try running an appropriate implied command to change the
<a name="3737"></a>         *   posture 
<a name="3738"></a>         */
<a name="3739"></a>        if (gActor.isDirectlyIn(self))
<a name="3740"></a>        {
<a name="3741"></a>            /* if the actor's already in the default posture, we're okay */
<a name="3742"></a>            if (gActor.posture == defaultPosture)
<a name="3743"></a>                return nil;
<a name="3744"></a>            
<a name="3745"></a>            /* run the implied command to stand up (or whatever) */
<a name="3746"></a>            if (allowImplicit &amp;&amp; tryMakingDefaultPosture())
<a name="3747"></a>            {
<a name="3748"></a>                /* make sure we're in the proper posture now */
<a name="3749"></a>                if (gActor.posture != defaultPosture)
<a name="3750"></a>                    exit;
<a name="3751"></a>                
<a name="3752"></a>                /* note that we ran an implied command */
<a name="3753"></a>                return true;
<a name="3754"></a>            }
<a name="3755"></a>            
<a name="3756"></a>            /* we couldn't get into the default posture - give up */
<a name="3757"></a>            reportFailure(mustDefaultPostureProp);
<a name="3758"></a>            exit;
<a name="3759"></a>        }
<a name="3760"></a>
<a name="3761"></a>        /*
<a name="3762"></a>         *   The actor is within a nested room within me.  Find our
<a name="3763"></a>         *   immediate child containing the actor, and remove the actor
<a name="3764"></a>         *   from the child. 
<a name="3765"></a>         */
<a name="3766"></a>        foreach (local cur in contents)
<a name="3767"></a>        {
<a name="3768"></a>            /* if this is the one containing the actor, remove the actor */
<a name="3769"></a>            if (gActor.isIn(cur))
<a name="3770"></a>                return cur.checkActorOutOfNested(allowImplicit);
<a name="3771"></a>        }
<a name="3772"></a>
<a name="3773"></a>        /* we didn't find the nested room with the actor, so give up */
<a name="3774"></a>        reportFailure(&amp;cannotDoFromHereMsg);
<a name="3775"></a>        exit;
<a name="3776"></a>    }
<a name="3777"></a>
<a name="3778"></a>    /*
<a name="3779"></a>     *   Check, using pre-condition rules, that the actor is ready to
<a name="3780"></a>     *   enter this room as a nested location.  By default, we do nothing,
<a name="3781"></a>     *   since we're not designed as a nested location.  
<a name="3782"></a>     */
<a name="3783"></a>    checkActorReadyToEnterNestedRoom(allowImplicit)
<a name="3784"></a>    {
<a name="3785"></a>        return nil;
<a name="3786"></a>    }
<a name="3787"></a>
<a name="3788"></a>    /*
<a name="3789"></a>     *   Check that the traveler is directly in the given room, using
<a name="3790"></a>     *   pre-condition rules.  'nested' is the nested location immediately
<a name="3791"></a>     *   within this room that contains the actor (directly or
<a name="3792"></a>     *   indirectly).  
<a name="3793"></a>     */
<a name="3794"></a>    checkTravelerDirectlyInRoom(traveler, allowImplicit)
<a name="3795"></a>    {
<a name="3796"></a>        /* if the actor is already directly in this room, we're done */
<a name="3797"></a>        if (traveler.isDirectlyIn(self))
<a name="3798"></a>            return nil;
<a name="3799"></a>
<a name="3800"></a>        /* try moving the actor here */
<a name="3801"></a>        return traveler.checkMovingTravelerInto(self, allowImplicit);
<a name="3802"></a>    }
<a name="3803"></a>
<a name="3804"></a>    /*
<a name="3805"></a>     *   Check, using pre-condition rules, that the actor is removed from
<a name="3806"></a>     *   this nested location and moved to its exit destination.  By
<a name="3807"></a>     *   default, we're not a nested location, so there's nothing for us
<a name="3808"></a>     *   to do.  
<a name="3809"></a>     */
<a name="3810"></a>    checkActorOutOfNested(allowImplicit)
<a name="3811"></a>    {
<a name="3812"></a>        /* we're not a nested location, so there's nothing for us to do */
<a name="3813"></a>        return nil;
<a name="3814"></a>    }
<a name="3815"></a>
<a name="3816"></a>    /*
<a name="3817"></a>     *   Determine if the current gActor, who is directly in this location,
<a name="3818"></a>     *   is "travel ready."  This means that the actor is ready, as far as
<a name="3819"></a>     *   this location is concerned, to traverse the given connector.  By
<a name="3820"></a>     *   default, we consider an actor to be travel-ready if the actor is
<a name="3821"></a>     *   standing; this takes care of most nested room situations, such as
<a name="3822"></a>     *   chairs and beds, automatically.  
<a name="3823"></a>     */
<a name="3824"></a>    isActorTravelReady(conn) { return gActor.posture == standing; }
<a name="3825"></a>
<a name="3826"></a>    /*
<a name="3827"></a>     *   Run an implicit action, if possible, to make the current actor
<a name="3828"></a>     *   "travel ready."  This will be called if the actor is directly in
<a name="3829"></a>     *   this location and isActorTravelReady() returns nil.  By default,
<a name="3830"></a>     *   we try to make the actor stand up.  This should always be paired
<a name="3831"></a>     *   with isActorTravelReady - the condition that routine tests should
<a name="3832"></a>     *   be the condition this routine tries to bring into effect.  If no
<a name="3833"></a>     *   implicit action is possible, simply return nil.  
<a name="3834"></a>     */
<a name="3835"></a>    tryMakingTravelReady(conn) { return tryImplicitAction(Stand); }
<a name="3836"></a>
<a name="3837"></a>    /* the message explaining what we must do to be travel-ready */
<a name="3838"></a>    notTravelReadyMsg = &amp;mustBeStandingMsg
<a name="3839"></a>
<a name="3840"></a>    /*
<a name="3841"></a>     *   An actor is attempting to disembark this location.  By default,
<a name="3842"></a>     *   we'll simply turn this into an "exit" command.  
<a name="3843"></a>     */
<a name="3844"></a>    disembarkRoom()
<a name="3845"></a>    {
<a name="3846"></a>        /* treat this as an 'exit' command */
<a name="3847"></a>        replaceAction(Out);
<a name="3848"></a>    }
<a name="3849"></a>
<a name="3850"></a>    /*
<a name="3851"></a>     *   The destination for objects explicitly dropped by an actor within
<a name="3852"></a>     *   this room.  By default, we'll return self, because items dropped
<a name="3853"></a>     *   should simply go in the room itself.  Some types of rooms will
<a name="3854"></a>     *   want to override this; for example, a room that represents the
<a name="3855"></a>     *   middle of a tightrope would probably want to set the drop
<a name="3856"></a>     *   destination to the location below the tightrope.  Likewise,
<a name="3857"></a>     *   objects like chairs will usually prefer to have dropped items go
<a name="3858"></a>     *   into the enclosing room.  
<a name="3859"></a>     */
<a name="3860"></a>    getDropDestination(objToDrop, path)
<a name="3861"></a>    {
<a name="3862"></a>        /* by default, objects dropped in this room end up in this room */
<a name="3863"></a>        return self;
<a name="3864"></a>    }
<a name="3865"></a>
<a name="3866"></a>    /* 
<a name="3867"></a>     *   The nominal drop destination - this is the location where objects
<a name="3868"></a>     *   are *reported* to go when dropped by an actor in this location.
<a name="3869"></a>     *   By default, we simply return 'self'.
<a name="3870"></a>     *   
<a name="3871"></a>     *   The difference between the actual drop location and the nominal
<a name="3872"></a>     *   drop location is that the nominal drop location is used only for
<a name="3873"></a>     *   reporting messages, while the actual drop location is the
<a name="3874"></a>     *   location where objects are moved on 'drop' or equivalent actions.
<a name="3875"></a>     *   Rooms, for example, want to report that a dropped object lands on
<a name="3876"></a>     *   the floor (or the ground, or whatever), even though the room
<a name="3877"></a>     *   itself is the location where the object actually ends up.  We
<a name="3878"></a>     *   distinguish between the nominal and actual drop location to allow
<a name="3879"></a>     *   these distinctions in reported messages.  
<a name="3880"></a>     */
<a name="3881"></a>    getNominalDropDestination() { return self; }
<a name="3882"></a>
<a name="3883"></a>    /*
<a name="3884"></a>     *   The "nominal actor container" - this is the container which we'll
<a name="3885"></a>     *   say actors are in when we describe actors who are actually in
<a name="3886"></a>     *   this location.  By default, this simply returns self, but it's
<a name="3887"></a>     *   sometimes useful to describe actors as being in some object other
<a name="3888"></a>     *   than self.  The most common case is that normal top-level rooms
<a name="3889"></a>     *   usually want to describe actors as being "on the floor" or
<a name="3890"></a>     *   similar.  
<a name="3891"></a>     */
<a name="3892"></a>    getNominalActorContainer(posture) { return self; }
<a name="3893"></a>
<a name="3894"></a>    /*
<a name="3895"></a>     *   Get any extra items in scope for an actor in this location.
<a name="3896"></a>     *   These are items that are to be in scope even if they're not
<a name="3897"></a>     *   reachable through any of the normal sense paths (so they'll be in
<a name="3898"></a>     *   scope even in the dark, for example).
<a name="3899"></a>     *   
<a name="3900"></a>     *   By default, this returns nothing.  Subclasses can override as
<a name="3901"></a>     *   necessary to include additional items in scope.  For example, a
<a name="3902"></a>     *   chair would probably want to include itself in scope, since the
<a name="3903"></a>     *   actor presumably knows he or she is sitting in a chair even if
<a name="3904"></a>     *   it's too dark to see the chair.  
<a name="3905"></a>     */
<a name="3906"></a>    getExtraScopeItems(actor) { return []; }
<a name="3907"></a>    
<a name="3908"></a>    /*
<a name="3909"></a>     *   Receive notification that we're about to perform a command within
<a name="3910"></a>     *   this location.  This is called on the outermost room first, then
<a name="3911"></a>     *   on the nested rooms, from the outside in, until reaching the room
<a name="3912"></a>     *   directly containing the actor performing the command.  
<a name="3913"></a>     */
<a name="3914"></a>    roomBeforeAction()
<a name="3915"></a>    {
<a name="3916"></a>    }
<a name="3917"></a>
<a name="3918"></a>    /*
<a name="3919"></a>     *   Receive notification that we've just finished a command within
<a name="3920"></a>     *   this location.  This is called on the room immediately containing
<a name="3921"></a>     *   the actor performing the command, then on the room containing
<a name="3922"></a>     *   that room, and so on to the outermost room. 
<a name="3923"></a>     */
<a name="3924"></a>    roomAfterAction()
<a name="3925"></a>    {
<a name="3926"></a>    }
<a name="3927"></a>
<a name="3928"></a>    /*
<a name="3929"></a>     *   Get my notification list - this is a list of objects on which we
<a name="3930"></a>     *   must call beforeAction and afterAction when an action is
<a name="3931"></a>     *   performed within this room.
<a name="3932"></a>     *   
<a name="3933"></a>     *   We'll also include any registered notification items for all of
<a name="3934"></a>     *   our containing rooms up to the outermost container.
<a name="3935"></a>     *   
<a name="3936"></a>     *   The general notification mechanism always includes in the
<a name="3937"></a>     *   notification list all of the objects connected by containment to
<a name="3938"></a>     *   the actor, so objects that are in this room need not register for
<a name="3939"></a>     *   explicit notification.  
<a name="3940"></a>     */
<a name="3941"></a>    getRoomNotifyList()
<a name="3942"></a>    {
<a name="3943"></a>        local lst;
<a name="3944"></a>        
<a name="3945"></a>        /* start with our explicitly registered list */
<a name="3946"></a>        lst = roomNotifyList;
<a name="3947"></a>
<a name="3948"></a>        /* add notification items for our immediate locations  */
<a name="3949"></a>        forEachContainer(
<a name="3950"></a>            {cont: lst = lst.appendUnique(cont.getRoomNotifyList())});
<a name="3951"></a>
<a name="3952"></a>        /* return the result */
<a name="3953"></a>        return lst;
<a name="3954"></a>    }
<a name="3955"></a>
<a name="3956"></a>    /*
<a name="3957"></a>     *   Add an item to our registered notification list for actions in
<a name="3958"></a>     *   the room.
<a name="3959"></a>     *   
<a name="3960"></a>     *   Items can be added here if they must be notified of actions
<a name="3961"></a>     *   performed by within the room even when the items aren't in the
<a name="3962"></a>     *   room at the time of the action.  All items connected by
<a name="3963"></a>     *   containment with the actor performing an action are automatically
<a name="3964"></a>     *   notified of the action; only items that must receive notification
<a name="3965"></a>     *   even when not connected by containment need to be registered
<a name="3966"></a>     *   here.  
<a name="3967"></a>     */
<a name="3968"></a>    addRoomNotifyItem(obj)
<a name="3969"></a>    {
<a name="3970"></a>        roomNotifyList += obj;
<a name="3971"></a>    }
<a name="3972"></a>
<a name="3973"></a>    /* remove an item from the registered notification list */
<a name="3974"></a>    removeRoomNotifyItem(obj)
<a name="3975"></a>    {
<a name="3976"></a>        roomNotifyList -= obj;
<a name="3977"></a>    }
<a name="3978"></a>
<a name="3979"></a>    /* our list of registered notification items */
<a name="3980"></a>    roomNotifyList = []
<a name="3981"></a>
<a name="3982"></a>    /*
<a name="3983"></a>     *   Get the room location.  Since we're capable of holding actors, we
<a name="3984"></a>     *   are our own room location. 
<a name="3985"></a>     */
<a name="3986"></a>    roomLocation = (self)
<a name="3987"></a>
<a name="3988"></a>    /*
<a name="3989"></a>     *   Receive notification that a traveler is arriving.  This is a
<a name="3990"></a>     *   convenience method that rooms can override to carry out side
<a name="3991"></a>     *   effects of arrival.  This is called just before the room's
<a name="3992"></a>     *   arrival message (usually the location description) is displayed,
<a name="3993"></a>     *   so the method can make any adjustments to the room's status or
<a name="3994"></a>     *   contents needed for the arrival.  By default, we do nothing.
<a name="3995"></a>     */
<a name="3996"></a>    enteringRoom(traveler) { }
<a name="3997"></a>
<a name="3998"></a>    /*
<a name="3999"></a>     *   Receive notification that a traveler is leaving.  This is a
<a name="4000"></a>     *   convenience method that rooms can override to carry out side
<a name="4001"></a>     *   effects of departure.  This is called just after any departure
<a name="4002"></a>     *   message is displayed.  By default, we do nothing.  
<a name="4003"></a>     */
<a name="4004"></a>    leavingRoom(traveler) { }
<a name="4005"></a>
<a name="4006"></a>    /*
<a name="4007"></a>     *   Receive notification that a traveler is about to leave the room.
<a name="4008"></a>     *   'traveler' is the object actually traveling.  In most cases this
<a name="4009"></a>     *   is simply the actor; but when the actor is in a vehicle, this is
<a name="4010"></a>     *   the vehicle instead.  
<a name="4011"></a>     *   
<a name="4012"></a>     *   By default, we describe the traveler's departure if the traveler's
<a name="4013"></a>     *   destination is different from its present location.  
<a name="4014"></a>     */
<a name="4015"></a>    travelerLeaving(traveler, dest, connector)
<a name="4016"></a>    {
<a name="4017"></a>        /* describe the departure */
<a name="4018"></a>        if (dest != traveler.location)
<a name="4019"></a>            traveler.describeDeparture(dest, connector);
<a name="4020"></a>
<a name="4021"></a>        /* run the departure notification */
<a name="4022"></a>        leavingRoom(traveler);
<a name="4023"></a>    }
<a name="4024"></a>
<a name="4025"></a>    /*
<a name="4026"></a>     *   Receive notification that a traveler is arriving in the room.
<a name="4027"></a>     *   'traveler' is the object actually traveling.  In most cases this
<a name="4028"></a>     *   is simply the actor; but when the actor is in a vehicle, this is
<a name="4029"></a>     *   the vehicle instead.  
<a name="4030"></a>     *   
<a name="4031"></a>     *   By default, we set each of the "motive" actors to its default
<a name="4032"></a>     *   posture, then describe the arrival.  
<a name="4033"></a>     */
<a name="4034"></a>    travelerArriving(traveler, origin, connector, backConnector)
<a name="4035"></a>    {
<a name="4036"></a>        /* 
<a name="4037"></a>         *   Set the self-motive actors into the proper default posture
<a name="4038"></a>         *   for the location.  We only do this for actors moving under
<a name="4039"></a>         *   their own power, since actors in vehicles will presumably
<a name="4040"></a>         *   just stay in the posture that's appropriate for the vehicle. 
<a name="4041"></a>         */
<a name="4042"></a>        foreach (local actor in traveler.getTravelerMotiveActors)
<a name="4043"></a>        {
<a name="4044"></a>            /*
<a name="4045"></a>             *   If the actor isn't in this posture already, set the actor
<a name="4046"></a>             *   to the new posture.  Note that we set the new posture
<a name="4047"></a>             *   directly, rather than via a nested command; we don't want
<a name="4048"></a>             *   the travel to consist of a NORTH plus a SIT, but simply of
<a name="4049"></a>             *   a NORTH.  Note that this could bypass side effects
<a name="4050"></a>             *   normally associated with the SIT (or whatever), but we
<a name="4051"></a>             *   assume that when a room with a specific posture is linked
<a name="4052"></a>             *   directly from a separate location, the travel connector
<a name="4053"></a>             *   linking up to the new room will take care of the necessary
<a name="4054"></a>             *   side effects.  
<a name="4055"></a>             */
<a name="4056"></a>            if (actor.posture != defaultPosture)
<a name="4057"></a>                actor.makePosture(defaultPosture);
<a name="4058"></a>        }
<a name="4059"></a>        
<a name="4060"></a>        /* run the arrival notification */
<a name="4061"></a>        enteringRoom(traveler);
<a name="4062"></a>        
<a name="4063"></a>        /* describe the arrival */
<a name="4064"></a>        traveler.describeArrival(origin, backConnector);
<a name="4065"></a>    }
<a name="4066"></a>
<a name="4067"></a>    /*
<a name="4068"></a>     *   Receive notification of travel among nested rooms.  When an actor
<a name="4069"></a>     *   moves between two locations related directly by containing (such
<a name="4070"></a>     *   as from a chair to the room containing the chair, or vice versa),
<a name="4071"></a>     *   we first call this routine on the origin of the travel, then we
<a name="4072"></a>     *   move the actor, then we call this same routine on the destination
<a name="4073"></a>     *   of the travel.
<a name="4074"></a>     *   
<a name="4075"></a>     *   This routine is used any time an actor is moved with
<a name="4076"></a>     *   travelWithin().  This is not used when an actor travels between
<a name="4077"></a>     *   locations related by a TravelConnector object rather than by
<a name="4078"></a>     *   direct containment.
<a name="4079"></a>     *   
<a name="4080"></a>     *   We do nothing by default.  Locations can override this if they
<a name="4081"></a>     *   wish to perform any special handling during this type of travel.  
<a name="4082"></a>     */
<a name="4083"></a>    actorTravelingWithin(origin, dest)
<a name="4084"></a>    {
<a name="4085"></a>    }
<a name="4086"></a>
<a name="4087"></a>    /*
<a name="4088"></a>     *   Determine if the given actor has "intrinsic" knowledge of the
<a name="4089"></a>     *   destination of the given travel connector leading away from this
<a name="4090"></a>     *   location.  This knowledge is independent of any memory the actor
<a name="4091"></a>     *   has of actual travel through the connector in the course of the
<a name="4092"></a>     *   game, which we track separately via the TravelConnector's travel
<a name="4093"></a>     *   memory mechanism.
<a name="4094"></a>     *   
<a name="4095"></a>     *   There are two main reasons an actor would have intrinsic
<a name="4096"></a>     *   knowledge of a connector's destination:
<a name="4097"></a>     *   
<a name="4098"></a>     *   1. The actor is supposed to be familiar with the location and its
<a name="4099"></a>     *   surroundings, within the context of the game.  For example, if
<a name="4100"></a>     *   part of the game is the player character's own house, the PC
<a name="4101"></a>     *   would probably know where all of the connections among rooms go.
<a name="4102"></a>     *   
<a name="4103"></a>     *   2. The destination location is plainly visible from this location
<a name="4104"></a>     *   or is clearly marked (such as with a sign).  For example, if the
<a name="4105"></a>     *   current location is an open field, a nearby hilltop to the east
<a name="4106"></a>     *   might be visible from here, so we could see from here where we'll
<a name="4107"></a>     *   end up by going east.  Alternatively, if we're in a lobby, and
<a name="4108"></a>     *   the passage to the west is marked with a sign reading "electrical
<a name="4109"></a>     *   room," an actor would have good reason to think an electrical
<a name="4110"></a>     *   room lies to the west.
<a name="4111"></a>     *   
<a name="4112"></a>     *   We handle case (1) automatically through our actorIsFamiliar()
<a name="4113"></a>     *   method: if the actor is familiar with the location, we assume by
<a name="4114"></a>     *   default that the actor knows where all of the connectors from
<a name="4115"></a>     *   here go.  We don't have any default handling for case (2), so
<a name="4116"></a>     *   individual rooms (or subclasses) must override this method if
<a name="4117"></a>     *   they want to specify intrinsic knowledge for any of their
<a name="4118"></a>     *   outgoing connectors.  
<a name="4119"></a>     */
<a name="4120"></a>    actorKnowsDestination(actor, conn)
<a name="4121"></a>    {
<a name="4122"></a>        /* 
<a name="4123"></a>         *   if the actor is familiar with this location, then the actor
<a name="4124"></a>         *   by default knows where all of the outgoing connections go 
<a name="4125"></a>         */
<a name="4126"></a>        if (actorIsFamiliar(actor))
<a name="4127"></a>            return true;
<a name="4128"></a>
<a name="4129"></a>        /* there's no other way the actor would know the destination */
<a name="4130"></a>        return nil;
<a name="4131"></a>    }
<a name="4132"></a>
<a name="4133"></a>    /*
<a name="4134"></a>     *   Is the actor familiar with this location?  In other words, is the
<a name="4135"></a>     *   actor supposed to know the location well at the start of the game?
<a name="4136"></a>     *   
<a name="4137"></a>     *   This should return true if the actor is familiar with this
<a name="4138"></a>     *   location, nil if not.  By default, we return nil, since actors
<a name="4139"></a>     *   are not by default familiar with any locations.
<a name="4140"></a>     *   
<a name="4141"></a>     *   The purpose of this routine is to determine if the actor is meant
<a name="4142"></a>     *   to know the location well, within the context of the game, even
<a name="4143"></a>     *   before the game starts.  For example, if an area in the game is
<a name="4144"></a>     *   an actor's own house, the actor would naturally be familiar,
<a name="4145"></a>     *   within the context of the game, with the locations making up the
<a name="4146"></a>     *   house.
<a name="4147"></a>     *   
<a name="4148"></a>     *   Note that this routine doesn't need to "learn" based on the
<a name="4149"></a>     *   events of the game.  The familiarity here is meant only to model
<a name="4150"></a>     *   the actor's knowledge as of the start of the game.  
<a name="4151"></a>     */
<a name="4152"></a>    actorIsFamiliar(actor) { return nil; }
<a name="4153"></a>
<a name="4154"></a>    /* 
<a name="4155"></a>     *   The default "you can't go that way" message for travel within this
<a name="4156"></a>     *   location in directions that don't allow travel.  This is shown
<a name="4157"></a>     *   whenever an actor tries to travel in one of the directions we have
<a name="4158"></a>     *   set to point to noTravel.  A room can override this to produce a
<a name="4159"></a>     *   different, customized message for unset travel directions - this
<a name="4160"></a>     *   is an easy way to change the cannot-travel message for several
<a name="4161"></a>     *   directions at once.
<a name="4162"></a>     *   
<a name="4163"></a>     *   The handling depends on whether or not it's dark.  If it's dark,
<a name="4164"></a>     *   we don't want to reveal whether or not it's actually possible to
<a name="4165"></a>     *   perform the travel, since there's no light to see where the exits
<a name="4166"></a>     *   are.  
<a name="4167"></a>     */
<a name="4168"></a>    cannotTravel()
<a name="4169"></a>    {
<a name="4170"></a>        /* check for darkness */
<a name="4171"></a>        if (!gActor.isLocationLit())
<a name="4172"></a>        {
<a name="4173"></a>            /* the actor is in the dark - use our dark travel message */
<a name="4174"></a>            cannotGoThatWayInDark();
<a name="4175"></a>        }
<a name="4176"></a>        else
<a name="4177"></a>        {
<a name="4178"></a>            /* use the standard "can't go that way" routine */
<a name="4179"></a>            cannotGoThatWay();
<a name="4180"></a>        }
<a name="4181"></a>    }
<a name="4182"></a>
<a name="4183"></a>    /*
<a name="4184"></a>     *   Receive notification of travel from one dark location to another.
<a name="4185"></a>     *   This is called before the actor is moved from the source
<a name="4186"></a>     *   location, and can cancel the travel if desired by using 'exit' to
<a name="4187"></a>     *   terminate the command.
<a name="4188"></a>     *   
<a name="4189"></a>     *   By default, we'll simply display the same handler we do when the
<a name="4190"></a>     *   player attempts travel in a direction with no travel possible in
<a name="4191"></a>     *   the dark (cannotGoThatWayInDark), and then use 'exit' to cancel
<a name="4192"></a>     *   the command.  This default behavior provides the player with no
<a name="4193"></a>     *   mapping information in the dark, since the same message is
<a name="4194"></a>     *   generated whether or not travel would be possible in a given
<a name="4195"></a>     *   direction were light present.  
<a name="4196"></a>     */
<a name="4197"></a>    roomDarkTravel(actor)
<a name="4198"></a>    {
<a name="4199"></a>        /* 
<a name="4200"></a>         *   show the same message we would show if we attempted travel in
<a name="4201"></a>         *   the dark in a direction with no exit 
<a name="4202"></a>         */
<a name="4203"></a>        cannotGoThatWayInDark();
<a name="4204"></a>
<a name="4205"></a>        /* terminate the command */
<a name="4206"></a>        exit;
<a name="4207"></a>    }
<a name="4208"></a>
<a name="4209"></a>    /* 
<a name="4210"></a>     *   Show the default "you can't go that way" message for this
<a name="4211"></a>     *   location.  By default, we show a generic message, but individual
<a name="4212"></a>     *   rooms might want to override this to provide a more specific
<a name="4213"></a>     *   description of why travel isn't allowed.  
<a name="4214"></a>     */
<a name="4215"></a>    cannotGoThatWay()
<a name="4216"></a>    {
<a name="4217"></a>        /* "you can't go that way" */
<a name="4218"></a>        reportFailure(cannotGoThatWayMsg);
<a name="4219"></a>
<a name="4220"></a>        /* show a list of exits, if appropriate */
<a name="4221"></a>        cannotGoShowExits(gActor);
<a name="4222"></a>    }
<a name="4223"></a>
<a name="4224"></a>    /* 
<a name="4225"></a>     *   The message to display when it's not possible to travel in a given
<a name="4226"></a>     *   direction from this room; this is either a single-quoted string or
<a name="4227"></a>     *   an actor action messages property (by default, it's the latter,
<a name="4228"></a>     *   giving a default library message).  
<a name="4229"></a>     */
<a name="4230"></a>    cannotGoThatWayMsg = &amp;cannotGoThatWayMsg
<a name="4231"></a>
<a name="4232"></a>    /*
<a name="4233"></a>     *   Show a version of the "you can't go that way" message for travel
<a name="4234"></a>     *   while in the dark.  This is called when the actor is in the dark
<a name="4235"></a>     *   (i.e., there's no ambient light at the actor) and attempts to
<a name="4236"></a>     *   travel in a direction that doesn't allow travel.  By default, we
<a name="4237"></a>     *   show a generic "you can't see where you're going in the dark"
<a name="4238"></a>     *   message.
<a name="4239"></a>     *   
<a name="4240"></a>     *   This routine is essentially a replacement for the
<a name="4241"></a>     *   cannotGoThatWay() routine that we use when the actor is in the
<a name="4242"></a>     *   dark.  
<a name="4243"></a>     */
<a name="4244"></a>    cannotGoThatWayInDark()
<a name="4245"></a>    {
<a name="4246"></a>        /* "it's too dark; you can't see where you're going */
<a name="4247"></a>        reportFailure(&amp;cannotGoThatWayInDarkMsg);
<a name="4248"></a>    }
<a name="4249"></a>
<a name="4250"></a>    /*
<a name="4251"></a>     *   Get preconditions for travel for an actor in this location.  These
<a name="4252"></a>     *   preconditions should be applied by any command that will involve
<a name="4253"></a>     *   travel from this location.  By default, we impose no additional
<a name="4254"></a>     *   requirements.
<a name="4255"></a>     */
<a name="4256"></a>    roomTravelPreCond = []
<a name="4257"></a>
<a name="4258"></a>    /*
<a name="4259"></a>     *   Get the effective location of an actor directly within me, for
<a name="4260"></a>     *   the purposes of a "follow" command.  To follow someone, we must
<a name="4261"></a>     *   have the same effective follow location that the target had when
<a name="4262"></a>     *   we last observed the target leaving.
<a name="4263"></a>     *   
<a name="4264"></a>     *   For most rooms, this is simply the room itself.  
<a name="4265"></a>     */
<a name="4266"></a>    effectiveFollowLocation = (self)
<a name="4267"></a>
<a name="4268"></a>    /*
<a name="4269"></a>     *   Dispatch the room daemon.  This is a daemon routine invoked once
<a name="4270"></a>     *   per turn; we in turn invoke roomDaemon on the current player
<a name="4271"></a>     *   character's current location.  
<a name="4272"></a>     */
<a name="4273"></a>    dispatchRoomDaemon()
<a name="4274"></a>    {
<a name="4275"></a>        /* call roomDaemon on the player character's location */
<a name="4276"></a>        if (gPlayerChar.location != nil)
<a name="4277"></a>            gPlayerChar.location.roomDaemon();
<a name="4278"></a>    }
<a name="4279"></a>;
<a name="4280"></a>
<a name="4281"></a>/* ------------------------------------------------------------------------ */
<a name="4282"></a>/*
<a name="4283"></a> *   Room: the basic class for top-level game locations (that is, game
<a name="4284"></a> *   locations that aren't inside any other simulation objects, but are at
<a name="4285"></a> *   the top level of the containment hierarchy).  This is the smallest
<a name="4286"></a> *   unit of movement; we do not distinguish among locations within a
<a name="4287"></a> *   room, even if a Room represents a physically large location.  If it
<a name="4288"></a> *   is necessary to distinguish among different locations in a large
<a name="4289"></a> *   physical room, simply divide the physical room into sections and
<a name="4290"></a> *   represent each section with a separate Room object.
<a name="4291"></a> *   
<a name="4292"></a> *   A Room is not necessarily indoors; it is simply a location where an
<a name="4293"></a> *   actor can be located.  This peculiar usage of "room" to denote any
<a name="4294"></a> *   atomic location, even outdoors, was adopted by the authors of the
<a name="4295"></a> *   earliest adventure games, and has been the convention ever since.
<a name="4296"></a> *   
<a name="4297"></a> *   A room's contents are the objects contained directly within the room.
<a name="4298"></a> *   These include fixed features of the room as well as loose items in
<a name="4299"></a> *   the room, which are effectively "on the floor" in the room.
<a name="4300"></a> *   
<a name="4301"></a> *   The Room class implements the Travel Connector interface in such a
<a name="4302"></a> *   way that travel from one room to another can be established simply by
<a name="4303"></a> *   setting a direction property (north, south, etc) in the origin room
<a name="4304"></a> *   to point to the destination room.  This type of travel link has no
<a name="4305"></a> *   side effects and is unconditional.
<a name="4306"></a> *   
<a name="4307"></a> *   A room is by default an indoor location; this means that it contains
<a name="4308"></a> *   walls, floor, and ceiling.  An outdoor location should be based on
<a name="4309"></a> *   OutdoorRoom rather than Room.  
<a name="4310"></a> */
<a name="4311"></a>class Room: Fixture, BasicLocation, RoomAutoConnector
<a name="4312"></a>    /* 
<a name="4313"></a>     *   Initialize 
<a name="4314"></a>     */
<a name="4315"></a>    initializeThing()
<a name="4316"></a>    {
<a name="4317"></a>        /* inherit default handling */
<a name="4318"></a>        inherited();
<a name="4319"></a>
<a name="4320"></a>        /* 
<a name="4321"></a>         *   Add my room parts to my contents list.  Only include room
<a name="4322"></a>         *   parts that don't have explicit locations. 
<a name="4323"></a>         */
<a name="4324"></a>        contents += roomParts.subset({x: x.location == nil});
<a name="4325"></a>    }
<a name="4326"></a>
<a name="4327"></a>    /* 
<a name="4328"></a>     *   we're a "top-level" location: we don't have any other object
<a name="4329"></a>     *   containing us, but we're nonetheless part of the game world, so
<a name="4330"></a>     *   we're at the top level of the containment tree 
<a name="4331"></a>     */
<a name="4332"></a>    isTopLevel = true
<a name="4333"></a>
<a name="4334"></a>    /*
<a name="4335"></a>     *   we generally do not want rooms to be included when a command
<a name="4336"></a>     *   refers to 'all' 
<a name="4337"></a>     */
<a name="4338"></a>    hideFromAll(action) { return true; }
<a name="4339"></a>
<a name="4340"></a>    /* don't consider myself a default for STAND ON, SIT ON, or LIE ON */
<a name="4341"></a>    hideFromDefault(action)
<a name="4342"></a>    {
<a name="4343"></a>        /* don't hide from STAND ON, SIT ON, LIE ON */
<a name="4344"></a>        if (action.ofKind(StandOnAction)
<a name="4345"></a>            || action.ofKind(SitOnAction)
<a name="4346"></a>            || action.ofKind(LieOnAction))
<a name="4347"></a>            return nil;
<a name="4348"></a>
<a name="4349"></a>        /* don't hide from defaults for other actions, though */
<a name="4350"></a>        return inherited(action);
<a name="4351"></a>    }
<a name="4352"></a>
<a name="4353"></a>
<a name="4354"></a>    /*
<a name="4355"></a>     *   Most rooms provide their own implicit lighting.  We'll use
<a name="4356"></a>     *   'medium' lighting (level 3) by default, which provides enough
<a name="4357"></a>     *   light for all activities, but is reduced to dim light (level 2)
<a name="4358"></a>     *   when it goes through obscuring media or over distance.  
<a name="4359"></a>     */
<a name="4360"></a>    brightness = 3
<a name="4361"></a>
<a name="4362"></a>    /*
<a name="4363"></a>     *   Get my "destination name," as seen by the given actor from the
<a name="4364"></a>     *   given origin location.  This gives the name we can use to
<a name="4365"></a>     *   describe this location from the perspective of an actor in an
<a name="4366"></a>     *   adjoining location looking at a travel connector from that
<a name="4367"></a>     *   location to here.
<a name="4368"></a>     *   
<a name="4369"></a>     *   By default, we simply return our destName property.  This default
<a name="4370"></a>     *   behavior can be overridden if it's necessary for a location to
<a name="4371"></a>     *   have different destination names in different adjoining
<a name="4372"></a>     *   locations, or when seen by different actors.
<a name="4373"></a>     *   
<a name="4374"></a>     *   If this location's name cannot or should not be described from an
<a name="4375"></a>     *   adjoining location, this should simply return nil.  
<a name="4376"></a>     */
<a name="4377"></a>    getDestName(actor, origin) { return destName; }
<a name="4378"></a>
<a name="4379"></a>    /* 
<a name="4380"></a>     *   Our destination name, if we have one.  By default, we make this
<a name="4381"></a>     *   nil, which means the room cannot be described as a destination of
<a name="4382"></a>     *   connectors from adjoining locations. 
<a name="4383"></a>     */
<a name="4384"></a>    destName = nil
<a name="4385"></a>
<a name="4386"></a>    /*
<a name="4387"></a>     *   My "atmosphere" list.  This can be set to an EventList object to
<a name="4388"></a>     *   provide atmosphere messages while the player character is within
<a name="4389"></a>     *   this room.  The default roomDaemon will show one message from this
<a name="4390"></a>     *   EventList (by calling the EventList's doScript() method) on each
<a name="4391"></a>     *   turn the player character is in this location.  
<a name="4392"></a>     */
<a name="4393"></a>    atmosphereList = nil
<a name="4394"></a>
<a name="4395"></a>    /*
<a name="4396"></a>     *   Room daemon - this is invoked on the player character's immediate
<a name="4397"></a>     *   location once per turn in a daemon.
<a name="4398"></a>     */
<a name="4399"></a>    roomDaemon()
<a name="4400"></a>    {
<a name="4401"></a>        /* 
<a name="4402"></a>         *   if we have an atmosphere message list, display the next
<a name="4403"></a>         *   message 
<a name="4404"></a>         */
<a name="4405"></a>        if (atmosphereList != nil)
<a name="4406"></a>            atmosphereList.doScript();
<a name="4407"></a>    }
<a name="4408"></a>
<a name="4409"></a>    /* 
<a name="4410"></a>     *   The nominal drop destination - this is the location where we
<a name="4411"></a>     *   describe objects as being when they're actually directly within
<a name="4412"></a>     *   the room.
<a name="4413"></a>     *   
<a name="4414"></a>     *   By default, we return the object representing the room's floor.
<a name="4415"></a>     *   If there's no floor, we simply return 'self'.  
<a name="4416"></a>     */
<a name="4417"></a>    getNominalDropDestination()
<a name="4418"></a>    {
<a name="4419"></a>        local floor;
<a name="4420"></a>
<a name="4421"></a>        /* 
<a name="4422"></a>         *   if there's a floor, it's the nominal drop destination;
<a name="4423"></a>         *   otherwise, just indicate that our contents are in 'self' 
<a name="4424"></a>         */
<a name="4425"></a>        return ((floor = roomFloor) != nil ? floor : self);
<a name="4426"></a>    }
<a name="4427"></a>
<a name="4428"></a>    /*
<a name="4429"></a>     *   The nominal actor container.  By default, this is the room's
<a name="4430"></a>     *   nominal drop destination, which is usually the floor or
<a name="4431"></a>     *   equivalent.  
<a name="4432"></a>     */
<a name="4433"></a>    getNominalActorContainer(posture) { return getNominalDropDestination(); }
<a name="4434"></a>
<a name="4435"></a>    /* 
<a name="4436"></a>     *   move something into a room is accomplished by putting the object
<a name="4437"></a>     *   on the floor 
<a name="4438"></a>     */
<a name="4439"></a>    tryMovingObjInto(obj)
<a name="4440"></a>    {
<a name="4441"></a>        local floor;
<a name="4442"></a>
<a name="4443"></a>        /* if we have a floor, put the object there */
<a name="4444"></a>        if ((floor = roomFloor) != nil)
<a name="4445"></a>            return tryImplicitAction(PutOn, obj, floor);
<a name="4446"></a>        else
<a name="4447"></a>            return nil;
<a name="4448"></a>    }
<a name="4449"></a>
<a name="4450"></a>    /* explain that something must be in the room first */
<a name="4451"></a>    mustMoveObjInto(obj)
<a name="4452"></a>    {
<a name="4453"></a>        local floor;
<a name="4454"></a>
<a name="4455"></a>        /* if we have a floor, say that the object has to go there */
<a name="4456"></a>        if ((floor = roomFloor) != nil)
<a name="4457"></a>            reportFailure(&amp;mustBeInMsg, obj, floor);
<a name="4458"></a>        else
<a name="4459"></a>            inherited(obj);
<a name="4460"></a>    }
<a name="4461"></a>
<a name="4462"></a>    /*
<a name="4463"></a>     *   Get the apparent location of one of our room parts.
<a name="4464"></a>     *   
<a name="4465"></a>     *   In most cases, we use generic objects (defaultFloor,
<a name="4466"></a>     *   defaultNorthWall, etc.) for the room parts.  There's only one
<a name="4467"></a>     *   instance of each of these generic objects in the whole game -
<a name="4468"></a>     *   there's only one floor, one north wall, and so on - so these
<a name="4469"></a>     *   instances can't have specific locations the way normal objects do.
<a name="4470"></a>     *   Thus the need for this method: this tells us the *apparent*
<a name="4471"></a>     *   location of one of the room part objects as perceived from this
<a name="4472"></a>     *   room.
<a name="4473"></a>     *   
<a name="4474"></a>     *   If the part isn't in this location, we'll return nil.  
<a name="4475"></a>     */
<a name="4476"></a>    getRoomPartLocation(part)
<a name="4477"></a>    {
<a name="4478"></a>        local loc;
<a name="4479"></a>        
<a name="4480"></a>        /* 
<a name="4481"></a>         *   if this part is in our part list, then its apparent location
<a name="4482"></a>         *   is 'self' 
<a name="4483"></a>         */
<a name="4484"></a>        if (roomParts.indexOf(part) != nil)
<a name="4485"></a>            return self;
<a name="4486"></a>
<a name="4487"></a>        /* 
<a name="4488"></a>         *   if the room part has an explicit location itself, and that
<a name="4489"></a>         *   location is either 'self' or is in 'self', return the
<a name="4490"></a>         *   location 
<a name="4491"></a>         */
<a name="4492"></a>        if ((loc = part.location) != nil &amp;&amp; (loc == self || loc.isIn(self)))
<a name="4493"></a>            return loc;
<a name="4494"></a>
<a name="4495"></a>        /* we don't have the part */
<a name="4496"></a>        return nil;
<a name="4497"></a>    }
<a name="4498"></a>
<a name="4499"></a>    /*
<a name="4500"></a>     *   Get the list of extra parts for the room.  An indoor location has
<a name="4501"></a>     *   walls, floor, and ceiling; these are all generic objects that are
<a name="4502"></a>     *   included for completeness only.
<a name="4503"></a>     *   
<a name="4504"></a>     *   A room with special walls, floor, or ceiling should override this
<a name="4505"></a>     *   to eliminate the default objects from appearing in the room.
<a name="4506"></a>     *   Note that if the room has a floor, it should always be
<a name="4507"></a>     *   represented by an object of class Floor, and should always be
<a name="4508"></a>     *   part of this list.  
<a name="4509"></a>     */
<a name="4510"></a>    roomParts = [defaultFloor, defaultCeiling,
<a name="4511"></a>                 defaultNorthWall, defaultSouthWall,
<a name="4512"></a>                 defaultEastWall, defaultWestWall]
<a name="4513"></a>
<a name="4514"></a>    /*
<a name="4515"></a>     *   Get the room's floor.  This looks for an object of class Floor in
<a name="4516"></a>     *   the roomParts list; if there is no such object, we'll return nil,
<a name="4517"></a>     *   indicating that the room has no floor at all.  
<a name="4518"></a>     */
<a name="4519"></a>    roomFloor = (roomParts.valWhich({x: x.ofKind(Floor)}))
<a name="4520"></a>
<a name="4521"></a>    /*
<a name="4522"></a>     *   Get any extra items in scope in this location.  These are items
<a name="4523"></a>     *   that are to be in scope even if they're not reachable through any
<a name="4524"></a>     *   of the normal sense paths (so they'll be in scope even in the
<a name="4525"></a>     *   dark, for example).
<a name="4526"></a>     *   
<a name="4527"></a>     *   By default, if we have a floor, and the actor is directly in this
<a name="4528"></a>     *   room, we return our floor: this is because an actor is presumed to
<a name="4529"></a>     *   be in physical contact with the floor whenever directly in the
<a name="4530"></a>     *   room, and thus the actor would be aware that there's a floor
<a name="4531"></a>     *   there, even if the actor can't see the floor.  In some rooms, it's
<a name="4532"></a>     *   desirable to have certain objects in scope because they're
<a name="4533"></a>     *   essential features of the room; for example, a location that is
<a name="4534"></a>     *   part of a stairway would probably have the stairs in scope by
<a name="4535"></a>     *   virtue of the actor standing on them.  
<a name="4536"></a>     */
<a name="4537"></a>    getExtraScopeItems(actor)
<a name="4538"></a>    {
<a name="4539"></a>        local floor;
<a name="4540"></a>        
<a name="4541"></a>        /* 
<a name="4542"></a>         *   if we have a floor, and the actor is in this room, explicitly
<a name="4543"></a>         *   make the floor in scope 
<a name="4544"></a>         */
<a name="4545"></a>        if ((floor = roomFloor) != nil &amp;&amp; actor.isDirectlyIn(self))
<a name="4546"></a>            return [floor];
<a name="4547"></a>        else
<a name="4548"></a>            return [];
<a name="4549"></a>    }
<a name="4550"></a>
<a name="4551"></a>    /*
<a name="4552"></a>     *   When we're in the room, treat EXAMINE &lt;ROOM&gt; the same as LOOK
<a name="4553"></a>     *   AROUND.  (This will only work if the room is given vocabulary
<a name="4554"></a>     *   like a normal object.)  
<a name="4555"></a>     */
<a name="4556"></a>    dobjFor(Examine)
<a name="4557"></a>    {
<a name="4558"></a>        verify()
<a name="4559"></a>        {
<a name="4560"></a>            /* 
<a name="4561"></a>             *   When we're in the room, downgrade the likelihood a bit, as
<a name="4562"></a>             *   we'd rather inspect an object within the room if there's
<a name="4563"></a>             *   something with the same name.  When we're *not* in the
<a name="4564"></a>             *   room - meaning this is a remote room that's visible from
<a name="4565"></a>             *   the player's location - downgrade the likelihood even
<a name="4566"></a>             *   more, since we're more likely to want to examine the room
<a name="4567"></a>             *   we're actually in than a remote room with the same name.  
<a name="4568"></a>             */
<a name="4569"></a>            if (gActor.isIn(self))
<a name="4570"></a>                logicalRank(80, 'x room');
<a name="4571"></a>            else
<a name="4572"></a>                logicalRank(70, 'x room');
<a name="4573"></a>        }
<a name="4574"></a>
<a name="4575"></a>        action()
<a name="4576"></a>        {
<a name="4577"></a>            /* 
<a name="4578"></a>             *   if the looker is within the room, replace EXAMINE &lt;self&gt;
<a name="4579"></a>             *   with LOOK AROUND; otherwise, use the normal description 
<a name="4580"></a>             */
<a name="4581"></a>            if (gActor.isIn(self) &amp;&amp; gActor.canSee(self))
<a name="4582"></a>                gActor.lookAround(LookRoomDesc | LookListSpecials
<a name="4583"></a>                                  | LookListPortables);
<a name="4584"></a>            else
<a name="4585"></a>                inherited();
<a name="4586"></a>        }
<a name="4587"></a>    }
<a name="4588"></a>
<a name="4589"></a>    /* treat LOOK IN &lt;room&gt; as EXAMINE &lt;room&gt; */
<a name="4590"></a>    dobjFor(LookIn) remapTo(Examine, self)
<a name="4591"></a>
<a name="4592"></a>    /* LOOK UNDER and BEHIND are illogical */
<a name="4593"></a>    dobjFor(LookUnder) { verify { illogical(&amp;cannotLookUnderMsg); } }
<a name="4594"></a>    dobjFor(LookBehind) { verify { illogical(&amp;cannotLookBehindMsg); } }
<a name="4595"></a>
<a name="4596"></a>    /* treat SMELL/LISTEN TO &lt;room&gt; as just SMELL/LISTEN */
<a name="4597"></a>    dobjFor(Smell) remapTo(SmellImplicit)
<a name="4598"></a>    dobjFor(ListenTo) remapTo(ListenImplicit)
<a name="4599"></a>
<a name="4600"></a>    /* map STAND/SIT/LIE ON &lt;room&gt; to my default floor */
<a name="4601"></a>    dobjFor(StandOn) maybeRemapTo(roomFloor != nil, StandOn, roomFloor)
<a name="4602"></a>    dobjFor(SitOn) maybeRemapTo(roomFloor != nil, SitOn, roomFloor)
<a name="4603"></a>    dobjFor(LieOn) maybeRemapTo(roomFloor != nil, LieOn, roomFloor)
<a name="4604"></a>
<a name="4605"></a>    /* 
<a name="4606"></a>     *   treat an explicit GET OUT OF &lt;ROOM&gt; as OUT if there's an apparent
<a name="4607"></a>     *   destination for OUT; otherwise treat it as "vague travel," which
<a name="4608"></a>     *   simply tells the player that they need to specify a direction 
<a name="4609"></a>     */
<a name="4610"></a>    dobjFor(GetOutOf)
<a name="4611"></a>    {
<a name="4612"></a>        remap()
<a name="4613"></a>        {
<a name="4614"></a>            /* remap only if this isn't an implied action */
<a name="4615"></a>            if (gAction.parentAction == nil)
<a name="4616"></a>            {
<a name="4617"></a>                /* 
<a name="4618"></a>                 *   if we have an apparent Out connection, go there;
<a name="4619"></a>                 *   otherwise it's not obvious where we're meant to go 
<a name="4620"></a>                 */
<a name="4621"></a>                if (out != nil &amp;&amp; out.isConnectorApparent(self, gActor))
<a name="4622"></a>                    return [OutAction];
<a name="4623"></a>                else
<a name="4624"></a>                    return [VagueTravelAction];
<a name="4625"></a>            }
<a name="4626"></a>
<a name="4627"></a>            /* don't remap here - use the standard handling */
<a name="4628"></a>            return inherited();
<a name="4629"></a>        }
<a name="4630"></a>    }
<a name="4631"></a>
<a name="4632"></a>    /* 
<a name="4633"></a>     *   for BOARD and ENTER, there are three possibilities:
<a name="4634"></a>     *   
<a name="4635"></a>     *   - we're already directly in this room, in which case it's
<a name="4636"></a>     *   illogical to travel here again
<a name="4637"></a>     *   
<a name="4638"></a>     *   - we're in a nested room within this room, in which case ENTER
<a name="4639"></a>     *   &lt;self&gt; is the same as GET OUT OF &lt;outermost nested room within
<a name="4640"></a>     *   self&gt;
<a name="4641"></a>     *   
<a name="4642"></a>     *   - we're in a separate top-level room that's connected by a sense
<a name="4643"></a>     *   connector, in which case ENTER &lt;self&gt; should be handled as TRAVEL
<a name="4644"></a>     *   VIA &lt;connector from actor's current location to self&gt; 
<a name="4645"></a>     */
<a name="4646"></a>    dobjFor(Board) asDobjFor(Enter)
<a name="4647"></a>    dobjFor(Enter)
<a name="4648"></a>    {
<a name="4649"></a>        verify()
<a name="4650"></a>        {
<a name="4651"></a>            /* 
<a name="4652"></a>             *   if we're already here, entering the same location is
<a name="4653"></a>             *   redundant; if we're not in a nested room, we need a travel
<a name="4654"></a>             *   connector to get there from here 
<a name="4655"></a>             */
<a name="4656"></a>            if (gActor.isDirectlyIn(self))
<a name="4657"></a>                illogicalAlready(&amp;alreadyInLocMsg);
<a name="4658"></a>            else if (!gActor.isIn(self)
<a name="4659"></a>                     &amp;&amp; gActor.location.getConnectorTo(gActor, self) == nil)
<a name="4660"></a>                illogicalNow(&amp;whereToGoMsg);
<a name="4661"></a>        }
<a name="4662"></a>        preCond()
<a name="4663"></a>        {
<a name="4664"></a>            /* 
<a name="4665"></a>             *   if we're in a different top-level room, and there's a
<a name="4666"></a>             *   travel connector, we'll simply travel via the connector,
<a name="4667"></a>             *   so we don't need to impose any pre-conditions of our own 
<a name="4668"></a>             */
<a name="4669"></a>            if (!gActor.isIn(self)
<a name="4670"></a>                &amp;&amp; gActor.location.getConnectorTo(gActor, self) != nil)
<a name="4671"></a>                return [];
<a name="4672"></a>
<a name="4673"></a>            /* 
<a name="4674"></a>             *   if we're in a nested room within this object, we'll
<a name="4675"></a>             *   replace the action with "get out of &lt;outermost nested
<a name="4676"></a>             *   room&gt;", so there's no need for any extra preconditions
<a name="4677"></a>             *   here 
<a name="4678"></a>             */
<a name="4679"></a>            if (gActor.isIn(self) &amp;&amp; !gActor.isDirectlyIn(self))
<a name="4680"></a>                return [];
<a name="4681"></a>
<a name="4682"></a>            /* otherwise, use the default conditions */
<a name="4683"></a>            return inherited();
<a name="4684"></a>        }
<a name="4685"></a>        action()
<a name="4686"></a>        {
<a name="4687"></a>            /* 
<a name="4688"></a>             *   if we're in a nested room, get out; otherwise travel via a
<a name="4689"></a>             *   suitable travel connector 
<a name="4690"></a>             */
<a name="4691"></a>            if (gActor.isIn(self) &amp;&amp; !gActor.isDirectlyIn(self))
<a name="4692"></a>            {
<a name="4693"></a>                /* 
<a name="4694"></a>                 *   get out of the *outermost* nested room - that is, our
<a name="4695"></a>                 *   direct child that contains the actor 
<a name="4696"></a>                 */
<a name="4697"></a>                local chi = contents.valWhich({x: gActor.isIn(x)});
<a name="4698"></a>
<a name="4699"></a>                /* if we found it, get out of it */
<a name="4700"></a>                if (chi != nil)
<a name="4701"></a>                    replaceAction(GetOutOf, chi);
<a name="4702"></a>            }
<a name="4703"></a>            else
<a name="4704"></a>            {
<a name="4705"></a>                /* get the connector from here to there */
<a name="4706"></a>                local conn = gActor.location.getConnectorTo(gActor, self);
<a name="4707"></a>
<a name="4708"></a>                /* if we found it, go that way */
<a name="4709"></a>                if (conn != nil)
<a name="4710"></a>                    replaceAction(TravelVia, conn);
<a name="4711"></a>            }
<a name="4712"></a>
<a name="4713"></a>            /* 
<a name="4714"></a>             *   if we didn't replace the action yet, we can't figure out
<a name="4715"></a>             *   how to get here from the actor's current location 
<a name="4716"></a>             */
<a name="4717"></a>            reportFailure(&amp;whereToGoMsg);
<a name="4718"></a>        }
<a name="4719"></a>    }
<a name="4720"></a>;
<a name="4721"></a>
<a name="4722"></a>/*
<a name="4723"></a> *   A dark room, which provides no light of its own 
<a name="4724"></a> */
<a name="4725"></a>class DarkRoom: Room
<a name="4726"></a>    /* 
<a name="4727"></a>     *   turn off the lights 
<a name="4728"></a>     */
<a name="4729"></a>    brightness = 0
<a name="4730"></a>;
<a name="4731"></a>
<a name="4732"></a>/*
<a name="4733"></a> *   An outdoor location.  This differs from an indoor location in that it
<a name="4734"></a> *   has ground and sky rather than floor and ceiling, and has no walls.  
<a name="4735"></a> */
<a name="4736"></a>class OutdoorRoom: Room
<a name="4737"></a>    /* an outdoor room has ground and sky, but no walls */
<a name="4738"></a>    roomParts = [defaultGround, defaultSky]
<a name="4739"></a>;
<a name="4740"></a>
<a name="4741"></a>/*
<a name="4742"></a> *   A shipboard room.  This is a simple mix-in class: it can be used
<a name="4743"></a> *   along with any type of Room to indicate that this room is aboard a
<a name="4744"></a> *   ship.  When a room is aboard a ship, the shipboard travel directions
<a name="4745"></a> *   (port, starboard, fore, aft) are allowed; these directions normally
<a name="4746"></a> *   make no sense.
<a name="4747"></a> *   
<a name="4748"></a> *   This is a mix-in class rather than a Room subclass to allow it to be
<a name="4749"></a> *   used in conjunction with any other Room subclass.  To make a room
<a name="4750"></a> *   shipboard, simply declare your room like this:
<a name="4751"></a> *   
<a name="4752"></a> *   mainDeck: Shipboard, Room // etc 
<a name="4753"></a> */
<a name="4754"></a>class Shipboard: object
<a name="4755"></a>    /* mark the location as being aboard ship */
<a name="4756"></a>    isShipboard = true
<a name="4757"></a>;
<a name="4758"></a>
<a name="4759"></a>/* 
<a name="4760"></a> *   For convenience, we define ShipboardRoom as a shipboard version of the
<a name="4761"></a> *   basic Room type. 
<a name="4762"></a> */
<a name="4763"></a>class ShipboardRoom: Shipboard, Room
<a name="4764"></a>;
<a name="4765"></a>
<a name="4766"></a>/* ------------------------------------------------------------------------ */
<a name="4767"></a>/*
<a name="4768"></a> *   Make a room "floorless."  This is a mix-in class that you can include
<a name="4769"></a> *   in a superclass list ahead of Room or any of its subclasses to create
<a name="4770"></a> *   a room where support is provided by some means other than standing on
<a name="4771"></a> *   a surface, or where there's simply no support.  Examples: hanging on a
<a name="4772"></a> *   rope over a chasm; climbing a ladder; in free-fall after jumping out
<a name="4773"></a> *   of a plane; levitating in mid-air.
<a name="4774"></a> *   
<a name="4775"></a> *   There are two main special features of a floorless room.  First, and
<a name="4776"></a> *   most obviously, there's no "floor" or "ground" object among the room
<a name="4777"></a> *   parts.  We accomplish this by simply subtracting out any object of
<a name="4778"></a> *   class Floor from the room parts list inherited from the combined base
<a name="4779"></a> *   room class.
<a name="4780"></a> *   
<a name="4781"></a> *   Second, there's no place to put anything down, so objects dropped here
<a name="4782"></a> *   either disappear from the game or are transported to another location
<a name="4783"></a> *   (the room at the bottom of the chasm, for example).  
<a name="4784"></a> */
<a name="4785"></a>class Floorless: object
<a name="4786"></a>    /* 
<a name="4787"></a>     *   Omit the default floor/ground objects from the room parts list.
<a name="4788"></a>     *   Room classes generally have static room parts lists, so calculate
<a name="4789"></a>     *   this once per instance and store the results.
<a name="4790"></a>     *   
<a name="4791"></a>     *   NOTE - if you combine Floorless with a base Room class that has a
<a name="4792"></a>     *   dynamic room parts list, you'll need to override this to calculate
<a name="4793"></a>     *   the subset dynamically on each invocation.  
<a name="4794"></a>     */
<a name="4795"></a>    roomParts = perInstance(inherited().subset({x: !x.ofKind(Floor)}))
<a name="4796"></a>
<a name="4797"></a>    /* 
<a name="4798"></a>     *   The room below, if any - this is where objects dropped here will
<a name="4799"></a>     *   actually end up.  By default, this is nil, which means that
<a name="4800"></a>     *   objects dropped here simply disappear from the game.  If there's a
<a name="4801"></a>     *   "bottom of chasm" location where dropped objects should land,
<a name="4802"></a>     *   provide it here.  
<a name="4803"></a>     */
<a name="4804"></a>    bottomRoom = nil
<a name="4805"></a>
<a name="4806"></a>    /* receive a dropped object */
<a name="4807"></a>    receiveDrop(obj, desc)
<a name="4808"></a>    {
<a name="4809"></a>        /* 
<a name="4810"></a>         *   move the dropped object to the room at the bottom of whatever
<a name="4811"></a>         *   it is we're suspended over; if there is no bottom room, we'll
<a name="4812"></a>         *   simply remove the dropped object from the game 
<a name="4813"></a>         */
<a name="4814"></a>        obj.moveInto(bottomRoom);
<a name="4815"></a>
<a name="4816"></a>        /* 
<a name="4817"></a>         *   Say that the object drops out of sight below.  Build this by
<a name="4818"></a>         *   combining the generic report prefix from the drop descriptor
<a name="4819"></a>         *   with our generic suffix, which describes the object as
<a name="4820"></a>         *   vanishing below. 
<a name="4821"></a>         */
<a name="4822"></a>        mainReport(desc.getReportPrefix(obj, self)
<a name="4823"></a>                   + gActor.getActionMessageObj().floorlessDropMsg(obj));
<a name="4824"></a>    }
<a name="4825"></a>;
<a name="4826"></a>
<a name="4827"></a>/* 
<a name="4828"></a> *   For convenience, provide a combination of Floorless with the ordinary
<a name="4829"></a> *   Room. 
<a name="4830"></a> */
<a name="4831"></a>class FloorlessRoom: Floorless, Room;
<a name="4832"></a>
<a name="4833"></a>/* ------------------------------------------------------------------------ */
<a name="4834"></a>/*
<a name="4835"></a> *   Room Part - base class for "parts" of rooms, such as floors and walls.
<a name="4836"></a> *   Room parts are unusual in a couple of ways.
<a name="4837"></a> *   
<a name="4838"></a> *   First, room parts are frequently re-used widely throughout a game.  We
<a name="4839"></a> *   define a single instance of each of several parts that are found in
<a name="4840"></a> *   typical rooms, and then re-use those instances in all rooms with those
<a name="4841"></a> *   parts.  For example, we define one "default floor" object, and then
<a name="4842"></a> *   use that object in most or all rooms that have floors.  We do this for
<a name="4843"></a> *   efficiency, to avoid creating hundreds of essentially identical copies
<a name="4844"></a> *   of the common parts.
<a name="4845"></a> *   
<a name="4846"></a> *   Second, because room parts are designed to be re-used, things that are
<a name="4847"></a> *   in or on the parts are actually represented in the containment model
<a name="4848"></a> *   as being directly in their containing rooms.  For example, an object
<a name="4849"></a> *   that is said to be "on the floor" actually has its 'location' property
<a name="4850"></a> *   set to its immediate room container, and the 'contents' list that
<a name="4851"></a> *   contains the object is that of the room, not of the floor object.  We
<a name="4852"></a> *   must therefore override some of the normal handling for object
<a name="4853"></a> *   locations within room parts, in order to make it appear (for the
<a name="4854"></a> *   purposes of command input and descriptive messages) that the things
<a name="4855"></a> *   are in/on their room parts, even though they're not really represented
<a name="4856"></a> *   that way in the containment model.  
<a name="4857"></a> */
<a name="4858"></a>class RoomPart: Fixture
<a name="4859"></a>    /*
<a name="4860"></a>     *   When we explicitly examine a RoomPart, list any object that's
<a name="4861"></a>     *   nominally contained in the room part, as long it doesn't have a
<a name="4862"></a>     *   special description for the purposes of the room part.  (If it
<a name="4863"></a>     *   does have a special description, then examining the room part will
<a name="4864"></a>     *   automatically display that special desc, so we don't want to
<a name="4865"></a>     *   include the object in a separate list of miscellaneous contents of
<a name="4866"></a>     *   the room part.)  
<a name="4867"></a>     */
<a name="4868"></a>    isObjListedInRoomPart(obj)
<a name="4869"></a>    {
<a name="4870"></a>         /* 
<a name="4871"></a>          *   list the object *unless* it has a special description for the
<a name="4872"></a>          *   purposes of examining this room part 
<a name="4873"></a>          */
<a name="4874"></a>        return !obj.useSpecialDescInRoomPart(self);
<a name="4875"></a>    }
<a name="4876"></a>
<a name="4877"></a>    /*
<a name="4878"></a>     *   Add this room part to the given room.
<a name="4879"></a>     *   
<a name="4880"></a>     *   Room parts don't have normal "location" properties.  Instead, a
<a name="4881"></a>     *   room part explicitly appears in the "roomParts" list of each room
<a name="4882"></a>     *   that contains it.  For the most part, room parts are static -
<a name="4883"></a>     *   they're initialized in the room definitions and never changed.
<a name="4884"></a>     *   However, if you need to dynamically add a room part to a room
<a name="4885"></a>     *   during the game, you can do so using this method.  
<a name="4886"></a>     */
<a name="4887"></a>    moveIntoAdd(room)
<a name="4888"></a>    {
<a name="4889"></a>        /* add me to the room's 'roomParts' and 'contents' lists */
<a name="4890"></a>        room.roomParts += self;
<a name="4891"></a>        room.contents += self;
<a name="4892"></a>    }
<a name="4893"></a>
<a name="4894"></a>    /*
<a name="4895"></a>     *   Remove this room part from the given room.  This can be used if
<a name="4896"></a>     *   it's necessary to remove the room part dynamically from a room.  
<a name="4897"></a>     */
<a name="4898"></a>    moveOutOf(room)
<a name="4899"></a>    {
<a name="4900"></a>        /* remove me from the room's 'roomParts' and 'contents' lists */
<a name="4901"></a>        room.roomParts -= self;
<a name="4902"></a>        room.contents -= self;
<a name="4903"></a>    }
<a name="4904"></a>
<a name="4905"></a>    /* 
<a name="4906"></a>     *   Don't include room parts in 'all'.  Room parts are so ubiquitous
<a name="4907"></a>     *   that we never want to assume that they're involved in a command
<a name="4908"></a>     *   except when it is specifically so stated.  
<a name="4909"></a>     */
<a name="4910"></a>    hideFromAll(action) { return true; }
<a name="4911"></a>
<a name="4912"></a>    /* do allow use as a default, though */
<a name="4913"></a>    hideFromDefault(action) { return nil; }
<a name="4914"></a>
<a name="4915"></a>    /*
<a name="4916"></a>     *   When multiple room parts show up in a resolve list, and some of
<a name="4917"></a>     *   the parts are local to the actor's immediate location and others
<a name="4918"></a>     *   aren't, keep only the local ones.  This helps avoid pointless
<a name="4919"></a>     *   ambiguity in cases where two (or more) top-level locations are
<a name="4920"></a>     *   linked with a sense connector, and one or the other location has
<a name="4921"></a>     *   custom room part objects. 
<a name="4922"></a>     */
<a name="4923"></a>    filterResolveList(lst, action, whichObj, np, requiredNum)
<a name="4924"></a>    {
<a name="4925"></a>        /* if a definite number of objects is required, check ambiguity */
<a name="4926"></a>        if (requiredNum != nil)
<a name="4927"></a>        {
<a name="4928"></a>            /* get the subset that's just RoomParts */
<a name="4929"></a>            local partLst = lst.subset({x: x.obj_.ofKind(RoomPart)});
<a name="4930"></a>
<a name="4931"></a>            /* 
<a name="4932"></a>             *   get the *remote* subset - this is the subset that's not in
<a name="4933"></a>             *   the outermost room of the target actor 
<a name="4934"></a>             */
<a name="4935"></a>            local outer = action.actor_.getOutermostRoom();
<a name="4936"></a>            local remoteLst = partLst.subset({x: !x.obj_.isIn(outer)});
<a name="4937"></a>
<a name="4938"></a>            /* 
<a name="4939"></a>             *   If all of the objects are remote, or all of them are
<a name="4940"></a>             *   local, we can't narrow things down on this basis; but if
<a name="4941"></a>             *   we found some remote and some local, eliminate the remote
<a name="4942"></a>             *   items, since we want to favor the local ones 
<a name="4943"></a>             */
<a name="4944"></a>            if (remoteLst.length() not in (0, partLst.length()))
<a name="4945"></a>                lst -= remoteLst;
<a name="4946"></a>        }
<a name="4947"></a>
<a name="4948"></a>        /* now do any inherited work, and return the result */
<a name="4949"></a>        return inherited(lst, action, whichObj, np, requiredNum);
<a name="4950"></a>    }
<a name="4951"></a>
<a name="4952"></a>    /*
<a name="4953"></a>     *   Since room parts are generally things like walls and floors that
<a name="4954"></a>     *   enclose the entire room, they're typically visually large, and
<a name="4955"></a>     *   tend to have fairly large-scale details (such as doors and
<a name="4956"></a>     *   windows).  So, by default we set the sightSize to 'large' so that
<a name="4957"></a>     *   the details are visible at a distance.  
<a name="4958"></a>     */
<a name="4959"></a>    sightSize = large
<a name="4960"></a>
<a name="4961"></a>    /* 
<a name="4962"></a>     *   as with decorations, downgrade the likelihood for Examine, as the
<a name="4963"></a>     *   standard walls, floors, etc. are pretty much background noise
<a name="4964"></a>     *   that are just here in case someone wants to refer to them
<a name="4965"></a>     *   explicitly 
<a name="4966"></a>     */
<a name="4967"></a>    dobjFor(Examine)
<a name="4968"></a>    {
<a name="4969"></a>        verify()
<a name="4970"></a>        {
<a name="4971"></a>            inherited();
<a name="4972"></a>            logicalRank(70, 'x decoration');
<a name="4973"></a>        }
<a name="4974"></a>    }
<a name="4975"></a>
<a name="4976"></a>    /* describe the status - shows the things that are in/on the part */
<a name="4977"></a>    examineStatus()
<a name="4978"></a>    {
<a name="4979"></a>        /* show the contents of the room part */
<a name="4980"></a>        examinePartContents(&amp;descContentsLister);
<a name="4981"></a>    }
<a name="4982"></a>
<a name="4983"></a>    /* show our contents */
<a name="4984"></a>    examinePartContents(listerProp)
<a name="4985"></a>    {
<a name="4986"></a>        local loc;
<a name="4987"></a>        
<a name="4988"></a>        /* 
<a name="4989"></a>         *   Get my location, as perceived by the actor - this is the room
<a name="4990"></a>         *   that contains this part.  If I don't have a location as
<a name="4991"></a>         *   perceived by the actor, then we can't show any contents.  
<a name="4992"></a>         */
<a name="4993"></a>        loc = gActor.location.getRoomPartLocation(self);
<a name="4994"></a>        if (loc == nil)
<a name="4995"></a>            return;
<a name="4996"></a>
<a name="4997"></a>        /* 
<a name="4998"></a>         *   create a copy of the lister customized for this part, if we
<a name="4999"></a>         *   haven't already done so 
<a name="5000"></a>         */
<a name="5001"></a>        if (self.(listerProp).part_ == nil)
<a name="5002"></a>        {
<a name="5003"></a>            self.(listerProp) = self.(listerProp).createClone();
<a name="5004"></a>            self.(listerProp).part_ = self;
<a name="5005"></a>        }
<a name="5006"></a>
<a name="5007"></a>        /* show the contents of the containing location */
<a name="5008"></a>        self.(listerProp).showList(gActor, self, loc.contents, 0, 0,
<a name="5009"></a>                                   gActor.visibleInfoTable(), nil);
<a name="5010"></a>    }
<a name="5011"></a>
<a name="5012"></a>    /* 
<a name="5013"></a>     *   show our special contents - this shows objects with special
<a name="5014"></a>     *   descriptions that are specifically in this room part 
<a name="5015"></a>     */
<a name="5016"></a>    examineSpecialContents()
<a name="5017"></a>    {
<a name="5018"></a>        local infoTab;
<a name="5019"></a>        local lst;
<a name="5020"></a>        
<a name="5021"></a>        /* get the actor's list of visible items */
<a name="5022"></a>        infoTab = gActor.visibleInfoTable();
<a name="5023"></a>
<a name="5024"></a>        /* 
<a name="5025"></a>         *   get the list of special description items, using only the
<a name="5026"></a>         *   subset that uses special descriptions in this room part 
<a name="5027"></a>         */
<a name="5028"></a>        lst = specialDescList(infoTab,
<a name="5029"></a>                              {obj: obj.useSpecialDescInRoomPart(self)});
<a name="5030"></a>
<a name="5031"></a>        /* show the list */
<a name="5032"></a>        specialContentsLister.showList(gActor, nil, lst, 0, 0, infoTab, nil);
<a name="5033"></a>    }
<a name="5034"></a>
<a name="5035"></a>    /* 
<a name="5036"></a>     *   Get the destination for a thrown object that hits me.  Since we
<a name="5037"></a>     *   don't have a real location, we must ask the actor for our room
<a name="5038"></a>     *   part location, and then use its hit-and-fall destination.  
<a name="5039"></a>     */
<a name="5040"></a>    getHitFallDestination(thrownObj, path)
<a name="5041"></a>    {
<a name="5042"></a>        local loc;
<a name="5043"></a>        local dest;
<a name="5044"></a>        
<a name="5045"></a>        /* 
<a name="5046"></a>         *   if we have an explicit location, start with it; otherwise, ask
<a name="5047"></a>         *   the actor's location to find us; if we can't even find
<a name="5048"></a>         *   ourselves there, just use the actor's current location 
<a name="5049"></a>         */
<a name="5050"></a>        if ((loc = location) == nil
<a name="5051"></a>            &amp;&amp; (loc = gActor.location.getRoomPartLocation(self)) == nil)
<a name="5052"></a>            loc = gActor.location;
<a name="5053"></a>
<a name="5054"></a>        /* use the location's drop destination for thrown objects */
<a name="5055"></a>        dest = loc.getDropDestination(thrownObj, path);
<a name="5056"></a>
<a name="5057"></a>        /* give the destination a chance to make adjustments */
<a name="5058"></a>        return dest.adjustThrowDestination(thrownObj, path);
<a name="5059"></a>    }
<a name="5060"></a>
<a name="5061"></a>    /* consider me to be in any room of which I'm a part */
<a name="5062"></a>    isIn(loc)
<a name="5063"></a>    {
<a name="5064"></a>        local rpl;
<a name="5065"></a>
<a name="5066"></a>        /* 
<a name="5067"></a>         *   get the room-part location of this room part, from the
<a name="5068"></a>         *   perspective of the prospective location we're asking about 
<a name="5069"></a>         */
<a name="5070"></a>        if (loc != nil &amp;&amp; (rpl = loc.getRoomPartLocation(self)) != nil)
<a name="5071"></a>        {
<a name="5072"></a>            /* 
<a name="5073"></a>             *   We indeed have a room part location in the given
<a name="5074"></a>             *   location, so we're a part of the overall location.  We
<a name="5075"></a>             *   might be directly in the location (i.e., 'rpl' could
<a name="5076"></a>             *   equal 'loc'), or we might be somewhere relative to 'loc'
<a name="5077"></a>             *   (for example, we could be within a nested room within
<a name="5078"></a>             *   'loc', in which case 'rpl' is a nested room unequal to
<a name="5079"></a>             *   'loc' but is within 'loc').  So, if 'rpl' equals 'loc' or
<a name="5080"></a>             *   is contained in 'loc', I'm within 'loc', because I'm
<a name="5081"></a>             *   within 'rpl'.  
<a name="5082"></a>             */
<a name="5083"></a>            if (rpl == loc || rpl.isIn(loc))
<a name="5084"></a>                return true;
<a name="5085"></a>        }
<a name="5086"></a>
<a name="5087"></a>        /* 
<a name="5088"></a>         *   we don't appear to be in 'loc' on the basis of our special
<a name="5089"></a>         *   room-part location; fall back on the inherited handling 
<a name="5090"></a>         */
<a name="5091"></a>        return inherited(loc);
<a name="5092"></a>    }
<a name="5093"></a>
<a name="5094"></a>    /* our contents listers */
<a name="5095"></a>    contentsLister = roomPartContentsLister
<a name="5096"></a>    descContentsLister = roomPartDescContentsLister
<a name="5097"></a>    lookInLister = roomPartLookInLister
<a name="5098"></a>    specialContentsLister = specialDescLister
<a name="5099"></a>
<a name="5100"></a>    /* look in/on: show our contents */
<a name="5101"></a>    dobjFor(LookIn)
<a name="5102"></a>    {
<a name="5103"></a>        verify() { }
<a name="5104"></a>        action()
<a name="5105"></a>        {
<a name="5106"></a>            /* show my contents */
<a name="5107"></a>            examinePartContents(&amp;lookInLister);
<a name="5108"></a>
<a name="5109"></a>            /* show my special contents */
<a name="5110"></a>            examineSpecialContents();
<a name="5111"></a>        }
<a name="5112"></a>    }
<a name="5113"></a>
<a name="5114"></a>    /* we can't look behind/through/under a room part by default */
<a name="5115"></a>    nothingUnderMsg = &amp;cannotLookUnderMsg
<a name="5116"></a>    nothingBehindMsg = &amp;cannotLookBehindMsg
<a name="5117"></a>    nothingThroughMsg = &amp;cannotLookThroughMsg
<a name="5118"></a>
<a name="5119"></a>    /* 
<a name="5120"></a>     *   initialization - add myself to my location's roomPart list if I
<a name="5121"></a>     *   have an explicit location 
<a name="5122"></a>     */
<a name="5123"></a>    initializeThing()
<a name="5124"></a>    {
<a name="5125"></a>        /* do the normal work first */
<a name="5126"></a>        inherited();
<a name="5127"></a>
<a name="5128"></a>        /* 
<a name="5129"></a>         *   if I have an explicit location, and I'm not in my location's
<a name="5130"></a>         *   roomPart list, add myself to the list 
<a name="5131"></a>         */
<a name="5132"></a>        if (location != nil &amp;&amp; location.roomParts.indexOf(self) == nil)
<a name="5133"></a>            location.roomParts += self;
<a name="5134"></a>    }
<a name="5135"></a>;
<a name="5136"></a>
<a name="5137"></a>
<a name="5138"></a>/*
<a name="5139"></a> *   A floor for a nested room.  This should be placed directly within a
<a name="5140"></a> *   nested room object if the nested room is to be described as having a
<a name="5141"></a> *   floor separate from the nested room itself.  We simply remap any
<a name="5142"></a> *   commands relating to using the floor as a surface (Put On, Throw At,
<a name="5143"></a> *   Sit On, Lie On, Stand On) to the enclosing nested room.  
<a name="5144"></a> */
<a name="5145"></a>class NestedRoomFloor: Fixture
<a name="5146"></a>    iobjFor(PutOn) remapTo(PutOn, DirectObject, location)
<a name="5147"></a>    iobjFor(ThrowAt) remapTo(ThrowAt, DirectObject, location)
<a name="5148"></a>    dobjFor(SitOn) remapTo(SitOn, location)
<a name="5149"></a>    dobjFor(LieOn) remapTo(LieOn, location)
<a name="5150"></a>    dobjFor(StandOn) remapTo(StandOn, location)
<a name="5151"></a>;
<a name="5152"></a>
<a name="5153"></a>/*
<a name="5154"></a> *   Base class for the default floor and the default ground of a top-level
<a name="5155"></a> *   room.  The floor and ground are where things usually go when dropped,
<a name="5156"></a> *   and they're the locations where actors within a room are normally
<a name="5157"></a> *   standing.  
<a name="5158"></a> */
<a name="5159"></a>class Floor: RoomPart
<a name="5160"></a>    /* specifically allow me as a default for STAND ON, SIT ON, and LIE ON */
<a name="5161"></a>    hideFromDefault(action)
<a name="5162"></a>    {
<a name="5163"></a>        /* don't hide from STAND ON, SIT ON, LIE ON */
<a name="5164"></a>        if (action.ofKind(StandOnAction)
<a name="5165"></a>            || action.ofKind(SitOnAction)
<a name="5166"></a>            || action.ofKind(LieOnAction))
<a name="5167"></a>            return nil;
<a name="5168"></a>
<a name="5169"></a>        /* for other actions, use the standard handling */
<a name="5170"></a>        return inherited(action);
<a name="5171"></a>    }
<a name="5172"></a>
<a name="5173"></a>    /* 
<a name="5174"></a>     *   When explicitly examining a Floor object, list any objects that
<a name="5175"></a>     *   are listed in the normal room description (as in LOOK AROUND).  By
<a name="5176"></a>     *   default, the floor is the nominal container for anything directly
<a name="5177"></a>     *   in the room, so we'll normally want LOOK AROUND and LOOK AT FLOOR
<a name="5178"></a>     *   to produce the same list of objects.  
<a name="5179"></a>     */
<a name="5180"></a>    isObjListedInRoomPart(obj)
<a name="5181"></a>    {
<a name="5182"></a>         /* list the object if it's listed in a normal LOOK AROUND */
<a name="5183"></a>        return obj.isListed;
<a name="5184"></a>    }
<a name="5185"></a>
<a name="5186"></a>    /* 
<a name="5187"></a>     *   'put x on floor' equals 'drop x'.  Add a precondition that the
<a name="5188"></a>     *   drop destination is the main room, since otherwise we could have
<a name="5189"></a>     *   strange results if we dropped something inside a nested room.  
<a name="5190"></a>     */
<a name="5191"></a>    iobjFor(PutOn)
<a name="5192"></a>    {
<a name="5193"></a>        preCond()
<a name="5194"></a>        {
<a name="5195"></a>            /* 
<a name="5196"></a>             *   require that this floor object itself is reachable, and
<a name="5197"></a>             *   that the drop destination for the direct object is an
<a name="5198"></a>             *   outermost room 
<a name="5199"></a>             */
<a name="5200"></a>            return [touchObj, new ObjectPreCondition(
<a name="5201"></a>                gDobj, dropDestinationIsOuterRoom)];
<a name="5202"></a>        }
<a name="5203"></a>        verify() { }
<a name="5204"></a>        action() { replaceAction(Drop, gDobj); }
<a name="5205"></a>    }
<a name="5206"></a>
<a name="5207"></a>    /* 
<a name="5208"></a>     *   The message we use to describe this object prepositionally, as the
<a name="5209"></a>     *   destination of a throw or drop.  This should be a gLibMessages
<a name="5210"></a>     *   property with the appropriate prepositional phrase.  We use a
<a name="5211"></a>     *   custom message specific to floor-like objects.  
<a name="5212"></a>     */
<a name="5213"></a>    putDestMessage = &amp;putDestFloor
<a name="5214"></a>
<a name="5215"></a>    /* 'throw x at floor' */
<a name="5216"></a>    iobjFor(ThrowAt)
<a name="5217"></a>    {
<a name="5218"></a>        check()
<a name="5219"></a>        {
<a name="5220"></a>            /* 
<a name="5221"></a>             *   If I'm reachable, suggest just putting it down instead.
<a name="5222"></a>             *   We only make the suggestion, rather than automatically
<a name="5223"></a>             *   treating the command as DROP, because a player explicitly
<a name="5224"></a>             *   typing THROW &lt;obj&gt; AT FLOOR is probably attempting to
<a name="5225"></a>             *   express something more violent than merely putting the
<a name="5226"></a>             *   object down; the player probably is thinking in terms of
<a name="5227"></a>             *   breaking the object (or the floor).  
<a name="5228"></a>             */
<a name="5229"></a>            if (canBeTouchedBy(gActor))
<a name="5230"></a>            {
<a name="5231"></a>                mainReport(&amp;shouldNotThrowAtFloorMsg);
<a name="5232"></a>                exit;
<a name="5233"></a>            }
<a name="5234"></a>        }
<a name="5235"></a>    }
<a name="5236"></a>
<a name="5237"></a>    /* is the given actor already on the floor? */
<a name="5238"></a>    isActorOnFloor(actor)
<a name="5239"></a>    {
<a name="5240"></a>        /* 
<a name="5241"></a>         *   the actor is on the floor if the actor is directly in the
<a name="5242"></a>         *   floor's room-part-location for the actor's location 
<a name="5243"></a>         */
<a name="5244"></a>        return actor.isDirectlyIn(actor.location.getRoomPartLocation(self));
<a name="5245"></a>    }
<a name="5246"></a>
<a name="5247"></a>    /* verify sitting/standing/lying on the floor */
<a name="5248"></a>    verifyEntry(newPosture, alreadyMsg)
<a name="5249"></a>    {
<a name="5250"></a>        /* 
<a name="5251"></a>         *   If we're already in my location, and we're in the desired
<a name="5252"></a>         *   posture, this command is illogical because we're already
<a name="5253"></a>         *   where they want us to end up.  Otherwise, it's logical to
<a name="5254"></a>         *   stand/sit/lie on the floor, but rank it low since we don't
<a name="5255"></a>         *   want the floor to interfere with selecting a default if
<a name="5256"></a>         *   there's anything around that's actually like a chair.
<a name="5257"></a>         *   
<a name="5258"></a>         *   If it's logical, note that we've verified okay for the
<a name="5259"></a>         *   action.  On a future pass, we might have enforced a
<a name="5260"></a>         *   precondition that moved us here, at which point our work will
<a name="5261"></a>         *   be done - but we don't want to complain in that case, since
<a name="5262"></a>         *   it was logical from the player's perspective to carry out the
<a name="5263"></a>         *   command even though we have nothing left to do.  
<a name="5264"></a>         */
<a name="5265"></a>        if (gActor.posture == newPosture
<a name="5266"></a>            &amp;&amp; isActorOnFloor(gActor)
<a name="5267"></a>            &amp;&amp; gAction.verifiedOkay.indexOf(self) == nil)
<a name="5268"></a>        {
<a name="5269"></a>            /* we're already on the floor in the desired posture */
<a name="5270"></a>            illogicalNow(alreadyMsg);
<a name="5271"></a>        }
<a name="5272"></a>        else
<a name="5273"></a>        {
<a name="5274"></a>            /* 
<a name="5275"></a>             *   it's logical, but rank it low in case there's something
<a name="5276"></a>             *   more special we can stand/sit/lie on 
<a name="5277"></a>             */
<a name="5278"></a>            logicalRank(50, 'on floor');
<a name="5279"></a>
<a name="5280"></a>            /* 
<a name="5281"></a>             *   note that we've verified okay, so we don't complain on a
<a name="5282"></a>             *   future pass if we discover that a precondition has
<a name="5283"></a>             *   brought us into compliance with the request prematurely 
<a name="5284"></a>             */
<a name="5285"></a>            gAction.verifiedOkay += self;
<a name="5286"></a>        }
<a name="5287"></a>    }
<a name="5288"></a>
<a name="5289"></a>    /* perform sitting/standing/lying on the floor */
<a name="5290"></a>    performEntry(newPosture)
<a name="5291"></a>    {
<a name="5292"></a>        /* 
<a name="5293"></a>         *   bring the new posture into effect; there's no need for
<a name="5294"></a>         *   actually moving the actor, since the preconditions will have
<a name="5295"></a>         *   moved us to our main enclosing room already 
<a name="5296"></a>         */
<a name="5297"></a>        gActor.makePosture(newPosture);
<a name="5298"></a>
<a name="5299"></a>        /* report success */
<a name="5300"></a>        defaultReport(&amp;roomOkayPostureChangeMsg, newPosture, self);
<a name="5301"></a>    }
<a name="5302"></a>
<a name="5303"></a>    /* 'stand on floor' causes actor to stand in the containing room */
<a name="5304"></a>    dobjFor(StandOn)
<a name="5305"></a>    {
<a name="5306"></a>        preCond = [touchObj,
<a name="5307"></a>                   new ObjectPreCondition(gActor.location.getOutermostRoom(),
<a name="5308"></a>                                          actorDirectlyInRoom)]
<a name="5309"></a>        verify() { verifyEntry(standing, &amp;alreadyStandingOnMsg); }
<a name="5310"></a>        action() { performEntry(standing); }
<a name="5311"></a>    }
<a name="5312"></a>
<a name="5313"></a>    /* 'sit on floor' causes the actor to sit in the containing room */
<a name="5314"></a>    dobjFor(SitOn)
<a name="5315"></a>    {
<a name="5316"></a>        preCond = [touchObj,
<a name="5317"></a>                   new ObjectPreCondition(gActor.location.getOutermostRoom(),
<a name="5318"></a>                                          actorDirectlyInRoom)]
<a name="5319"></a>        verify() { verifyEntry(sitting, &amp;alreadySittingOnMsg); }
<a name="5320"></a>        action() { performEntry(sitting); }
<a name="5321"></a>    }
<a name="5322"></a>
<a name="5323"></a>    /* 'lie on floor' causes the actor to lie down in the room */
<a name="5324"></a>    dobjFor(LieOn)
<a name="5325"></a>    {
<a name="5326"></a>        preCond = [touchObj,
<a name="5327"></a>                   new ObjectPreCondition(gActor.location.getOutermostRoom(),
<a name="5328"></a>                                          actorDirectlyInRoom)]
<a name="5329"></a>        verify() { verifyEntry(lying, &amp;alreadyLyingOnMsg); }
<a name="5330"></a>        action() { performEntry(lying); }
<a name="5331"></a>    }
<a name="5332"></a>
<a name="5333"></a>    /* 
<a name="5334"></a>     *   Mention that an actor is here, as part of a room description.
<a name="5335"></a>     *   When the actor is standing, just say that the actor is here, since
<a name="5336"></a>     *   it's overstating the obvious to say that the actor is standing on
<a name="5337"></a>     *   the floor.  For other postures, do mention the floor.  
<a name="5338"></a>     */
<a name="5339"></a>    roomActorHereDesc(actor)
<a name="5340"></a>    {
<a name="5341"></a>        /* 
<a name="5342"></a>         *   if we're standing, just say that the actor is "here";
<a name="5343"></a>         *   otherwise, say that the actor is sitting/lying/etc on self 
<a name="5344"></a>         */
<a name="5345"></a>        if (actor.posture == standing)
<a name="5346"></a>            gLibMessages.roomActorHereDesc(actor);
<a name="5347"></a>        else
<a name="5348"></a>            gLibMessages.actorInRoom(actor, self);
<a name="5349"></a>    }
<a name="5350"></a>
<a name="5351"></a>    /* 
<a name="5352"></a>     *   Mention that an actor is here, as part of a room description.
<a name="5353"></a>     *   Since a floor is a trivial part of its enclosing room, there's no
<a name="5354"></a>     *   point in mentioning that we're on the floor, as that's stating the
<a name="5355"></a>     *   obvious; instead, simply describe the actor as being in the
<a name="5356"></a>     *   actor's actual enclosing room.  
<a name="5357"></a>     */
<a name="5358"></a>    roomActorThereDesc(actor) { actor.location.roomActorThereDesc(actor); }
<a name="5359"></a>
<a name="5360"></a>    /*
<a name="5361"></a>     *   Show our room name status for an actor on the floor.  Since
<a name="5362"></a>     *   standing on the floor is the trivial default for any room, we
<a name="5363"></a>     *   won't bother mentioning it.  Other postures we'll mention the same
<a name="5364"></a>     *   way we would for any nested room.  
<a name="5365"></a>     */
<a name="5366"></a>    roomActorStatus(actor)
<a name="5367"></a>    {
<a name="5368"></a>        if (actor.posture != standing)
<a name="5369"></a>            gLibMessages.actorInRoomStatus(actor, self);
<a name="5370"></a>    }
<a name="5371"></a>
<a name="5372"></a>    /* 
<a name="5373"></a>     *   Show the actor's posture here.  When we're standing on the floor,
<a name="5374"></a>     *   don't mention the posture, as this is too trivial a condition to
<a name="5375"></a>     *   state.  Otherwise, mention it as normal for a nested room.  
<a name="5376"></a>     */
<a name="5377"></a>    roomActorPostureDesc(actor)
<a name="5378"></a>    {
<a name="5379"></a>        if (actor.posture != standing)
<a name="5380"></a>            gLibMessages.actorInRoomPosture(actor, self);
<a name="5381"></a>    }
<a name="5382"></a>
<a name="5383"></a>    /* 
<a name="5384"></a>     *   Generate an acknowledgment for a posture change here.  If the
<a name="5385"></a>     *   actor is standing, just say "okay, you're now standing" without
<a name="5386"></a>     *   mentioning the floor, since standing on the floor is the trivial
<a name="5387"></a>     *   default.  For other postures, say that we're sitting/lying/etc on
<a name="5388"></a>     *   the floor.  
<a name="5389"></a>     */
<a name="5390"></a>    roomOkayPostureChange(actor)
<a name="5391"></a>    {
<a name="5392"></a>        if (actor.posture == standing)
<a name="5393"></a>            defaultReport(&amp;okayPostureChangeMsg, standing);
<a name="5394"></a>        else
<a name="5395"></a>            defaultReport(&amp;roomOkayPostureChangeMsg, actor.posture, self);
<a name="5396"></a>    }
<a name="5397"></a>
<a name="5398"></a>    /* 
<a name="5399"></a>     *   mention the actor as part of the EXAMINE description of a nested
<a name="5400"></a>     *   room containing the actor 
<a name="5401"></a>     */
<a name="5402"></a>    roomListActorPosture(actor)
<a name="5403"></a>    {
<a name="5404"></a>        /*
<a name="5405"></a>         *   Since standing is the default posture for an actor, and since
<a name="5406"></a>         *   the floor (or equivalent) is the default place to be standing,
<a name="5407"></a>         *   don't bother mentioning actors standing on a floor.
<a name="5408"></a>         *   Otherwise, mention that the actor is sitting/lying/etc here.  
<a name="5409"></a>         */
<a name="5410"></a>        if (actor.posture != standing)
<a name="5411"></a>            gLibMessages.actorInRoom(actor, self);
<a name="5412"></a>    }
<a name="5413"></a>    
<a name="5414"></a>    /*
<a name="5415"></a>     *   Prefix and suffix messages for listing a group of actors
<a name="5416"></a>     *   nominally on the this floor.  Actors are said to be on the floor
<a name="5417"></a>     *   when they're really in the location containing the floor.
<a name="5418"></a>     *   
<a name="5419"></a>     *   If we're talking about a remote location, simply describe it as
<a name="5420"></a>     *   the location rather than mentioning the floor, since the floor is
<a name="5421"></a>     *   a trivial part of the remote location not worth mentioning.
<a name="5422"></a>     *   
<a name="5423"></a>     *   If we're local, and we're standing, we'll simply say that we're
<a name="5424"></a>     *   "standing here"; again, saying that we're standing on the floor
<a name="5425"></a>     *   is stating the obvious.  If we're not standing, we will mention
<a name="5426"></a>     *   that we're on the floor.  
<a name="5427"></a>     */
<a name="5428"></a>    actorInGroupPrefix(pov, posture, remote, lst)
<a name="5429"></a>    {
<a name="5430"></a>        if (remote != nil)
<a name="5431"></a>            gLibMessages.actorThereGroupPrefix(pov, posture, remote, lst);
<a name="5432"></a>        else if (posture == standing)
<a name="5433"></a>            gLibMessages.actorHereGroupPrefix(posture, lst);
<a name="5434"></a>        else
<a name="5435"></a>            gLibMessages.actorInGroupPrefix(posture, self, lst);
<a name="5436"></a>    }
<a name="5437"></a>    actorInGroupSuffix(pov, posture, remote, lst)
<a name="5438"></a>    {
<a name="5439"></a>        if (remote != nil)
<a name="5440"></a>            gLibMessages.actorThereGroupSuffix(pov, posture, remote, lst);
<a name="5441"></a>        else if (posture == standing)
<a name="5442"></a>            gLibMessages.actorHereGroupSuffix(posture, lst);
<a name="5443"></a>        else
<a name="5444"></a>            gLibMessages.actorInGroupSuffix(posture, self, lst);
<a name="5445"></a>    }
<a name="5446"></a>;
<a name="5447"></a>
<a name="5448"></a>/* ------------------------------------------------------------------------ */
<a name="5449"></a>/*
<a name="5450"></a> *   Define the default room parts. 
<a name="5451"></a> */
<a name="5452"></a>
<a name="5453"></a>/*
<a name="5454"></a> *   the default floor, for indoor locations 
<a name="5455"></a> */
<a name="5456"></a>defaultFloor: Floor
<a name="5457"></a>;
<a name="5458"></a>
<a name="5459"></a>/*
<a name="5460"></a> *   the default ceiling, for indoor locations 
<a name="5461"></a> */
<a name="5462"></a>defaultCeiling: RoomPart
<a name="5463"></a>;
<a name="5464"></a>
<a name="5465"></a>/*
<a name="5466"></a> *   The default walls, for indoor locations.  We provide a north, south,
<a name="5467"></a> *   east, and west wall in each indoor location by default. 
<a name="5468"></a> */
<a name="5469"></a>class DefaultWall: RoomPart
<a name="5470"></a>;
<a name="5471"></a>
<a name="5472"></a>defaultNorthWall: DefaultWall
<a name="5473"></a>;
<a name="5474"></a>
<a name="5475"></a>defaultSouthWall: DefaultWall
<a name="5476"></a>;
<a name="5477"></a>
<a name="5478"></a>defaultEastWall: DefaultWall
<a name="5479"></a>;
<a name="5480"></a>
<a name="5481"></a>defaultWestWall: DefaultWall
<a name="5482"></a>;
<a name="5483"></a>
<a name="5484"></a>/*
<a name="5485"></a> *   the default sky, for outdoor locations 
<a name="5486"></a> */
<a name="5487"></a>defaultSky: Distant, RoomPart
<a name="5488"></a>;
<a name="5489"></a>
<a name="5490"></a>/*
<a name="5491"></a> *   The default ground, for outdoor locations.
<a name="5492"></a> */
<a name="5493"></a>defaultGround: Floor
<a name="5494"></a>;
<a name="5495"></a>
<a name="5496"></a>/* ------------------------------------------------------------------------ */
<a name="5497"></a>/*
<a name="5498"></a> *   A "room part item" is an object that's specially described as being
<a name="5499"></a> *   part of, or attached to, a RoomPart (a wall, ceiling, floor, or the
<a name="5500"></a> *   like).  This is a mix-in class that can be combined with any ordinary
<a name="5501"></a> *   object class (but usually with something non-portable, such as a
<a name="5502"></a> *   Fixture or Immovable).  The effect of adding RoomPartItem to an
<a name="5503"></a> *   object's superclasses is that a command like EXAMINE EAST WALL (or
<a name="5504"></a> *   whichever room part the object is associated with) will display the
<a name="5505"></a> *   object's specialDesc, but a simple LOOK will not.  This class is
<a name="5506"></a> *   sometimes useful for things like doors, windows, ceiling fans, and
<a name="5507"></a> *   other things attached to the room.
<a name="5508"></a> *   
<a name="5509"></a> *   Note that this is a mix-in class, so you should always combine it with
<a name="5510"></a> *   a regular Thing-based class.
<a name="5511"></a> *   
<a name="5512"></a> *   When using this class, you should define two properties in the object:
<a name="5513"></a> *   specialNominalRoomPartLocation, which you should set to the RoomPart
<a name="5514"></a> *   (such as a wall) where the object should be described; and
<a name="5515"></a> *   specialDesc, which is the description to show when the room part is
<a name="5516"></a> *   examined.  Alternatively (or in addition), you can define
<a name="5517"></a> *   initNominalRoomPartLocation and initSpecialDesc - these work the same
<a name="5518"></a> *   way, but will only be in effect until the object is moved.  
<a name="5519"></a> */
<a name="5520"></a>class RoomPartItem: object
<a name="5521"></a>    /* 
<a name="5522"></a>     *   show our special description when examining our associated room
<a name="5523"></a>     *   part, as long as we actually define a special description 
<a name="5524"></a>     */
<a name="5525"></a>    useSpecialDescInRoomPart(part)
<a name="5526"></a>    {
<a name="5527"></a>        /* only show the special description in our associated room part */
<a name="5528"></a>        if (!isNominallyInRoomPart(part))
<a name="5529"></a>            return nil;
<a name="5530"></a>
<a name="5531"></a>        /* 
<a name="5532"></a>         *   if we define an initial special description, and this is our
<a name="5533"></a>         *   nominal room part for that description, use it
<a name="5534"></a>         */
<a name="5535"></a>        if (isInInitState
<a name="5536"></a>            &amp;&amp; propType(&amp;initSpecialDesc) != TypeNil
<a name="5537"></a>            &amp;&amp; initNominalRoomPartLocation == part)
<a name="5538"></a>            return true;
<a name="5539"></a>
<a name="5540"></a>        /* likewise for our specialDesc */
<a name="5541"></a>        if (propType(&amp;specialDesc) != TypeNil
<a name="5542"></a>            &amp;&amp; specialNominalRoomPartLocation == part)
<a name="5543"></a>            return true;
<a name="5544"></a>
<a name="5545"></a>        /* otherwise, don't use the special description */
<a name="5546"></a>        return nil;
<a name="5547"></a>    }
<a name="5548"></a>
<a name="5549"></a>    /* 
<a name="5550"></a>     *   don't use the special description in room descriptions, or in
<a name="5551"></a>     *   examining any other container 
<a name="5552"></a>     */
<a name="5553"></a>    useSpecialDescInRoom(room) { return nil; }
<a name="5554"></a>    useSpecialDescInContents(cont) { return nil; }
<a name="5555"></a>;
<a name="5556"></a>
<a name="5557"></a>/* ------------------------------------------------------------------------ */
<a name="5558"></a>/*
<a name="5559"></a> *   A Nested Room is any object that isn't a room but which can contain
<a name="5560"></a> *   an actor: chairs, beds, platforms, vehicles, and the like.
<a name="5561"></a> *   
<a name="5562"></a> *   An important property of nested rooms is that they're not
<a name="5563"></a> *   full-fledged rooms for the purposes of actor arrivals and departures.
<a name="5564"></a> *   Specifically, an actor moving from a room to a nested room within the
<a name="5565"></a> *   room does not trigger an actor.travelTo invocation, but simply moves
<a name="5566"></a> *   the actor from the containing room to the nested room.  Moving from
<a name="5567"></a> *   the nested room to the containing room likewise triggers no
<a name="5568"></a> *   actor.travelTo invocation.  The travelTo method is not applicable for
<a name="5569"></a> *   intra-room travel because no TravelConnector objects are traversed in
<a name="5570"></a> *   such travel; we simply move in and out of contained objects.  To
<a name="5571"></a> *   mitigate this loss of notification, we instead call
<a name="5572"></a> *   actor.travelWithin() when moving among nested locations.
<a name="5573"></a> *   
<a name="5574"></a> *   By default, an actor attempting to travel from a nested location via
<a name="5575"></a> *   a directional command will simply attempt the travel as though the
<a name="5576"></a> *   actor were in the enclosing location.  
<a name="5577"></a> */
<a name="5578"></a>class NestedRoom: BasicLocation
<a name="5579"></a>    /*
<a name="5580"></a>     *   Our interior room name.  This is the status line name we display
<a name="5581"></a>     *   when an actor is within this object and can't see out to the
<a name="5582"></a>     *   enclosing room.  Since we can't rely on the enclosing room's
<a name="5583"></a>     *   status line name if we can't see the enclosing room, we must
<a name="5584"></a>     *   provide one of our own.
<a name="5585"></a>     *   
<a name="5586"></a>     *   By default, we'll use our regular name.  
<a name="5587"></a>     */
<a name="5588"></a>    roomName = (name)
<a name="5589"></a>
<a name="5590"></a>    /*
<a name="5591"></a>     *   Show our interior room description.  We use this to generate the
<a name="5592"></a>     *   long "look" description for the room when an actor is within the
<a name="5593"></a>     *   room and cannot see the enclosing room.
<a name="5594"></a>     *   
<a name="5595"></a>     *   Note that this is used ONLY when the actor cannot see the
<a name="5596"></a>     *   enclosing room - when the enclosing room is visible (because the
<a name="5597"></a>     *   nested room is something like a chair that doesn't enclose the
<a name="5598"></a>     *   actor, or can enclose the actor but is open or transparent), then
<a name="5599"></a>     *   we'll simply use the description of the enclosing room instead,
<a name="5600"></a>     *   adding a note to the short name shown at the start of the room
<a name="5601"></a>     *   description indicating that the actor is in the nested room.
<a name="5602"></a>     *   
<a name="5603"></a>     *   By default, we'll show the appropriate "actor here" description
<a name="5604"></a>     *   for the posture, so we'll say something like "You are sitting on
<a name="5605"></a>     *   the red chair" or "You are in the phone booth."  Instances can
<a name="5606"></a>     *   override this to customize the description with something more
<a name="5607"></a>     *   detailed, if desired.  
<a name="5608"></a>     */
<a name="5609"></a>    roomDesc
<a name="5610"></a>    {
<a name="5611"></a>        local pov = getPOVActorDefault(gActor);
<a name="5612"></a>        pov.listActorPosture(pov);
<a name="5613"></a>    }
<a name="5614"></a>
<a name="5615"></a>    /*
<a name="5616"></a>     *   The maximum bulk the room can hold.  We'll define this to a large
<a name="5617"></a>     *   number by default so that bulk isn't a concern.
<a name="5618"></a>     *   
<a name="5619"></a>     *   Lower numbers here can be used, for example, to limit the seating
<a name="5620"></a>     *   capacity of a chair.  
<a name="5621"></a>     */
<a name="5622"></a>    bulkCapacity = 10000
<a name="5623"></a>
<a name="5624"></a>    /*
<a name="5625"></a>     *   Check for ownership.  For a nested room, an actor can be taken to
<a name="5626"></a>     *   own the nested room by virtue of being inside the room - the
<a name="5627"></a>     *   chair Bob is sitting in can be called "bob's chair".
<a name="5628"></a>     *   
<a name="5629"></a>     *   If we don't have an explicit owner, and the potential owner 'obj'
<a name="5630"></a>     *   is in me and can own me, we'll report that 'obj' does in fact own
<a name="5631"></a>     *   me.  Otherwise, we'll defer to the inherited implementation.  
<a name="5632"></a>     */
<a name="5633"></a>    isOwnedBy(obj)
<a name="5634"></a>    {
<a name="5635"></a>        /* 
<a name="5636"></a>         *   if we're not explicitly owned, and 'obj' can own me, and
<a name="5637"></a>         *   'obj' is inside me, consider us owned by 'obj' 
<a name="5638"></a>         */
<a name="5639"></a>        if (owner == nil &amp;&amp; obj.isIn(self) &amp;&amp; obj.canOwn(self))
<a name="5640"></a>            return true;
<a name="5641"></a>
<a name="5642"></a>        /* defer to the inherited definition of ownership */
<a name="5643"></a>        return inherited(obj);
<a name="5644"></a>    }
<a name="5645"></a>
<a name="5646"></a>    /*
<a name="5647"></a>     *   Get the extra scope items within this room.  Normally, the
<a name="5648"></a>     *   immediately enclosing nested room is in scope for an actor in the
<a name="5649"></a>     *   room.  So, if the actor is directly in 'self', return 'self'.  
<a name="5650"></a>     */
<a name="5651"></a>    getExtraScopeItems(actor)
<a name="5652"></a>    {
<a name="5653"></a>        /* if the actor is directly in the nested room, return it */
<a name="5654"></a>        if (actor.isDirectlyIn(self))
<a name="5655"></a>            return [self];
<a name="5656"></a>        else
<a name="5657"></a>            return [];
<a name="5658"></a>    }
<a name="5659"></a>
<a name="5660"></a>    /* 
<a name="5661"></a>     *   By default, 'out' within a nested room should take us out of the
<a name="5662"></a>     *   nested room itself.  The easy way to accomplish this is to set up
<a name="5663"></a>     *   a 'nestedRoomOut' connector for the nested room, which will
<a name="5664"></a>     *   automatically try a GET OUT command.  If we didn't do this, we'd
<a name="5665"></a>     *   *usually* pick up the noTravelOut from our enclosing room, but
<a name="5666"></a>     *   only when the enclosing room didn't override 'out' to point
<a name="5667"></a>     *   somewhere else.  Explicitly setting up a 'noTravelOut' here
<a name="5668"></a>     *   ensures that we'll consistently GET OUT of the nested room even if
<a name="5669"></a>     *   the enclosing room has its own 'out' destination.
<a name="5670"></a>     *   
<a name="5671"></a>     *   Note that nestedRoomOut shows as a listed exit in exit listings
<a name="5672"></a>     *   (for the EXITS command and in the status line).  If you don't want
<a name="5673"></a>     *   OUT to be listed as an available exit for the nested room, you
<a name="5674"></a>     *   should override this to use noTravelOut instead.  
<a name="5675"></a>     */
<a name="5676"></a>    out = nestedRoomOut
<a name="5677"></a>
<a name="5678"></a>    /*
<a name="5679"></a>     *   An actor is attempting to "get out" while in this location.  By
<a name="5680"></a>     *   default, we'll treat this as getting out of this object.  This
<a name="5681"></a>     *   can be overridden if "get out" should do something different.  
<a name="5682"></a>     */
<a name="5683"></a>    disembarkRoom()
<a name="5684"></a>    {
<a name="5685"></a>        /* run the appropriate command to get out of this nested room */
<a name="5686"></a>        removeFromNested();
<a name="5687"></a>    }
<a name="5688"></a>
<a name="5689"></a>    /*
<a name="5690"></a>     *   Make the actor stand up from this location.  By default, we'll
<a name="5691"></a>     *   cause the actor to travel (using travelWithin) to our container,
<a name="5692"></a>     *   and assume the appropriate posture for the container.  
<a name="5693"></a>     */
<a name="5694"></a>    makeStandingUp()
<a name="5695"></a>    {
<a name="5696"></a>        /* remember the old posture, in case the travel fails */
<a name="5697"></a>        local oldPosture = gActor.posture;
<a name="5698"></a>
<a name="5699"></a>        /* get the exit destination; if there isn't one, we can't proceed */
<a name="5700"></a>        local dest = exitDestination;
<a name="5701"></a>        if (dest == nil)
<a name="5702"></a>        {
<a name="5703"></a>            reportFailure(&amp;cannotDoFromHereMsg);
<a name="5704"></a>            exit;
<a name="5705"></a>        }
<a name="5706"></a>        
<a name="5707"></a>        /* 
<a name="5708"></a>         *   Set the actor's posture to the default for the destination.
<a name="5709"></a>         *   Do this before effecting the actual travel, so that the
<a name="5710"></a>         *   destination can change this default if it wants.  
<a name="5711"></a>         */
<a name="5712"></a>        gActor.makePosture(dest.defaultPosture);
<a name="5713"></a>
<a name="5714"></a>        /* protect against 'exit' and the like during the travel attempt */
<a name="5715"></a>        try
<a name="5716"></a>        {
<a name="5717"></a>            /* 
<a name="5718"></a>             *   move the actor to our exit destination, traveling entirely
<a name="5719"></a>             *   within nested locations 
<a name="5720"></a>             */
<a name="5721"></a>            gActor.travelWithin(dest);
<a name="5722"></a>        }
<a name="5723"></a>        finally
<a name="5724"></a>        {
<a name="5725"></a>            /* if we didn't end up traveling, restore the old posture */
<a name="5726"></a>            if (gActor.isIn(self))
<a name="5727"></a>                gActor.makePosture(oldPosture);
<a name="5728"></a>        }
<a name="5729"></a>
<a name="5730"></a>        /* generate the appropriate default for the new location */
<a name="5731"></a>        gActor.okayPostureChange();
<a name="5732"></a>    }
<a name="5733"></a>
<a name="5734"></a>    /*
<a name="5735"></a>     *   Try an implied command to move the actor from outside of this
<a name="5736"></a>     *   nested room into this nested room.  This must be overridden in
<a name="5737"></a>     *   subclasses to carry out the appropriate implied command.  Returns
<a name="5738"></a>     *   the result of tryImplicitAction().
<a name="5739"></a>     *   
<a name="5740"></a>     *   This is called when we need to move an actor into this location
<a name="5741"></a>     *   as part of an implied command.  We use an overridable method
<a name="5742"></a>     *   because different kinds of nested rooms have different commands
<a name="5743"></a>     *   for entering: SIT ON CHAIR, LIE ON BED, GET IN CAR, RIDE BIKE,
<a name="5744"></a>     *   and so on.  This should be normally be overridden imply by
<a name="5745"></a>     *   calling tryImplicitAction() with the appropriate command for the
<a name="5746"></a>     *   specific type of nested room, and returning the result.  
<a name="5747"></a>     */
<a name="5748"></a>    tryMovingIntoNested()
<a name="5749"></a>    {
<a name="5750"></a>        /* do nothing by default - subclasses must override */
<a name="5751"></a>        return nil;
<a name="5752"></a>    }
<a name="5753"></a>
<a name="5754"></a>    /* 
<a name="5755"></a>     *   message property to use for reportFailure when
<a name="5756"></a>     *   tryMovingIntoNested fails 
<a name="5757"></a>     */
<a name="5758"></a>    mustMoveIntoProp = nil
<a name="5759"></a>
<a name="5760"></a>    /*
<a name="5761"></a>     *   Try an implied command to remove an actor from this location and
<a name="5762"></a>     *   place the actor in my immediate containing location.  This must
<a name="5763"></a>     *   be overridden in subclasses to carry out the appropriate implied
<a name="5764"></a>     *   command.  Returns the result of tryImplicitAction().
<a name="5765"></a>     *   
<a name="5766"></a>     *   This is essentially the reverse of tryMovingIntoNested(), and
<a name="5767"></a>     *   should in most cases be implemented by calling
<a name="5768"></a>     *   tryImplicitAction() with the appropriate command to get out of
<a name="5769"></a>     *   the room, and returning the result.  
<a name="5770"></a>     */
<a name="5771"></a>    tryRemovingFromNested()
<a name="5772"></a>    {
<a name="5773"></a>        /* do nothing by default - subclasses must override */
<a name="5774"></a>        return nil;
<a name="5775"></a>    }
<a name="5776"></a>
<a name="5777"></a>    /*
<a name="5778"></a>     *   Replace the current action with one that removes the actor from
<a name="5779"></a>     *   this nested room.  This is used to implement the GET OUT command
<a name="5780"></a>     *   when the actor is directly in this nested room.  In most cases,
<a name="5781"></a>     *   this should simply be implemented with a call to replaceAction()
<a name="5782"></a>     *   with the appropriate command.  
<a name="5783"></a>     */
<a name="5784"></a>    removeFromNested()
<a name="5785"></a>    {
<a name="5786"></a>        /* subclasses must override */
<a name="5787"></a>    }
<a name="5788"></a>
<a name="5789"></a>    /*
<a name="5790"></a>     *   Try moving the actor into this location.  This is used to move
<a name="5791"></a>     *   the actor into this location as part of meeting preconditions,
<a name="5792"></a>     *   and we use the normal precondition check protocol: we return nil
<a name="5793"></a>     *   if the condition (actor is in this room) is already met; we
<a name="5794"></a>     *   return true if we successfully execute an implied command to meet
<a name="5795"></a>     *   the condition; and we report a failure message and terminate the
<a name="5796"></a>     *   command with 'exit' if we don't know how to meet the condition or
<a name="5797"></a>     *   the implied command we try to execute fails or fails to satisfy
<a name="5798"></a>     *   the condition.
<a name="5799"></a>     *   
<a name="5800"></a>     *   This does not normally need to be overridden in subclasses.  
<a name="5801"></a>     */
<a name="5802"></a>    checkMovingActorInto(allowImplicit)
<a name="5803"></a>    {
<a name="5804"></a>        /* if the actor is within me, use default handling */
<a name="5805"></a>        if (gActor.isIn(self))
<a name="5806"></a>            return inherited(allowImplicit);
<a name="5807"></a>
<a name="5808"></a>        /* try an implied command to move the actor into this nested room */
<a name="5809"></a>        if (allowImplicit &amp;&amp; tryMovingIntoNested())
<a name="5810"></a>        {
<a name="5811"></a>            /* if we didn't succeed, terminate the command */
<a name="5812"></a>            if (!gActor.isDirectlyIn(self))
<a name="5813"></a>                exit;
<a name="5814"></a>
<a name="5815"></a>            /* tell the caller we executed an implied command */
<a name="5816"></a>            return true;
<a name="5817"></a>        }
<a name="5818"></a>
<a name="5819"></a>        /* 
<a name="5820"></a>         *   if we can be seen, report that the actor must travel here
<a name="5821"></a>         *   first; if we can't be seen, simply say that this can't be done
<a name="5822"></a>         *   from here 
<a name="5823"></a>         */
<a name="5824"></a>        if (gActor.canSee(self))
<a name="5825"></a>        {
<a name="5826"></a>            /* report that we have to move into 'self' first */
<a name="5827"></a>            reportFailure(mustMoveIntoProp, self);
<a name="5828"></a>        }
<a name="5829"></a>        else
<a name="5830"></a>        {
<a name="5831"></a>            /* 
<a name="5832"></a>             *   we can't be seen; simply say this we can't do this command
<a name="5833"></a>             *   from the current location 
<a name="5834"></a>             */
<a name="5835"></a>            reportFailure(&amp;cannotDoFromHereMsg);
<a name="5836"></a>        }
<a name="5837"></a>
<a name="5838"></a>        /* terminate the action */
<a name="5839"></a>        exit;
<a name="5840"></a>    }
<a name="5841"></a>
<a name="5842"></a>    /*
<a name="5843"></a>     *   Check, using pre-condition rules, that the actor is removed from
<a name="5844"></a>     *   this nested location and moved to my immediate location.  This is
<a name="5845"></a>     *   used to enforce a precondition that the actor is in the enclosing
<a name="5846"></a>     *   location.
<a name="5847"></a>     *   
<a name="5848"></a>     *   This isn't normally overridden in subclasses.  
<a name="5849"></a>     */
<a name="5850"></a>    checkActorOutOfNested(allowImplicit)
<a name="5851"></a>    {
<a name="5852"></a>        /* try removing the actor from this nested location */
<a name="5853"></a>        if (allowImplicit &amp;&amp; tryRemovingFromNested())
<a name="5854"></a>        {
<a name="5855"></a>            /* 
<a name="5856"></a>             *   make sure we managed to move the actor to our exit
<a name="5857"></a>             *   destination 
<a name="5858"></a>             */
<a name="5859"></a>            if (!gActor.isDirectlyIn(exitDestination))
<a name="5860"></a>                exit;
<a name="5861"></a>
<a name="5862"></a>            /* indicate that we carried out an implied command */
<a name="5863"></a>            return true;
<a name="5864"></a>        }
<a name="5865"></a>
<a name="5866"></a>        /* we can't carry out our implied departure plan - fail */
<a name="5867"></a>        reportFailure(&amp;cannotDoFromMsg, self);
<a name="5868"></a>        exit;
<a name="5869"></a>    }
<a name="5870"></a>
<a name="5871"></a>    /*
<a name="5872"></a>     *   Check, using pre-condition rules, that the actor is ready to
<a name="5873"></a>     *   enter this room as a nested location.
<a name="5874"></a>     *   
<a name="5875"></a>     *   This isn't normally overridden in subclasses.  
<a name="5876"></a>     */
<a name="5877"></a>    checkActorReadyToEnterNestedRoom(allowImplicit)
<a name="5878"></a>    {
<a name="5879"></a>        /* 
<a name="5880"></a>         *   If the actor is directly in this room, we obviously need do
<a name="5881"></a>         *   nothing, as the actor is already in this nested room.  
<a name="5882"></a>         */
<a name="5883"></a>        if (gActor.isDirectlyIn(self))
<a name="5884"></a>            return nil;
<a name="5885"></a>
<a name="5886"></a>        /*
<a name="5887"></a>         *   If the actor isn't within us (directly or indirectly), we
<a name="5888"></a>         *   must move the actor to a valid "staging location," so that
<a name="5889"></a>         *   the actor can move from the staging location into us.  (A
<a name="5890"></a>         *   staging location is simply any location from which we can
<a name="5891"></a>         *   move directly into this nested room without any intervening
<a name="5892"></a>         *   travel in or out of other nested rooms.)  
<a name="5893"></a>         */
<a name="5894"></a>        if (!gActor.isIn(self))
<a name="5895"></a>            return checkActorInStagingLocation(allowImplicit);
<a name="5896"></a>
<a name="5897"></a>        /*
<a name="5898"></a>         *   The actor is within us, but isn't directly within us, so
<a name="5899"></a>         *   handle this with the normal routine to move the actor into
<a name="5900"></a>         *   this room. 
<a name="5901"></a>         */
<a name="5902"></a>        return checkMovingActorInto(allowImplicit);
<a name="5903"></a>    }
<a name="5904"></a>
<a name="5905"></a>    /*
<a name="5906"></a>     *   Check, using precondition rules, that the actor is in a valid
<a name="5907"></a>     *   "staging location" for entering this nested room.  We'll ensure
<a name="5908"></a>     *   that the actor is directly in one of the locations in our
<a name="5909"></a>     *   stagingLocations list, running an appropriate implicit command to
<a name="5910"></a>     *   move the actor to the first item in that list if the actor isn't
<a name="5911"></a>     *   in any of them.
<a name="5912"></a>     *   
<a name="5913"></a>     *   This isn't normally overridden in subclasses.
<a name="5914"></a>     */
<a name="5915"></a>    checkActorInStagingLocation(allowImplicit)
<a name="5916"></a>    {
<a name="5917"></a>        local lst;
<a name="5918"></a>        local target;
<a name="5919"></a>
<a name="5920"></a>        /* get the list of staging locations */
<a name="5921"></a>        lst = stagingLocations;
<a name="5922"></a>
<a name="5923"></a>        /* if there are no valid staging locations, we can't move here */
<a name="5924"></a>        if (lst.length() == 0)
<a name="5925"></a>        {
<a name="5926"></a>            cannotMoveActorToStagingLocation();
<a name="5927"></a>            exit;
<a name="5928"></a>        }
<a name="5929"></a>        
<a name="5930"></a>        /*
<a name="5931"></a>         *   Try each of the locations in our staging list, to see if the
<a name="5932"></a>         *   actor is directly in any of them. 
<a name="5933"></a>         */
<a name="5934"></a>        foreach (local cur in lst)
<a name="5935"></a>        {
<a name="5936"></a>            /* 
<a name="5937"></a>             *   if the actor is directly in this staging location, then
<a name="5938"></a>             *   the actor can reach the destination with no additional
<a name="5939"></a>             *   intervening travel - simply return nil in this case to
<a name="5940"></a>             *   indicate that no implicit commands are needed before the
<a name="5941"></a>             *   proposed nested room entry 
<a name="5942"></a>             */
<a name="5943"></a>            if (gActor.isDirectlyIn(cur))
<a name="5944"></a>                return nil;
<a name="5945"></a>        }
<a name="5946"></a>
<a name="5947"></a>        /*
<a name="5948"></a>         *   The actor isn't directly in any staging location, so we must
<a name="5949"></a>         *   move the actor to an appropriate staging location before we
<a name="5950"></a>         *   can proceed.  Choose a staging location based on the actor's
<a name="5951"></a>         *   current location.  
<a name="5952"></a>         */
<a name="5953"></a>        if ((target = chooseStagingLocation()) != nil)
<a name="5954"></a>        {
<a name="5955"></a>            /* 
<a name="5956"></a>             *   We've chosen a target staging location.  First, check to
<a name="5957"></a>             *   make sure the location we've chosen is valid - we might
<a name="5958"></a>             *   have chosen a default (such as the nested room's
<a name="5959"></a>             *   immediate container) that isn't usable as a staging
<a name="5960"></a>             *   location, so we need to check with it first to make sure
<a name="5961"></a>             *   it's willing to allow this.  
<a name="5962"></a>             */
<a name="5963"></a>            target.checkStagingLocation(self);
<a name="5964"></a>
<a name="5965"></a>            /* 
<a name="5966"></a>             *   The check routine didn't abort the command, so try an
<a name="5967"></a>             *   appropriate implicit command to move the actor into the
<a name="5968"></a>             *   chosen staging location. 
<a name="5969"></a>             */
<a name="5970"></a>            return target.checkMovingActorInto(allowImplicit);
<a name="5971"></a>        }
<a name="5972"></a>
<a name="5973"></a>        /*
<a name="5974"></a>         *   There's no apparent intermediate staging location given the
<a name="5975"></a>         *   actor's current location.  We thus cannot proceed with the
<a name="5976"></a>         *   command; simply report that we can't get there from here.  
<a name="5977"></a>         */
<a name="5978"></a>        cannotMoveActorToStagingLocation();
<a name="5979"></a>        exit;
<a name="5980"></a>    }
<a name="5981"></a>
<a name="5982"></a>    /*
<a name="5983"></a>     *   Choose an intermediate staging location, given the actor's
<a name="5984"></a>     *   current location.  This routine is called when the actor is
<a name="5985"></a>     *   attempting to move into 'self', but isn't in any of the allowed
<a name="5986"></a>     *   staging locations for 'self'; this routine's purpose is to choose
<a name="5987"></a>     *   the staging location that the actor should implicitly try to
<a name="5988"></a>     *   reach on the way to 'self'.
<a name="5989"></a>     *   
<a name="5990"></a>     *   By default, we'll attempt to find the first of our staging
<a name="5991"></a>     *   locations that indirectly contains the actor.  (We know none of
<a name="5992"></a>     *   the staging locations directly contains the actor, because if one
<a name="5993"></a>     *   did, we wouldn't be called in the first place - we're only called
<a name="5994"></a>     *   when the actor isn't already directly in one of our staging
<a name="5995"></a>     *   locations.)  This approach is appropriate when nested rooms are
<a name="5996"></a>     *   related purely by containment: if an actor is in a nested room
<a name="5997"></a>     *   within one of our staging locations, we can reach that staging
<a name="5998"></a>     *   location by having the actor get out of the more deeply nested
<a name="5999"></a>     *   room.
<a name="6000"></a>     *   
<a name="6001"></a>     *   However, this default approach is not appropriate when nested
<a name="6002"></a>     *   rooms are related in some way other than simple containment.  We
<a name="6003"></a>     *   don't have any general framework for other types of nested room
<a name="6004"></a>     *   relationships, so this routine must be overridden in such a case
<a name="6005"></a>     *   with special-purpose code defining the special relationship.
<a name="6006"></a>     *   
<a name="6007"></a>     *   If we fail to find any staging location indirectly containing the
<a name="6008"></a>     *   actor, we'll return the result of defaultStagingLocation().  
<a name="6009"></a>     */
<a name="6010"></a>    chooseStagingLocation()
<a name="6011"></a>    {
<a name="6012"></a>        /* look for a staging location indirectly containing the actor */
<a name="6013"></a>        foreach (local cur in stagingLocations)
<a name="6014"></a>        {
<a name="6015"></a>            /* 
<a name="6016"></a>             *   if the actor is indirectly in this staging location,
<a name="6017"></a>             *   choose it as the target intermediate staging location
<a name="6018"></a>             */
<a name="6019"></a>            if (gActor.isIn(cur))
<a name="6020"></a>                return cur;
<a name="6021"></a>        }
<a name="6022"></a>            
<a name="6023"></a>        /*
<a name="6024"></a>         *   We didn't find any locations in the staging list that
<a name="6025"></a>         *   indirectly contain the actor, so use the default staging
<a name="6026"></a>         *   location.  
<a name="6027"></a>         */
<a name="6028"></a>        return defaultStagingLocation();
<a name="6029"></a>    }
<a name="6030"></a>
<a name="6031"></a>    /*
<a name="6032"></a>     *   The default staging location for this nested room.  This is the
<a name="6033"></a>     *   staging location we'll attempt to reach implicitly if the actor
<a name="6034"></a>     *   isn't in any of the rooms in the stagingLocations list already.
<a name="6035"></a>     *   We'll return the first element of our stagingLocations list for
<a name="6036"></a>     *   which isStagingLocationKnown returns true.  
<a name="6037"></a>     */
<a name="6038"></a>    defaultStagingLocation()
<a name="6039"></a>    {
<a name="6040"></a>        local lst;
<a name="6041"></a>        
<a name="6042"></a>        /* get the list of valid staging locations */
<a name="6043"></a>        lst = stagingLocations;
<a name="6044"></a>
<a name="6045"></a>        /* find the first element which is known to the actor */
<a name="6046"></a>        foreach (local cur in lst)
<a name="6047"></a>        {
<a name="6048"></a>            /* if this staging location is known, take it as the default */
<a name="6049"></a>            if (isStagingLocationKnown(cur))
<a name="6050"></a>                return cur;
<a name="6051"></a>        }
<a name="6052"></a>
<a name="6053"></a>        /* we didn't find any known staging locations - there's no default */
<a name="6054"></a>        return nil;
<a name="6055"></a>    }
<a name="6056"></a>
<a name="6057"></a>    /*
<a name="6058"></a>     *   Report that we are unable to move an actor to any staging
<a name="6059"></a>     *   location for this nested room.  By default, we'll generate the
<a name="6060"></a>     *   message "you can't do that from here," but this can overridden to
<a name="6061"></a>     *   provide a more specific if desired.  
<a name="6062"></a>     */
<a name="6063"></a>    cannotMoveActorToStagingLocation()
<a name="6064"></a>    {
<a name="6065"></a>        /* report the standard "you can't do that from here" message */
<a name="6066"></a>        reportFailure(&amp;cannotDoFromHereMsg);
<a name="6067"></a>    }
<a name="6068"></a>
<a name="6069"></a>    /*
<a name="6070"></a>     *   Report that we are unable to move an actor out of this nested
<a name="6071"></a>     *   room, because there's no valid 'exit destination'.  This is
<a name="6072"></a>     *   called when we attempt to GET OUT OF the nested room, and the
<a name="6073"></a>     *   'exitDestination' property is nil.  
<a name="6074"></a>     */
<a name="6075"></a>    cannotMoveActorOutOf()
<a name="6076"></a>    {
<a name="6077"></a>        /* report the standard "you can't do that from here" message */
<a name="6078"></a>        reportFailure(&amp;cannotDoFromHereMsg);
<a name="6079"></a>    }
<a name="6080"></a>    
<a name="6081"></a>
<a name="6082"></a>    /*
<a name="6083"></a>     *   The valid "staging locations" for this nested room.  This is a
<a name="6084"></a>     *   list of the rooms from which an actor can DIRECTLY reach this
<a name="6085"></a>     *   nested room; in other words, the actor will be allowed to enter
<a name="6086"></a>     *   'self', with no intervening travel, if the actor is directly in
<a name="6087"></a>     *   any of these locations.
<a name="6088"></a>     *   
<a name="6089"></a>     *   If the list is empty, there are no valid staging locations.
<a name="6090"></a>     *   
<a name="6091"></a>     *   The point of listing staging locations is to make certain that
<a name="6092"></a>     *   the actor has to go through one of these locations in order to
<a name="6093"></a>     *   get into this nested room.  This ensures that we enforce any
<a name="6094"></a>     *   conditions or trigger any side effects of moving through the
<a name="6095"></a>     *   staging locations, so that a player can't bypass a puzzle by
<a name="6096"></a>     *   trying to move directly from one location to another without
<a name="6097"></a>     *   going through the required intermediate steps.  Since we always
<a name="6098"></a>     *   require that an actor go through one of our staging locations in
<a name="6099"></a>     *   order to enter this nested room, and since we carry out the
<a name="6100"></a>     *   travel to the staging location using implied commands (which are
<a name="6101"></a>     *   just ordinary commands, entered and executed automatically by the
<a name="6102"></a>     *   parser), we can avoid having to code any checks redudantly in
<a name="6103"></a>     *   both the staging locations and any other nearby locations.
<a name="6104"></a>     *   
<a name="6105"></a>     *   By default, an actor can only enter a nested room from the room's
<a name="6106"></a>     *   direct container.  For example, if a chair is on a stage, an
<a name="6107"></a>     *   actor must be standing on the stage before the actor can sit on
<a name="6108"></a>     *   the chair.  
<a name="6109"></a>     */
<a name="6110"></a>    stagingLocations = [location]
<a name="6111"></a>
<a name="6112"></a>    /*
<a name="6113"></a>     *   Our exit destination.  This is where an actor ends up when the
<a name="6114"></a>     *   actor is immediately inside this nested room and uses a "get out
<a name="6115"></a>     *   of" or equivalent command to exit the nested room.
<a name="6116"></a>     *   
<a name="6117"></a>     *   By default, we'll use the default staging location as the exit
<a name="6118"></a>     *   destination.  
<a name="6119"></a>     */
<a name="6120"></a>    exitDestination = (defaultStagingLocation())
<a name="6121"></a>
<a name="6122"></a>    /*
<a name="6123"></a>     *   Is the given staging location "known"?  This returns true if the
<a name="6124"></a>     *   staging location is usable as a default, nil if not.  If this
<a name="6125"></a>     *   returns true, then the location can be used in an implied command
<a name="6126"></a>     *   to move the actor to the staging location in order to move the
<a name="6127"></a>     *   actor into self.
<a name="6128"></a>     *   
<a name="6129"></a>     *   If this returns nil, no implied command will be attempted for
<a name="6130"></a>     *   this possible staging location.  This doesn't mean that an actor
<a name="6131"></a>     *   gets a free pass through the staging location; on the contrary,
<a name="6132"></a>     *   it simply means that we won't try any automatic command to move
<a name="6133"></a>     *   an actor to the staging location, hence travel from a non-staging
<a name="6134"></a>     *   location to this nested room will simply fail.  This can be used
<a name="6135"></a>     *   when part of the puzzle is to figure out that moving to the
<a name="6136"></a>     *   staging location is required in the first place: if we allowed an
<a name="6137"></a>     *   implied command in such cases, we'd give away the puzzle by
<a name="6138"></a>     *   solving it automatically.
<a name="6139"></a>     *   
<a name="6140"></a>     *   By default, we'll treat all of our staging locations as known.  
<a name="6141"></a>     */
<a name="6142"></a>    isStagingLocationKnown(loc) { return true; }
<a name="6143"></a>
<a name="6144"></a>    /*
<a name="6145"></a>     *   Get the travel preconditions for an actor in this location.  By
<a name="6146"></a>     *   default, if we have a container, and the actor can see the
<a name="6147"></a>     *   container, we'll return its travel preconditions; otherwise, we'll
<a name="6148"></a>     *   use our inherited preconditions.  
<a name="6149"></a>     */
<a name="6150"></a>    roomTravelPreCond()
<a name="6151"></a>    {
<a name="6152"></a>        local ret;
<a name="6153"></a>
<a name="6154"></a>        /* 
<a name="6155"></a>         *   If we can see out to our location, use the location's
<a name="6156"></a>         *   conditions, since by default we'll try traveling from the
<a name="6157"></a>         *   location; if we can't see out to our location, we won't be
<a name="6158"></a>         *   attempting travel through our location's connectors, so use
<a name="6159"></a>         *   our own preconditions instead. 
<a name="6160"></a>         */
<a name="6161"></a>        if (location != nil &amp;&amp; gActor.canSee(location))
<a name="6162"></a>            ret = location.roomTravelPreCond();
<a name="6163"></a>        else
<a name="6164"></a>            ret = inherited();
<a name="6165"></a>
<a name="6166"></a>        /* return the results */
<a name="6167"></a>        return ret;
<a name="6168"></a>    }
<a name="6169"></a>
<a name="6170"></a>    /*
<a name="6171"></a>     *   We cannot take a nested room that the actor is occupying 
<a name="6172"></a>     */
<a name="6173"></a>    dobjFor(Take)
<a name="6174"></a>    {
<a name="6175"></a>        verify()
<a name="6176"></a>        {
<a name="6177"></a>            /* it's illogical to take something that contains the actor */
<a name="6178"></a>            if (gActor.isIn(self))
<a name="6179"></a>                illogicalNow(&amp;cannotTakeLocationMsg);
<a name="6180"></a>
<a name="6181"></a>            /* inherit the default handling */
<a name="6182"></a>            inherited();
<a name="6183"></a>        }
<a name="6184"></a>    }
<a name="6185"></a>
<a name="6186"></a>    /*
<a name="6187"></a>     *   "get out of" action - exit the nested room
<a name="6188"></a>     */
<a name="6189"></a>    dobjFor(GetOutOf)
<a name="6190"></a>    {
<a name="6191"></a>        preCond()
<a name="6192"></a>        {
<a name="6193"></a>            return [new ObjectPreCondition(self, actorDirectlyInRoom)];
<a name="6194"></a>        }
<a name="6195"></a>        verify()
<a name="6196"></a>        {
<a name="6197"></a>            /* 
<a name="6198"></a>             *   the actor must be located on the platform; but allow the
<a name="6199"></a>             *   actor to be indirectly on the platform, since we'll use a
<a name="6200"></a>             *   precondition to move the actor out of any more nested
<a name="6201"></a>             *   rooms within us 
<a name="6202"></a>             */
<a name="6203"></a>            if (!gActor.isIn(self))
<a name="6204"></a>                illogicalNow(&amp;notOnPlatformMsg);
<a name="6205"></a>        }
<a name="6206"></a>        check()
<a name="6207"></a>        {
<a name="6208"></a>            /* 
<a name="6209"></a>             *   If we have no 'exit destination' - that is, we have
<a name="6210"></a>             *   nowhere to go when we GET OUT OF the nested room - then
<a name="6211"></a>             *   prohibit the operation. 
<a name="6212"></a>             */
<a name="6213"></a>            if (exitDestination == nil)
<a name="6214"></a>            {
<a name="6215"></a>                /* explain the problem and terminate the command */
<a name="6216"></a>                cannotMoveActorOutOf();
<a name="6217"></a>                exit;
<a name="6218"></a>            }
<a name="6219"></a>        }
<a name="6220"></a>        action()
<a name="6221"></a>        {
<a name="6222"></a>            /* travel to our get-out-of destination */
<a name="6223"></a>            gActor.travelWithin(exitDestination);
<a name="6224"></a>
<a name="6225"></a>            /* 
<a name="6226"></a>             *   set the actor's posture to the default posture for the
<a name="6227"></a>             *   new location 
<a name="6228"></a>             */
<a name="6229"></a>            gActor.makePosture(gActor.location.defaultPosture);
<a name="6230"></a>
<a name="6231"></a>            /* issue a default report of the change */
<a name="6232"></a>            defaultReport(&amp;okayNotStandingOnMsg);
<a name="6233"></a>        }
<a name="6234"></a>    }
<a name="6235"></a>
<a name="6236"></a>    /* explicitly define the push-travel indirect object mappings */
<a name="6237"></a>    mapPushTravelIobj(PushTravelOutOf, TravelVia)
<a name="6238"></a>;
<a name="6239"></a>
<a name="6240"></a>
<a name="6241"></a>/* ------------------------------------------------------------------------ */
<a name="6242"></a>/*
<a name="6243"></a> *   A "high nested room" is a nested room that is elevated above the rest
<a name="6244"></a> *   of the room.  This specializes the staging location handling so that
<a name="6245"></a> *   it generates more specific messages.  
<a name="6246"></a> */
<a name="6247"></a>class HighNestedRoom: NestedRoom
<a name="6248"></a>    /* report that we're unable to move to a staging location */
<a name="6249"></a>    cannotMoveActorToStagingLocation()
<a name="6250"></a>    {
<a name="6251"></a>        reportFailure(&amp;nestedRoomTooHighMsg, self);
<a name="6252"></a>    }
<a name="6253"></a>
<a name="6254"></a>    /* if we can't get out, report that it's because we're too high up */
<a name="6255"></a>    cannotMoveActorOutOf()
<a name="6256"></a>    {
<a name="6257"></a>        reportFailure(&amp;nestedRoomTooHighToExitMsg, self);
<a name="6258"></a>    }
<a name="6259"></a>
<a name="6260"></a>    /*
<a name="6261"></a>     *   Staging locations.  By default, we'll return an empty list,
<a name="6262"></a>     *   because a high location is not usually reachable directly from its
<a name="6263"></a>     *   containing location.
<a name="6264"></a>     *   
<a name="6265"></a>     *   Note that puzzles involving moving platforms will have to manage
<a name="6266"></a>     *   this list dynamically, which could be done either by writing a
<a name="6267"></a>     *   method here that returns a list of currently valid staging
<a name="6268"></a>     *   locations, or by adding objects to this list as they become valid
<a name="6269"></a>     *   staging locations and removing them when they cease to be.  For
<a name="6270"></a>     *   example, if we have an air vent in the ceiling that we can only
<a name="6271"></a>     *   reach when a chair is placed under the vent, this property could
<a name="6272"></a>     *   be implemented as a method that returns a list containing the
<a name="6273"></a>     *   chair only when the chair is in the under-the-vent state.
<a name="6274"></a>     *   
<a name="6275"></a>     *   Note that this empty default setting will also give us no exit
<a name="6276"></a>     *   destination, since the default exit location is the default
<a name="6277"></a>     *   staging location.  
<a name="6278"></a>     */
<a name="6279"></a>    stagingLocations = []
<a name="6280"></a>;
<a name="6281"></a>
<a name="6282"></a>
<a name="6283"></a>/* ------------------------------------------------------------------------ */
<a name="6284"></a>/*
<a name="6285"></a> *   A chair is an item that an actor can sit on.  When an actor is sitting
<a name="6286"></a> *   on a chair, the chair contains the actor.  In addition to sitting,
<a name="6287"></a> *   chairs can optionally allow standing as well.
<a name="6288"></a> *   
<a name="6289"></a> *   We define the "BasicChair" as something that an actor can sit on, and
<a name="6290"></a> *   then subclass this with the standard "Chair", which adds surface
<a name="6291"></a> *   capabilities.  
<a name="6292"></a> */
<a name="6293"></a>class BasicChair: NestedRoom
<a name="6294"></a>    /*
<a name="6295"></a>     *   A list of the allowed postures for this object.  By default, we
<a name="6296"></a>     *   can sit and stand on a chair, since most ordinary chairs are
<a name="6297"></a>     *   suitable for both.  
<a name="6298"></a>     */
<a name="6299"></a>    allowedPostures = [sitting, standing]
<a name="6300"></a>
<a name="6301"></a>    /*
<a name="6302"></a>     *   A list of the obvious postures for this object.  The only obvious,
<a name="6303"></a>     *   default thing you do with most ordinary chairs is sit on them,
<a name="6304"></a>     *   even they allow other postures.  Something like a large sofa might
<a name="6305"></a>     *   want to allow both sitting and lying.
<a name="6306"></a>     *   
<a name="6307"></a>     *   This list differs from the allowed postures list because some
<a name="6308"></a>     *   postures might be possible but not probable.  For most ordinary
<a name="6309"></a>     *   chairs, standing is possible, but it's not the first thing you'd
<a name="6310"></a>     *   think of doing with the chair.  
<a name="6311"></a>     */
<a name="6312"></a>    obviousPostures = [sitting]
<a name="6313"></a>
<a name="6314"></a>    /*
<a name="6315"></a>     *   A chair's effective follow location is usually its location's
<a name="6316"></a>     *   effective follow location, because we don't usually want to treat
<a name="6317"></a>     *   a chair as a separate location for the purposes of "follow."
<a name="6318"></a>     *   That is, if A and B are in the same room, and A sits down on a
<a name="6319"></a>     *   chair in the room, we don't want to count this as a move that B
<a name="6320"></a>     *   could follow.  
<a name="6321"></a>     */
<a name="6322"></a>    effectiveFollowLocation = (location.effectiveFollowLocation)
<a name="6323"></a>
<a name="6324"></a>    /*
<a name="6325"></a>     *   Try an implied command to move the actor from outside of this
<a name="6326"></a>     *   nested room into this nested room.  By default, we'll call upon
<a name="6327"></a>     *   our default posture object to activate its command to move the
<a name="6328"></a>     *   actor into this object in the default posture.  For a chair, the
<a name="6329"></a>     *   default posture is typically sitting, so the 'sitting' posture
<a name="6330"></a>     *   will perform a SIT ON &lt;self&gt; command.  
<a name="6331"></a>     */
<a name="6332"></a>    tryMovingIntoNested()
<a name="6333"></a>    {
<a name="6334"></a>        /* 
<a name="6335"></a>         *   ask our default posture object to carry out the appropriate
<a name="6336"></a>         *   command to move the actor into 'self' in that posture 
<a name="6337"></a>         */
<a name="6338"></a>        return defaultPosture.tryMakingPosture(self);
<a name="6339"></a>    }
<a name="6340"></a>
<a name="6341"></a>    /* tryMovingIntoNested failure message is "must sit on chair" */
<a name="6342"></a>    mustMoveIntoProp = &amp;mustSitOnMsg
<a name="6343"></a>
<a name="6344"></a>    /* default posture in this nested room is sitting */
<a name="6345"></a>    defaultPosture = sitting
<a name="6346"></a>
<a name="6347"></a>    /* 
<a name="6348"></a>     *   by default, objects dropped while sitting in a chair go into the
<a name="6349"></a>     *   enclosing location's drop destination 
<a name="6350"></a>     */
<a name="6351"></a>    getDropDestination(obj, path)
<a name="6352"></a>    {
<a name="6353"></a>        return location != nil
<a name="6354"></a>            ? location.getDropDestination(obj, path)
<a name="6355"></a>            : self;
<a name="6356"></a>    }
<a name="6357"></a>
<a name="6358"></a>    /*
<a name="6359"></a>     *   Remove an actor from the chair.  By default, we'll simply stand
<a name="6360"></a>     *   up, since this is the normal way out of a chair.  
<a name="6361"></a>     */
<a name="6362"></a>    tryRemovingFromNested()
<a name="6363"></a>    {
<a name="6364"></a>        /* try standing up */
<a name="6365"></a>        if (gActor.posture == sitting)
<a name="6366"></a>            return tryImplicitAction(Stand);
<a name="6367"></a>        else
<a name="6368"></a>            return tryImplicitAction(GetOffOf, self);
<a name="6369"></a>    }
<a name="6370"></a>
<a name="6371"></a>    /*
<a name="6372"></a>     *   Run the appropriate command to remove us from this nested
<a name="6373"></a>     *   container, as a replacement command. 
<a name="6374"></a>     */
<a name="6375"></a>    removeFromNested()
<a name="6376"></a>    {
<a name="6377"></a>        /* to get out of a chair, we simply stand up */
<a name="6378"></a>        if (gActor.posture == sitting)
<a name="6379"></a>            replaceAction(Stand);
<a name="6380"></a>        else
<a name="6381"></a>            replaceAction(GetOutOf, self);
<a name="6382"></a>    }
<a name="6383"></a>
<a name="6384"></a>    /*
<a name="6385"></a>     *   "sit on" action 
<a name="6386"></a>     */
<a name="6387"></a>    dobjFor(SitOn)
<a name="6388"></a>    {
<a name="6389"></a>        preCond = (preCondForEntry(sitting))
<a name="6390"></a>        verify()
<a name="6391"></a>        {
<a name="6392"></a>            /* verify entering the chair in a 'sitting' posture */
<a name="6393"></a>            if (verifyEntry(sitting, &amp;alreadySittingOnMsg, &amp;noRoomToSitMsg))
<a name="6394"></a>                inherited();
<a name="6395"></a>        }
<a name="6396"></a>        action()
<a name="6397"></a>        {
<a name="6398"></a>            /* enter the chair in the 'sitting' posture */
<a name="6399"></a>            performEntry(sitting);
<a name="6400"></a>        }
<a name="6401"></a>    }
<a name="6402"></a>
<a name="6403"></a>    /*
<a name="6404"></a>     *   "stand on" action 
<a name="6405"></a>     */
<a name="6406"></a>    dobjFor(StandOn)
<a name="6407"></a>    {
<a name="6408"></a>        /* if it's allowed, use the same preconditions as 'sit on' */
<a name="6409"></a>        preCond = (preCondForEntry(standing))
<a name="6410"></a>
<a name="6411"></a>        verify()
<a name="6412"></a>        {
<a name="6413"></a>            /* verify entering in a 'standing' posture */
<a name="6414"></a>            if (verifyEntry(standing, &amp;alreadyStandingOnMsg,
<a name="6415"></a>                            &amp;noRoomToStandMsg))
<a name="6416"></a>                inherited();
<a name="6417"></a>        }
<a name="6418"></a>        action()
<a name="6419"></a>        {
<a name="6420"></a>            /* enter the chair in the 'standing' posture */
<a name="6421"></a>            performEntry(standing);
<a name="6422"></a>        }
<a name="6423"></a>    }
<a name="6424"></a>
<a name="6425"></a>    /*
<a name="6426"></a>     *   "lie on" action 
<a name="6427"></a>     */
<a name="6428"></a>    dobjFor(LieOn)
<a name="6429"></a>    {
<a name="6430"></a>        preCond = (preCondForEntry(lying))
<a name="6431"></a>        verify()
<a name="6432"></a>        {
<a name="6433"></a>            /* verify entering in a 'lying' posture */
<a name="6434"></a>            if (verifyEntry(lying, &amp;alreadyLyingOnMsg, &amp;noRoomToLieMsg))
<a name="6435"></a>                inherited();
<a name="6436"></a>        }
<a name="6437"></a>        action()
<a name="6438"></a>        {
<a name="6439"></a>            /* enter in the 'lying' posture */
<a name="6440"></a>            performEntry(lying);
<a name="6441"></a>        }
<a name="6442"></a>    }
<a name="6443"></a>
<a name="6444"></a>    /* 
<a name="6445"></a>     *   For "get on/in" / "board", let our default posture object handle
<a name="6446"></a>     *   it, by running the appropriate nested action that moves the actor
<a name="6447"></a>     *   into self in the default posture. 
<a name="6448"></a>     */
<a name="6449"></a>    dobjFor(Board)
<a name="6450"></a>    {
<a name="6451"></a>        verify() { }
<a name="6452"></a>        action() { defaultPosture.setActorToPosture(gActor, self); }
<a name="6453"></a>    }
<a name="6454"></a>
<a name="6455"></a>    /* "get off of" is the same as "get out of" */
<a name="6456"></a>    dobjFor(GetOffOf) asDobjFor(GetOutOf)
<a name="6457"></a>
<a name="6458"></a>    /* standard preconditions for sitting/lying/standing on the chair */
<a name="6459"></a>    preCondForEntry(posture)
<a name="6460"></a>    {
<a name="6461"></a>        /* 
<a name="6462"></a>         *   if this is not among my allowed postures, we don't need any
<a name="6463"></a>         *   special preconditions, since we'll fail in the verify 
<a name="6464"></a>         */
<a name="6465"></a>        if (allowedPostures.indexOf(posture) == nil)
<a name="6466"></a>            return inherited();
<a name="6467"></a>
<a name="6468"></a>        /* 
<a name="6469"></a>         *   in order to enter the chair, we have to be able to touch it
<a name="6470"></a>         *   and we have to be able to enter it as a nested room 
<a name="6471"></a>         */
<a name="6472"></a>        return [touchObj,
<a name="6473"></a>                new ObjectPreCondition(self, actorReadyToEnterNestedRoom)];
<a name="6474"></a>    }
<a name="6475"></a>
<a name="6476"></a>    /*
<a name="6477"></a>     *   Verify that we can enter the chair in the given posture.  This
<a name="6478"></a>     *   performs verification work common to SIT ON, LIE ON, and STAND ON.
<a name="6479"></a>     *   If this returns true, the caller should inherit the base class
<a name="6480"></a>     *   default handling, otherwise it shouldn't.  
<a name="6481"></a>     */
<a name="6482"></a>    verifyEntry(posture, alreadyMsg, noRoomMsg)
<a name="6483"></a>    {
<a name="6484"></a>        /* 
<a name="6485"></a>         *   if the given posture isn't allowed, tell the caller to use the
<a name="6486"></a>         *   inherited default handling 
<a name="6487"></a>         */
<a name="6488"></a>        if (allowedPostures.indexOf(posture) == nil)
<a name="6489"></a>            return true;
<a name="6490"></a>
<a name="6491"></a>        /* this posture is allowed, but it might not be obvious */
<a name="6492"></a>        if (obviousPostures.indexOf(posture) == nil)
<a name="6493"></a>            nonObvious;
<a name="6494"></a>
<a name="6495"></a>        /* 
<a name="6496"></a>         *   If the actor is already on this chair in the given posture,
<a name="6497"></a>         *   this action is redundant.  If we already verified okay on this
<a name="6498"></a>         *   point for this same action, ignore the repeated command - it
<a name="6499"></a>         *   must mean that we applied a precondition that did all of our
<a name="6500"></a>         *   work for us (such as moving us out of a nested room
<a name="6501"></a>         *   immediately within us).  
<a name="6502"></a>         */
<a name="6503"></a>        if (gActor.posture == posture &amp;&amp; gActor.isDirectlyIn(self)
<a name="6504"></a>            &amp;&amp; gAction.verifiedOkay.indexOf(self) == nil)
<a name="6505"></a>            illogicalNow(alreadyMsg);
<a name="6506"></a>        else
<a name="6507"></a>            gAction.verifiedOkay += self;
<a name="6508"></a>
<a name="6509"></a>        /*
<a name="6510"></a>         *   If there's not room for the actor's added bulk, don't allow
<a name="6511"></a>         *   the actor to sit/lie/stand on the chair.  If the actor is
<a name="6512"></a>         *   already within the chair, there's no need to add the actor's
<a name="6513"></a>         *   bulk for this change, since it's already counted as being
<a name="6514"></a>         *   within us.  
<a name="6515"></a>         */
<a name="6516"></a>        if (!gActor.isIn(self)
<a name="6517"></a>            &amp;&amp; getBulkWithin() + gActor.getBulk() &gt; bulkCapacity)
<a name="6518"></a>            illogicalNow(noRoomMsg);
<a name="6519"></a>
<a name="6520"></a>        /* we can't sit/stand/lie on something the actor is holding */
<a name="6521"></a>        if (isIn(gActor))
<a name="6522"></a>            illogicalNow(&amp;cannotEnterHeldMsg);
<a name="6523"></a>
<a name="6524"></a>        /* 
<a name="6525"></a>         *   if the actor is already in me, but in a different posture,
<a name="6526"></a>         *   boost the likelihood slightly 
<a name="6527"></a>         */
<a name="6528"></a>        if (gActor.isDirectlyIn(self) &amp;&amp; gActor.posture != posture)
<a name="6529"></a>            logicalRank(120, 'already in');
<a name="6530"></a>
<a name="6531"></a>        /* tell the caller we don't want to inherit the base class handling */
<a name="6532"></a>        return nil;
<a name="6533"></a>    }
<a name="6534"></a>
<a name="6535"></a>    /*
<a name="6536"></a>     *   Perform entry in the given posture.  This carries out the common
<a name="6537"></a>     *   actions for SIT ON, LIE ON, and STAND ON. 
<a name="6538"></a>     */
<a name="6539"></a>    performEntry(posture)
<a name="6540"></a>    {
<a name="6541"></a>        /* 
<a name="6542"></a>         *   Move the actor into me - this counts as interior travel within
<a name="6543"></a>         *   the enclosing room.  Note that we move the actor before
<a name="6544"></a>         *   changing the actor's posture in case the travel fails.  
<a name="6545"></a>         */
<a name="6546"></a>        gActor.travelWithin(self);
<a name="6547"></a>            
<a name="6548"></a>        /* set the actor to the desired posture */
<a name="6549"></a>        gActor.makePosture(posture);
<a name="6550"></a>
<a name="6551"></a>        /* report success */
<a name="6552"></a>        defaultReport(&amp;roomOkayPostureChangeMsg, posture, self);
<a name="6553"></a>    }
<a name="6554"></a>;
<a name="6555"></a>
<a name="6556"></a>/*
<a name="6557"></a> *   A Chair is a basic chair with the addition of being a Surface.
<a name="6558"></a> */
<a name="6559"></a>class Chair: BasicChair, Surface
<a name="6560"></a>    /*
<a name="6561"></a>     *   By default, a chair has a seating capacity of one person, so use
<a name="6562"></a>     *   a maximum bulk that only allows one actor to occupy the chair at
<a name="6563"></a>     *   a time.  
<a name="6564"></a>     */
<a name="6565"></a>    bulkCapacity = 10
<a name="6566"></a>;
<a name="6567"></a>
<a name="6568"></a>/*
<a name="6569"></a> *   Bed.  This is an extension of Chair that allows actors to lie on it
<a name="6570"></a> *   as well as sit on it.  As with chairs, we have a basic bed, plus a
<a name="6571"></a> *   regular bed that serves as a surface as well.  
<a name="6572"></a> */
<a name="6573"></a>class BasicBed: BasicChair
<a name="6574"></a>    /* 
<a name="6575"></a>     *   we can sit, lie, and stand on a typical bed, but only sitting and
<a name="6576"></a>     *   lying are obvious default actions 
<a name="6577"></a>     */
<a name="6578"></a>    allowedPostures = [sitting, lying, standing]
<a name="6579"></a>    obviousPostures = [sitting, lying]
<a name="6580"></a>
<a name="6581"></a>    /* tryMovingIntoNested failure message is "must sit on chair" */
<a name="6582"></a>    mustMoveIntoProp = &amp;mustLieOnMsg
<a name="6583"></a>
<a name="6584"></a>    /* default posture in this nested room is sitting */
<a name="6585"></a>    defaultPosture = lying
<a name="6586"></a>;
<a name="6587"></a>
<a name="6588"></a>/*
<a name="6589"></a> *   A Bed is a basic bed with the addition of Surface capabilities. 
<a name="6590"></a> */
<a name="6591"></a>class Bed: BasicBed, Surface
<a name="6592"></a>;
<a name="6593"></a>
<a name="6594"></a>/*
<a name="6595"></a> *   A Platform is a nested room upon which an actor can stand.  In
<a name="6596"></a> *   general, when you can stand on something, you can also sit and lie on
<a name="6597"></a> *   it as well (it might not be comfortable, but it is usually at least
<a name="6598"></a> *   possible), so we make this a subclass of Bed.
<a name="6599"></a> *   
<a name="6600"></a> *   The main difference between a platform and a chair that allows
<a name="6601"></a> *   standing is that a platform is more of a mini-room.  In particular,
<a name="6602"></a> *   items an actor drops while standing on a platform land on the platform
<a name="6603"></a> *   itself, whereas items dropped while sitting (or standing) on a chair
<a name="6604"></a> *   land in the enclosing room.  In addition, the obvious default action
<a name="6605"></a> *   for a chair is to sit on it, while the obvious default action for a
<a name="6606"></a> *   platform is to stand on it.  
<a name="6607"></a> */
<a name="6608"></a>class BasicPlatform: BasicBed
<a name="6609"></a>    /* 
<a name="6610"></a>     *   we can sit, lie, and stand on a typical platform, and all of
<a name="6611"></a>     *   these could be reasonably expected to be done
<a name="6612"></a>     */
<a name="6613"></a>    allowedPostures = [sitting, lying, standing]
<a name="6614"></a>    obviousPostures = [sitting, lying, standing]
<a name="6615"></a>
<a name="6616"></a>    /* an actor can follow another actor onto or off of a platform */
<a name="6617"></a>    effectiveFollowLocation = (self)
<a name="6618"></a>
<a name="6619"></a>    /* tryMovingIntoNested failure message is "must get on platform" */
<a name="6620"></a>    mustMoveIntoProp = &amp;mustGetOnMsg
<a name="6621"></a>
<a name="6622"></a>    /* default posture in this nested room is sitting */
<a name="6623"></a>    defaultPosture = standing
<a name="6624"></a>
<a name="6625"></a>    /* by default, objects dropped on a platform go onto the platform */
<a name="6626"></a>    getDropDestination(obj, path)
<a name="6627"></a>    {
<a name="6628"></a>        return self;
<a name="6629"></a>    }
<a name="6630"></a>
<a name="6631"></a>    /*
<a name="6632"></a>     *   Remove an actor from the platform.  "Get off" is the normal
<a name="6633"></a>     *   command to leave a platform.  
<a name="6634"></a>     */
<a name="6635"></a>    tryRemovingFromNested()
<a name="6636"></a>    {
<a name="6637"></a>        /* try getting off of the platform */
<a name="6638"></a>        return tryImplicitAction(GetOffOf, self);
<a name="6639"></a>    }
<a name="6640"></a>
<a name="6641"></a>    /*
<a name="6642"></a>     *   Replace the current action with one that removes the actor from
<a name="6643"></a>     *   this nested room.
<a name="6644"></a>     */
<a name="6645"></a>    removeFromNested()
<a name="6646"></a>    {
<a name="6647"></a>        /* get off of the platform */
<a name="6648"></a>        replaceAction(GetOffOf, self);
<a name="6649"></a>    }
<a name="6650"></a>
<a name="6651"></a>    /*
<a name="6652"></a>     *   Make the actor stand up.  On a platform, standing is normally
<a name="6653"></a>     *   allowed, so STAND doesn't usually imply "get off platform" as it
<a name="6654"></a>     *   does in the base class.  
<a name="6655"></a>     */
<a name="6656"></a>    makeStandingUp()
<a name="6657"></a>    {
<a name="6658"></a>        /* 
<a name="6659"></a>         *   If standing isn't among my allowed postures, inherit the
<a name="6660"></a>         *   default behavior, which is to get out of the nested room. 
<a name="6661"></a>         */
<a name="6662"></a>        if (allowedPostures.indexOf(standing) == nil)
<a name="6663"></a>        {
<a name="6664"></a>            /* we can't stand on the platform, so use the default handling */
<a name="6665"></a>            inherited();
<a name="6666"></a>        }
<a name="6667"></a>        else
<a name="6668"></a>        {
<a name="6669"></a>            /* we can stand on the platform, so make the actor stand */
<a name="6670"></a>            gActor.makePosture(standing);
<a name="6671"></a>            
<a name="6672"></a>            /* issue a default report of the change */
<a name="6673"></a>            defaultReport(&amp;roomOkayPostureChangeMsg, standing, self);
<a name="6674"></a>        }
<a name="6675"></a>    }
<a name="6676"></a>
<a name="6677"></a>    /*
<a name="6678"></a>     *   Traveling 'down' from a platform should generally be taken to
<a name="6679"></a>     *   mean 'get off platform'. 
<a name="6680"></a>     */
<a name="6681"></a>    down = noTravelDown
<a name="6682"></a>;
<a name="6683"></a>
<a name="6684"></a>/*
<a name="6685"></a> *   A Platform is a basic platform with the addition of Surface behavior. 
<a name="6686"></a> */
<a name="6687"></a>class Platform: BasicPlatform, Surface
<a name="6688"></a>;
<a name="6689"></a>
<a name="6690"></a>/*
<a name="6691"></a> *   A "nominal platform" is a named place where NPC's can stand.  This
<a name="6692"></a> *   class makes it easy to arrange for an NPC to be described as standing
<a name="6693"></a> *   in a particular location in the room: for example, we could have an
<a name="6694"></a> *   actor "standing in a doorway", or "leaning against the streetlamp."
<a name="6695"></a> *   
<a name="6696"></a> *   In most cases, a nominal platform is a "secret" object, in that it
<a name="6697"></a> *   won't be listed in a room's contents and it won't have any vocabulary
<a name="6698"></a> *   words.  So, the player will never be able to refer to the object in a
<a name="6699"></a> *   command.  
<a name="6700"></a> *   
<a name="6701"></a> *   To use this class, instantiate it with an object located in the room
<a name="6702"></a> *   containing the pseudo-platform.  Don't give the object any vocabulary
<a name="6703"></a> *   words.  Locate actors within the pseudo-platform to give them the
<a name="6704"></a> *   special description.
<a name="6705"></a> *   
<a name="6706"></a> *   For simple platform-like "standing on" descriptions, just define the
<a name="6707"></a> *   name.  For descriptions like "standing in", "standing under", or
<a name="6708"></a> *   "standing near", where only the preposition needs to be customized,
<a name="6709"></a> *   define the name and define actorInPrep.  For more elaborate
<a name="6710"></a> *   customizations, such as "leaning against the streetlamp", you'll need
<a name="6711"></a> *   to override roomActorHereDesc, roomActorStatus, roomActorPostureDesc,
<a name="6712"></a> *   roomListActorPosture, and actorInGroupPrefix/Suffix, 
<a name="6713"></a> */
<a name="6714"></a>class NominalPlatform: Fixture, Platform
<a name="6715"></a>    /* don't let anyone stand/sit/lie here via a command */
<a name="6716"></a>    dobjFor(StandOn) { verify() { illogical(&amp;cannotStandOnMsg); } }
<a name="6717"></a>    dobjFor(SitOn) { verify() { illogical(&amp;cannotSitOnMsg); } }
<a name="6718"></a>    dobjFor(LieOn) { verify() { illogical(&amp;cannotLieOnMsg); } }
<a name="6719"></a>
<a name="6720"></a>    /* ignore me for 'all' and object defaulting */
<a name="6721"></a>    hideFromAll(action) { return true; }
<a name="6722"></a>    hideFromDefault(action) { return true; }
<a name="6723"></a>
<a name="6724"></a>    /* 
<a name="6725"></a>     *   nominal platforms are internal objects only, not part of the
<a name="6726"></a>     *   visible game world structure, so treat them as equivalent to their
<a name="6727"></a>     *   location for FOLLOW purposes 
<a name="6728"></a>     */
<a name="6729"></a>    effectiveFollowLocation = (location.effectiveFollowLocation)
<a name="6730"></a>;
<a name="6731"></a>
<a name="6732"></a>/*
<a name="6733"></a> *   A booth is a nested room that serves as a small enclosure within a
<a name="6734"></a> *   larger room.  Booths can serve as regular containers as well as
<a name="6735"></a> *   nested rooms, and can be made openable by addition of the Openable
<a name="6736"></a> *   mix-in class.  Note that booths don't have to be fully enclosed, nor
<a name="6737"></a> *   do they actually have to be closable.
<a name="6738"></a> *   
<a name="6739"></a> *   Examples of booths: a cardboard box large enough for an actor can
<a name="6740"></a> *   stand in; a closet; a shallow pit.  
<a name="6741"></a> */
<a name="6742"></a>class Booth: BasicPlatform, Container
<a name="6743"></a>    /*
<a name="6744"></a>     *   Try an implied command to move the actor from outside of this
<a name="6745"></a>     *   nested room into this nested room.
<a name="6746"></a>     */
<a name="6747"></a>    tryMovingIntoNested()
<a name="6748"></a>    {
<a name="6749"></a>        /* try getting in me */
<a name="6750"></a>        return tryImplicitAction(Board, self);
<a name="6751"></a>    }
<a name="6752"></a>
<a name="6753"></a>    /*
<a name="6754"></a>     *   Remove an actor from the booth.  "Get out" is the normal command
<a name="6755"></a>     *   to leave this type of room.  
<a name="6756"></a>     */
<a name="6757"></a>    tryRemovingFromNested()
<a name="6758"></a>    {
<a name="6759"></a>        /* try getting out of the object */
<a name="6760"></a>        return tryImplicitAction(GetOutOf, self);
<a name="6761"></a>    }
<a name="6762"></a>
<a name="6763"></a>    /*
<a name="6764"></a>     *   Replace the current action with one that removes the actor from
<a name="6765"></a>     *   this nested room.
<a name="6766"></a>     */
<a name="6767"></a>    removeFromNested()
<a name="6768"></a>    {
<a name="6769"></a>        /* get out of the object */
<a name="6770"></a>        replaceAction(GetOutOf, self);
<a name="6771"></a>    }
<a name="6772"></a>
<a name="6773"></a>    /*
<a name="6774"></a>     *   "Enter" is equivalent to "get in" (or "board") for a booth 
<a name="6775"></a>     */
<a name="6776"></a>    dobjFor(Enter) asDobjFor(Board)
<a name="6777"></a>
<a name="6778"></a>    /* explicitly define the push-travel indirect object mapping */
<a name="6779"></a>    mapPushTravelIobj(PushTravelEnter, Board)
<a name="6780"></a>;
<a name="6781"></a>
<a name="6782"></a>/* ------------------------------------------------------------------------ */
<a name="6783"></a>/*
<a name="6784"></a> *   A Vehicle is a special type of nested room that moves instead of the
<a name="6785"></a> *   actor in response to travel commands.  When an actor in a vehicle
<a name="6786"></a> *   types, for example, "go north," the vehicle moves north, not the
<a name="6787"></a> *   actor.
<a name="6788"></a> *   
<a name="6789"></a> *   In most cases, a Vehicle should multiply inherit from one of the
<a name="6790"></a> *   other nested room subclasses to make it more specialized.  For
<a name="6791"></a> *   example, a bicycle might inherit from Chair, so that actors can sit
<a name="6792"></a> *   on the bike.
<a name="6793"></a> *   
<a name="6794"></a> *   Note that because Vehicle inherits from NestedRoom, the OUT direction
<a name="6795"></a> *   in the vehicle by default means what it does in NestedRoom -
<a name="6796"></a> *   specifically, getting out of the vehicle.  This is appropriate for
<a name="6797"></a> *   vehicles where we'd describe passengers as being inside the vehicle,
<a name="6798"></a> *   such as a car or a boat.  However, if the vehicle is something you
<a name="6799"></a> *   ride on, like a horse or a bike, it's probably more appropriate for
<a name="6800"></a> *   OUT to mean "ride the vehicle out of the enclosing room."  To get
<a name="6801"></a> *   this effect, simply override the "out" property and set it to nil;
<a name="6802"></a> *   this will prevent the NestedRoom definition from being inherited,
<a name="6803"></a> *   which will make us look for the OUT location of the enclosing room as
<a name="6804"></a> *   the travel destination.  
<a name="6805"></a> */
<a name="6806"></a>class Vehicle: NestedRoom, Traveler
<a name="6807"></a>    /*
<a name="6808"></a>     *   When a traveler is in a vehicle, and the traveler performs a
<a name="6809"></a>     *   travel command, the vehicle is what changes location; the
<a name="6810"></a>     *   contained traveler simply stays put while the vehicle moves.  
<a name="6811"></a>     */
<a name="6812"></a>    getLocTraveler(trav, conn)
<a name="6813"></a>    {
<a name="6814"></a>        local stage;
<a name="6815"></a>        
<a name="6816"></a>        /*
<a name="6817"></a>         *   If the connector is contained within the vehicle, take it as
<a name="6818"></a>         *   leading out of the vehicle - this means we want to move
<a name="6819"></a>         *   traveler within the vehicle rather than the vehicle.
<a name="6820"></a>         *   Consider the connector be inside the vehicle if it's a
<a name="6821"></a>         *   physical object (a Thing) that's inside the vehicle, or one
<a name="6822"></a>         *   of the vehicle's own directional links points directly to the
<a name="6823"></a>         *   connector.
<a name="6824"></a>         *   
<a name="6825"></a>         *   Likewise, if the connector is marked with the vehicle or any
<a name="6826"></a>         *   object inside the vehicle as its staging location, the
<a name="6827"></a>         *   vehicle obviously isn't involved in the travel.  
<a name="6828"></a>         */
<a name="6829"></a>        if ((conn != nil &amp;&amp; conn.ofKind(Thing) &amp;&amp; conn.isIn(self))
<a name="6830"></a>            || Direction.allDirections.indexWhich(
<a name="6831"></a>                {dir: self.(dir.dirProp) == conn}) != nil
<a name="6832"></a>            || ((stage = conn.connectorStagingLocation) != nil
<a name="6833"></a>                &amp;&amp; (stage == self || stage.isIn(self))))
<a name="6834"></a>        {
<a name="6835"></a>            /* 
<a name="6836"></a>             *   this connector leads out from within the vehicle - move
<a name="6837"></a>             *   the inner traveler rather than the vehicle itself 
<a name="6838"></a>             */
<a name="6839"></a>            return trav;
<a name="6840"></a>        }
<a name="6841"></a>
<a name="6842"></a>        /* 
<a name="6843"></a>         *   If we have a location, ask it who travels when the VEHICLE is
<a name="6844"></a>         *   the traveler within it; otherwise, the vehicle is the
<a name="6845"></a>         *   traveler.
<a name="6846"></a>         *   
<a name="6847"></a>         *   We ask the location, because the location might itself be a
<a name="6848"></a>         *   vehicle, in which case it might want us to be driving around
<a name="6849"></a>         *   the enclosing vehicle.  However, we pass ourselves (i.e.,
<a name="6850"></a>         *   this vehicle) as the inner traveler, rather than the traveler
<a name="6851"></a>         *   we were passed, because a traveler within a vehicle moves the
<a name="6852"></a>         *   vehicle when traveling.  
<a name="6853"></a>         */
<a name="6854"></a>        return (location != nil ? location.getLocTraveler(self, conn) : self);
<a name="6855"></a>    }
<a name="6856"></a>
<a name="6857"></a>    /*
<a name="6858"></a>     *   An OUT command while within a vehicle could mean one of two
<a name="6859"></a>     *   things: either to GET OUT of the vehicle, or to ride/drive the
<a name="6860"></a>     *   vehicle out of its enclosing location.
<a name="6861"></a>     *   
<a name="6862"></a>     *   There's no good way of guessing which meaning the player intends,
<a name="6863"></a>     *   so we have to choose one or the other.  We choose the ride/drive
<a name="6864"></a>     *   interpretation as the default, for two reasons.  First, it seems
<a name="6865"></a>     *   to be what most players expect.  Second, the other interpretation
<a name="6866"></a>     *   leaves no standard way of expressing the ride/drive meaning.  We
<a name="6867"></a>     *   return nil here to indicate to the OUT action that we want the
<a name="6868"></a>     *   enclosing location's 'out' connector to be used while an actor is
<a name="6869"></a>     *   in the vehicle.
<a name="6870"></a>     *   
<a name="6871"></a>     *   For some vehicles, it might be more appropriate for OUT to mean
<a name="6872"></a>     *   GET OUT.  In these cases, simply override this so that it returns
<a name="6873"></a>     *   nestedRoomOut.  
<a name="6874"></a>     */
<a name="6875"></a>    out = nil
<a name="6876"></a>
<a name="6877"></a>    /*
<a name="6878"></a>     *   Get the "location push traveler" - this is the traveler when a
<a name="6879"></a>     *   push-travel command is performed by a traveler within this
<a name="6880"></a>     *   location.  If the object we're trying to push is within me, use
<a name="6881"></a>     *   the contained traveler, since the contained traveler must be
<a name="6882"></a>     *   trying to push the object around directly.  If the object isn't
<a name="6883"></a>     *   inside me, then we're presumably trying to use the vehicle to push
<a name="6884"></a>     *   around the object, so the traveler is the vehicle or something
<a name="6885"></a>     *   containing the vehicle.  
<a name="6886"></a>     */
<a name="6887"></a>    getLocPushTraveler(trav, obj)
<a name="6888"></a>    {
<a name="6889"></a>        /* 
<a name="6890"></a>         *   If the object is inside me, use the nested traveler;
<a name="6891"></a>         *   otherwise, we're presumably trying to use the vehicle to move
<a name="6892"></a>         *   the object. 
<a name="6893"></a>         */
<a name="6894"></a>        if (obj.isIn(self))
<a name="6895"></a>        {
<a name="6896"></a>            /* 
<a name="6897"></a>             *   we're moving something around inside me; use the
<a name="6898"></a>             *   contained traveler 
<a name="6899"></a>             */
<a name="6900"></a>            return trav;
<a name="6901"></a>        }
<a name="6902"></a>        else if (location != nil)
<a name="6903"></a>        {
<a name="6904"></a>            /* 
<a name="6905"></a>             *   we're pushing something around outside me, so we're
<a name="6906"></a>             *   probably trying to use the vehicle to do so; we have a
<a name="6907"></a>             *   location, so ask it what it thinks, passing myself as the
<a name="6908"></a>             *   new suggested traveler 
<a name="6909"></a>             */
<a name="6910"></a>            return location.getLocPushTraveler(self, obj);
<a name="6911"></a>        }
<a name="6912"></a>        else
<a name="6913"></a>        {
<a name="6914"></a>            /* 
<a name="6915"></a>             *   we're pushing something around outside me, and I have no
<a name="6916"></a>             *   location, so I must be the traveler 
<a name="6917"></a>             */
<a name="6918"></a>            return self;
<a name="6919"></a>        }
<a name="6920"></a>    }
<a name="6921"></a>
<a name="6922"></a>    /* 
<a name="6923"></a>     *   Determine if an actor is traveling with me.  The normal base
<a name="6924"></a>     *   class implementation works, but it's more efficient just to check
<a name="6925"></a>     *   to see if the actor is inside this object than to construct the
<a name="6926"></a>     *   entire nested contents list just to check to see if the actor's
<a name="6927"></a>     *   in that list. 
<a name="6928"></a>     */
<a name="6929"></a>    isActorTraveling(actor) { return actor.isIn(self); }
<a name="6930"></a>
<a name="6931"></a>    /* invoke a callback for each actor traveling with us */
<a name="6932"></a>    forEachTravelingActor(func)
<a name="6933"></a>    {
<a name="6934"></a>        /* invoke the callback on each actor in our contents */
<a name="6935"></a>        allContents().forEach(new function(obj) {
<a name="6936"></a>            if (obj.isActor)
<a name="6937"></a>                (func)(obj);
<a name="6938"></a>        });
<a name="6939"></a>    }
<a name="6940"></a>
<a name="6941"></a>    /* 
<a name="6942"></a>     *   Get the actors involved in the travel.  This is a list consisting
<a name="6943"></a>     *   of all of the actors contained within the vehicle. 
<a name="6944"></a>     */
<a name="6945"></a>    getTravelerActors = (allContents().subset({x: x.isActor}))
<a name="6946"></a>
<a name="6947"></a>    /* 
<a name="6948"></a>     *   there are no self-motive actors in a vehicle - the vehicle is
<a name="6949"></a>     *   doing the travel, and the actors within are just moving along
<a name="6950"></a>     *   with it as cargo 
<a name="6951"></a>     */
<a name="6952"></a>    getTravelerMotiveActors = []
<a name="6953"></a>
<a name="6954"></a>    /*
<a name="6955"></a>     *   Traveler preconditions for the vehicle.  By default, we add no
<a name="6956"></a>     *   preconditions of our own, but specific vehicles might want to
<a name="6957"></a>     *   override this.  For example, a car might want to require that the
<a name="6958"></a>     *   doors are closed, the engine is running, and the seatbelts are
<a name="6959"></a>     *   fastened before it can travel.  
<a name="6960"></a>     */
<a name="6961"></a>    travelerPreCond(conn) { return []; }
<a name="6962"></a>
<a name="6963"></a>    /*
<a name="6964"></a>     *   Check, using pre-condition rules, that the traveler is in the
<a name="6965"></a>     *   given room, moving the traveler to the room if possible. 
<a name="6966"></a>     */
<a name="6967"></a>    checkMovingTravelerInto(room, allowImplicit)
<a name="6968"></a>    {
<a name="6969"></a>        /* if we're in the desired location, we're set */
<a name="6970"></a>        if (isDirectlyIn(room))
<a name="6971"></a>            return nil;
<a name="6972"></a>
<a name="6973"></a>        /* 
<a name="6974"></a>         *   By default, we can't move a vehicle into a room implicitly.
<a name="6975"></a>         *   Individual vehicles can override this when there's an obvious
<a name="6976"></a>         *   way of moving the vehicle in and out of nested rooms.  
<a name="6977"></a>         */
<a name="6978"></a>        reportFailure(&amp;vehicleCannotDoFromMsg, self);
<a name="6979"></a>        exit;
<a name="6980"></a>    }
<a name="6981"></a>
<a name="6982"></a>    /* 
<a name="6983"></a>     *   the lister object we use to display the list of actors aboard, in
<a name="6984"></a>     *   arrival and departure messages for the vehicle 
<a name="6985"></a>     */
<a name="6986"></a>    aboardVehicleListerObj = aboardVehicleLister
<a name="6987"></a>;
<a name="6988"></a>
<a name="6989"></a>/*
<a name="6990"></a> *   A VehicleBarrier is a TravelConnector that allows actors to travel,
<a name="6991"></a> *   but blocks vehicles.  By default, we block all vehicles, but
<a name="6992"></a> *   subclasses can customize this so that we block only specific
<a name="6993"></a> *   vehicles. 
<a name="6994"></a> */
<a name="6995"></a>class VehicleBarrier: TravelBarrier
<a name="6996"></a>    /*
<a name="6997"></a>     *   Determine if the given traveler can pass through this connector.
<a name="6998"></a>     *   By default, we'll return nil for a Vehicle, true for anything
<a name="6999"></a>     *   else.  This can be overridden to allow specific vehicles to pass,
<a name="7000"></a>     *   or to filter on any other criteria.  
<a name="7001"></a>     */
<a name="7002"></a>    canTravelerPass(traveler) { return !traveler.ofKind(Vehicle); }
<a name="7003"></a>
<a name="7004"></a>    /* explain why we can't pass */
<a name="7005"></a>    explainTravelBarrier(traveler)
<a name="7006"></a>    {
<a name="7007"></a>        reportFailure(&amp;cannotGoThatWayInVehicleMsg, traveler);
<a name="7008"></a>    }
<a name="7009"></a>;
<a name="7010"></a>
</pre>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/6/2009 from TADS version 3.0.18.1</div>
</body>
</html>
