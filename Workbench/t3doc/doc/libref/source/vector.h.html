<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>vector.h</title></head><body>
<table class=ban><tr><td><h1>vector.h</h1><td align=right><a href="../file/vector.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/*
<a name="4"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts
<a name="5"></a> *   
<a name="6"></a> *   This file is part of TADS 3.
<a name="7"></a> *   
<a name="8"></a> *   This header defines the Vector intrinsic class.  
<a name="9"></a> */
<a name="10"></a>
<a name="11"></a>#ifndef _VECTOR_H_
<a name="12"></a>#define _VECTOR_H_
<a name="13"></a>
<a name="14"></a>/* include our base class definition */
<a name="15"></a>#include "systype.h"
<a name="16"></a>
<a name="17"></a>
<a name="18"></a>/*
<a name="19"></a> *   The Vector intrinsic class provides a varying-length array type.
<a name="20"></a> *   Vectors can be expanded dynamically, and values within a vector can be
<a name="21"></a> *   changed.  (In contrast, List is a constant type: a value within a list
<a name="22"></a> *   cannot be changed, and new values can't be added to a list.  Any
<a name="23"></a> *   manipulation of a List results in a new, separate List object, leaving
<a name="24"></a> *   the original unchanged.  Vector allows new values to be added and
<a name="25"></a> *   existing values to be changed in place, without creating a new object.)
<a name="26"></a> */
<a name="27"></a>intrinsic class Vector 'vector/030004': Collection
<a name="28"></a>{
<a name="29"></a>    /* 
<a name="30"></a>     *   Create a list with the same elements as the vector.  If 'start' is
<a name="31"></a>     *   specified, it's the index of the first element we store; we'll
<a name="32"></a>     *   store elements starting at index 'start'.  If 'cnt' is specified,
<a name="33"></a>     *   it gives the maximum number of elements for the new list; by
<a name="34"></a>     *   default, we'll store all of the elements from 'start' to the last
<a name="35"></a>     *   element.  
<a name="36"></a>     */
<a name="37"></a>    toList(start?, cnt?);
<a name="38"></a>
<a name="39"></a>    /* get the number of elements in the vector */
<a name="40"></a>    length();
<a name="41"></a>
<a name="42"></a>    /* 
<a name="43"></a>     *   Copy from another vector or list.  Elements are copied from the
<a name="44"></a>     *   source vector or list starting at the element given by 'src_start',
<a name="45"></a>     *   and are copied into 'self' starting at the index given by
<a name="46"></a>     *   'dst_start'.  At most 'cnt' values are copied, but we stop when we
<a name="47"></a>     *   reach the last element of either the source or destination values.  
<a name="48"></a>     */
<a name="49"></a>    copyFrom(src, src_start, dst_start, cnt);
<a name="50"></a>
<a name="51"></a>    /* 
<a name="52"></a>     *   Fill with a given value, starting at the given element (the first
<a name="53"></a>     *   element if not specified), and running for the given number of
<a name="54"></a>     *   elements (the remaining existing elements of the vector, if not
<a name="55"></a>     *   specified).  The vector is expanded if necessary.  
<a name="56"></a>     */
<a name="57"></a>    fillValue(val, start?, cnt?);
<a name="58"></a>
<a name="59"></a>    /*
<a name="60"></a>     *   Select a subset of the vector.  Returns a new vector consisting
<a name="61"></a>     *   only of the elements of this vector for which the callback function
<a name="62"></a>     *   returns true.  
<a name="63"></a>     */
<a name="64"></a>    subset(func);
<a name="65"></a>
<a name="66"></a>    /*
<a name="67"></a>     *   Apply a callback function to each element of the vector.  For each
<a name="68"></a>     *   element of the vector, invokes the callback, and replaces the
<a name="69"></a>     *   element with the return value of the callback.  Modifies the vector
<a name="70"></a>     *   in-place, and returns 'self'.  
<a name="71"></a>     */
<a name="72"></a>    applyAll(func);
<a name="73"></a>
<a name="74"></a>    /* 
<a name="75"></a>     *   Find the first element for which the given condition is true.
<a name="76"></a>     *   Apply the callback function (which encodes the condition to
<a name="77"></a>     *   evaluate) to each element in turn, starting with the first.  For
<a name="78"></a>     *   each element, if the callback returns nil, proceed to the next
<a name="79"></a>     *   element; otherwise, stop and return the index of the element.  If
<a name="80"></a>     *   the callback never returns true for any element, we'll return nil.  
<a name="81"></a>     */
<a name="82"></a>    indexWhich(cond);
<a name="83"></a>
<a name="84"></a>    /* 
<a name="85"></a>     *   Invoke the callback func(val) on each element, in order from first
<a name="86"></a>     *   to last.  No return value.  
<a name="87"></a>     */
<a name="88"></a>    forEach(func);
<a name="89"></a>
<a name="90"></a>    /* 
<a name="91"></a>     *   Invoke the callback func(index, val) on each element, in order from
<a name="92"></a>     *   first to last.  No return value.  
<a name="93"></a>     */
<a name="94"></a>    forEachAssoc(func);
<a name="95"></a>
<a name="96"></a>    /*
<a name="97"></a>     *   Apply the callback function to each element of this vector, and
<a name="98"></a>     *   return a new vector consisting of the results.  Effectively maps
<a name="99"></a>     *   the vector to a new vector using the given function, leaving the
<a name="100"></a>     *   original vector unchanged.  
<a name="101"></a>     */
<a name="102"></a>    mapAll(func);
<a name="103"></a>
<a name="104"></a>    /* get the index of the first match for the given value */
<a name="105"></a>    indexOf(val);
<a name="106"></a>
<a name="107"></a>    /* 
<a name="108"></a>     *   Find the first element for which the given condition is true, and
<a name="109"></a>     *   return the value of the element.  
<a name="110"></a>     */
<a name="111"></a>    valWhich(cond);
<a name="112"></a>
<a name="113"></a>    /* find the last element with the given value, and return its index */
<a name="114"></a>    lastIndexOf(val);
<a name="115"></a>
<a name="116"></a>    /* 
<a name="117"></a>     *   Find the last element for which the condition is true, and return
<a name="118"></a>     *   the index of the element.  Applies the callback to each element in
<a name="119"></a>     *   turn, starting with the last element and working backwards.  For
<a name="120"></a>     *   each element, if the callback returns nil, proceeds to the previous
<a name="121"></a>     *   element; otherwise, stops and returns the index of the element.  If
<a name="122"></a>     *   the callback never returns true for any element, we'll return nil.  
<a name="123"></a>     */
<a name="124"></a>    lastIndexWhich(cond);
<a name="125"></a>
<a name="126"></a>    /* 
<a name="127"></a>     *   Find the last element for which the condition is true, and return
<a name="128"></a>     *   the value of the element 
<a name="129"></a>     */
<a name="130"></a>    lastValWhich(cond);
<a name="131"></a>
<a name="132"></a>    /* count the number of elements with the given value */
<a name="133"></a>    countOf(val);
<a name="134"></a>
<a name="135"></a>    /* count the number of elements for which the callback returns true */
<a name="136"></a>    countWhich(cond);
<a name="137"></a>
<a name="138"></a>    /* create a new vector consisting of the unique elements of this vector */
<a name="139"></a>    getUnique();
<a name="140"></a>
<a name="141"></a>    /*
<a name="142"></a>     *   append the elements of the list or vector 'val' to the elements of
<a name="143"></a>     *   this vector, then remove repeated elements in the result; returns a
<a name="144"></a>     *   new vector with the unique elements of the combination 
<a name="145"></a>     */
<a name="146"></a>    appendUnique(val);
<a name="147"></a>
<a name="148"></a>    /* 
<a name="149"></a>     *   Sort the vector in place; returns 'self'.  If the 'descending'
<a name="150"></a>     *   flag is provided and is not nil, we'll sort the vector in
<a name="151"></a>     *   descending order rather than ascending order.
<a name="152"></a>     *   
<a name="153"></a>     *   If the 'comparisonFunction' argument is provided, it must be a
<a name="154"></a>     *   callback function; the callback takes two arguments, and returns
<a name="155"></a>     *   an integer less than zero if the first argument value is less
<a name="156"></a>     *   than the second, zero if they're equal, and an integer greater
<a name="157"></a>     *   than zero if the first is greater than the second.  If no
<a name="158"></a>     *   'comparisonFunction' argument is provided, or it's provided and
<a name="159"></a>     *   its value is nil, we'll simply compare the vector elements as
<a name="160"></a>     *   ordinary values.  The comparison function can be provided for
<a name="161"></a>     *   caller-defined orderings, such as ordering a set of objects.  
<a name="162"></a>     */
<a name="163"></a>    sort(descending?, comparisonFunction?);
<a name="164"></a>
<a name="165"></a>    /* 
<a name="166"></a>     *   Set the length - if this is shorter than the current length,
<a name="167"></a>     *   existing items will be discarded; if it's longer, the newly added
<a name="168"></a>     *   slots will be set to nil.  Returns 'self'.
<a name="169"></a>     */
<a name="170"></a>    setLength(newElementCount);
<a name="171"></a>
<a name="172"></a>    /* 
<a name="173"></a>     *   Insert one or more elements at the given index.  If the index is
<a name="174"></a>     *   1, the elements will be inserted before the first existing
<a name="175"></a>     *   element.  If the index is one higher than the number of elements,
<a name="176"></a>     *   the elements will be inserted after all existing elements.
<a name="177"></a>     *   
<a name="178"></a>     *   Note that a list value argument will simply be inserted as a
<a name="179"></a>     *   single element.
<a name="180"></a>     *   
<a name="181"></a>     *   Returns 'self'.  
<a name="182"></a>     */
<a name="183"></a>    insertAt(startingIndex, val, ...);
<a name="184"></a>
<a name="185"></a>    /*
<a name="186"></a>     *   Delete the element at the given index, reducing the length of the
<a name="187"></a>     *   vector by one element.  Returns 'self'.  
<a name="188"></a>     */
<a name="189"></a>    removeElementAt(index);
<a name="190"></a>
<a name="191"></a>    /*
<a name="192"></a>     *   Delete the range of elements starting at startingIndex and ending
<a name="193"></a>     *   at endingIndex.  The elements at the ends of the range are
<a name="194"></a>     *   included in the deletion.  If startingIndex == endingIndex, only
<a name="195"></a>     *   one element is removed.  Reduces the length of the vector by the
<a name="196"></a>     *   number of elements removed.  Returns 'self'.  
<a name="197"></a>     */
<a name="198"></a>    removeRange(startingIndex, endingIndex);
<a name="199"></a>
<a name="200"></a>    /* 
<a name="201"></a>     *   Append an element to the vector.  This works just like insertAt()
<a name="202"></a>     *   with a starting index one higher than the length of the vector.
<a name="203"></a>     *   This has almost the same effect as the '+' operator, but treats a
<a name="204"></a>     *   list value like any other value by simply inserting the list as a
<a name="205"></a>     *   single new element (rather than appending each item in the list
<a name="206"></a>     *   individually, as the '+' operator would).  
<a name="207"></a>     */
<a name="208"></a>    append(val);
<a name="209"></a>
<a name="210"></a>    /*
<a name="211"></a>     *   Prepend an element.  This works like insertAt() with a starting
<a name="212"></a>     *   index of 1. 
<a name="213"></a>     */
<a name="214"></a>    prepend(val);
<a name="215"></a>
<a name="216"></a>    /*
<a name="217"></a>     *   Append all elements from a list or vector.  This works like
<a name="218"></a>     *   append(val), except that if 'val' is a list or vector, the elements
<a name="219"></a>     *   of 'val' will be appended individually, like the '+' operator does.
<a name="220"></a>     *   The difference between this method and the '+' operator is that
<a name="221"></a>     *   this method modifies this Vector by adding the new elements
<a name="222"></a>     *   directly to the existing Vector object, whereas the '+' operator
<a name="223"></a>     *   creates a new Vector to store the result.  
<a name="224"></a>     */
<a name="225"></a>    appendAll(val);
<a name="226"></a>
<a name="227"></a>    /*
<a name="228"></a>     *   Remove an element by value.  Each element of the vector matching
<a name="229"></a>     *   the given value is removed.  The vector is modified in-place.  The
<a name="230"></a>     *   return value is 'self'.  
<a name="231"></a>     */
<a name="232"></a>    removeElement(val);
<a name="233"></a>}
<a name="234"></a>
<a name="235"></a>#endif /* _VECTOR_H_ */
<a name="236"></a>
</pre>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/6/2009 from TADS version 3.0.18.1</div>
</body>
</html>
