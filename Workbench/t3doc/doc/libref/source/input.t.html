<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>input.t</title></head><body>
<table class=ban><tr><td><h1>input.t</h1><td align=right><a href="../file/input.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/* 
<a name="4"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts.  All Rights Reserved. 
<a name="5"></a> *   
<a name="6"></a> *   TADS 3 Library: input
<a name="7"></a> *   
<a name="8"></a> *   This modules defines functions and objects related to reading input
<a name="9"></a> *   from the player.  
<a name="10"></a> */
<a name="11"></a>
<a name="12"></a>#include "adv3.h"
<a name="13"></a>
<a name="14"></a>
<a name="15"></a>/* ------------------------------------------------------------------------ */
<a name="16"></a>/*
<a name="17"></a> *   Keyboard input parameter definition. 
<a name="18"></a> */
<a name="19"></a>class InputDef: object
<a name="20"></a>    /* 
<a name="21"></a>     *   The prompt function.  This is a function pointer (which is
<a name="22"></a>     *   frequently given as an anonymous function) or nil; if it's nil,
<a name="23"></a>     *   we won't show any prompt at all, otherwise we'll call the
<a name="24"></a>     *   function pointer to display a prompt as needed. 
<a name="25"></a>     */
<a name="26"></a>    promptFunc = nil
<a name="27"></a>
<a name="28"></a>    /* 
<a name="29"></a>     *   Allow real-time events.  If this is true, we'll allow real-time
<a name="30"></a>     *   events to interrupt the input; if it's nil, we'll freeze the
<a name="31"></a>     *   real-time clock while reading input.  
<a name="32"></a>     */
<a name="33"></a>    allowRealTime = nil
<a name="34"></a>
<a name="35"></a>    /* 
<a name="36"></a>     *   Begin the input style.  This should do anything required to set
<a name="37"></a>     *   the font to the desired attributes for the input text.  By
<a name="38"></a>     *   default, we'll simply display &lt;.inputline&gt; to set up the default
<a name="39"></a>     *   input style.  
<a name="40"></a>     */
<a name="41"></a>    beginInputFont() { "&lt;.inputline&gt;"; }
<a name="42"></a>
<a name="43"></a>    /* 
<a name="44"></a>     *   End the input style.  By default, we'll close the &lt;.inputline&gt;
<a name="45"></a>     *   that we opened in beginInputFont(). 
<a name="46"></a>     */
<a name="47"></a>    endInputFont() { "&lt;./inputline&gt;"; }
<a name="48"></a>;
<a name="49"></a>
<a name="50"></a>/*
<a name="51"></a> *   Basic keyboard input parameter definition.  This class defines
<a name="52"></a> *   keyboard input parameters with the real-time status and prompt
<a name="53"></a> *   function specified via the constructor.  
<a name="54"></a> */
<a name="55"></a>class BasicInputDef: InputDef
<a name="56"></a>    construct(allowRealTime, promptFunc)
<a name="57"></a>    {
<a name="58"></a>        self.allowRealTime = allowRealTime;
<a name="59"></a>        self.promptFunc = promptFunc;
<a name="60"></a>    }
<a name="61"></a>;
<a name="62"></a>
<a name="63"></a>
<a name="64"></a>/* ------------------------------------------------------------------------ */
<a name="65"></a>/*
<a name="66"></a> *   Keyboard input manager. 
<a name="67"></a> */
<a name="68"></a>inputManager: PostRestoreObject
<a name="69"></a>    /*
<a name="70"></a>     *   Read a line of input from the keyboard.
<a name="71"></a>     *   
<a name="72"></a>     *   If allowRealTime is true, we'll execute any real-time events that
<a name="73"></a>     *   are already due to run, and then we'll allow the input to be
<a name="74"></a>     *   interrupted by real-time events, if interrupted input is
<a name="75"></a>     *   supported on the local platform.  Otherwise, we will not process
<a name="76"></a>     *   any real-time events.
<a name="77"></a>     *   
<a name="78"></a>     *   promptFunc is a callback function to invoke to display the
<a name="79"></a>     *   prompt.  This is provided as a callback so that we can re-display
<a name="80"></a>     *   the prompt as necessary after real-time event interruptions.
<a name="81"></a>     *   Note that if real-time interruption is not to be allowed, the
<a name="82"></a>     *   caller can simply display the prompt before calling this routine
<a name="83"></a>     *   rather than passing in a prompt callback, if desired.
<a name="84"></a>     *   
<a name="85"></a>     *   If we're in HTML mode, this will switch into the 'tads-input'
<a name="86"></a>     *   font while reading the line, so this routine should be used
<a name="87"></a>     *   wherever possible rather than calling inputLine() or
<a name="88"></a>     *   inputLineTimeout() directly.  
<a name="89"></a>     */
<a name="90"></a>    getInputLine(allowRealTime, promptFunc)
<a name="91"></a>    {
<a name="92"></a>        /* read input using a basic InputDef for the given parameters */
<a name="93"></a>        return getInputLineExt(new BasicInputDef(allowRealTime, promptFunc));
<a name="94"></a>    }
<a name="95"></a>
<a name="96"></a>    /*
<a name="97"></a>     *   Read a line of input from the keyboard - extended interface,
<a name="98"></a>     *   using the InputDef object to define the input parameters.
<a name="99"></a>     *   'defObj' is an instance of class InputDef, defining how we're to
<a name="100"></a>     *   handle the input.  
<a name="101"></a>     */
<a name="102"></a>    getInputLineExt(defObj)
<a name="103"></a>    {
<a name="104"></a>        /* make sure the command transcript is flushed */
<a name="105"></a>        if (gTranscript != nil)
<a name="106"></a>            gTranscript.flushForInput();
<a name="107"></a>        
<a name="108"></a>        /* 
<a name="109"></a>         *   If a previous input was in progress, cancel it - this must be
<a name="110"></a>         *   a recursive entry from a real-time event that's interrupting
<a name="111"></a>         *   the enclosing input attempt. Simply cancel out the enclosing
<a name="112"></a>         *   read attempt entirely in this case; if and when we return to
<a name="113"></a>         *   the enclosing reader, that reader will start over with a
<a name="114"></a>         *   fresh read attempt at that point.  
<a name="115"></a>         */
<a name="116"></a>        cancelInputInProgress(true);
<a name="117"></a>        
<a name="118"></a>        /* 
<a name="119"></a>         *   Keep going until we finish reading the command.  We might
<a name="120"></a>         *   have to try several times, because our attempts might be
<a name="121"></a>         *   interrupted by real-time events. 
<a name="122"></a>         */
<a name="123"></a>        for (;;)
<a name="124"></a>        {
<a name="125"></a>            local result;
<a name="126"></a>            local timeout;
<a name="127"></a>            local t0;
<a name="128"></a>
<a name="129"></a>            /* note the starting time, in case we want to freeze the clock */
<a name="130"></a>            t0 = realTimeManager.getElapsedTime();
<a name="131"></a>
<a name="132"></a>            /* process real-time events, if possible */
<a name="133"></a>            timeout = processRealTimeEvents(defObj.allowRealTime);
<a name="134"></a>
<a name="135"></a>            /* show the prompt and any pre-input codes */
<a name="136"></a>            inputLineBegin(defObj);
<a name="137"></a>
<a name="138"></a>        getInput:
<a name="139"></a>            /* 
<a name="140"></a>             *   Read the input.  (Note that if our timeout is nil, this
<a name="141"></a>             *   will simply act like the ordinary untimed inputLine.)  
<a name="142"></a>             */
<a name="143"></a>            result = inputLineTimeout(timeout);
<a name="144"></a>
<a name="145"></a>            /*
<a name="146"></a>             *   If we're not allowing real-time event processing, freeze
<a name="147"></a>             *   the clock during the read - set the elapsed game
<a name="148"></a>             *   real-time clock back to the value it had on entry, so
<a name="149"></a>             *   that the input effectively consumes no real time.  
<a name="150"></a>             */
<a name="151"></a>            if (!defObj.allowRealTime)
<a name="152"></a>                realTimeManager.setElapsedTime(t0);
<a name="153"></a>
<a name="154"></a>            /* check the event code from the result list */
<a name="155"></a>            switch(result[1])
<a name="156"></a>            {
<a name="157"></a>            case InEvtNoTimeout:
<a name="158"></a>                /* 
<a name="159"></a>                 *   the platform doesn't support timeouts - note it for
<a name="160"></a>                 *   future reference so that we don't ask for input with
<a name="161"></a>                 *   timeout again, then go back to try the input again
<a name="162"></a>                 *   without a timeout 
<a name="163"></a>                 */
<a name="164"></a>                noInputTimeout = true;
<a name="165"></a>                timeout = nil;
<a name="166"></a>                goto getInput;
<a name="167"></a>            
<a name="168"></a>            case InEvtLine:
<a name="169"></a>                /* we've finished the current line - end input mode */
<a name="170"></a>                inputLineEnd();
<a name="171"></a>
<a name="172"></a>                /* return the line of text we got */
<a name="173"></a>                return result[2];
<a name="174"></a>            
<a name="175"></a>            case InEvtTimeout:
<a name="176"></a>                /* 
<a name="177"></a>                 *   We got a timeout without finishing the input line.
<a name="178"></a>                 *   This means that we have reached the time when the
<a name="179"></a>                 *   next real-time event is ready to execute.  Simply
<a name="180"></a>                 *   continue looping; we'll process all real-time events
<a name="181"></a>                 *   that are ready to go, then we'll resume reading the
<a name="182"></a>                 *   command.  
<a name="183"></a>                 *   
<a name="184"></a>                 *   Before we proceed, though, notify the command
<a name="185"></a>                 *   sequencer (via the command-interrupt pseudo-tag) that
<a name="186"></a>                 *   we're at the start of output text after an
<a name="187"></a>                 *   interrupted command line input 
<a name="188"></a>                 */
<a name="189"></a>                "&lt;.commandint&gt;";
<a name="190"></a>                break;
<a name="191"></a>            
<a name="192"></a>            case InEvtEof:
<a name="193"></a>                /* 
<a name="194"></a>                 *   End of file - this indicates that the user has closed
<a name="195"></a>                 *   down the application, or that the keyboard has become
<a name="196"></a>                 *   unreadable due to a hardware or OS error.
<a name="197"></a>                 *   
<a name="198"></a>                 *   Write a blank line to the display in an attempt to
<a name="199"></a>                 *   flush any partially-entered command line text, then
<a name="200"></a>                 *   throw an error to signal the EOF condition.  
<a name="201"></a>                 */
<a name="202"></a>                "\b";
<a name="203"></a>                throw new EndOfFileException();
<a name="204"></a>
<a name="205"></a>            case InEvtEndQuietScript:
<a name="206"></a>                /* 
<a name="207"></a>                 *   End of "quiet" script - this indicates that we've
<a name="208"></a>                 *   been reading input from a script file, but we've now
<a name="209"></a>                 *   reached the end of that file and are about to return
<a name="210"></a>                 *   to reading from the keyboard.
<a name="211"></a>                 *   
<a name="212"></a>                 *   "Quiet script" mode causes all output to be hidden
<a name="213"></a>                 *   while the script is being processed.  This means that
<a name="214"></a>                 *   we won't have displayed a prompt for the current
<a name="215"></a>                 *   line, or updated the status line.  We'll
<a name="216"></a>                 *   automatically display a new prompt when we loop back
<a name="217"></a>                 *   for another line of input, but we have to mark the
<a name="218"></a>                 *   current input line as actually ended now for that to
<a name="219"></a>                 *   happen.  
<a name="220"></a>                 */
<a name="221"></a>                inputLineInProgress = nil;
<a name="222"></a>                inProgressDefObj = nil;
<a name="223"></a>
<a name="224"></a>                /* 
<a name="225"></a>                 *   update the status line, since the quiet script mode
<a name="226"></a>                 *   will have suppressed all status line updates while we
<a name="227"></a>                 *   were reading the script, and thus the last update
<a name="228"></a>                 *   before this prompt won't have been shown 
<a name="229"></a>                 */
<a name="230"></a>                statusLine.showStatusLine();
<a name="231"></a>
<a name="232"></a>                /* back for more */
<a name="233"></a>                break;
<a name="234"></a>            }
<a name="235"></a>        }
<a name="236"></a>    }
<a name="237"></a>
<a name="238"></a>    /*
<a name="239"></a>     *   Pause for a MORE prompt.  If freezeRealTime is true, we'll stop
<a name="240"></a>     *   the real-time clock; otherwise we'll let it keep running.  Even if
<a name="241"></a>     *   we don't freeze the clock, we won't actually process any real-time
<a name="242"></a>     *   events while waiting: the point of the MORE prompt is to allow the
<a name="243"></a>     *   player to read and acknowledge the on-screen display before
<a name="244"></a>     *   showing anything new, so we don't want to allow any output to
<a name="245"></a>     *   result from real-time events that occur while waiting for user
<a name="246"></a>     *   input.  If any real-time events come due while we're waiting,
<a name="247"></a>     *   we'll process them when we're done.
<a name="248"></a>     *   
<a name="249"></a>     *   In order to ensure that the display makes sense to the user, we
<a name="250"></a>     *   flush any captured input in the transcript before pausing.  We
<a name="251"></a>     *   re-activate transcript capture after the pause if it was active
<a name="252"></a>     *   before.  Note that in some cases, this could affect the overall
<a name="253"></a>     *   output for the command, since some commands wait until the very
<a name="254"></a>     *   end of the command to go back and process the entire transcript
<a name="255"></a>     *   for the command.  Since we interrupt the transcript, flushing any
<a name="256"></a>     *   output that occurred before the pause, a command that goes back
<a name="257"></a>     *   over its entire output stream at the end of the turn won't be able
<a name="258"></a>     *   to see or modify any of the output that occurred prior to the
<a name="259"></a>     *   pause, since we will have flushed the output to that point.  
<a name="260"></a>     */
<a name="261"></a>    pauseForMore(freezeRealTime)
<a name="262"></a>    {
<a name="263"></a>        local t0;
<a name="264"></a>        local wasTranscriptActive = nil;
<a name="265"></a>
<a name="266"></a>        /* 
<a name="267"></a>         *   flush any command transcript and turn off transcript capture,
<a name="268"></a>         *   so that we show any pent-up reports before pausing for the
<a name="269"></a>         *   MORE prompt 
<a name="270"></a>         */
<a name="271"></a>        if (gTranscript != nil)
<a name="272"></a>            wasTranscriptActive = gTranscript.flushForInput();
<a name="273"></a>        
<a name="274"></a>        /* 
<a name="275"></a>         *   cancel any pending input - we must be interrupting the
<a name="276"></a>         *   pending input with a real-time event 
<a name="277"></a>         */
<a name="278"></a>        cancelInputInProgress(true);
<a name="279"></a>
<a name="280"></a>        /* note the starting time, in case we want to freeze the clock */
<a name="281"></a>        t0 = realTimeManager.getElapsedTime();
<a name="282"></a>
<a name="283"></a>        /* run the MORE prompt */
<a name="284"></a>        morePrompt();
<a name="285"></a>
<a name="286"></a>        /* if the transcript was previously active, re-activate it */
<a name="287"></a>        if (wasTranscriptActive)
<a name="288"></a>            gTranscript.activate();
<a name="289"></a>
<a name="290"></a>        /* 
<a name="291"></a>         *   if the caller wanted us to freeze the clock, restore the
<a name="292"></a>         *   elapsed game real time to what it was when we started, so
<a name="293"></a>         *   that the time the player took to acknowledge the MORE prompt
<a name="294"></a>         *   won't count against the elapsed game time; otherwise, process
<a name="295"></a>         *   any real-time events that came due while we were waiting 
<a name="296"></a>         */
<a name="297"></a>        if (freezeRealTime)
<a name="298"></a>        {
<a name="299"></a>            /* time was frozen - restore the original elapsed time */
<a name="300"></a>            realTimeManager.setElapsedTime(t0);
<a name="301"></a>        }
<a name="302"></a>        else
<a name="303"></a>        {
<a name="304"></a>            /* 
<a name="305"></a>             *   time wasn't frozen - check for any events that have come
<a name="306"></a>             *   due since we started waiting, and process them
<a name="307"></a>             *   immediately 
<a name="308"></a>             */
<a name="309"></a>            processRealTimeEvents(true);
<a name="310"></a>        }
<a name="311"></a>    }
<a name="312"></a>
<a name="313"></a>    /*
<a name="314"></a>     *   Read a keystroke, processing real-time events while waiting, if
<a name="315"></a>     *   desired.  'allowRealTime' and 'promptFunc' work the same way they
<a name="316"></a>     *   do with getInputLine().  
<a name="317"></a>     */
<a name="318"></a>    getKey(allowRealTime, promptFunc)
<a name="319"></a>    {
<a name="320"></a>        local evt;
<a name="321"></a>        
<a name="322"></a>        /* get an event */
<a name="323"></a>        evt = getEventOrKey(allowRealTime, promptFunc, true);
<a name="324"></a>
<a name="325"></a>        /* 
<a name="326"></a>         *   the only event that getEventOrKey will return is a keystroke,
<a name="327"></a>         *   so return the keystroke from the event record 
<a name="328"></a>         */
<a name="329"></a>        return evt[2];
<a name="330"></a>    }
<a name="331"></a>
<a name="332"></a>    /*
<a name="333"></a>     *   Read an event, processing real-time events while waiting, if
<a name="334"></a>     *   desired.  'allowRealTime' and 'promptFunc' work the same way they
<a name="335"></a>     *   do with getInputLine().  
<a name="336"></a>     */
<a name="337"></a>    getEvent(allowRealTime, promptFunc)
<a name="338"></a>    {
<a name="339"></a>        /* read and return an event */
<a name="340"></a>        return getEventOrKey(allowRealTime, promptFunc, nil);
<a name="341"></a>    }
<a name="342"></a>
<a name="343"></a>    /*
<a name="344"></a>     *   Read an event or keystroke.  'allowRealTime' and 'promptFunc' work
<a name="345"></a>     *   the same way they do in getInputLine().  If 'keyOnly' is true,
<a name="346"></a>     *   then we're only interested in keystroke events, and we'll ignore
<a name="347"></a>     *   any other events entered.
<a name="348"></a>     *   
<a name="349"></a>     *   Note that this routine is not generally called directly; callers
<a name="350"></a>     *   should usually call the convenience routines getKey() or
<a name="351"></a>     *   getEvent(), as needed.  
<a name="352"></a>     */
<a name="353"></a>    getEventOrKey(allowRealTime, promptFunc, keyOnly)
<a name="354"></a>    {
<a name="355"></a>        /* make sure the command transcript is flushed */
<a name="356"></a>        if (gTranscript != nil)
<a name="357"></a>            gTranscript.flushForInput();
<a name="358"></a>        
<a name="359"></a>        /* 
<a name="360"></a>         *   Cancel any in-progress input.  If there's an in-progress
<a name="361"></a>         *   input, a real-time event must be interrupting the input,
<a name="362"></a>         *   which is recursively invoking us to start a new input. 
<a name="363"></a>         */
<a name="364"></a>        cancelInputInProgress(true);
<a name="365"></a>        
<a name="366"></a>        /* keep going until we get a keystroke or other event */
<a name="367"></a>        for (;;)
<a name="368"></a>        {
<a name="369"></a>            local result;
<a name="370"></a>            local timeout;
<a name="371"></a>            local t0;
<a name="372"></a>
<a name="373"></a>            /* note the starting time, in case we want to freeze the clock */
<a name="374"></a>            t0 = realTimeManager.getElapsedTime();
<a name="375"></a>
<a name="376"></a>            /* process real-time events, if possible */
<a name="377"></a>            timeout = processRealTimeEvents(allowRealTime);
<a name="378"></a>
<a name="379"></a>            /* show the prompt and any pre-input codes */
<a name="380"></a>            inputEventBegin(promptFunc);
<a name="381"></a>
<a name="382"></a>        getInput:
<a name="383"></a>            /* 
<a name="384"></a>             *   Read the input.  (Note that if our timeout is nil, this
<a name="385"></a>             *   will simply act like the ordinary untimed inputLine.)  
<a name="386"></a>             */
<a name="387"></a>            result = inputEvent(timeout);
<a name="388"></a>
<a name="389"></a>            /*
<a name="390"></a>             *   If we're not allowing real-time event processing, freeze
<a name="391"></a>             *   the clock during the read - set the elapsed game
<a name="392"></a>             *   real-time clock back to the value it had on entry, so
<a name="393"></a>             *   that the input effectively consumes no real time.  
<a name="394"></a>             */
<a name="395"></a>            if (!allowRealTime)
<a name="396"></a>                realTimeManager.setElapsedTime(t0);
<a name="397"></a>
<a name="398"></a>            /* check the event code from the result list */
<a name="399"></a>            switch(result[1])
<a name="400"></a>            {
<a name="401"></a>            case InEvtNoTimeout:
<a name="402"></a>                /* 
<a name="403"></a>                 *   the platform doesn't support timeouts - note it for
<a name="404"></a>                 *   future reference so that we don't ask for input with
<a name="405"></a>                 *   timeout again, then go back to try the input again
<a name="406"></a>                 *   without a timeout 
<a name="407"></a>                 */
<a name="408"></a>                noInputTimeout = true;
<a name="409"></a>                timeout = nil;
<a name="410"></a>                goto getInput;
<a name="411"></a>            
<a name="412"></a>            case InEvtTimeout:
<a name="413"></a>                /* 
<a name="414"></a>                 *   We got a timeout without finishing the input line.
<a name="415"></a>                 *   This means that we have reached the time when the
<a name="416"></a>                 *   next real-time event is ready to execute.  Simply
<a name="417"></a>                 *   continue looping; we'll process all real-time events
<a name="418"></a>                 *   that are ready to go, then we'll resume reading the
<a name="419"></a>                 *   command.  
<a name="420"></a>                 */
<a name="421"></a>                break;
<a name="422"></a>            
<a name="423"></a>            case InEvtEof:
<a name="424"></a>                /* 
<a name="425"></a>                 *   End of file - this indicates that the user has closed
<a name="426"></a>                 *   down the application, or that the keyboard has become
<a name="427"></a>                 *   unreadable due to a hardware or OS error.
<a name="428"></a>                 *   
<a name="429"></a>                 *   Write a blank line to the display in an attempt to
<a name="430"></a>                 *   flush any partially-entered command line text, then
<a name="431"></a>                 *   throw an error to signal the EOF condition.  
<a name="432"></a>                 */
<a name="433"></a>                "\b";
<a name="434"></a>                throw new EndOfFileException();
<a name="435"></a>
<a name="436"></a>            case InEvtKey:
<a name="437"></a>                /* keystroke - finish the input and return the event */
<a name="438"></a>                inputEventEnd();
<a name="439"></a>                return result;
<a name="440"></a>
<a name="441"></a>            case InEvtHref:
<a name="442"></a>                /* 
<a name="443"></a>                 *   Hyperlink activation - if we're allowed to return
<a name="444"></a>                 *   events other than keystrokes, finish the input and
<a name="445"></a>                 *   return the event; otherwise, ignore the event and keep
<a name="446"></a>                 *   looping.  
<a name="447"></a>                 */
<a name="448"></a>                if (!keyOnly)
<a name="449"></a>                {
<a name="450"></a>                    inputEventEnd();
<a name="451"></a>                    return result;
<a name="452"></a>                }
<a name="453"></a>                break;
<a name="454"></a>
<a name="455"></a>            default:
<a name="456"></a>                /* ignore other events */
<a name="457"></a>                break;
<a name="458"></a>            }
<a name="459"></a>        }
<a name="460"></a>    }
<a name="461"></a>
<a name="462"></a>    /*
<a name="463"></a>     *   Cancel input in progress.
<a name="464"></a>     *   
<a name="465"></a>     *   If 'reset' is true, we'll clear any input state saved from the
<a name="466"></a>     *   interrupted in-progress editing session; otherwise, we'll retain
<a name="467"></a>     *   the saved editing state for restoration on the next input.
<a name="468"></a>     *   
<a name="469"></a>     *   This MUST be called before calling tadsSay().  Games should
<a name="470"></a>     *   generally never call tadsSay() directly (call the library
<a name="471"></a>     *   function say() instead), so in most cases authors will not need
<a name="472"></a>     *   to worry about calling this on output.
<a name="473"></a>     *   
<a name="474"></a>     *   This MUST ALSO be called before performing any keyboard input.
<a name="475"></a>     *   Callers using inputManager methods for keyboard operations won't
<a name="476"></a>     *   have to worry about this, because the inputManager methods call
<a name="477"></a>     *   this routine when necessary.  
<a name="478"></a>     */
<a name="479"></a>    cancelInputInProgress(reset)
<a name="480"></a>    {
<a name="481"></a>        /* cancel the interpreter's internal input state */
<a name="482"></a>        inputLineCancel(reset);
<a name="483"></a>
<a name="484"></a>        /* if we were editing a command line, terminate the editing session */
<a name="485"></a>        if (inputLineInProgress)
<a name="486"></a>        {
<a name="487"></a>            /* do our normal after-input work */
<a name="488"></a>            inputLineEnd();
<a name="489"></a>        }
<a name="490"></a>
<a name="491"></a>        /* if we were waiting for event input, note that we are no longer */
<a name="492"></a>        if (inputEventInProgress)
<a name="493"></a>        {
<a name="494"></a>            /* do our normal after-input work */
<a name="495"></a>            inputEventEnd();
<a name="496"></a>        }
<a name="497"></a>    }
<a name="498"></a>
<a name="499"></a>    /*
<a name="500"></a>     *   Process any real-time events that are ready to run, and return the
<a name="501"></a>     *   timeout until the next real-time event.
<a name="502"></a>     *   
<a name="503"></a>     *   If allowRealTime is nil, we won't process real-time events at all;
<a name="504"></a>     *   we'll merely return nil for the timeout to indicate to the caller
<a name="505"></a>     *   that any user input interaction about to be attempted should wait
<a name="506"></a>     *   indefinitely.  
<a name="507"></a>     */
<a name="508"></a>    processRealTimeEvents(allowRealTime)
<a name="509"></a>    {
<a name="510"></a>        local timeout;
<a name="511"></a>        
<a name="512"></a>        /* presume we will not use a timeout */
<a name="513"></a>        timeout = nil;
<a name="514"></a>
<a name="515"></a>        /* process real-time events, if allowed */
<a name="516"></a>        if (allowRealTime)
<a name="517"></a>        {
<a name="518"></a>            local tNext;
<a name="519"></a>            
<a name="520"></a>            /* 
<a name="521"></a>             *   Process any real-time events that are currently ready to
<a name="522"></a>             *   execute, and note the amount of time until the next
<a name="523"></a>             *   real-time event is ready.  
<a name="524"></a>             */
<a name="525"></a>            tNext = realTimeManager.executeEvents();
<a name="526"></a>
<a name="527"></a>            /* 
<a name="528"></a>             *   If there's an event pending, note the interval between the
<a name="529"></a>             *   current time and the event's scheduled time - this will
<a name="530"></a>             *   give us the maximum amount of time we want to wait for the
<a name="531"></a>             *   user to edit the command line before interrupting to
<a name="532"></a>             *   execute the pending event.  Ignore this if the platform
<a name="533"></a>             *   doesn't support timeouts to begin with.  
<a name="534"></a>             */
<a name="535"></a>            if (tNext != nil &amp;&amp; !noInputTimeout)
<a name="536"></a>                timeout = tNext - realTimeManager.getElapsedTime();
<a name="537"></a>        }
<a name="538"></a>
<a name="539"></a>        /* return the timeout until the next real-time event */
<a name="540"></a>        return timeout;
<a name="541"></a>    }
<a name="542"></a>
<a name="543"></a>    /*
<a name="544"></a>     *   Begin reading key/event input.  We'll cancel any report gatherer
<a name="545"></a>     *   so that prompt text shows immediately, and show the prompt if
<a name="546"></a>     *   desired.  
<a name="547"></a>     */
<a name="548"></a>    inputEventBegin(promptFunc)
<a name="549"></a>    {
<a name="550"></a>        /* if we're not continuing previous input, show the prompt */
<a name="551"></a>        if (!inputEventInProgress)
<a name="552"></a>        {
<a name="553"></a>            inputBegin(promptFunc);
<a name="554"></a>
<a name="555"></a>            /* note that we're in input mode */
<a name="556"></a>            inputEventInProgress = true;
<a name="557"></a>        }
<a name="558"></a>    }
<a name="559"></a>
<a name="560"></a>    /*
<a name="561"></a>     *   End keystroke/event input.
<a name="562"></a>     */
<a name="563"></a>    inputEventEnd()
<a name="564"></a>    {
<a name="565"></a>        /* if input is in progress, terminate it */
<a name="566"></a>        if (inputEventInProgress)
<a name="567"></a>        {
<a name="568"></a>            /* note that we're no longer reading an event */
<a name="569"></a>            inputEventInProgress = nil;
<a name="570"></a>        }
<a name="571"></a>    }
<a name="572"></a>
<a name="573"></a>    /*
<a name="574"></a>     *   Begin command line editing.  If we're in HTML mode, we'll show
<a name="575"></a>     *   the appropriate codes to establish the input font.  
<a name="576"></a>     */
<a name="577"></a>    inputLineBegin(defObj)
<a name="578"></a>    {
<a name="579"></a>        /* notify the command sequencer that we're reading a command */
<a name="580"></a>        "&lt;.commandbefore&gt;";
<a name="581"></a>        
<a name="582"></a>        /* if we're not resuming a session, set up a new session */
<a name="583"></a>        if (!inputLineInProgress)
<a name="584"></a>        {
<a name="585"></a>            /* begin input */
<a name="586"></a>            inputBegin(defObj.promptFunc);
<a name="587"></a>            
<a name="588"></a>            /* switch to input font */
<a name="589"></a>            defObj.beginInputFont();
<a name="590"></a>
<a name="591"></a>            /* note that we're in input mode */
<a name="592"></a>            inputLineInProgress = true;
<a name="593"></a>
<a name="594"></a>            /* remember the parameter object for this input */
<a name="595"></a>            inProgressDefObj = defObj;
<a name="596"></a>        }
<a name="597"></a>    }
<a name="598"></a>
<a name="599"></a>    /*
<a name="600"></a>     *   End command line editing.  If we're in HTML mode, we'll show the
<a name="601"></a>     *   appropriate codes to close the input font.  
<a name="602"></a>     */
<a name="603"></a>    inputLineEnd()
<a name="604"></a>    {
<a name="605"></a>        /* if input is in progress, terminate it */
<a name="606"></a>        if (inputLineInProgress)
<a name="607"></a>        {
<a name="608"></a>            /* note that we're no longer reading a line of input */
<a name="609"></a>            inputLineInProgress = nil;
<a name="610"></a>
<a name="611"></a>            /* end input font mode */
<a name="612"></a>            inProgressDefObj.endInputFont();
<a name="613"></a>
<a name="614"></a>            /* notify the command sequencer that we're done reading */
<a name="615"></a>            "&lt;.commandafter&gt;";
<a name="616"></a>
<a name="617"></a>            /* 
<a name="618"></a>             *   tell the main text area's output stream that we just
<a name="619"></a>             *   ended an input line 
<a name="620"></a>             */
<a name="621"></a>            mainOutputStream.inputLineEnd();
<a name="622"></a>
<a name="623"></a>            /* forget the parameter object for the input */
<a name="624"></a>            inProgressDefObj = nil;
<a name="625"></a>        }
<a name="626"></a>    }
<a name="627"></a>
<a name="628"></a>    /*
<a name="629"></a>     *   Begin generic input.  Cancels command report list capture, and
<a name="630"></a>     *   shows the prompt if given.  
<a name="631"></a>     */
<a name="632"></a>    inputBegin(promptFunc)
<a name="633"></a>    {
<a name="634"></a>        /* 
<a name="635"></a>         *   Turn off command transcript capture, if it's active.  Once
<a name="636"></a>         *   we're soliciting input interactively, we can no longer
<a name="637"></a>         *   usefully capture the text output of commands, but this is fine
<a name="638"></a>         *   because we must be doing something for which capture isn't
<a name="639"></a>         *   important anyway.  Reporting capture is used for things like
<a name="640"></a>         *   selecting the kind of result to show, which clearly isn't a
<a name="641"></a>         *   factor for actions involving interactive input.  
<a name="642"></a>         */
<a name="643"></a>        if (gTranscript != nil)
<a name="644"></a>            gTranscript.flushForInput();
<a name="645"></a>
<a name="646"></a>        /* if we have a prompt, display it */
<a name="647"></a>        if (promptFunc != nil)
<a name="648"></a>            (promptFunc)();
<a name="649"></a>    }
<a name="650"></a>
<a name="651"></a>    /* receive post-restore notification */
<a name="652"></a>    execute()
<a name="653"></a>    {
<a name="654"></a>        /* 
<a name="655"></a>         *   Reset the inputLine state.  If we had any previously
<a name="656"></a>         *   interrupted input from the current interpreter session,
<a name="657"></a>         *   forget it by cancelling and resetting the input line.  If we
<a name="658"></a>         *   had an interrupted line in the session being restored, forget
<a name="659"></a>         *   about that, too.  
<a name="660"></a>         */
<a name="661"></a>        inputLineCancel(true);
<a name="662"></a>        inputLineInProgress = nil;
<a name="663"></a>        inputEventInProgress = nil;
<a name="664"></a>
<a name="665"></a>        /* 
<a name="666"></a>         *   Clear the inputLineTimeout disabling flag - we might be
<a name="667"></a>         *   restoring the game on a different platform from the one where
<a name="668"></a>         *   the game started, so we might be able to use timed command
<a name="669"></a>         *   line input even if we didn't when we started the game.  By
<a name="670"></a>         *   clearing this flag, we'll check again to see if we can
<a name="671"></a>         *   perform timed input; if we can't, we'll just set the flag
<a name="672"></a>         *   again, so there will be no harm done.  
<a name="673"></a>         */
<a name="674"></a>        noInputTimeout = nil;
<a name="675"></a>    }
<a name="676"></a>
<a name="677"></a>    /* 
<a name="678"></a>     *   Flag: command line input is in progress.  If this is set, it means
<a name="679"></a>     *   that we interrupted command-line editing by a timeout, so we
<a name="680"></a>     *   should not show a prompt the next time we go back to the keyboard
<a name="681"></a>     *   for input.  
<a name="682"></a>     */
<a name="683"></a>    inputLineInProgress = nil
<a name="684"></a>
<a name="685"></a>    /* the InputDef object for the input in progress */
<a name="686"></a>    inProgressDefObj = nil
<a name="687"></a>
<a name="688"></a>    /* flag: keystroke/event input is in progress */
<a name="689"></a>    inputEventInProgress = nil
<a name="690"></a>
<a name="691"></a>    /*
<a name="692"></a>     *   Flag: inputLine does not support timeouts on the current platform.
<a name="693"></a>     *   We set this when we get an InEvtNoTimeout return code from
<a name="694"></a>     *   inputLineTimeout, so that we'll know not to try calling again with
<a name="695"></a>     *   a timeout.  This applies to the current interpreter only, so we
<a name="696"></a>     *   must ignore any value restored from a previously saved game, since
<a name="697"></a>     *   the game might have been saved on a different platform.
<a name="698"></a>     *   
<a name="699"></a>     *   Note that if this value is nil, it means only that we've never
<a name="700"></a>     *   seen an InEvtNoTimeout return code from inputLineEvent - it does
<a name="701"></a>     *   NOT mean that timeouts are supported locally.
<a name="702"></a>     *   
<a name="703"></a>     *   We assume that the input functions are uniform in their treatment
<a name="704"></a>     *   of timeouts; that is, we assume that if inputLineTimeout supports
<a name="705"></a>     *   timeout, then so does inputEvent, and that if one doesn't support
<a name="706"></a>     *   timeout, the other won't either.  
<a name="707"></a>     */
<a name="708"></a>    noInputTimeout = nil
<a name="709"></a>;
<a name="710"></a>
<a name="711"></a>
<a name="712"></a>/* ------------------------------------------------------------------------ */
<a name="713"></a>/*
<a name="714"></a> *   Read a command line from the player.  Displays the main command
<a name="715"></a> *   prompt and returns a line of input.
<a name="716"></a> *   
<a name="717"></a> *   We process any pending real-time events before reading the command.
<a name="718"></a> *   If the local platform supports real-time command-line interruptions,
<a name="719"></a> *   we'll continue processing real-time events as they occur in the
<a name="720"></a> *   course of command editing.  
<a name="721"></a> */
<a name="722"></a>readMainCommand(which)
<a name="723"></a>{
<a name="724"></a>    local str;
<a name="725"></a>    
<a name="726"></a>    /* execute any pre-command-prompt daemons */
<a name="727"></a>    eventManager.executePrompt();
<a name="728"></a>            
<a name="729"></a>    /* 
<a name="730"></a>     *   Read a line of input, allowing real-time event processing, and
<a name="731"></a>     *   return the line of text we read.  Use the appropriate main
<a name="732"></a>     *   command prompt for the given prompt mode.  
<a name="733"></a>     */
<a name="734"></a>    str = inputManager.getInputLine(
<a name="735"></a>        true, {: gLibMessages.mainCommandPrompt(which) });
<a name="736"></a>
<a name="737"></a>    /* return the string we read */
<a name="738"></a>    return str;
<a name="739"></a>}
<a name="740"></a>
<a name="741"></a>
<a name="742"></a>/* ------------------------------------------------------------------------ */
<a name="743"></a>/*
<a name="744"></a> *   End-of-file exception - this is thrown when readMainCommand()
<a name="745"></a> *   encounters end of file reading the console input. 
<a name="746"></a> */
<a name="747"></a>class EndOfFileException: Exception
<a name="748"></a>;
<a name="749"></a>
<a name="750"></a>
<a name="751"></a>/* ------------------------------------------------------------------------ */
<a name="752"></a>/*
<a name="753"></a> *   'Quitting' exception.  This isn't an error - it merely indicates that
<a name="754"></a> *   the user has explicitly asked to quit the game. 
<a name="755"></a> */
<a name="756"></a>class QuittingException: Exception
<a name="757"></a>;
<a name="758"></a>
<a name="759"></a>/* ------------------------------------------------------------------------ */
<a name="760"></a>/*
<a name="761"></a> *   Base class for command input string preparsers.
<a name="762"></a> *   
<a name="763"></a> *   Preparsers must be registered in order to run.  During
<a name="764"></a> *   preinitialization, we will automatically register any existing
<a name="765"></a> *   preparser objects; preparsers that are created dynamically during
<a name="766"></a> *   execution must be registered explicitly, which can be accomplished by
<a name="767"></a> *   inheriting the default constructor from this class.  
<a name="768"></a> */
<a name="769"></a>class StringPreParser: PreinitObject
<a name="770"></a>    /*
<a name="771"></a>     *   My execution order number.  When multiple preparsers are
<a name="772"></a>     *   registered, we'll run the preparsers in ascending order of this
<a name="773"></a>     *   value (i.e., smallest runOrder goes first).  
<a name="774"></a>     */
<a name="775"></a>    runOrder = 100
<a name="776"></a>
<a name="777"></a>    /*
<a name="778"></a>     *   Do our parsing.  Each instance should override this method to
<a name="779"></a>     *   define the parsing that it does.
<a name="780"></a>     *   
<a name="781"></a>     *   'str' is the string to parse, and 'which' is the rmcXxx enum
<a name="782"></a>     *   giving the type of command we're working with.
<a name="783"></a>     *   
<a name="784"></a>     *   This method returns a string or nil.  If the method returns a
<a name="785"></a>     *   string, the caller will forget the original string and work from
<a name="786"></a>     *   here on out with the new version returned; this allows the method
<a name="787"></a>     *   to rewrite the original input as desired.  If the method returns
<a name="788"></a>     *   nil, it means that the string has been fully handled and that
<a name="789"></a>     *   further parsing of the same string is not desired.  
<a name="790"></a>     */
<a name="791"></a>    doParsing(str, which)
<a name="792"></a>    {
<a name="793"></a>        /* return the original string unchanged */
<a name="794"></a>        return str;
<a name="795"></a>    }
<a name="796"></a>
<a name="797"></a>    /* 
<a name="798"></a>     *   construction - when we dynamically create a preparser, register
<a name="799"></a>     *   it by default
<a name="800"></a>     */
<a name="801"></a>    construct()
<a name="802"></a>    {
<a name="803"></a>        /* register the preparser */
<a name="804"></a>        StringPreParser.registerPreParser(self);
<a name="805"></a>    }
<a name="806"></a>
<a name="807"></a>    /* run pre-initialization */
<a name="808"></a>    execute()
<a name="809"></a>    {
<a name="810"></a>        /* register the preparser if it's not already registered */
<a name="811"></a>        StringPreParser.registerPreParser(self);
<a name="812"></a>    }
<a name="813"></a>
<a name="814"></a>    /* register a preparser */
<a name="815"></a>    registerPreParser(pp)
<a name="816"></a>    {
<a name="817"></a>        /* if the preparser isn't already in our list, add it */
<a name="818"></a>        if (regList.indexOf(pp) == nil)
<a name="819"></a>        {
<a name="820"></a>            /* append this new item to the list */
<a name="821"></a>            regList.append(pp);
<a name="822"></a>
<a name="823"></a>            /* the list is no longer sorted */
<a name="824"></a>            regListSorted = nil;
<a name="825"></a>        }
<a name="826"></a>    }
<a name="827"></a>
<a name="828"></a>    /*
<a name="829"></a>     *   Class method - Run all preparsers.  Returns the result of
<a name="830"></a>     *   successively calling each preparser on the given string.  
<a name="831"></a>     */
<a name="832"></a>    runAll(str, which)
<a name="833"></a>    {
<a name="834"></a>        /* 
<a name="835"></a>         *   if the list of preparsers isn't sorted, sort it in ascending
<a name="836"></a>         *   order of execution order number
<a name="837"></a>         */
<a name="838"></a>        if (!regListSorted)
<a name="839"></a>        {
<a name="840"></a>            /* sort the list */
<a name="841"></a>            regList.sort(SortAsc, {x, y: x.runOrder - y.runOrder});
<a name="842"></a>            
<a name="843"></a>            /* the list is now sorted */
<a name="844"></a>            regListSorted = true;
<a name="845"></a>        }
<a name="846"></a>
<a name="847"></a>        /* run each preparser */
<a name="848"></a>        foreach (local cur in regList)
<a name="849"></a>        {
<a name="850"></a>            /* run this preparser */
<a name="851"></a>            str = cur.doParsing(str, which);
<a name="852"></a>
<a name="853"></a>            /* 
<a name="854"></a>             *   if the result is nil, it means that the string has been
<a name="855"></a>             *   fully handled, so we need not run any further preparsing 
<a name="856"></a>             */
<a name="857"></a>            if (str == nil)
<a name="858"></a>                return nil;
<a name="859"></a>        }
<a name="860"></a>
<a name="861"></a>        /* return the result of the series of preparsing steps */
<a name="862"></a>        return str;
<a name="863"></a>    }
<a name="864"></a>
<a name="865"></a>    /* class property containing the list of registered parsers */
<a name="866"></a>    regList = static new Vector(10)
<a name="867"></a>
<a name="868"></a>    /* class property - the registration list has been sorted */
<a name="869"></a>    regListSorted = nil
<a name="870"></a>;
<a name="871"></a>
<a name="872"></a>/* ------------------------------------------------------------------------ */
<a name="873"></a>/*
<a name="874"></a> *   The "comment" pre-parser.  If the command line starts with a special
<a name="875"></a> *   prefix string (by default, "*", but this can be changed via our
<a name="876"></a> *   commentPrefix property), this pre-parser intercepts the command,
<a name="877"></a> *   treating it as a comment from the player and otherwise ignoring the
<a name="878"></a> *   entire input line.  The main purpose is to give players a way to put
<a name="879"></a> *   comments into recorded transcripts, as notes to themselves when later
<a name="880"></a> *   reviewing the transcripts or as notes to the author when submitting
<a name="881"></a> *   play-testing feedback.  
<a name="882"></a> */
<a name="883"></a>commentPreParser: StringPreParser
<a name="884"></a>    doParsing(str, which)
<a name="885"></a>    {
<a name="886"></a>        /* get the amount of leading whitespace, so we can ignore it */
<a name="887"></a>        local sp = rexMatch(leadPat, str);
<a name="888"></a>        
<a name="889"></a>        /* 
<a name="890"></a>         *   if the command line starts with the comment prefix, treat it
<a name="891"></a>         *   as a comment 
<a name="892"></a>         */
<a name="893"></a>        if (str.substr(sp + 1, commentPrefix.length()) == commentPrefix)
<a name="894"></a>        {
<a name="895"></a>            /*
<a name="896"></a>             *   It's a comment.
<a name="897"></a>             *   
<a name="898"></a>             *   If a transcript is being recorded, simply acknowledge the
<a name="899"></a>             *   comment; if not, acknowledge it, but with a warning that
<a name="900"></a>             *   the comment isn't being saved anywhere 
<a name="901"></a>             */
<a name="902"></a>            if (scriptStatus.scriptFile != nil)
<a name="903"></a>                gLibMessages.noteWithScript;
<a name="904"></a>            else if (warningCount++ == 0)
<a name="905"></a>                gLibMessages.noteWithoutScriptWarning;
<a name="906"></a>            else
<a name="907"></a>                gLibMessages.noteWithoutScript;
<a name="908"></a>
<a name="909"></a>            /* 
<a name="910"></a>             *   Otherwise completely ignore the command line.  To do this,
<a name="911"></a>             *   simply return nil: this tells the parser that the command
<a name="912"></a>             *   has been fully handled by the preparser. 
<a name="913"></a>             */
<a name="914"></a>            return nil;
<a name="915"></a>        }
<a name="916"></a>        else
<a name="917"></a>        {
<a name="918"></a>            /* it's not a command - return the string unchanged */
<a name="919"></a>            return str;
<a name="920"></a>        }
<a name="921"></a>    }
<a name="922"></a>
<a name="923"></a>    /* 
<a name="924"></a>     *   The comment prefix.  You can change this to any character, or to
<a name="925"></a>     *   any sequence of characters (longer sequences, such as '//', will
<a name="926"></a>     *   work fine).  If a command line starts with this exact string (or
<a name="927"></a>     *   starts with whitespace followed by this string), we'll consider
<a name="928"></a>     *   the line to be a comment.  
<a name="929"></a>     */
<a name="930"></a>    commentPrefix = '*'
<a name="931"></a>    
<a name="932"></a>    /* 
<a name="933"></a>     *   The leading-whitespace pattern.  We skip any text that matches
<a name="934"></a>     *   this pattern at the start of a command line before looking for the
<a name="935"></a>     *   comment prefix.
<a name="936"></a>     *   
<a name="937"></a>     *   If you don't want to allow leading whitespace before the comment
<a name="938"></a>     *   prefix, you can simply change this to '' - a pattern consisting of
<a name="939"></a>     *   an empty string always matches zero characters, so it will prevent
<a name="940"></a>     *   us from skipping any leading charactres in the player's input.  
<a name="941"></a>     */
<a name="942"></a>    leadPat = static new RexPattern('&lt;space&gt;*')
<a name="943"></a>
<a name="944"></a>    /* warning count for entering comments without SCRIPT in effect */
<a name="945"></a>    warningCount = 0
<a name="946"></a>
<a name="947"></a>    /*
<a name="948"></a>     *   Use a lower execution order than the default, so that we run
<a name="949"></a>     *   before most other pre-parsers.  Most other pre-parsers are written
<a name="950"></a>     *   to handle actual commands, so it's usually just a waste of time to
<a name="951"></a>     *   have them look at comments at all - and can occasionally be
<a name="952"></a>     *   problematic, since the free-form text of a comment could confuse a
<a name="953"></a>     *   pre-parser that's expecting a more conventional command format.
<a name="954"></a>     *   When the comment pre-parser detects a comment, it halts any
<a name="955"></a>     *   further processing of the command - so by running ahead of other
<a name="956"></a>     *   pre-parsers, we'll effectively bypass other pre-parsers when we
<a name="957"></a>     *   detect a comment.  
<a name="958"></a>     */
<a name="959"></a>    runOrder = 50
<a name="960"></a>;
<a name="961"></a>
<a name="962"></a>
<a name="963"></a>/* ------------------------------------------------------------------------ */
<a name="964"></a>/*
<a name="965"></a> *   Read a line of text and return the token list and the original text.
<a name="966"></a> *   We keep going until a non-empty line of text is read.
<a name="967"></a> *   
<a name="968"></a> *   'which' is one of the rmcXxx enum values specifying what kind of
<a name="969"></a> *   command line we're reading.
<a name="970"></a> *   
<a name="971"></a> *   The return value is a list of two elements.  The first element is the
<a name="972"></a> *   string entered, and the second element is the token list.  
<a name="973"></a> */
<a name="974"></a>readMainCommandTokens(which)
<a name="975"></a>{
<a name="976"></a>    local str;
<a name="977"></a>    local toks;
<a name="978"></a>
<a name="979"></a>    /* keep going until we get a non-empty command line */
<a name="980"></a>    for (;;)
<a name="981"></a>    {
<a name="982"></a>        /* read a command line */
<a name="983"></a>        str = readMainCommand(which);
<a name="984"></a>
<a name="985"></a>        /* run any preparsing desired on the string */
<a name="986"></a>        str = StringPreParser.runAll(str, which);
<a name="987"></a>
<a name="988"></a>        /* 
<a name="989"></a>         *   if preparsing returned nil, it means that the preparser fully
<a name="990"></a>         *   handled the string - simply return nil to tell the caller
<a name="991"></a>         *   that its work is done 
<a name="992"></a>         */
<a name="993"></a>        if (str == nil)
<a name="994"></a>            return nil;
<a name="995"></a>
<a name="996"></a>        try
<a name="997"></a>        {
<a name="998"></a>            /* tokenize the command string */
<a name="999"></a>            toks = cmdTokenizer.tokenize(str);
<a name="1000"></a>        }
<a name="1001"></a>        catch (TokErrorNoMatch tokExc)
<a name="1002"></a>        {
<a name="1003"></a>            /* 
<a name="1004"></a>             *   Invalid tokens in the response - complain about it.  Flag
<a name="1005"></a>             *   the error as being in the first character of the
<a name="1006"></a>             *   remaining string, since that's the character for which we
<a name="1007"></a>             *   could find no match. 
<a name="1008"></a>             */
<a name="1009"></a>            gLibMessages.invalidCommandToken(tokExc.curChar_.htmlify());
<a name="1010"></a>
<a name="1011"></a>            /* go back for another input line */
<a name="1012"></a>            continue;
<a name="1013"></a>        }
<a name="1014"></a>
<a name="1015"></a>        /* if we got a non-empty token list, return it */
<a name="1016"></a>        if (toks.length() != 0)
<a name="1017"></a>            return [str, toks];
<a name="1018"></a>
<a name="1019"></a>        /* show the empty-command reply */
<a name="1020"></a>        gLibMessages.emptyCommandResponse();
<a name="1021"></a>    }
<a name="1022"></a>}
<a name="1023"></a>
<a name="1024"></a>
</pre>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/6/2009 from TADS version 3.0.18.1</div>
</body>
</html>
