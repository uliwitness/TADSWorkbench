<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>lister.t</title></head><body>
<table class=ban><tr><td><h1>lister.t</h1><td align=right><a href="../file/lister.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/* 
<a name="4"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts.  All Rights Reserved. 
<a name="5"></a> *   
<a name="6"></a> *   TADS 3 Library - Lister class
<a name="7"></a> *   
<a name="8"></a> *   This module defines the "Lister" class, which generates formatted
<a name="9"></a> *   lists of objects, and several subclasses of Lister that generate
<a name="10"></a> *   special kinds of lists.  
<a name="11"></a> */
<a name="12"></a>
<a name="13"></a>/* include the library header */
<a name="14"></a>#include "adv3.h"
<a name="15"></a>
<a name="16"></a>
<a name="17"></a>/* ------------------------------------------------------------------------ */
<a name="18"></a>/*
<a name="19"></a> *   Lister.  This is the base class for formatting of lists of objects.
<a name="20"></a> *   
<a name="21"></a> *   The external interface consists of the showList() method, which
<a name="22"></a> *   displays a formatted list of objects according to the rules of the
<a name="23"></a> *   lister subclass.
<a name="24"></a> *   
<a name="25"></a> *   The rest of the methods are an internal interface which lister
<a name="26"></a> *   subclasses can override to customize the way that a list is shown.
<a name="27"></a> *   Certain of these methods are meant to be overridden by virtually all
<a name="28"></a> *   listers, such as the methods that show the prefix and suffix
<a name="29"></a> *   messages.  The remaining methods are designed to allow subclasses to
<a name="30"></a> *   customize detailed aspects of the formatting, so they only need to be
<a name="31"></a> *   overridden when something other than the default behavior is needed.  
<a name="32"></a> */
<a name="33"></a>class Lister: object
<a name="34"></a>    /*
<a name="35"></a>     *   Show a list, showing all items in the list as though they were
<a name="36"></a>     *   fully visible, regardless of their actual sense status.  
<a name="37"></a>     */
<a name="38"></a>    showListAll(lst, options, indent)
<a name="39"></a>    {
<a name="40"></a>        local infoTab;
<a name="41"></a>    
<a name="42"></a>        /* create a sense information table with each item in full view */
<a name="43"></a>        infoTab = new LookupTable(16, 32);
<a name="44"></a>        foreach (local cur in lst)
<a name="45"></a>        {
<a name="46"></a>            /* add a plain view sensory description to the info list */
<a name="47"></a>            infoTab[cur] = new SenseInfo(cur, transparent, nil, 3);
<a name="48"></a>        }
<a name="49"></a>        
<a name="50"></a>        /* show the list from the current global point of view */
<a name="51"></a>        showList(getPOV(), nil, lst, options, indent, infoTab, nil);
<a name="52"></a>    }
<a name="53"></a>
<a name="54"></a>    /*
<a name="55"></a>     *   Display a list of items, grouping according to the 'listWith'
<a name="56"></a>     *   associations of the items.  We will only list items for which
<a name="57"></a>     *   isListed() returns true.
<a name="58"></a>     *   
<a name="59"></a>     *   'pov' is the point of view of the listing, which is usually an
<a name="60"></a>     *   actor (and usually the player character actor).
<a name="61"></a>     *   
<a name="62"></a>     *   'parent' is the parent (container) of the list being shown.  This
<a name="63"></a>     *   should be nil if the listed objects are not all within a single
<a name="64"></a>     *   object.
<a name="65"></a>     *   
<a name="66"></a>     *   'lst' is the list of items to display.
<a name="67"></a>     *   
<a name="68"></a>     *   'options' gives a set of ListXxx option flags.
<a name="69"></a>     *   
<a name="70"></a>     *   'indent' gives the indentation level.  This is used only for
<a name="71"></a>     *   "tall" lists (specified by including ListTall in the options
<a name="72"></a>     *   flags).  An indentation level of zero indicates no indentation.
<a name="73"></a>     *   
<a name="74"></a>     *   'infoTab' is a lookup table of SenseInfo objects for all of the
<a name="75"></a>     *   objects that can be sensed from the perspective of the actor
<a name="76"></a>     *   performing the action that's causing the listing.  This is
<a name="77"></a>     *   normally the table returned from Thing.senseInfoTable() for the
<a name="78"></a>     *   actor from whose point of view the list is being generated.  (We
<a name="79"></a>     *   take this as a parameter rather than generating ourselves for two
<a name="80"></a>     *   reasons.  First, it's often the case that the same information
<a name="81"></a>     *   table will be needed for a series of listings, so we can save the
<a name="82"></a>     *   compute time of recalculating the same table repeatedly by having
<a name="83"></a>     *   the caller obtain the table and pass it to each lister.  Second,
<a name="84"></a>     *   in some cases the caller will want to synthesize a special sense
<a name="85"></a>     *   table rather than using the actual sense information; taking this
<a name="86"></a>     *   as a parameter allows the caller to easily customize the table.)
<a name="87"></a>     *   
<a name="88"></a>     *   'parentGroup' is the ListGroup object that is showing this list.
<a name="89"></a>     *   We will not group the objects we list into the parent group, or
<a name="90"></a>     *   into any group more general than the parent group.  
<a name="91"></a>     *   
<a name="92"></a>     *   This routine is not usually overridden in lister subclasses.
<a name="93"></a>     *   Instead, this method calls a number of other methods that
<a name="94"></a>     *   determine the listing style in more detail; usually those other,
<a name="95"></a>     *   simpler methods are customized in subclasses.  
<a name="96"></a>     */
<a name="97"></a>    showList(pov, parent, lst, options, indent, infoTab, parentGroup)
<a name="98"></a>    {
<a name="99"></a>        local groups;
<a name="100"></a>        local groupTab;
<a name="101"></a>        local singles;
<a name="102"></a>        local origLst;
<a name="103"></a>        local itemCount;
<a name="104"></a>
<a name="105"></a>        /* remember the original list */
<a name="106"></a>        origLst = lst;
<a name="107"></a>
<a name="108"></a>        /* filter the list to get only the items we actually will list */
<a name="109"></a>        lst = getFilteredList(lst, infoTab);
<a name="110"></a>
<a name="111"></a>        /* create a lookup table to keep track of the groups we've seen */
<a name="112"></a>        groupTab = new LookupTable();
<a name="113"></a>        groups = new Vector(10);
<a name="114"></a>        
<a name="115"></a>        /* set up a vector to keep track of the singles */
<a name="116"></a>        singles = new Vector(10);
<a name="117"></a>
<a name="118"></a>        /* figure the groupings */
<a name="119"></a>        itemCount = getListGrouping(groupTab, groups, singles,
<a name="120"></a>                                    lst, parentGroup);
<a name="121"></a>
<a name="122"></a>        /*
<a name="123"></a>         *   Now that we've figured out what's in the list and how it's
<a name="124"></a>         *   arranged into groups, show the list.  
<a name="125"></a>         */
<a name="126"></a>        showArrangedList(pov, parent, lst, options, indent, infoTab,
<a name="127"></a>                         itemCount, singles, groups, groupTab, origLst);
<a name="128"></a>
<a name="129"></a>        /* 
<a name="130"></a>         *   If the list is recursive, mention the contents of any items
<a name="131"></a>         *   that weren't listed in the main list, and of any contents
<a name="132"></a>         *   that are specifically to be listed out-of-line.  Don't do
<a name="133"></a>         *   this if we're already recursively showing such a listing,
<a name="134"></a>         *   since if we did so we could show items at recursive depths
<a name="135"></a>         *   more than once; if we're already doing a recursive listing,
<a name="136"></a>         *   our caller will itself recurse through all levels of the
<a name="137"></a>         *   tree, so we don't have to recurse any further ourselves.  
<a name="138"></a>         */
<a name="139"></a>        if ((options &amp; ListRecurse) != 0
<a name="140"></a>            &amp;&amp; indent == 0
<a name="141"></a>            &amp;&amp; (options &amp; ListContents) == 0)
<a name="142"></a>        {
<a name="143"></a>            /* show the contents of each object we didn't list */
<a name="144"></a>            showSeparateContents(pov, origLst,
<a name="145"></a>                                 options | ListContents, infoTab);
<a name="146"></a>        }
<a name="147"></a>    }
<a name="148"></a>
<a name="149"></a>    /*
<a name="150"></a>     *   Filter a list to get only the elements we actually want to show.
<a name="151"></a>     *   Returns a new list consisting only of the items that (1) pass the
<a name="152"></a>     *   isListed() test, and (2) are represented in the sense information
<a name="153"></a>     *   table (infoTab).  If infoTab is nil, no sense filtering is
<a name="154"></a>     *   applied.  
<a name="155"></a>     */
<a name="156"></a>    getFilteredList(lst, infoTab)
<a name="157"></a>    {
<a name="158"></a>        /* narrow the list down based on the isListed criteria */
<a name="159"></a>        lst = lst.subset({x: isListed(x)});
<a name="160"></a>        
<a name="161"></a>        /* 
<a name="162"></a>         *   If we have an infoTab, build a new list consisting only of
<a name="163"></a>         *   the items in 'lst' that have infoTab entries - we can't sense
<a name="164"></a>         *   anything that doesn't have an infoTab entry, so we don't want
<a name="165"></a>         *   to show any such objects.  
<a name="166"></a>         */
<a name="167"></a>        if (infoTab != nil)
<a name="168"></a>        {
<a name="169"></a>            /* create a vector to contain the new filtered list */
<a name="170"></a>            local filteredList = new Vector(lst.length());
<a name="171"></a>            
<a name="172"></a>            /* 
<a name="173"></a>             *   run through our original list and confirm that each one
<a name="174"></a>             *   is in the infoTab
<a name="175"></a>             */
<a name="176"></a>            foreach (local cur in lst)
<a name="177"></a>            {
<a name="178"></a>                /* 
<a name="179"></a>                 *   if this item has an infoTab entry, add this item to
<a name="180"></a>                 *   the filtered list 
<a name="181"></a>                 */
<a name="182"></a>                if (infoTab[cur] != nil)
<a name="183"></a>                    filteredList.append(cur);
<a name="184"></a>            }
<a name="185"></a>            
<a name="186"></a>            /* forget the original list, and use the filtered list instead */
<a name="187"></a>            lst = filteredList;
<a name="188"></a>        }
<a name="189"></a>
<a name="190"></a>        /* return the filtered list */
<a name="191"></a>        return lst;
<a name="192"></a>    }
<a name="193"></a>    
<a name="194"></a>    /*
<a name="195"></a>     *   Get the groupings for a given listing.
<a name="196"></a>     *   
<a name="197"></a>     *   'groupTab' is an empty LookupTable, and 'groups' is an empty
<a name="198"></a>     *   Vector; we'll populate these with the grouping information.
<a name="199"></a>     *   'singles' is an empty Vector that we'll populate with the single
<a name="200"></a>     *   items not part of any group.  
<a name="201"></a>     */
<a name="202"></a>    getListGrouping(groupTab, groups, singles, lst, parentGroup)
<a name="203"></a>    {
<a name="204"></a>        local cur;
<a name="205"></a>        local i, cnt;
<a name="206"></a>
<a name="207"></a>        /* 
<a name="208"></a>         *   First, scan the list to determine how we're going to group
<a name="209"></a>         *   the objects.
<a name="210"></a>         */
<a name="211"></a>        for (i = 1, cnt = lst.length() ; i &lt;= cnt ; ++i)
<a name="212"></a>        {
<a name="213"></a>            local curGroups;
<a name="214"></a>            local parentIdx;
<a name="215"></a>            
<a name="216"></a>            /* get this object into a local for easy reference */
<a name="217"></a>            cur = lst[i];
<a name="218"></a>            
<a name="219"></a>            /* if the item isn't part of this listing, skip it */
<a name="220"></a>            if (!isListed(cur))
<a name="221"></a>                continue;
<a name="222"></a>
<a name="223"></a>            /* get the list of groups with which this object is listed */
<a name="224"></a>            curGroups = listWith(cur);
<a name="225"></a>
<a name="226"></a>            /* if there are no groups, we can move on to the next item */
<a name="227"></a>            if (curGroups == nil)
<a name="228"></a>                continue;
<a name="229"></a>
<a name="230"></a>            /* 
<a name="231"></a>             *   If we have a parent group, and it appears in the list of
<a name="232"></a>             *   groups for this item, eliminate everything in the item's
<a name="233"></a>             *   group list up to and including the parent group.  If
<a name="234"></a>             *   we're showing this list as part of a group to begin with,
<a name="235"></a>             *   we obviously don't want to show this list grouped into
<a name="236"></a>             *   the same group, and we also don't want to group it into
<a name="237"></a>             *   anything broader than the parent group.  Groups are
<a name="238"></a>             *   listed from most general to most specific, so we can
<a name="239"></a>             *   eliminate anything up to and including the parent group. 
<a name="240"></a>             */
<a name="241"></a>            if (parentGroup != nil
<a name="242"></a>                &amp;&amp; (parentIdx = curGroups.indexOf(parentGroup)) != nil)
<a name="243"></a>            {
<a name="244"></a>                /* eliminate everything up to and including the parent */
<a name="245"></a>                curGroups = curGroups.sublist(parentIdx + 1);
<a name="246"></a>            }
<a name="247"></a>
<a name="248"></a>            /* if this item has no groups, skip it */
<a name="249"></a>            if (curGroups.length() == 0)
<a name="250"></a>                continue;
<a name="251"></a>
<a name="252"></a>            /*
<a name="253"></a>             *   This item has one or more group associations that we must
<a name="254"></a>             *   consider.
<a name="255"></a>             */
<a name="256"></a>            foreach (local g in curGroups)
<a name="257"></a>            {
<a name="258"></a>                local itemsInGroup;
<a name="259"></a>                
<a name="260"></a>                /* find the group table entry for this group */
<a name="261"></a>                itemsInGroup = groupTab[g];
<a name="262"></a>
<a name="263"></a>                /* if there's no entry for this group, create a new one */
<a name="264"></a>                if (itemsInGroup == nil)
<a name="265"></a>                {
<a name="266"></a>                    /* create a new group table entry */
<a name="267"></a>                    itemsInGroup = groupTab[g] = new Vector(10);
<a name="268"></a>
<a name="269"></a>                    /* add it to the group vector */
<a name="270"></a>                    groups.append(g);
<a name="271"></a>                }
<a name="272"></a>
<a name="273"></a>                /* 
<a name="274"></a>                 *   add this item to the list of items that want to be
<a name="275"></a>                 *   grouped with this group 
<a name="276"></a>                 */
<a name="277"></a>                itemsInGroup.append(cur);
<a name="278"></a>            }
<a name="279"></a>        }
<a name="280"></a>
<a name="281"></a>        /*
<a name="282"></a>         *   We now have the set of all of the groups that could possibly
<a name="283"></a>         *   be involved in this list display.  We must now choose the
<a name="284"></a>         *   single group we'll use to display each grouped object.
<a name="285"></a>         *   
<a name="286"></a>         *   First, eliminate any groups with insufficient membership.
<a name="287"></a>         *   (Most groups require at least two members, but this can vary
<a name="288"></a>         *   by group.)  
<a name="289"></a>         */
<a name="290"></a>        for (i = 1, cnt = groups.length() ; i &lt;= cnt ; ++i)
<a name="291"></a>        {
<a name="292"></a>            /* if this group has only one member, drop it */
<a name="293"></a>            if (groupTab[groups[i]].length() &lt; groups[i].minGroupSize)
<a name="294"></a>            {
<a name="295"></a>                /* remove this group from the group list */
<a name="296"></a>                groups.removeElementAt(i);
<a name="297"></a>
<a name="298"></a>                /* 
<a name="299"></a>                 *   adjust the list count, and back up to try the element
<a name="300"></a>                 *   newly at this index on the next iteration 
<a name="301"></a>                 */
<a name="302"></a>                --cnt;
<a name="303"></a>                --i;
<a name="304"></a>            }
<a name="305"></a>        }
<a name="306"></a>
<a name="307"></a>        /*
<a name="308"></a>         *   Next, scan for groups with identical member lists, and for
<a name="309"></a>         *   groups with subset member lists.  For each pair of identical
<a name="310"></a>         *   elements we find, eliminate the more general of the two.  
<a name="311"></a>         */
<a name="312"></a>        for (i = 1, cnt = groups.length() ; i &lt;= cnt ; ++i)
<a name="313"></a>        {
<a name="314"></a>            local g1;
<a name="315"></a>            local mem1;
<a name="316"></a>
<a name="317"></a>            /* get the current group and its membership list */
<a name="318"></a>            g1 = groups[i];
<a name="319"></a>            mem1 = groupTab[g1];
<a name="320"></a>
<a name="321"></a>            /* look for matching items in the list after this one */
<a name="322"></a>            for (local j = i + 1 ; j &lt;= cnt ; ++j)
<a name="323"></a>            {
<a name="324"></a>                local g2;
<a name="325"></a>                local mem2;
<a name="326"></a>
<a name="327"></a>                /* get the current item and its membership list */
<a name="328"></a>                g2 = groups[j];
<a name="329"></a>                mem2 = groupTab[g2];
<a name="330"></a>                
<a name="331"></a>                /*
<a name="332"></a>                 *   Compare the membership lists for the two items.  Note
<a name="333"></a>                 *   that we built these membership lists all in the same
<a name="334"></a>                 *   order of objects, so if two membership lists have all
<a name="335"></a>                 *   the same members, those members will be in the same
<a name="336"></a>                 *   order in the two lists; hence, we can simply compare
<a name="337"></a>                 *   the two lists to determine the membership order.  
<a name="338"></a>                 */
<a name="339"></a>                if (mem1 == mem2)
<a name="340"></a>                {
<a name="341"></a>                    local ordList;
<a name="342"></a>                    
<a name="343"></a>                    /* 
<a name="344"></a>                     *   The groups have identical membership, so
<a name="345"></a>                     *   eliminate the more general group.  Groups are
<a name="346"></a>                     *   ordered from most general to least general, so
<a name="347"></a>                     *   keep the one with the higher index in the group
<a name="348"></a>                     *   list for an object in the membership list.  Note
<a name="349"></a>                     *   that we assume that each member has the same
<a name="350"></a>                     *   ordering for the common groups, so we can pick a
<a name="351"></a>                     *   member arbitrarily to find the way a member
<a name="352"></a>                     *   orders the groups.  
<a name="353"></a>                     */
<a name="354"></a>                    ordList = listWith(mem1[1]);
<a name="355"></a>                    if (ordList.indexOf(g1) &gt; ordList.indexOf(g2))
<a name="356"></a>                    {
<a name="357"></a>                        /* 
<a name="358"></a>                         *   group g1 is more specific than group g2, so
<a name="359"></a>                         *   keep g1 and discard g2 - remove the 'j'
<a name="360"></a>                         *   element from the list, and back up in the
<a name="361"></a>                         *   inner loop so we reconsider the element newly
<a name="362"></a>                         *   at this index on the next iteration 
<a name="363"></a>                         */
<a name="364"></a>                        groups.removeElementAt(j);
<a name="365"></a>                        --cnt;
<a name="366"></a>                        --j;
<a name="367"></a>                    }
<a name="368"></a>                    else
<a name="369"></a>                    {
<a name="370"></a>                        /* 
<a name="371"></a>                         *   group g2 is more specific, so discard g1 -
<a name="372"></a>                         *   remove the 'i' element from the list, back up
<a name="373"></a>                         *   in the outer loop, and break out of the inner
<a name="374"></a>                         *   loop, since the outer loop element is no
<a name="375"></a>                         *   longer there for us to consider in comparing
<a name="376"></a>                         *   more elements in the inner loop 
<a name="377"></a>                         */
<a name="378"></a>                        groups.removeElementAt(i);
<a name="379"></a>                        --cnt;
<a name="380"></a>                        --i;
<a name="381"></a>                        break;
<a name="382"></a>                    }
<a name="383"></a>                }
<a name="384"></a>            }
<a name="385"></a>        }
<a name="386"></a>
<a name="387"></a>        /*
<a name="388"></a>         *   Scan for subsets.  For each group whose membership list is a
<a name="389"></a>         *   subset of another group in our list, eliminate the subset,
<a name="390"></a>         *   keeping only the larger group.  The group lister will be able
<a name="391"></a>         *   to show the subgroup as grouped within its larger list.  
<a name="392"></a>         */
<a name="393"></a>        for (local i = 1, cnt = groups.length() ; i &lt;= cnt ; ++i)
<a name="394"></a>        {
<a name="395"></a>            local g1;
<a name="396"></a>            local mem1;
<a name="397"></a>
<a name="398"></a>            /* get the current group and its membership list */
<a name="399"></a>            g1 = groups[i];
<a name="400"></a>            mem1 = groupTab[g1];
<a name="401"></a>
<a name="402"></a>            /* look at the other elements to see if we have any subsets */
<a name="403"></a>            for (local j = 1 ; j &lt;= cnt ; ++j)
<a name="404"></a>            {
<a name="405"></a>                local g2;
<a name="406"></a>                local mem2;
<a name="407"></a>
<a name="408"></a>                /* don't bother checking the same element */
<a name="409"></a>                if (j == i)
<a name="410"></a>                    continue;
<a name="411"></a>
<a name="412"></a>                /* get the current item and its membership list */
<a name="413"></a>                g2 = groups[j];
<a name="414"></a>                mem2 = groupTab[g2];
<a name="415"></a>
<a name="416"></a>                /* 
<a name="417"></a>                 *   if g2's membership is a subset, eliminate g2 from the
<a name="418"></a>                 *   group list 
<a name="419"></a>                 */
<a name="420"></a>                if (isListSubset(mem2, mem1))
<a name="421"></a>                {
<a name="422"></a>                    /* remove g2 from the list */
<a name="423"></a>                    groups.removeElementAt(j);
<a name="424"></a>
<a name="425"></a>                    /* adjust the loop counters for the removal */
<a name="426"></a>                    --cnt;
<a name="427"></a>                    --j;
<a name="428"></a>
<a name="429"></a>                    /* 
<a name="430"></a>                     *   adjust the outer loop counter if it's affected -
<a name="431"></a>                     *   the outer loop is affected if it's already past
<a name="432"></a>                     *   this point in the list, which means that its
<a name="433"></a>                     *   index is higher than the inner loop index 
<a name="434"></a>                     */
<a name="435"></a>                    if (i &gt; j)
<a name="436"></a>                        --i;
<a name="437"></a>                }
<a name="438"></a>            }
<a name="439"></a>        }
<a name="440"></a>
<a name="441"></a>        /*
<a name="442"></a>         *   We now have a final accounting of the groups that we will
<a name="443"></a>         *   consider using.  Reset the membership list for each group in
<a name="444"></a>         *   the surviving list. 
<a name="445"></a>         */
<a name="446"></a>        foreach (local g in groups)
<a name="447"></a>        {
<a name="448"></a>            local itemsInList;
<a name="449"></a>
<a name="450"></a>            /* get this group's membership list vector */
<a name="451"></a>            itemsInList = groupTab[g];
<a name="452"></a>
<a name="453"></a>            /* clear the vector */
<a name="454"></a>            itemsInList.removeRange(1, itemsInList.length());
<a name="455"></a>        }
<a name="456"></a>
<a name="457"></a>        /*
<a name="458"></a>         *   Now, run through our item list again, and assign each item to
<a name="459"></a>         *   the surviving group that comes earliest in the item's group
<a name="460"></a>         *   list.  
<a name="461"></a>         */
<a name="462"></a>        for (i = 1, cnt = lst.length() ; i &lt;= cnt ; ++i)
<a name="463"></a>        {
<a name="464"></a>            local curGroups;
<a name="465"></a>            local winningGroup;
<a name="466"></a>
<a name="467"></a>            /* get this object into a local for easy reference */
<a name="468"></a>            cur = lst[i];
<a name="469"></a>            
<a name="470"></a>            /* if the item isn't part of this listing, skip it */
<a name="471"></a>            if (!isListed(cur))
<a name="472"></a>                continue;
<a name="473"></a>
<a name="474"></a>            /* get the list of groups with which this object is listed */
<a name="475"></a>            curGroups = listWith(cur);
<a name="476"></a>            if (curGroups == nil)
<a name="477"></a>                curGroups = [];
<a name="478"></a>
<a name="479"></a>            /* 
<a name="480"></a>             *   find the first element in the group list that is in the
<a name="481"></a>             *   surviving group list
<a name="482"></a>             */
<a name="483"></a>            winningGroup = nil;
<a name="484"></a>            foreach (local g in curGroups)
<a name="485"></a>            {
<a name="486"></a>                /* if this group is in the surviving list, it's the one */
<a name="487"></a>                if (groups.indexOf(g) != nil)
<a name="488"></a>                {
<a name="489"></a>                    winningGroup = g;
<a name="490"></a>                    break;
<a name="491"></a>                }
<a name="492"></a>            }
<a name="493"></a>
<a name="494"></a>            /* 
<a name="495"></a>             *   if we have a group, add this item to the group's
<a name="496"></a>             *   membership; otherwise, add it to the singles list 
<a name="497"></a>             */
<a name="498"></a>            if (winningGroup != nil)
<a name="499"></a>                groupTab[winningGroup].append(cur);
<a name="500"></a>            else
<a name="501"></a>                singles.append(cur);
<a name="502"></a>        }
<a name="503"></a>
<a name="504"></a>        /* eliminate any surviving group with too few members */
<a name="505"></a>        for (i = 1, cnt = groups.length() ; i &lt;= cnt ; ++i)
<a name="506"></a>        {
<a name="507"></a>            local mem;
<a name="508"></a>
<a name="509"></a>            /* get this group's membership list */
<a name="510"></a>            mem = groupTab[groups[i]];
<a name="511"></a>
<a name="512"></a>            /* 
<a name="513"></a>             *   if this group's membership is too small, eliminate the
<a name="514"></a>             *   group and add the member into the singles pile 
<a name="515"></a>             */
<a name="516"></a>            if (mem.length() &lt; groups[i].minGroupSize)
<a name="517"></a>            {
<a name="518"></a>                /* put the item into the singles list */
<a name="519"></a>                if (mem.length() &gt; 0)
<a name="520"></a>                    singles.append(mem[1]);
<a name="521"></a>
<a name="522"></a>                /* eliminate this item from the group list */
<a name="523"></a>                groups.removeElementAt(i);
<a name="524"></a>
<a name="525"></a>                /* adjust the loop counters */
<a name="526"></a>                --cnt;
<a name="527"></a>                --i;
<a name="528"></a>            }
<a name="529"></a>        }
<a name="530"></a>
<a name="531"></a>        /* return the cardinality of the arranged list */
<a name="532"></a>        return getArrangedListCardinality(singles, groups, groupTab);
<a name="533"></a>    }
<a name="534"></a>
<a name="535"></a>    /*
<a name="536"></a>     *   Show the list.  This is called after we've figured out which items
<a name="537"></a>     *   we intend to display, and after we've arranged the items into
<a name="538"></a>     *   groups.  In rare cases, listers might want to override this, to
<a name="539"></a>     *   customize the way the way the list is displayed based on the
<a name="540"></a>     *   internal arrangement of the list.  
<a name="541"></a>     */
<a name="542"></a>    showArrangedList(pov, parent, lst, options, indent, infoTab, itemCount,
<a name="543"></a>                     singles, groups, groupTab, origLst)
<a name="544"></a>    {
<a name="545"></a>        /*
<a name="546"></a>         *   We now know how many items we're listing (grammatically
<a name="547"></a>         *   speaking), so we're ready to display the list prefix.  If
<a name="548"></a>         *   we're displaying nothing at all, just display the "empty"
<a name="549"></a>         *   message, and we're done.  
<a name="550"></a>         */
<a name="551"></a>        if (itemCount == 0)
<a name="552"></a>        {
<a name="553"></a>            /* show the empty list */
<a name="554"></a>            showListEmpty(pov, parent);
<a name="555"></a>        }
<a name="556"></a>        else
<a name="557"></a>        {
<a name="558"></a>            local i;
<a name="559"></a>            local cnt;
<a name="560"></a>            local sublists;
<a name="561"></a>            local origOptions = options;
<a name="562"></a>            local itemOptions;
<a name="563"></a>            local groupOptions;
<a name="564"></a>            local listCount;
<a name="565"></a>            local dispCount;
<a name="566"></a>            local cur;
<a name="567"></a>
<a name="568"></a>            /* 
<a name="569"></a>             *   Check to see if we have one or more group sublists - if
<a name="570"></a>             *   we do, we must use the "long" list format for our overall
<a name="571"></a>             *   list, otherwise we can use the normal "short" list
<a name="572"></a>             *   format.  The long list format uses semicolons to separate
<a name="573"></a>             *   items.  
<a name="574"></a>             */
<a name="575"></a>            for (i = 1, cnt = groups.length(), sublists = nil ;
<a name="576"></a>                 i &lt;= cnt ; ++i)
<a name="577"></a>            {
<a name="578"></a>                /* 
<a name="579"></a>                 *   if this group's lister item displays a sublist, we
<a name="580"></a>                 *   must use the long format 
<a name="581"></a>                 */
<a name="582"></a>                if (groups[i].groupDisplaysSublist)
<a name="583"></a>                {
<a name="584"></a>                    /* note that we are using the long format */
<a name="585"></a>                    sublists = true;
<a name="586"></a>                    
<a name="587"></a>                    /* 
<a name="588"></a>                     *   one is enough to make us use the long format, so
<a name="589"></a>                     *   we need not look any further 
<a name="590"></a>                     */
<a name="591"></a>                    break;
<a name="592"></a>                }
<a name="593"></a>            }
<a name="594"></a>            
<a name="595"></a>            /* generate the prefix message if we're in a 'tall' listing */
<a name="596"></a>            if ((options &amp; ListTall) != 0)
<a name="597"></a>            {
<a name="598"></a>                /* indent the prefix */
<a name="599"></a>                showListIndent(options, indent);
<a name="600"></a>                
<a name="601"></a>                /* 
<a name="602"></a>                 *   Show the prefix.  If this is a contents listing, and
<a name="603"></a>                 *   it's not at the top level, show the contents prefix;
<a name="604"></a>                 *   otherwise show the full list prefix.  Note that we can
<a name="605"></a>                 *   have a contents listing at the top level, since some
<a name="606"></a>                 *   lists are broken out for separate listing.  
<a name="607"></a>                 */
<a name="608"></a>                if ((options &amp; ListContents) != 0 &amp;&amp; indent != 0)
<a name="609"></a>                    showListContentsPrefixTall(itemCount, pov, parent);
<a name="610"></a>                else
<a name="611"></a>                    showListPrefixTall(itemCount, pov, parent);
<a name="612"></a>                
<a name="613"></a>                /* go to a new line for the list contents */
<a name="614"></a>                "\n";
<a name="615"></a>                
<a name="616"></a>                /* indent the items one level now, since we showed a prefix */
<a name="617"></a>                ++indent;
<a name="618"></a>            }
<a name="619"></a>            else
<a name="620"></a>            {
<a name="621"></a>                /* show the prefix */
<a name="622"></a>                showListPrefixWide(itemCount, pov, parent);
<a name="623"></a>            }
<a name="624"></a>            
<a name="625"></a>            /* 
<a name="626"></a>             *   regardless of whether we're adding long formatting to the
<a name="627"></a>             *   main list, display the group sublists with whatever
<a name="628"></a>             *   formatting we were originally using 
<a name="629"></a>             */
<a name="630"></a>            groupOptions = options;
<a name="631"></a>            
<a name="632"></a>            /* show each item with our current set of options */
<a name="633"></a>            itemOptions = options;
<a name="634"></a>            
<a name="635"></a>            /* 
<a name="636"></a>             *   if we're using sublists, show "long list" separators in
<a name="637"></a>             *   the main list 
<a name="638"></a>             */
<a name="639"></a>            if (sublists)
<a name="640"></a>                itemOptions |= ListLong;
<a name="641"></a>            
<a name="642"></a>            /* 
<a name="643"></a>             *   calculate the number of items we'll show in the list -
<a name="644"></a>             *   each group shows up as one list entry, so the total
<a name="645"></a>             *   number of list entries is the number of single items plus
<a name="646"></a>             *   the number of groups 
<a name="647"></a>             */
<a name="648"></a>            listCount = singles.length() + groups.length();
<a name="649"></a>
<a name="650"></a>            /*
<a name="651"></a>             *   Show the items.  Run through the (filtered) original
<a name="652"></a>             *   list, so that we show everything in the original sorting
<a name="653"></a>             *   order.  
<a name="654"></a>             */
<a name="655"></a>            dispCount = 0;
<a name="656"></a>            foreach (cur in lst)
<a name="657"></a>            {
<a name="658"></a>                local group;
<a name="659"></a>                local displayedCur;
<a name="660"></a>                
<a name="661"></a>                /* presume we'll display this item */
<a name="662"></a>                displayedCur = true;
<a name="663"></a>                
<a name="664"></a>                /*
<a name="665"></a>                 *   Figure out how to show this item: if it's in the
<a name="666"></a>                 *   singles list, show it as a single item; if it's in
<a name="667"></a>                 *   the group list, show its group; if it's in a group
<a name="668"></a>                 *   we've previously shown, show nothing, as we showed
<a name="669"></a>                 *   the item when we showed its group.  
<a name="670"></a>                 */
<a name="671"></a>                if (singles.indexOf(cur) != nil)
<a name="672"></a>                {
<a name="673"></a>                    /*
<a name="674"></a>                     *   It's in the singles list, so show it as a single
<a name="675"></a>                     *   item.
<a name="676"></a>                     *   
<a name="677"></a>                     *   If the item has contents that we'll display in
<a name="678"></a>                     *   'tall' mode, show the item with its contents - we
<a name="679"></a>                     *   don't need to show the item separately, since it
<a name="680"></a>                     *   will provide a 'tall' list prefix showing itself.
<a name="681"></a>                     *   Otherwise, show the item singly.  
<a name="682"></a>                     */
<a name="683"></a>                    if ((options &amp; ListTall) != 0
<a name="684"></a>                        &amp;&amp; (options &amp; ListRecurse) != 0
<a name="685"></a>                        &amp;&amp; contentsListed(cur)
<a name="686"></a>                        &amp;&amp; getListedContents(cur, infoTab) != [])
<a name="687"></a>                    {
<a name="688"></a>                        /* show the item with its contents */
<a name="689"></a>                        showContentsList(pov, cur, origOptions | ListContents,
<a name="690"></a>                                         indent, infoTab);
<a name="691"></a>                    }
<a name="692"></a>                    else
<a name="693"></a>                    {
<a name="694"></a>                        /* show the list indent if necessary */
<a name="695"></a>                        showListIndent(itemOptions, indent);
<a name="696"></a>                        
<a name="697"></a>                        /* show the item */
<a name="698"></a>                        showListItem(cur, itemOptions, pov, infoTab);
<a name="699"></a>                        
<a name="700"></a>                        /* 
<a name="701"></a>                         *   if we're in wide recursive mode, show the
<a name="702"></a>                         *   item's contents as an in-line parenthetical 
<a name="703"></a>                         */
<a name="704"></a>                        if ((options &amp; ListTall) == 0
<a name="705"></a>                            &amp;&amp; (options &amp; ListRecurse) != 0
<a name="706"></a>                            &amp;&amp; contentsListed(cur)
<a name="707"></a>                            &amp;&amp; !contentsListedSeparately(cur))
<a name="708"></a>                        {
<a name="709"></a>                            /* show the item's in-line contents */
<a name="710"></a>                            showInlineContentsList(pov, cur,
<a name="711"></a>                                origOptions | ListContents,
<a name="712"></a>                                indent + 1, infoTab);
<a name="713"></a>                        }
<a name="714"></a>                    }
<a name="715"></a>                }
<a name="716"></a>                else if ((group = groups.valWhich(
<a name="717"></a>                    {g: groupTab[g].indexOf(cur) != nil})) != nil)
<a name="718"></a>                {
<a name="719"></a>                    /* show the list indent if necessary */
<a name="720"></a>                    showListIndent(itemOptions, indent);
<a name="721"></a>                    
<a name="722"></a>                    /* we found the item in a group, so show its group */
<a name="723"></a>                    group.showGroupList(pov, self, groupTab[group],
<a name="724"></a>                                        groupOptions, indent, infoTab);
<a name="725"></a>
<a name="726"></a>                    /* 
<a name="727"></a>                     *   Forget this group - we only need to show each
<a name="728"></a>                     *   group once, since the group shows every item it
<a name="729"></a>                     *   contains.  Since we'll encounter the groups other
<a name="730"></a>                     *   members as we continue to scan the main list, we
<a name="731"></a>                     *   want to make sure we don't show the group again
<a name="732"></a>                     *   when we reach the other items.  
<a name="733"></a>                     */
<a name="734"></a>                    groups.removeElement(group);
<a name="735"></a>                }
<a name="736"></a>                else
<a name="737"></a>                {
<a name="738"></a>                    /* 
<a name="739"></a>                     *   We didn't find the item in the singles list or in
<a name="740"></a>                     *   a group - it must be part of a group that we
<a name="741"></a>                     *   already showed previously, so we don't need to
<a name="742"></a>                     *   show it again now.  Simply make a note that we
<a name="743"></a>                     *   didn't display it.  
<a name="744"></a>                     */
<a name="745"></a>                    displayedCur = nil;
<a name="746"></a>                }
<a name="747"></a>                
<a name="748"></a>                /* if we displayed the item, show a suitable separator */
<a name="749"></a>                if (displayedCur)
<a name="750"></a>                {
<a name="751"></a>                    /* count another list entry displayed */
<a name="752"></a>                    ++dispCount;
<a name="753"></a>                    
<a name="754"></a>                    /* show an appropriate separator */
<a name="755"></a>                    showListSeparator(itemOptions, dispCount, listCount);
<a name="756"></a>                }
<a name="757"></a>            }
<a name="758"></a>
<a name="759"></a>            /* 
<a name="760"></a>             *   if we're in 'wide' mode, finish the listing (note that if
<a name="761"></a>             *   this is a 'tall' listing, we're already done, because a
<a name="762"></a>             *   tall listing format doesn't make provisions for anything
<a name="763"></a>             *   after the item list) 
<a name="764"></a>             */
<a name="765"></a>            if ((options &amp; ListTall) == 0)
<a name="766"></a>            {
<a name="767"></a>                /* show the wide-mode list suffix */
<a name="768"></a>                showListSuffixWide(itemCount, pov, parent);
<a name="769"></a>            }
<a name="770"></a>        }
<a name="771"></a>    }
<a name="772"></a>
<a name="773"></a>    /*
<a name="774"></a>     *   Get the cardinality of an arranged list.  Returns the number of
<a name="775"></a>     *   items that will appear in the list, for grammatical agreement.  
<a name="776"></a>     */
<a name="777"></a>    getArrangedListCardinality(singles, groups, groupTab)
<a name="778"></a>    {
<a name="779"></a>        local cnt;
<a name="780"></a>
<a name="781"></a>        /* start with a count of zero; we'll add to it as we go */
<a name="782"></a>        cnt = 0;
<a name="783"></a>        
<a name="784"></a>        /* 
<a name="785"></a>         *   Add up the cardinality of the single items.  Some individual
<a name="786"></a>         *   items in the singles list might count as multiple items
<a name="787"></a>         *   grammatically - in particular, if an item has a plural name,
<a name="788"></a>         *   we need a plural verb to agree with it. 
<a name="789"></a>         */
<a name="790"></a>        foreach (local s in singles)
<a name="791"></a>        {
<a name="792"></a>            /* add the grammatical cardinality of this single item */
<a name="793"></a>            cnt += listCardinality(s);
<a name="794"></a>        }
<a name="795"></a>        
<a name="796"></a>        /* add in the cardinality of each group */
<a name="797"></a>        foreach (local g in groups)
<a name="798"></a>        {
<a name="799"></a>            /* add the grammatical cardinality of this group */
<a name="800"></a>            cnt += g.groupCardinality(self, groupTab[g]);
<a name="801"></a>        }
<a name="802"></a>
<a name="803"></a>        /* return the total */
<a name="804"></a>        return cnt;
<a name="805"></a>    }
<a name="806"></a>
<a name="807"></a>    /*
<a name="808"></a>     *   Get the number of noun phrase elements in a list.  This differs
<a name="809"></a>     *   from the cardinality in that we only count noun phrases, not the
<a name="810"></a>     *   cardinality of each noun phrase.  So, for example, "five coins"
<a name="811"></a>     *   has cardinality five, but has only one noun phrase.  
<a name="812"></a>     */
<a name="813"></a>    getArrangedListNounPhraseCount(singles, groups, groupTab)
<a name="814"></a>    {
<a name="815"></a>        local cnt;
<a name="816"></a>        
<a name="817"></a>        /* each single item counts as one noun phrase */
<a name="818"></a>        cnt = singles.length();
<a name="819"></a>        
<a name="820"></a>        /* add in the noun phrases from each group */
<a name="821"></a>        foreach (local g in groups)
<a name="822"></a>            cnt += g.groupNounPhraseCount(self, groupTab[g]);
<a name="823"></a>
<a name="824"></a>        /* return the total */
<a name="825"></a>        return cnt;
<a name="826"></a>    }
<a name="827"></a>
<a name="828"></a>    /*
<a name="829"></a>     *   Service routine: show the separately-listed contents of the items
<a name="830"></a>     *   in the given list, and their separately-listed contents, and so
<a name="831"></a>     *   on.  This routine is not normally overridden in subclasses, and is
<a name="832"></a>     *   not usually called except from the Lister implementation.
<a name="833"></a>     *   
<a name="834"></a>     *   For each item in the given list, we show the item's contents if
<a name="835"></a>     *   the item is either marked as unlisted, or it's marked as showing
<a name="836"></a>     *   its contents separately.  In the former case, we know that we
<a name="837"></a>     *   cannot have shown the item's contents in-line in the main list,
<a name="838"></a>     *   since we didn't show the item at all in the main list.  In the
<a name="839"></a>     *   latter case, we know that we didn't show the item's contents in
<a name="840"></a>     *   the main list because it's specifically marked as showing its
<a name="841"></a>     *   contents out-of-line.  
<a name="842"></a>     */
<a name="843"></a>    showSeparateContents(pov, lst, options, infoTab)
<a name="844"></a>    {
<a name="845"></a>        /* 
<a name="846"></a>         *   show the separate contents list for each item in the list
<a name="847"></a>         *   which isn't itself listable or which has its contents listed
<a name="848"></a>         *   separately despite its being listed 
<a name="849"></a>         */
<a name="850"></a>        foreach (local cur in lst)
<a name="851"></a>        {
<a name="852"></a>            /* only show the contents if the contents are listed */
<a name="853"></a>            if (contentsListed(cur))
<a name="854"></a>            {
<a name="855"></a>                /* 
<a name="856"></a>                 *   if we didn't list this item, or if it specifically
<a name="857"></a>                 *   wants its contents listed out-of-line, show its
<a name="858"></a>                 *   listable contents 
<a name="859"></a>                 */
<a name="860"></a>                if (!isListed(cur) || contentsListedSeparately(cur))
<a name="861"></a>                {
<a name="862"></a>                    /* 
<a name="863"></a>                     *   Show the item's contents.  Note that even though
<a name="864"></a>                     *   we're showing this list recursively, it's actually
<a name="865"></a>                     *   a new top-level list, so show it at indent level
<a name="866"></a>                     *   zero.  
<a name="867"></a>                     */
<a name="868"></a>                    showContentsList(pov, cur, options, 0, infoTab);
<a name="869"></a>                }
<a name="870"></a>
<a name="871"></a>                /* recursively do the same thing with its contents */
<a name="872"></a>                showSeparateContents(pov, getContents(cur), options, infoTab);
<a name="873"></a>            }
<a name="874"></a>        }
<a name="875"></a>    }
<a name="876"></a>
<a name="877"></a>    /*	
<a name="878"></a>     *   Show a list indent if necessary.  If ListTall is included in the
<a name="879"></a>     *   options, we'll indent to the given level; otherwise we'll do
<a name="880"></a>     *   nothing.  
<a name="881"></a>     */
<a name="882"></a>    showListIndent(options, indent)
<a name="883"></a>    {
<a name="884"></a>        /* show the indent only if we're in "tall" mode */
<a name="885"></a>        if ((options &amp; ListTall) != 0)
<a name="886"></a>        {
<a name="887"></a>            for (local i = 0 ; i &lt; indent ; ++i)
<a name="888"></a>                "\t";
<a name="889"></a>        }
<a name="890"></a>    }
<a name="891"></a>
<a name="892"></a>    /*
<a name="893"></a>     *   Show a newline after a list item if we're in a tall list; does
<a name="894"></a>     *   nothing for a wide list.  
<a name="895"></a>     */
<a name="896"></a>    showTallListNewline(options)
<a name="897"></a>    {
<a name="898"></a>        if ((options &amp; ListTall) != 0)
<a name="899"></a>            "\n";
<a name="900"></a>    }
<a name="901"></a>
<a name="902"></a>    /*
<a name="903"></a>     *   Show a simple list, recursing into contents lists if necessary.
<a name="904"></a>     *   We pay no attention to grouping; we just show the items
<a name="905"></a>     *   individually.
<a name="906"></a>     *   
<a name="907"></a>     *   'prevCnt' is the number of items already displayed, if anything
<a name="908"></a>     *   has already been displayed for this list.  This should be zero if
<a name="909"></a>     *   this will display the entire list.  
<a name="910"></a>     */
<a name="911"></a>    showListSimple(pov, lst, options, indent, prevCnt, infoTab)
<a name="912"></a>    {
<a name="913"></a>        local i;
<a name="914"></a>        local cnt;
<a name="915"></a>        local dispCount;
<a name="916"></a>        local totalCount;
<a name="917"></a>
<a name="918"></a>        /* calculate the total number of items in the lis t*/
<a name="919"></a>        totalCount = prevCnt + lst.length();
<a name="920"></a>        
<a name="921"></a>        /* display the items */
<a name="922"></a>        for (i = 1, cnt = lst.length(), dispCount = prevCnt ; i &lt;= cnt ; ++i)
<a name="923"></a>        {
<a name="924"></a>            local cur;
<a name="925"></a>            
<a name="926"></a>            /* get the item */
<a name="927"></a>            cur = lst[i];
<a name="928"></a>            
<a name="929"></a>            /* 
<a name="930"></a>             *   If the item has contents that we'll display in 'tall'
<a name="931"></a>             *   mode, show the item with its contents - we don't need to
<a name="932"></a>             *   show the item separately, since it will provide a 'tall'
<a name="933"></a>             *   list prefix showing itself.  Otherwise, show the item
<a name="934"></a>             *   singly.  
<a name="935"></a>             */
<a name="936"></a>            if ((options &amp; ListTall) != 0
<a name="937"></a>                &amp;&amp; (options &amp; ListRecurse) != 0
<a name="938"></a>                &amp;&amp; contentsListed(cur)
<a name="939"></a>                &amp;&amp; getListedContents(cur, infoTab) != [])
<a name="940"></a>            {
<a name="941"></a>                /* show the item with its contents */
<a name="942"></a>                showContentsList(pov, cur, options | ListContents,
<a name="943"></a>                                 indent + 1, infoTab);
<a name="944"></a>            }
<a name="945"></a>            else
<a name="946"></a>            {
<a name="947"></a>                /* show the list indent if necessary */
<a name="948"></a>                showListIndent(options, indent);
<a name="949"></a>                
<a name="950"></a>                /* show the item */
<a name="951"></a>                showListItem(cur, options, pov, infoTab);
<a name="952"></a>
<a name="953"></a>                /* 
<a name="954"></a>                 *   if we're in wide recursive mode, show the item's
<a name="955"></a>                 *   contents as an in-line parenthetical 
<a name="956"></a>                 */
<a name="957"></a>                if ((options &amp; ListTall) == 0
<a name="958"></a>                    &amp;&amp; (options &amp; ListRecurse) != 0
<a name="959"></a>                    &amp;&amp; contentsListed(cur)
<a name="960"></a>                    &amp;&amp; !contentsListedSeparately(cur))
<a name="961"></a>                {
<a name="962"></a>                    /* show the item's in-line contents */
<a name="963"></a>                    showInlineContentsList(pov, cur,
<a name="964"></a>                                           options | ListContents,
<a name="965"></a>                                           indent + 1, infoTab);
<a name="966"></a>                }
<a name="967"></a>            }
<a name="968"></a>
<a name="969"></a>            /* count the item displayed */
<a name="970"></a>            ++dispCount;
<a name="971"></a>
<a name="972"></a>            /* show the list separator */
<a name="973"></a>            showListSeparator(options, dispCount, totalCount);
<a name="974"></a>        }
<a name="975"></a>    }
<a name="976"></a>
<a name="977"></a>    /*
<a name="978"></a>     *   List the contents of an item.
<a name="979"></a>     *   
<a name="980"></a>     *   'pov' is the point of view, which is usually an actor (and
<a name="981"></a>     *   usually the player character actor).
<a name="982"></a>     *   
<a name="983"></a>     *   'obj' is the item whose contents we are to display.
<a name="984"></a>     *   
<a name="985"></a>     *   'options' is the set of flags that we'll pass to showList(), and
<a name="986"></a>     *   has the same meaning as for that function.
<a name="987"></a>     *   
<a name="988"></a>     *   'infoTab' is a lookup table of SenseInfo objects giving the sense
<a name="989"></a>     *   information for all of the objects that the actor to whom we're
<a name="990"></a>     *   showing the contents listing can sense.  
<a name="991"></a>     */
<a name="992"></a>    showContentsList(pov, obj, options, indent, infoTab)
<a name="993"></a>    {
<a name="994"></a>        /* 
<a name="995"></a>         *   List the item's contents.  By default, use the contentsLister
<a name="996"></a>         *   property of the object whose contents we're showing to obtain
<a name="997"></a>         *   the lister for the contents.  
<a name="998"></a>         */
<a name="999"></a>        obj.showObjectContents(pov, obj.contentsLister, options,
<a name="1000"></a>                               indent, infoTab);
<a name="1001"></a>    }
<a name="1002"></a>
<a name="1003"></a>    /*
<a name="1004"></a>     *   Determine if an object's contents are listed separately from its
<a name="1005"></a>     *   own list entry for the purposes of our type of listing.  If this
<a name="1006"></a>     *   returns true, then we'll list the object's contents in a separate
<a name="1007"></a>     *   listing (a separate sentence following the main listing sentence,
<a name="1008"></a>     *   or a separate tree when in 'tall' mode).
<a name="1009"></a>     *   
<a name="1010"></a>     *   Note that this only matters for objects listed in the top-level
<a name="1011"></a>     *   list.  We'll always show the contents separately for an object
<a name="1012"></a>     *   that isn't listed in the top-level list (i.e., an object for which
<a name="1013"></a>     *   isListed(obj) returns nil).  
<a name="1014"></a>     */
<a name="1015"></a>    contentsListedSeparately(obj) { return obj.contentsListedSeparately; }
<a name="1016"></a>
<a name="1017"></a>    /*
<a name="1018"></a>     *   Show an "in-line" contents list.  This shows the item's contents
<a name="1019"></a>     *   list as a parenthetical, as part of a recursive listing.  This is
<a name="1020"></a>     *   pretty much the same as showContentsList(), but uses the object's
<a name="1021"></a>     *   in-line contents lister instead of its regular contents lister.  
<a name="1022"></a>     */
<a name="1023"></a>    showInlineContentsList(pov, obj, options, indent, infoTab)
<a name="1024"></a>    {
<a name="1025"></a>        /* show the item's contents using its in-line contents lister */
<a name="1026"></a>        obj.showObjectContents(pov, obj.inlineContentsLister,
<a name="1027"></a>                               options, indent, infoTab);
<a name="1028"></a>    }
<a name="1029"></a>
<a name="1030"></a>    /* 
<a name="1031"></a>     *   Show the prefix for a 'wide' listing - this is a message that
<a name="1032"></a>     *   appears just before we start listing the objects.  'itemCount' is
<a name="1033"></a>     *   the number of items to be listed; the items might be grouped in
<a name="1034"></a>     *   the listing, so a list that comes out as "three boxes and two
<a name="1035"></a>     *   books" will have an itemCount of 5.  (The purpose of itemCount is
<a name="1036"></a>     *   to allow the message to have grammatical agreement in number.)
<a name="1037"></a>     *   
<a name="1038"></a>     *   This will never be called with an itemCount of zero, because we
<a name="1039"></a>     *   will instead use showListEmpty() to display an empty list.  
<a name="1040"></a>     */
<a name="1041"></a>    showListPrefixWide(itemCount, pov, parent) { }
<a name="1042"></a>
<a name="1043"></a>    /* 
<a name="1044"></a>     *   show the suffix for a 'wide' listing - this is a message that
<a name="1045"></a>     *   appears just after we finish listing the objects 
<a name="1046"></a>     */
<a name="1047"></a>    showListSuffixWide(itemCount, pov, parent) { }
<a name="1048"></a>
<a name="1049"></a>    /* 
<a name="1050"></a>     *   Show the list prefix for a 'tall' listing.  Note that there is no
<a name="1051"></a>     *   list suffix for a tall listing, because the format doesn't allow
<a name="1052"></a>     *   it. 
<a name="1053"></a>     */
<a name="1054"></a>    showListPrefixTall(itemCount, pov, parent) { }
<a name="1055"></a>
<a name="1056"></a>    /* 
<a name="1057"></a>     *   Show the list prefix for the contents of an object in a 'tall'
<a name="1058"></a>     *   listing.  By default, we just show our usual tall list prefix.  
<a name="1059"></a>     */
<a name="1060"></a>    showListContentsPrefixTall(itemCount, pov, parent)
<a name="1061"></a>        { showListPrefixTall(itemCount, pov, parent); }
<a name="1062"></a>
<a name="1063"></a>    /*
<a name="1064"></a>     *   Show an empty list.  If the list to be displayed has no items at
<a name="1065"></a>     *   all, this is called instead of the prefix/suffix routines.  This
<a name="1066"></a>     *   can be left empty if no message is required for an empty list, or
<a name="1067"></a>     *   can display the complete message appropriate for an empty list
<a name="1068"></a>     *   (such as "You are empty-handed").  
<a name="1069"></a>     */
<a name="1070"></a>    showListEmpty(pov, parent) { }
<a name="1071"></a>
<a name="1072"></a>    /*
<a name="1073"></a>     *   Is this item to be listed in room descriptions?  Returns true if
<a name="1074"></a>     *   so, nil if not.  By default, we'll use the object's isListed
<a name="1075"></a>     *   method to make this determination.  We virtualize this into the
<a name="1076"></a>     *   lister interface to allow for different inclusion rules for the
<a name="1077"></a>     *   same object depending on the type of list we're generating.  
<a name="1078"></a>     */
<a name="1079"></a>    isListed(obj) { return obj.isListed(); }
<a name="1080"></a>
<a name="1081"></a>    /*
<a name="1082"></a>     *   Get the grammatical cardinality of this listing item.  This should
<a name="1083"></a>     *   return the number of items that this item appears to be
<a name="1084"></a>     *   grammatically, for noun-verb agreement purposes.  
<a name="1085"></a>     */
<a name="1086"></a>    listCardinality(obj) { return obj.listCardinality(self); }
<a name="1087"></a>
<a name="1088"></a>    /*
<a name="1089"></a>     *   Are this item's contents listable?  
<a name="1090"></a>     */
<a name="1091"></a>    contentsListed(obj) { return obj.contentsListed; }
<a name="1092"></a>
<a name="1093"></a>    /*
<a name="1094"></a>     *   Get all contents of this item. 
<a name="1095"></a>     */
<a name="1096"></a>    getContents(obj) { return obj.contents; }
<a name="1097"></a>
<a name="1098"></a>    /*
<a name="1099"></a>     *   Get the listed contents of an object.  'infoTab' is the sense
<a name="1100"></a>     *   information table for the enclosing listing.  By default, we call
<a name="1101"></a>     *   the object's getListedContents() method, but this is virtualized
<a name="1102"></a>     *   in the lister interface to allow for listing other hierarchies
<a name="1103"></a>     *   besides ordinary contents.  
<a name="1104"></a>     */
<a name="1105"></a>    getListedContents(obj, infoTab)
<a name="1106"></a>    {
<a name="1107"></a>        return obj.getListedContents(self, infoTab);
<a name="1108"></a>    }
<a name="1109"></a>
<a name="1110"></a>    /*
<a name="1111"></a>     *   Get the list of grouping objects for listing the item.  By
<a name="1112"></a>     *   default, we return the object's listWith result.  Subclasses can
<a name="1113"></a>     *   override this to specify different groupings for the same object
<a name="1114"></a>     *   depending on the type of list we're generating.
<a name="1115"></a>     *   
<a name="1116"></a>     *   The group list returned is in order from most general to most
<a name="1117"></a>     *   specific.  For example, if an item is grouped with coins in
<a name="1118"></a>     *   general and silver coins in particular, the general coins group
<a name="1119"></a>     *   would come first, then the silver coin group, because the silver
<a name="1120"></a>     *   coin group is more specific.  
<a name="1121"></a>     */
<a name="1122"></a>    listWith(obj) { return obj.listWith; }
<a name="1123"></a>
<a name="1124"></a>    /* show an item in a list */
<a name="1125"></a>    showListItem(obj, options, pov, infoTab)
<a name="1126"></a>    {
<a name="1127"></a>        obj.showListItem(options, pov, infoTab);
<a name="1128"></a>    }
<a name="1129"></a>
<a name="1130"></a>    /* 
<a name="1131"></a>     *   Show a set of equivalent items as a counted item ("three coins").
<a name="1132"></a>     *   The listing mechanism itself never calls this directly; instead,
<a name="1133"></a>     *   this is provided so that ListGroupEquivalent can ask the lister
<a name="1134"></a>     *   how to describe its equivalent sets, so that different listers
<a name="1135"></a>     *   can customize the display of equivalent items.
<a name="1136"></a>     *   
<a name="1137"></a>     *   'lst' is the full list of equivalent items.  By default, we pick
<a name="1138"></a>     *   one of these arbitrarily to show, since they're presumably all
<a name="1139"></a>     *   the same for the purposes of the list.  
<a name="1140"></a>     */
<a name="1141"></a>    showListItemCounted(lst, options, pov, infoTab)
<a name="1142"></a>    {
<a name="1143"></a>        /* 
<a name="1144"></a>         *   by defualt, show the counted name for one of the items
<a name="1145"></a>         *   (chosen arbitrarily, since they're all the same) 
<a name="1146"></a>         */
<a name="1147"></a>        lst[1].showListItemCounted(lst, options, pov, infoTab);
<a name="1148"></a>    }
<a name="1149"></a>
<a name="1150"></a>    /*
<a name="1151"></a>     *   Show a list separator after displaying an item.  curItemNum is
<a name="1152"></a>     *   the number of the item just displayed (1 is the first item), and
<a name="1153"></a>     *   totalItems is the total number of items that will be displayed in
<a name="1154"></a>     *   the list.
<a name="1155"></a>     *   
<a name="1156"></a>     *   This generic routine is further parameterized by properties for
<a name="1157"></a>     *   the individual types of separators.  This default implementation
<a name="1158"></a>     *   distinguishes the following separators: the separator between the
<a name="1159"></a>     *   two items in a list of exactly two items; the separator between
<a name="1160"></a>     *   adjacent items other than the last two in a list of more than two
<a name="1161"></a>     *   items; and the separator between the last two elements of a list
<a name="1162"></a>     *   of more than two items.
<a name="1163"></a>     */
<a name="1164"></a>    showListSeparator(options, curItemNum, totalItems)
<a name="1165"></a>    {
<a name="1166"></a>        local useLong = ((options &amp; ListLong) != 0);
<a name="1167"></a>        
<a name="1168"></a>        /* if this is a tall list, the separator is simply a newline */
<a name="1169"></a>        if ((options &amp; ListTall) != 0)
<a name="1170"></a>        {
<a name="1171"></a>            "\n";
<a name="1172"></a>            return;
<a name="1173"></a>        }
<a name="1174"></a>        
<a name="1175"></a>        /* if that was the last item, there are no separators */
<a name="1176"></a>        if (curItemNum == totalItems)
<a name="1177"></a>            return;
<a name="1178"></a>        
<a name="1179"></a>        /* check to see if the next item is the last */
<a name="1180"></a>        if (curItemNum + 1 == totalItems)
<a name="1181"></a>        {
<a name="1182"></a>            /* 
<a name="1183"></a>             *   We just displayed the penultimate item in the list, so we
<a name="1184"></a>             *   need to use the special last-item separator.  If we're
<a name="1185"></a>             *   only displaying two items total, we use an even more
<a name="1186"></a>             *   special separator.  
<a name="1187"></a>             */
<a name="1188"></a>            if (totalItems == 2)
<a name="1189"></a>            {
<a name="1190"></a>                /* use the two-item separator */
<a name="1191"></a>                if (useLong)
<a name="1192"></a>                    longListSepTwo;
<a name="1193"></a>                else
<a name="1194"></a>                    listSepTwo;
<a name="1195"></a>            }
<a name="1196"></a>            else
<a name="1197"></a>            {
<a name="1198"></a>                /* use the normal last-item separator */
<a name="1199"></a>                if (useLong)
<a name="1200"></a>                    longListSepEnd;
<a name="1201"></a>                else
<a name="1202"></a>                    listSepEnd;
<a name="1203"></a>            }
<a name="1204"></a>        }
<a name="1205"></a>        else
<a name="1206"></a>        {
<a name="1207"></a>            /* in the middle of the list - display the normal separator */
<a name="1208"></a>            if (useLong)
<a name="1209"></a>                longListSepMiddle;
<a name="1210"></a>            else
<a name="1211"></a>                listSepMiddle;
<a name="1212"></a>        }
<a name="1213"></a>    }
<a name="1214"></a>
<a name="1215"></a>    /* 
<a name="1216"></a>     *   Show the specific types of list separators for this list.  By
<a name="1217"></a>     *   default, these will use the generic separators defined in the
<a name="1218"></a>     *   library messages object (gLibMessages).  For English, these are
<a name="1219"></a>     *   commas and semicolons for short and long lists, respectively; the
<a name="1220"></a>     *   word "and" for a list with only two items; and a comma or
<a name="1221"></a>     *   semicolon and the word "and" between the last two items in a list
<a name="1222"></a>     *   with more than two items.  
<a name="1223"></a>     */
<a name="1224"></a>
<a name="1225"></a>    /* 
<a name="1226"></a>     *   normal and "long list" separator between the two items in a list
<a name="1227"></a>     *   with exactly two items 
<a name="1228"></a>     */
<a name="1229"></a>    listSepTwo { gLibMessages.listSepTwo; }
<a name="1230"></a>    longListSepTwo { gLibMessages.longListSepTwo; }
<a name="1231"></a>
<a name="1232"></a>    /* 
<a name="1233"></a>     *   normal and long list separator between items in list with more
<a name="1234"></a>     *   than two items 
<a name="1235"></a>     */
<a name="1236"></a>    listSepMiddle { gLibMessages.listSepMiddle; }
<a name="1237"></a>    longListSepMiddle { gLibMessages.longListSepMiddle; }
<a name="1238"></a>
<a name="1239"></a>    /* 
<a name="1240"></a>     *   normal and long list separator between second-to-last and last
<a name="1241"></a>     *   items in a list with more than two items 
<a name="1242"></a>     */
<a name="1243"></a>    listSepEnd { gLibMessages.listSepEnd; }
<a name="1244"></a>    longListSepEnd { gLibMessages.longListSepEnd; }
<a name="1245"></a>
<a name="1246"></a>    /*
<a name="1247"></a>     *   Get my "top-level" lister.  For a sub-lister, this will return
<a name="1248"></a>     *   the parent lister's top-level lister.  The default lister is a
<a name="1249"></a>     *   top-level lister, so we just return ourself.  
<a name="1250"></a>     */
<a name="1251"></a>    getTopLister() { return self; }
<a name="1252"></a>
<a name="1253"></a>    /*
<a name="1254"></a>     *   The last custom flag defined by this class.  Lister and each
<a name="1255"></a>     *   subclass are required to define this so that each subclass can
<a name="1256"></a>     *   allocate its own custom flags in a manner that adapts
<a name="1257"></a>     *   automatically to future additions of flags to base classes.  As
<a name="1258"></a>     *   the base class, we allocate our flags statically with #define's,
<a name="1259"></a>     *   so we simply use the fixed #define'd last flag value here.
<a name="1260"></a>     */
<a name="1261"></a>    nextCustomFlag = ListCustomFlag
<a name="1262"></a>;
<a name="1263"></a>
<a name="1264"></a>
<a name="1265"></a>/* ------------------------------------------------------------------------ */
<a name="1266"></a>/*
<a name="1267"></a> *   A SimpleLister provides simplified interfaces for creating formatted
<a name="1268"></a> *   lists.  
<a name="1269"></a> */
<a name="1270"></a>class SimpleLister: Lister
<a name="1271"></a>    /*
<a name="1272"></a>     *   Show a formatted list given a list of items.  This lets you create
<a name="1273"></a>     *   a formatted list from an item list without worrying about
<a name="1274"></a>     *   visibility or other factors that affect the full Lister
<a name="1275"></a>     *   interfaces. 
<a name="1276"></a>     */
<a name="1277"></a>    showSimpleList(lst)
<a name="1278"></a>    {
<a name="1279"></a>        showListAll(lst, 0, 0);
<a name="1280"></a>    }
<a name="1281"></a>
<a name="1282"></a>    /* by default, everything given to a simple lister is listed */
<a name="1283"></a>    isListed(obj) { return true; }
<a name="1284"></a>
<a name="1285"></a>    /*
<a name="1286"></a>     *   Format a simple list, but rather than displaying the result,
<a name="1287"></a>     *   return it as a string.  This simply displays the list as normal,
<a name="1288"></a>     *   but captures the output as a string and returns it. 
<a name="1289"></a>     */
<a name="1290"></a>    makeSimpleList(lst)
<a name="1291"></a>    {
<a name="1292"></a>        return mainOutputStream.captureOutput({: showSimpleList(lst) });
<a name="1293"></a>    }
<a name="1294"></a>;
<a name="1295"></a>
<a name="1296"></a>/*
<a name="1297"></a> *   objectLister is a concrete SimpleLister for listing simulation
<a name="1298"></a> *   objects.
<a name="1299"></a> */
<a name="1300"></a>objectLister: SimpleLister
<a name="1301"></a>;
<a name="1302"></a>
<a name="1303"></a>/*
<a name="1304"></a> *   stringLister is a concrete SimpleLister for formatting lists of
<a name="1305"></a> *   strings.  To use this lister, pass lists of single-quoted strings
<a name="1306"></a> *   (instead of simulation objects) to showSimpleList(), etc.  
<a name="1307"></a> */
<a name="1308"></a>stringLister: SimpleLister
<a name="1309"></a>    /* show a list item - list items are strings, so simply 'say' them */
<a name="1310"></a>    showListItem(str, options, pov, infoTab) { say(str); }
<a name="1311"></a>
<a name="1312"></a>    /* 
<a name="1313"></a>     *   get the cardinality of an arranged list (we need to override this
<a name="1314"></a>     *   because our items are strings, which don't have the normal object
<a name="1315"></a>     *   properties that would let us count cardinality the usual way) 
<a name="1316"></a>     */
<a name="1317"></a>    getArrangedListCardinality(singles, groups, groupTab)
<a name="1318"></a>    {
<a name="1319"></a>        return singles.length();
<a name="1320"></a>    }    
<a name="1321"></a>;
<a name="1322"></a>
<a name="1323"></a>
<a name="1324"></a>/* ------------------------------------------------------------------------ */
<a name="1325"></a>/*
<a name="1326"></a> *   Plain lister - this lister doesn't show anything for an empty list,
<a name="1327"></a> *   and doesn't show a list suffix or prefix. 
<a name="1328"></a> */
<a name="1329"></a>plainLister: Lister
<a name="1330"></a>    /* show the prefix/suffix in wide mode */
<a name="1331"></a>    showListPrefixWide(itemCount, pov, parent) { }
<a name="1332"></a>    showListSuffixWide(itemCount, pov, parent) { }
<a name="1333"></a>
<a name="1334"></a>    /* show the tall prefix */
<a name="1335"></a>    showListPrefixTall(itemCount, pov, parent) { }
<a name="1336"></a>;
<a name="1337"></a>
<a name="1338"></a>/*
<a name="1339"></a> *   Sub-lister for listing the contents of a group.  This lister shows a
<a name="1340"></a> *   simple list with no prefix or suffix, and otherwise uses the
<a name="1341"></a> *   characteristics of the parent lister.  
<a name="1342"></a> */
<a name="1343"></a>class GroupSublister: object
<a name="1344"></a>    construct(parentLister, parentGroup)
<a name="1345"></a>    {
<a name="1346"></a>        /* remember the parent lister and group objects */
<a name="1347"></a>        self.parentLister = parentLister;
<a name="1348"></a>        self.parentGroup = parentGroup;
<a name="1349"></a>    }
<a name="1350"></a>
<a name="1351"></a>    /* no prefix or suffix */
<a name="1352"></a>    showListPrefixWide(itemCount, pov, parent) { }
<a name="1353"></a>    showListSuffixWide(itemCount, pov, parent) { }
<a name="1354"></a>    showListPrefixTall(itemCount, pov, parent) { }
<a name="1355"></a>
<a name="1356"></a>    /* show nothing when empty */
<a name="1357"></a>    showListEmpty(pov, parent) { }
<a name="1358"></a>
<a name="1359"></a>    /*
<a name="1360"></a>     *   Show an item in the list.  Rather than going through the parent
<a name="1361"></a>     *   lister directly, we go through the parent group, so that it can
<a name="1362"></a>     *   customize the display of items in the group.  
<a name="1363"></a>     */
<a name="1364"></a>    showListItem(obj, options, pov, infoTab)
<a name="1365"></a>    {
<a name="1366"></a>        /* ask the parent group to handle it */
<a name="1367"></a>        parentGroup.showGroupItem(parentLister, obj, options, pov, infoTab);
<a name="1368"></a>    }
<a name="1369"></a>
<a name="1370"></a>    /*
<a name="1371"></a>     *   Show a counted item in the group.  As with showListItem, we ask
<a name="1372"></a>     *   the parent group to do the work, so that it can customize the
<a name="1373"></a>     *   display if desired.  
<a name="1374"></a>     */
<a name="1375"></a>    showListItemCounted(lst, options, pov, infoTab)
<a name="1376"></a>    {
<a name="1377"></a>        /* ask the parent group to handle it */
<a name="1378"></a>        parentGroup.showGroupItemCounted(
<a name="1379"></a>            parentLister, lst, options, pov, infoTab);
<a name="1380"></a>    }
<a name="1381"></a>
<a name="1382"></a>    /* delegate everything we don't explicitly handle to our parent lister */
<a name="1383"></a>    propNotDefined(prop, [args])
<a name="1384"></a>    {
<a name="1385"></a>        return delegated (getTopLister()).(prop)(args...);
<a name="1386"></a>    }
<a name="1387"></a>
<a name="1388"></a>    /* get the top-level lister - returns my parent's top-level lister */
<a name="1389"></a>    getTopLister() { return parentLister.getTopLister(); }
<a name="1390"></a>
<a name="1391"></a>    /* my parent lister */
<a name="1392"></a>    parentLister = nil
<a name="1393"></a>
<a name="1394"></a>    /* my parent list group */
<a name="1395"></a>    parentGroup = nil
<a name="1396"></a>;
<a name="1397"></a>
<a name="1398"></a>/*
<a name="1399"></a> *   Paragraph lister: this shows its list items separated by paragraph
<a name="1400"></a> *   breaks, with a paragraph break before the first item. 
<a name="1401"></a> */
<a name="1402"></a>class ParagraphLister: Lister
<a name="1403"></a>    /* start the list with a paragraph break */
<a name="1404"></a>    showListPrefixWide(itemCount, pov, parent) { "&lt;.p&gt;"; }
<a name="1405"></a>
<a name="1406"></a>    /* we show no list separators */
<a name="1407"></a>    showListSeparator(options, curItemNum, totalItems)
<a name="1408"></a>    {
<a name="1409"></a>        /* add a paragraph separator between items */
<a name="1410"></a>        if (curItemNum != totalItems)
<a name="1411"></a>            "&lt;.p&gt;";
<a name="1412"></a>    }
<a name="1413"></a>;
<a name="1414"></a>
<a name="1415"></a>/*
<a name="1416"></a> *   Lister for objects in a room description with special descriptions.
<a name="1417"></a> *   Each special description gets its own paragraph, so this is based on
<a name="1418"></a> *   the paragraph lister.  
<a name="1419"></a> */
<a name="1420"></a>specialDescLister: ParagraphLister
<a name="1421"></a>    /* list everything */
<a name="1422"></a>    isListed(obj) { return true; }
<a name="1423"></a>
<a name="1424"></a>    /* show a list item */
<a name="1425"></a>    showListItem(obj, options, pov, infoTab)
<a name="1426"></a>    {
<a name="1427"></a>        /* show the object's special description */
<a name="1428"></a>        obj.showSpecialDescWithInfo(infoTab[obj], pov);
<a name="1429"></a>    }
<a name="1430"></a>
<a name="1431"></a>    /* use the object's special description grouper */
<a name="1432"></a>    listWith(obj) { return obj.specialDescListWith; }
<a name="1433"></a>;
<a name="1434"></a>
<a name="1435"></a>/*
<a name="1436"></a> *   Special description lister for the contents of an item being examined.
<a name="1437"></a> *   This is similar to the regular specialDescLister, but shows the
<a name="1438"></a> *   special descriptions of the contents of an object being described with
<a name="1439"></a> *   "examine" or "look in," rather than of the entire location.  
<a name="1440"></a> */
<a name="1441"></a>class SpecialDescContentsLister: ParagraphLister
<a name="1442"></a>    construct(cont)
<a name="1443"></a>    {
<a name="1444"></a>        /* remember the containing object being described */
<a name="1445"></a>        cont_ = cont;
<a name="1446"></a>    }
<a name="1447"></a>
<a name="1448"></a>    /* list everything */
<a name="1449"></a>    isListed(obj) { return true; }
<a name="1450"></a>
<a name="1451"></a>    /* show a list item */
<a name="1452"></a>    showListItem(obj, options, pov, infoTab)
<a name="1453"></a>    {
<a name="1454"></a>        /* show the object's special description in our container */
<a name="1455"></a>        obj.showSpecialDescInContentsWithInfo(infoTab[obj], pov, cont_);
<a name="1456"></a>    }
<a name="1457"></a>
<a name="1458"></a>    /* use the object's special description grouper */
<a name="1459"></a>    listWith(obj) { return obj.specialDescListWith; }
<a name="1460"></a>
<a name="1461"></a>    /* the containing object we're examining */
<a name="1462"></a>    cont_ = nil
<a name="1463"></a>;
<a name="1464"></a>
<a name="1465"></a>
<a name="1466"></a>/*
<a name="1467"></a> *   Plain lister for actors.  This is the same as an ordinary
<a name="1468"></a> *   plainLister, but ignores each object's isListed flag and lists it
<a name="1469"></a> *   anyway. 
<a name="1470"></a> */
<a name="1471"></a>plainActorLister: plainLister
<a name="1472"></a>    isListed(obj) { return true; }
<a name="1473"></a>;
<a name="1474"></a>
<a name="1475"></a>/*
<a name="1476"></a> *   Grouper for actors in a common posture and in a common location.  We
<a name="1477"></a> *   create one of these per room per posture when we discover actors in
<a name="1478"></a> *   the room during "look around" (or "examine" on a nested room).  This
<a name="1479"></a> *   grouper lets us group actors like so: "Dan and Jane are sitting on
<a name="1480"></a> *   the couch."  
<a name="1481"></a> */
<a name="1482"></a>class RoomActorGrouper: ListGroup
<a name="1483"></a>    construct(location, posture)
<a name="1484"></a>    {
<a name="1485"></a>        self.location = location;
<a name="1486"></a>        self.posture = posture;
<a name="1487"></a>    }
<a name="1488"></a>    
<a name="1489"></a>    showGroupList(pov, lister, lst, options, indent, infoTab)
<a name="1490"></a>    {
<a name="1491"></a>        local cont;
<a name="1492"></a>        local outer;
<a name="1493"></a>        
<a name="1494"></a>        /* if the location isn't in the sense table, skip the whole list */
<a name="1495"></a>        if (infoTab[location] == nil)
<a name="1496"></a>            return;
<a name="1497"></a>
<a name="1498"></a>        /* get the nominal posture container, if it's visible */
<a name="1499"></a>        cont = location.getNominalActorContainer(posture);
<a name="1500"></a>        if (cont != nil &amp;&amp; !pov.canSee(cont))
<a name="1501"></a>            cont = nil;
<a name="1502"></a>
<a name="1503"></a>        /* get the outermost visible enclosing location */
<a name="1504"></a>        outer = location.getOutermostVisibleRoom(pov);
<a name="1505"></a>
<a name="1506"></a>        /* 
<a name="1507"></a>         *   Only mention the outermost location if it's remote and it's
<a name="1508"></a>         *   not the same as the nominal container.  (If the remote outer
<a name="1509"></a>         *   room is the same as the nominal container, it would be
<a name="1510"></a>         *   redundant to mention it as both the nominal and remote
<a name="1511"></a>         *   container.)  
<a name="1512"></a>         */
<a name="1513"></a>        if (outer == cont || pov.isIn(outer))
<a name="1514"></a>            outer = nil;
<a name="1515"></a>
<a name="1516"></a>        /* create a sub-lister for the group */
<a name="1517"></a>        lister = createGroupSublister(lister);
<a name="1518"></a>        
<a name="1519"></a>        /* 
<a name="1520"></a>         *   show the list prefix message - use the nominal container if
<a name="1521"></a>         *   we can see it, otherwise generate a generic message 
<a name="1522"></a>         */
<a name="1523"></a>        if (cont != nil)
<a name="1524"></a>            cont.actorInGroupPrefix(pov, posture, outer, lst);
<a name="1525"></a>        else if (outer != nil)
<a name="1526"></a>            gLibMessages.actorThereGroupPrefix(pov, posture, outer, lst);
<a name="1527"></a>        else
<a name="1528"></a>            gLibMessages.actorHereGroupPrefix(posture, lst);
<a name="1529"></a>
<a name="1530"></a>        /* list the actors' names as a plain list */
<a name="1531"></a>        plainActorLister.showList(pov, location, lst, options,
<a name="1532"></a>                                  indent, infoTab, self);
<a name="1533"></a>
<a name="1534"></a>        /* add the suffix message */
<a name="1535"></a>        if (cont != nil)
<a name="1536"></a>            cont.actorInGroupSuffix(pov, posture, outer, lst);
<a name="1537"></a>        else if (outer != nil)
<a name="1538"></a>            gLibMessages.actorThereGroupSuffix(pov, posture, outer, lst);
<a name="1539"></a>        else
<a name="1540"></a>            gLibMessages.actorHereGroupSuffix(posture, lst);
<a name="1541"></a>    }
<a name="1542"></a>;
<a name="1543"></a>
<a name="1544"></a>/* 
<a name="1545"></a> *   Base class for inventory listers.  This lister uses a special listing
<a name="1546"></a> *   method to show the items, so that items can be shown with special
<a name="1547"></a> *   notations in an inventory list that might not appear in other types
<a name="1548"></a> *   of listings.  
<a name="1549"></a> */
<a name="1550"></a>class InventoryLister: Lister
<a name="1551"></a>    /* list items in inventory according to their isListedInInventory */
<a name="1552"></a>    isListed(obj) { return obj.isListedInInventory; }
<a name="1553"></a>
<a name="1554"></a>    /*
<a name="1555"></a>     *   Show list items using the inventory name, which might differ from
<a name="1556"></a>     *   the regular nmae of the object.  
<a name="1557"></a>     */
<a name="1558"></a>    showListItem(obj, options, pov, infoTab)
<a name="1559"></a>        { obj.showInventoryItem(options, pov, infoTab); }
<a name="1560"></a>
<a name="1561"></a>    showListItemCounted(lst, options, pov, infoTab)
<a name="1562"></a>        { lst[1].showInventoryItemCounted(lst, options, pov, infoTab); }
<a name="1563"></a>
<a name="1564"></a>    /*
<a name="1565"></a>     *   Show contents of the items in the inventory.  We customize this
<a name="1566"></a>     *   so that we can differentiate inventory contents lists from other
<a name="1567"></a>     *   contents lists.  
<a name="1568"></a>     */
<a name="1569"></a>    showContentsList(pov, obj, options, indent, infoTab)
<a name="1570"></a>    {
<a name="1571"></a>        /* list the item's contents */
<a name="1572"></a>        obj.showInventoryContents(pov, obj.contentsLister, options,
<a name="1573"></a>                                  indent, infoTab);
<a name="1574"></a>    }
<a name="1575"></a>
<a name="1576"></a>    /*
<a name="1577"></a>     *   Show the contents in-line, for an inventory listing. 
<a name="1578"></a>     */
<a name="1579"></a>    showInlineContentsList(pov, obj, options, indent, infoTab)
<a name="1580"></a>    {
<a name="1581"></a>        /* list the item's contents using its in-line lister */
<a name="1582"></a>        obj.showInventoryContents(pov, obj.inlineContentsLister,
<a name="1583"></a>                                  options, indent, infoTab);
<a name="1584"></a>    }
<a name="1585"></a>;
<a name="1586"></a>
<a name="1587"></a>/*
<a name="1588"></a> *   Base class for worn-inventory listers.  This lister uses a special
<a name="1589"></a> *   listing method to show the items, so that items being worn are shown
<a name="1590"></a> *   *without* the special '(being worn)' notation that might otherwise
<a name="1591"></a> *   appear in inventory listings.  
<a name="1592"></a> */
<a name="1593"></a>class WearingLister: InventoryLister
<a name="1594"></a>    /* show the list item using the "worn listing" name */
<a name="1595"></a>    showListItem(obj, options, pov, infoTab)
<a name="1596"></a>        { obj.showWornItem(options, pov, infoTab); }
<a name="1597"></a>    showListItemCounted(lst, options, pov, infoTab)
<a name="1598"></a>        { lst[1].showWornItemCounted(lst, options, pov, infoTab); }
<a name="1599"></a>;
<a name="1600"></a>
<a name="1601"></a>/*
<a name="1602"></a> *   "Divided" inventory lister.  In 'wide' mode, this shows inventory in
<a name="1603"></a> *   two parts: the items being carried, and the items being worn.  (We use
<a name="1604"></a> *   the standard single tree-style listing in 'tall' mode.)  
<a name="1605"></a> */
<a name="1606"></a>class DividedInventoryLister: InventoryLister
<a name="1607"></a>    /*
<a name="1608"></a>     *   Show the list.  We completely override the main lister method so
<a name="1609"></a>     *   that we can show our two lists.  
<a name="1610"></a>     */
<a name="1611"></a>    showList(pov, parent, lst, options, indent, infoTab, parentGroup)
<a name="1612"></a>    {
<a name="1613"></a>        /* 
<a name="1614"></a>         *   If this is a 'tall' listing, use the normal listing style; for
<a name="1615"></a>         *   a 'wide' listing, use our special segregated style.  If we're
<a name="1616"></a>         *   being invoked recursively to show a contents listing, we
<a name="1617"></a>         *   similarly want to use the base handling. 
<a name="1618"></a>         */
<a name="1619"></a>        if ((options &amp; (ListTall | ListContents)) != 0)
<a name="1620"></a>        {
<a name="1621"></a>            /* inherit the standard behavior */
<a name="1622"></a>            inherited(pov, parent, lst, options, indent, infoTab,
<a name="1623"></a>                      parentGroup);
<a name="1624"></a>        }
<a name="1625"></a>        else
<a name="1626"></a>        {
<a name="1627"></a>            local carryingLst, wearingLst;
<a name="1628"></a>            local carryingStr, wearingStr;
<a name="1629"></a>
<a name="1630"></a>            /* divide the lists into 'carrying' and 'wearing' sublists */
<a name="1631"></a>            carryingLst = new Vector(32);
<a name="1632"></a>            wearingLst = new Vector(32);
<a name="1633"></a>            foreach (local cur in lst)
<a name="1634"></a>                (cur.isWornBy(parent) ? wearingLst : carryingLst).append(cur);
<a name="1635"></a>
<a name="1636"></a>            /* generate and capture the 'carried' listing */
<a name="1637"></a>            carryingStr = outputManager.curOutputStream.captureOutput({:
<a name="1638"></a>                carryingLister.showList(pov, parent, carryingLst, options,
<a name="1639"></a>                                        indent, infoTab, parentGroup)});
<a name="1640"></a>
<a name="1641"></a>            /* generate and capture the 'worn' listing */
<a name="1642"></a>            wearingStr = outputManager.curOutputStream.captureOutput({:
<a name="1643"></a>                wearingLister.showList(pov, parent, wearingLst, options,
<a name="1644"></a>                                       indent, infoTab, parentGroup)});
<a name="1645"></a>
<a name="1646"></a>            /* generate the combined listing */
<a name="1647"></a>            showCombinedInventoryList(parent, carryingStr, wearingStr);
<a name="1648"></a>
<a name="1649"></a>            /* 
<a name="1650"></a>             *   Now show the out-of-line contents for the whole list, if
<a name="1651"></a>             *   appropriate.  We save this until after showing both parts
<a name="1652"></a>             *   of the list, to keep the direct inventory parts together
<a name="1653"></a>             *   at the beginning of the output.  
<a name="1654"></a>             */
<a name="1655"></a>            if ((options &amp; ListRecurse) != 0
<a name="1656"></a>                &amp;&amp; indent == 0
<a name="1657"></a>                &amp;&amp; (options &amp; ListContents) == 0)
<a name="1658"></a>            {
<a name="1659"></a>                /* show the contents of each object we didn't list */
<a name="1660"></a>                showSeparateContents(pov, lst, options | ListContents,
<a name="1661"></a>                                     infoTab);
<a name="1662"></a>            }
<a name="1663"></a>        }
<a name="1664"></a>    }
<a name="1665"></a>
<a name="1666"></a>    /*
<a name="1667"></a>     *   Show the combined listing.  This must be provided by each
<a name="1668"></a>     *   language-specific subclass.  The inputs are the results (strings)
<a name="1669"></a>     *   of the captured output of the sublistings of the items being
<a name="1670"></a>     *   carried and the items being worn.  These will be "raw" listings,
<a name="1671"></a>     *   without any prefix or suffix text.  This routine's job is to
<a name="1672"></a>     *   display the final output, adding the framing text.  
<a name="1673"></a>     */
<a name="1674"></a>    showCombinedInventoryList(parent, carrying, wearing) { }
<a name="1675"></a>
<a name="1676"></a>    /* 
<a name="1677"></a>     *   The recommended maximum number of number of noun phrases to show
<a name="1678"></a>     *   in the single-sentence format.  This should be used by the
<a name="1679"></a>     *   showCombinedInventoryList() method to decide whether to display
<a name="1680"></a>     *   the combined listing as a single sentence or as two separate
<a name="1681"></a>     *   sentences.  
<a name="1682"></a>     */
<a name="1683"></a>    singleSentenceMaxNouns = 7
<a name="1684"></a>
<a name="1685"></a>    /*
<a name="1686"></a>     *   Our associated sub-listers for items begin carried and worn,
<a name="1687"></a>     *   respectively.  We'll use these to list our sublist of items being
<a name="1688"></a>     *   worn.  
<a name="1689"></a>     */
<a name="1690"></a>    carryingLister = actorCarryingSublister
<a name="1691"></a>    wearingLister = actorWearingSublister
<a name="1692"></a>;
<a name="1693"></a>
<a name="1694"></a>/*
<a name="1695"></a> *   Base class for the inventory sub-lister for items being carried.  This
<a name="1696"></a> *   is a minor specialization of the basic inventory lister; in this
<a name="1697"></a> *   version, we omit any prefix, suffix, or empty messages, since we'll
<a name="1698"></a> *   rely on the caller to combine our raw listing with the raw 'wearing'
<a name="1699"></a> *   listing to form the full results.  
<a name="1700"></a> *   
<a name="1701"></a> *   This type of lister should normally only be used from within an
<a name="1702"></a> *   inventory lister.  This type of lister assumes that it's part of a
<a name="1703"></a> *   larger listing controlled externally; for example, we don't show
<a name="1704"></a> *   out-of-line contents, since we assume the caller will be doing this.  
<a name="1705"></a> */
<a name="1706"></a>class InventorySublister: InventoryLister
<a name="1707"></a>    /* don't show any prefix, suffix, or 'empty' messages */
<a name="1708"></a>    showListPrefixWide(itemCount, pov, parent) { }
<a name="1709"></a>    showListSuffixWide(itemCount, pov, parent) { }
<a name="1710"></a>    showListEmpty(pov, parent) { }
<a name="1711"></a>
<a name="1712"></a>    /* don't show out-of-line contents */
<a name="1713"></a>    showSeparateContents(pov, lst, options, infoTab) { }
<a name="1714"></a>;
<a name="1715"></a>
<a name="1716"></a>/*
<a name="1717"></a> *   Base class for the inventory sub-lister for items being worn.  We use
<a name="1718"></a> *   a special listing method to show these items, so that items being
<a name="1719"></a> *   shown explicitly in a worn list can be shown differently from the way
<a name="1720"></a> *   they would in a normal inventory list.  (For example, a worn item in a
<a name="1721"></a> *   normal inventory list might show a "(worn)" indication, whereas it
<a name="1722"></a> *   would not want to show a similar indication in a list of objects
<a name="1723"></a> *   explicitly being worn.)
<a name="1724"></a> *   
<a name="1725"></a> *   This type of lister should normally only be used from within an
<a name="1726"></a> *   inventory lister.  This type of lister assumes that it's part of a
<a name="1727"></a> *   larger listing controlled externally; for example, we don't show
<a name="1728"></a> *   out-of-line contents, since we assume the caller will be doing this.  
<a name="1729"></a> */
<a name="1730"></a>class WearingSublister: WearingLister
<a name="1731"></a>    /* don't show any prefix, suffix, or 'empty' messages */
<a name="1732"></a>    showListPrefixWide(itemCount, pov, parent) { }
<a name="1733"></a>    showListSuffixWide(itemCount, pov, parent) { }
<a name="1734"></a>    showListEmpty(pov, parent) { }
<a name="1735"></a>
<a name="1736"></a>    /* don't show out-of-line contents */
<a name="1737"></a>    showSeparateContents(pov, lst, options, infoTab) { }
<a name="1738"></a>;
<a name="1739"></a>
<a name="1740"></a>/*
<a name="1741"></a> *   The standard inventory sublisters.
<a name="1742"></a> */
<a name="1743"></a>actorCarryingSublister: InventorySublister;
<a name="1744"></a>actorWearingSublister: WearingSublister;
<a name="1745"></a>
<a name="1746"></a>/*
<a name="1747"></a> *   Base class for contents listers.  This is used to list the contents
<a name="1748"></a> *   of the objects that appear in top-level lists (a top-level list is
<a name="1749"></a> *   the list of objects directly in a room that appears in a room
<a name="1750"></a> *   description, or the list of items being carried in an INVENTORY
<a name="1751"></a> *   command, or the direct contents of an object being examined). 
<a name="1752"></a> */
<a name="1753"></a>class ContentsLister: Lister
<a name="1754"></a>;
<a name="1755"></a>
<a name="1756"></a>/*
<a name="1757"></a> *   Base class for description contents listers.  This is used to list
<a name="1758"></a> *   the contents of an object when we examine the object, or when we
<a name="1759"></a> *   explicitly LOOK IN the object.  
<a name="1760"></a> */
<a name="1761"></a>class DescContentsLister: Lister
<a name="1762"></a>    /* 
<a name="1763"></a>     *   Use the explicit look-in flag for listing contents.  We might
<a name="1764"></a>     *   list items within an object on explicit examination of the item
<a name="1765"></a>     *   that we wouldn't list in a room or inventory list containing the
<a name="1766"></a>     *   item. 
<a name="1767"></a>     */
<a name="1768"></a>    isListed(obj) { return obj.isListedInContents; }
<a name="1769"></a>;
<a name="1770"></a>
<a name="1771"></a>/*
<a name="1772"></a> *   Base class for sense listers, which list the items that can be sensed
<a name="1773"></a> *   for a command like "listen" or "smell". 
<a name="1774"></a> */
<a name="1775"></a>class SenseLister: ParagraphLister
<a name="1776"></a>    /* show everything we're asked to list */
<a name="1777"></a>    isListed(obj) { return true; }
<a name="1778"></a>
<a name="1779"></a>    /* show a counted list item */
<a name="1780"></a>    showListItemCounted(lst, options, pov, infoTab)
<a name="1781"></a>    {
<a name="1782"></a>        /* 
<a name="1783"></a>         *   simply show one item, without the count - non-visual senses
<a name="1784"></a>         *   don't distinguish numbers of items that are equivalent 
<a name="1785"></a>         */
<a name="1786"></a>        showListItem(lst[1], options, pov, infoTab);
<a name="1787"></a>    }
<a name="1788"></a>;
<a name="1789"></a>
<a name="1790"></a>/*
<a name="1791"></a> *   Room contents lister for things that can be heard.  
<a name="1792"></a> */
<a name="1793"></a>roomListenLister: SenseLister
<a name="1794"></a>    /* list an item in a room if its isSoundListedInRoom is true */
<a name="1795"></a>    isListed(obj) { return obj.isSoundListedInRoom; }
<a name="1796"></a>
<a name="1797"></a>    /* list an item */
<a name="1798"></a>    showListItem(obj, options, pov, infoTab)
<a name="1799"></a>    {
<a name="1800"></a>        /* show the "listen" list name for the item */
<a name="1801"></a>        obj.soundHereDesc();
<a name="1802"></a>    }
<a name="1803"></a>;
<a name="1804"></a>
<a name="1805"></a>/*
<a name="1806"></a> *   Lister for explicit "listen" action 
<a name="1807"></a> */
<a name="1808"></a>listenActionLister: roomListenLister
<a name="1809"></a>    /* list everything in response to an explicit general LISTEN command */
<a name="1810"></a>    isListed(obj) { return true; }
<a name="1811"></a>
<a name="1812"></a>    /* show an empty list */
<a name="1813"></a>    showListEmpty(pov, parent)
<a name="1814"></a>    {
<a name="1815"></a>        mainReport(&amp;nothingToHearMsg);
<a name="1816"></a>    }
<a name="1817"></a>
<a name="1818"></a>;
<a name="1819"></a>
<a name="1820"></a>/*
<a name="1821"></a> *   Room contents lister for things that can be smelled. 
<a name="1822"></a> */
<a name="1823"></a>roomSmellLister: SenseLister
<a name="1824"></a>    /* list an item in a room if its isSmellListedInRoom is true */
<a name="1825"></a>    isListed(obj) { return obj.isSmellListedInRoom; }
<a name="1826"></a>
<a name="1827"></a>    /* list an item */
<a name="1828"></a>    showListItem(obj, options, pov, infoTab)
<a name="1829"></a>    {
<a name="1830"></a>        /* show the "smell" list name for the item */
<a name="1831"></a>        obj.smellHereDesc();
<a name="1832"></a>    }
<a name="1833"></a>;
<a name="1834"></a>
<a name="1835"></a>/*
<a name="1836"></a> *   Lister for explicit "smell" action 
<a name="1837"></a> */
<a name="1838"></a>smellActionLister: roomSmellLister
<a name="1839"></a>    /* list everything in response to an explicit general SMELL command */
<a name="1840"></a>    isListed(obj) { return true; }
<a name="1841"></a>
<a name="1842"></a>    /* show an empty list */
<a name="1843"></a>    showListEmpty(pov, parent)
<a name="1844"></a>    {
<a name="1845"></a>        mainReport(&amp;nothingToSmellMsg);
<a name="1846"></a>    }
<a name="1847"></a>
<a name="1848"></a>;
<a name="1849"></a>
<a name="1850"></a>/*
<a name="1851"></a> *   Inventory lister for things that can be heard.  
<a name="1852"></a> */
<a name="1853"></a>inventoryListenLister: SenseLister
<a name="1854"></a>    /* list an item */
<a name="1855"></a>    showListItem(obj, options, pov, infoTab)
<a name="1856"></a>    {
<a name="1857"></a>        /* show the "listen" list name for the item */
<a name="1858"></a>        obj.soundHereDesc();
<a name="1859"></a>    }
<a name="1860"></a>;
<a name="1861"></a>
<a name="1862"></a>/*
<a name="1863"></a> *   Inventory lister for things that can be smelled. 
<a name="1864"></a> */
<a name="1865"></a>inventorySmellLister: SenseLister
<a name="1866"></a>    /* list an item */
<a name="1867"></a>    showListItem(obj, options, pov, infoTab)
<a name="1868"></a>    {
<a name="1869"></a>        /* show the "smell" list name for the item */
<a name="1870"></a>        obj.smellHereDesc();
<a name="1871"></a>    }
<a name="1872"></a>;
<a name="1873"></a>
<a name="1874"></a>
<a name="1875"></a>/* ------------------------------------------------------------------------ */
<a name="1876"></a>/*
<a name="1877"></a> *   List Group Interface.  An instance of this object is created for each
<a name="1878"></a> *   set of objects that are to be grouped together.  
<a name="1879"></a> */
<a name="1880"></a>class ListGroup: object
<a name="1881"></a>    /*
<a name="1882"></a>     *   Show a list of items from this group.  All of the items in the
<a name="1883"></a>     *   list will be members of this list group; we are to display a
<a name="1884"></a>     *   sentence fragment showing the items in the list, suitable for
<a name="1885"></a>     *   embedding in a larger list.
<a name="1886"></a>     *   
<a name="1887"></a>     *   'options', 'indent', and 'infoTab' have the same meaning as they
<a name="1888"></a>     *   do for showList().
<a name="1889"></a>     *   
<a name="1890"></a>     *   Note that we are not to display any separator before or after our
<a name="1891"></a>     *   list; the caller is responsible for that.  
<a name="1892"></a>     */
<a name="1893"></a>    showGroupList(pov, lister, lst, options, indent, infoTab) { }
<a name="1894"></a>
<a name="1895"></a>    /*
<a name="1896"></a>     *   Show an item in the group's sublist.  The sublister calls this to
<a name="1897"></a>     *   display each item in the group when the group calls the sublister
<a name="1898"></a>     *   to display the group list.  By default, we simply let the
<a name="1899"></a>     *   sublister handle the request, which gives items in our group
<a name="1900"></a>     *   sublist the same appearance they would have had in the sublist to
<a name="1901"></a>     *   begin with.  We can customize this behavior to give our list
<a name="1902"></a>     *   items a different appearance special to the group sublist.
<a name="1903"></a>     *   
<a name="1904"></a>     *   Note that the same customization could be accomplished by
<a name="1905"></a>     *   creating a specialized subclass of GroupSublister in
<a name="1906"></a>     *   createGroupSublister(), and overriding showListItem() in the
<a name="1907"></a>     *   specialized GroupSublister subclass.  We use this mechanism as a
<a name="1908"></a>     *   convenience, so that a separate group sublister class doesn't
<a name="1909"></a>     *   have to be created simply to customize the display of group
<a name="1910"></a>     *   items.  
<a name="1911"></a>     */
<a name="1912"></a>    showGroupItem(sublister, obj, options, pov, infoTab)
<a name="1913"></a>    {
<a name="1914"></a>        /* by default, list using the regular sublister */
<a name="1915"></a>        sublister.showListItem(obj, options, pov, infoTab);
<a name="1916"></a>    }
<a name="1917"></a>
<a name="1918"></a>    /*
<a name="1919"></a>     *   Show a counted item in our group list.  This is the counted item
<a name="1920"></a>     *   equivalent of showGroupItem.  
<a name="1921"></a>     */
<a name="1922"></a>    showGroupItemCounted(sublister, lst, options, pov, infoTab)
<a name="1923"></a>    {
<a name="1924"></a>        /* by default, list using the regular sublister */
<a name="1925"></a>        sublister.showListItemCounted(lst, options, pov, infoTab);
<a name="1926"></a>    }
<a name="1927"></a>
<a name="1928"></a>    /* 
<a name="1929"></a>     *   Determine if showing the group list will introduce a sublist into
<a name="1930"></a>     *   an enclosing list.  This should return true if we will show a
<a name="1931"></a>     *   sublist without some kind of grouping, so that the caller knows
<a name="1932"></a>     *   to introduce some extra grouping into its enclosing list.  This
<a name="1933"></a>     *   should return nil if the sublist we display will be clearly set
<a name="1934"></a>     *   off in some way (for example, by being enclosed in parentheses). 
<a name="1935"></a>     */
<a name="1936"></a>    groupDisplaysSublist = true
<a name="1937"></a>
<a name="1938"></a>    /*
<a name="1939"></a>     *   The minimum number of elements for which we should retain the
<a name="1940"></a>     *   group in a listing.  By default, we need two elements to display a
<a name="1941"></a>     *   group; any group with only one element is discarded, and the
<a name="1942"></a>     *   single element is moved into the 'singles' list.  This can be
<a name="1943"></a>     *   overridden to allow single-element groups to be retained.  In most
<a name="1944"></a>     *   cases, it's undesirable to retain single-element groups, but when
<a name="1945"></a>     *   grouping is used to partition a list into two or more fixed
<a name="1946"></a>     *   portions, single-element groups become desirable.  
<a name="1947"></a>     */
<a name="1948"></a>    minGroupSize = 2
<a name="1949"></a>
<a name="1950"></a>    /*
<a name="1951"></a>     *   Determine the cardinality of the group listing, grammatically
<a name="1952"></a>     *   speaking.  This is the number of items that the group seems to be
<a name="1953"></a>     *   for the purposes of grammatical agreement.  For example, if the
<a name="1954"></a>     *   group is displayed as "$1.38 in change", it would be singular for
<a name="1955"></a>     *   grammatical agreement, hence would return 1 here; if it displays
<a name="1956"></a>     *   "five coins (two copper, three gold)," it would count as five
<a name="1957"></a>     *   items for grammatical agreement.
<a name="1958"></a>     *   
<a name="1959"></a>     *   For languages (like English) that grammatically distinguish
<a name="1960"></a>     *   number only between singular and plural, it is sufficient for
<a name="1961"></a>     *   this to return 1 for singular and anything higher for plural.
<a name="1962"></a>     *   For the sake of languages that make more elaborate number
<a name="1963"></a>     *   distinctions for grammatical agreement, though, this should
<a name="1964"></a>     *   return as accurate a count as is possible.
<a name="1965"></a>     *   
<a name="1966"></a>     *   By default, we return the number of items to be displayed in the
<a name="1967"></a>     *   list group.  This should be overridden when necessary, such as
<a name="1968"></a>     *   when the group message is singular in usage even if the list has
<a name="1969"></a>     *   multiple items (as in "$1.38 in change").  
<a name="1970"></a>     */
<a name="1971"></a>    groupCardinality(lister, lst) { return lst.length(); }
<a name="1972"></a>
<a name="1973"></a>    /*
<a name="1974"></a>     *   Get the number of noun phrases this group will display.  This
<a name="1975"></a>     *   differs from the cardinality in that it doesn't matter how many
<a name="1976"></a>     *   *objects* the phrases represent; it only matters how many phrases
<a name="1977"></a>     *   are displayed.  For example, "five coins" has cardinality 5 but
<a name="1978"></a>     *   only displays one noun phrase.
<a name="1979"></a>     *   
<a name="1980"></a>     *   By default, we simply return the number of items in the group,
<a name="1981"></a>     *   since most groups individually list their items.
<a name="1982"></a>     */
<a name="1983"></a>    groupNounPhraseCount(lister, lst) { return lst.length(); }
<a name="1984"></a>
<a name="1985"></a>    /*
<a name="1986"></a>     *   Create the group sublister.
<a name="1987"></a>     *   
<a name="1988"></a>     *   In most cases, when a group displays a list of the items in the
<a name="1989"></a>     *   group as a sublist, it will not want to use the same lister that
<a name="1990"></a>     *   was used to show the enclosing group, because the enclosing lister
<a name="1991"></a>     *   will usually have different prefix/suffix styles than the sublist.
<a name="1992"></a>     *   However, the group list and the enclosing list might share many
<a name="1993"></a>     *   other attributes, such as the style of name to use when displaying
<a name="1994"></a>     *   items in the list.  The default sublister we create,
<a name="1995"></a>     *   GroupSublister, is a hybrid that uses the enclosing lister's
<a name="1996"></a>     *   attributes except for a few, such as the prefix and suffix, that
<a name="1997"></a>     *   usually need to be changed for the sublist.
<a name="1998"></a>     *   
<a name="1999"></a>     *   This can be overridden to use a completely customized Lister
<a name="2000"></a>     *   object for the group list, if desired.  
<a name="2001"></a>     */
<a name="2002"></a>    createGroupSublister(parentLister)
<a name="2003"></a>    {
<a name="2004"></a>        /* create the standard group sublister by default */
<a name="2005"></a>        return new GroupSublister(parentLister, self);
<a name="2006"></a>    }
<a name="2007"></a>;
<a name="2008"></a>
<a name="2009"></a>/*
<a name="2010"></a> *   A "custom" List Group implementation.  This type of lister uses a
<a name="2011"></a> *   completely custom message to show the group, without a need to
<a name="2012"></a> *   recursively invoke a lister to list the individual elements.  The main
<a name="2013"></a> *   difference between this and the base ListGroup is that the interface
<a name="2014"></a> *   to the custom message generator is very simple - we can dispense with
<a name="2015"></a> *   most of the numerous arguments that the base group message receives,
<a name="2016"></a> *   since most of those arguments are there to allow recursive listing of
<a name="2017"></a> *   the group list.
<a name="2018"></a> *   
<a name="2019"></a> *   This group type is intended mainly for cases where you want to display
<a name="2020"></a> *   some sort of collective description of the group, rather than listing
<a name="2021"></a> *   its members individually.  The whole point of the simple interface is
<a name="2022"></a> *   that we don't pass the normal big pile of parameters because we won't
<a name="2023"></a> *   be invoking a full sublisting.  Since we assume that this group won't
<a name="2024"></a> *   itself look like a sublist, we set groupDisplaysSublist to nil by
<a name="2025"></a> *   default.  This means that our presence in the overall list won't
<a name="2026"></a> *   trigger the "long list" format (usually, this uses semicolons instead
<a name="2027"></a> *   of commas) in the enclosing list.  If your custom group message does
<a name="2028"></a> *   indeed look like a sublist (that is, it displays multiple items in a
<a name="2029"></a> *   comma-separated list), you might want to change groupDisplaysSublist
<a name="2030"></a> *   back to true so that the overall list is shown in the "long" format.  
<a name="2031"></a> */
<a name="2032"></a>class ListGroupCustom: ListGroup
<a name="2033"></a>    showGroupList(pov, lister, lst, options, indent, infoTab)
<a name="2034"></a>    {
<a name="2035"></a>        /* simply show the custom message for the list */
<a name="2036"></a>        showGroupMsg(lst);
<a name="2037"></a>    }
<a name="2038"></a>
<a name="2039"></a>    /* show the custom group message - subclasses should override */
<a name="2040"></a>    showGroupMsg(lst) { }
<a name="2041"></a>
<a name="2042"></a>    /* assume our listing message doesn't look like a sublist */
<a name="2043"></a>    groupDisplaysSublist = nil
<a name="2044"></a>;
<a name="2045"></a>
<a name="2046"></a>/*
<a name="2047"></a> *   Sorted group list.  This is a list that simply displays its members
<a name="2048"></a> *   in a specific sorting order. 
<a name="2049"></a> */
<a name="2050"></a>class ListGroupSorted: ListGroup
<a name="2051"></a>    /*
<a name="2052"></a>     *   Show the group list 
<a name="2053"></a>     */
<a name="2054"></a>    showGroupList(pov, lister, lst, options, indent, infoTab)
<a name="2055"></a>    {
<a name="2056"></a>        /* put the list in sorted order */
<a name="2057"></a>        lst = sortListGroup(lst);
<a name="2058"></a>
<a name="2059"></a>        /* create a sub-lister for the group */
<a name="2060"></a>        lister = createGroupSublister(lister);
<a name="2061"></a>
<a name="2062"></a>        /* show the list */
<a name="2063"></a>        lister.showList(pov, nil, lst, options &amp; ~ListContents,
<a name="2064"></a>                        indent, infoTab, self);
<a name="2065"></a>    }
<a name="2066"></a>
<a name="2067"></a>    /*
<a name="2068"></a>     *   Sort the group list.  By default, if we have a
<a name="2069"></a>     *   compareGroupItems() method defined, we'll sort the list using
<a name="2070"></a>     *   that method; otherwise, we'll just return the list unchanged. 
<a name="2071"></a>     */
<a name="2072"></a>    sortListGroup(lst)
<a name="2073"></a>    {
<a name="2074"></a>        /* 
<a name="2075"></a>         *   if we have a compareGroupItems method, use it to sort the
<a name="2076"></a>         *   list; otherwise, just return the list in its current order 
<a name="2077"></a>         */
<a name="2078"></a>        if (propDefined(&amp;compareGroupItems, PropDefAny))
<a name="2079"></a>            return lst.sort(SortAsc, {a, b: compareGroupItems(a, b)});
<a name="2080"></a>        else
<a name="2081"></a>            return lst;
<a name="2082"></a>    }
<a name="2083"></a>
<a name="2084"></a>    /*
<a name="2085"></a>     *   Compare a pair of items from the group to determine their relative
<a name="2086"></a>     *   sorting order.  This should return 0 if the two items are at the
<a name="2087"></a>     *   same sorting order, a positive integer if the first item sorts
<a name="2088"></a>     *   after the second item, or a negative integer if the first item
<a name="2089"></a>     *   sorts before the second item.
<a name="2090"></a>     *   
<a name="2091"></a>     *   Note that we don't care about the return value beyond whether it's
<a name="2092"></a>     *   positive, negative, or zero.  This makes it especially easy to
<a name="2093"></a>     *   implement this method if the sorting order is determined by a
<a name="2094"></a>     *   property on each object that has an integer value: in this case
<a name="2095"></a>     *   you simply return the difference of the two property values, as in
<a name="2096"></a>     *   a.prop - b.prop.  This will have the effect of sorting the objects
<a name="2097"></a>     *   in ascending order of their 'prop' property values.  To sort in
<a name="2098"></a>     *   descending order of the same property, simply reverse the
<a name="2099"></a>     *   subtraction: b.prop - a.prop.
<a name="2100"></a>     *   
<a name="2101"></a>     *   When no implementation of this method is defined in the group
<a name="2102"></a>     *   object, sortListGroup won't bother sorting the list at all.
<a name="2103"></a>     *   
<a name="2104"></a>     *   By default, we don't implement this method.  Subclasses that want
<a name="2105"></a>     *   to impose a sorting order must implement the method.  
<a name="2106"></a>     */
<a name="2107"></a>    // compareGroupItems(a, b) { return a &gt; b ? 1 : a == b ? 0 : -1; }
<a name="2108"></a>;
<a name="2109"></a>
<a name="2110"></a>/*
<a name="2111"></a> *   List Group implementation: parenthesized sublist.  Displays the
<a name="2112"></a> *   number of items collectively, then displays the list of items in
<a name="2113"></a> *   parentheses.
<a name="2114"></a> *   
<a name="2115"></a> *   Note that this is a ListGroupSorted subclass.  If our subclass
<a name="2116"></a> *   defines a compareGroupItems() method, we'll show the list in the
<a name="2117"></a> *   order specified by compareGroupItems().  
<a name="2118"></a> */
<a name="2119"></a>class ListGroupParen: ListGroupSorted
<a name="2120"></a>    /* 
<a name="2121"></a>     *   show the group list 
<a name="2122"></a>     */
<a name="2123"></a>    showGroupList(pov, lister, lst, options, indent, infoTab)
<a name="2124"></a>    {
<a name="2125"></a>        /* sort the list group, if we have an ordering method defined */
<a name="2126"></a>        lst = sortListGroup(lst);
<a name="2127"></a>
<a name="2128"></a>        /* create a sub-lister for the group */
<a name="2129"></a>        lister = createGroupSublister(lister);
<a name="2130"></a>
<a name="2131"></a>        /* show the collective count of the object */
<a name="2132"></a>        showGroupCountName(lst);
<a name="2133"></a>
<a name="2134"></a>        /* show the tall or wide sublist */
<a name="2135"></a>        if ((options &amp; ListTall) != 0)
<a name="2136"></a>        {
<a name="2137"></a>            /* tall list - show the items as a sublist */
<a name="2138"></a>            "\n";
<a name="2139"></a>            lister.showList(pov, nil, lst, options &amp; ~ListContents,
<a name="2140"></a>                            indent, infoTab, self);
<a name="2141"></a>        }
<a name="2142"></a>        else
<a name="2143"></a>        {
<a name="2144"></a>            /* wide list - add a space and a paren for the sublist */
<a name="2145"></a>            " (";
<a name="2146"></a>
<a name="2147"></a>            /* show the sublist */
<a name="2148"></a>            lister.showList(pov, nil, lst, options &amp; ~ListContents,
<a name="2149"></a>                            indent, infoTab, self);
<a name="2150"></a>
<a name="2151"></a>            /* end the sublist */
<a name="2152"></a>            ")";
<a name="2153"></a>        }
<a name="2154"></a>    }
<a name="2155"></a>
<a name="2156"></a>    /*
<a name="2157"></a>     *   Show the collective count for the list of objects.  By default,
<a name="2158"></a>     *   we'll simply display the countName of the first item in the list,
<a name="2159"></a>     *   on the assumption that each object has the same plural
<a name="2160"></a>     *   description.  However, in most cases this should be overridden to
<a name="2161"></a>     *   provide a more general collective name for the group. 
<a name="2162"></a>     */
<a name="2163"></a>    showGroupCountName(lst)
<a name="2164"></a>    {
<a name="2165"></a>        /* show the first item's countName */
<a name="2166"></a>        say(lst[1].countName(lst.length()));
<a name="2167"></a>    }
<a name="2168"></a>
<a name="2169"></a>    /* we don't add a sublist, since we enclose our list in parentheses */
<a name="2170"></a>    groupDisplaysSublist = nil
<a name="2171"></a>;
<a name="2172"></a>
<a name="2173"></a>/*
<a name="2174"></a> *   List Group implementation: simple prefix/suffix lister.  Shows a
<a name="2175"></a> *   prefix message, then shows the list, then shows a suffix message.
<a name="2176"></a> *   
<a name="2177"></a> *   Note that this is a ListGroupSorted subclass.  If our subclass
<a name="2178"></a> *   defines a compareGroupItems() method, we'll show the list in the
<a name="2179"></a> *   order specified by compareGroupItems().  
<a name="2180"></a> */
<a name="2181"></a>class ListGroupPrefixSuffix: ListGroupSorted
<a name="2182"></a>    showGroupList(pov, lister, lst, options, indent, infoTab)
<a name="2183"></a>    {
<a name="2184"></a>        /* sort the list group, if we have an ordering method defined */
<a name="2185"></a>        lst = sortListGroup(lst);
<a name="2186"></a>
<a name="2187"></a>        /* create a sub-lister for the group */
<a name="2188"></a>        lister = createGroupSublister(lister);
<a name="2189"></a>
<a name="2190"></a>        /* show the prefix */
<a name="2191"></a>        showGroupPrefix(pov, lst);
<a name="2192"></a>
<a name="2193"></a>        /* if we're in tall mode, start a new line */
<a name="2194"></a>        lister.showTallListNewline(options);
<a name="2195"></a>
<a name="2196"></a>        /* show the list */
<a name="2197"></a>        lister.showList(pov, nil, lst, options &amp; ~ListContents,
<a name="2198"></a>                        indent + 1, infoTab, self);
<a name="2199"></a>
<a name="2200"></a>        /* show the suffix */
<a name="2201"></a>        showGroupSuffix(pov, lst);
<a name="2202"></a>    }
<a name="2203"></a>
<a name="2204"></a>    /* show the prefix - we just show the groupPrefix message by default */
<a name="2205"></a>    showGroupPrefix(pov, lst) { groupPrefix; }
<a name="2206"></a>
<a name="2207"></a>    /* show the suffix - we just show the groupSuffix message by default */
<a name="2208"></a>    showGroupSuffix(pov, lst) { groupSuffix; }
<a name="2209"></a>
<a name="2210"></a>    /* 
<a name="2211"></a>     *   The prefix and suffix messages.  The showGroupPrefix and
<a name="2212"></a>     *   showGroupSuffix methods simply show these message properties.  We
<a name="2213"></a>     *   go through this two-step procedure for convenience: if the
<a name="2214"></a>     *   subclass doesn't need the POV and list parameters, it's less
<a name="2215"></a>     *   typing to just override these parameterless properties.  If the
<a name="2216"></a>     *   subclass needs to vary the message according to the POV or what's
<a name="2217"></a>     *   in the list, it can override the showGroupXxx methods instead.  
<a name="2218"></a>     */
<a name="2219"></a>    groupPrefix = ""
<a name="2220"></a>    groupSuffix = ""
<a name="2221"></a>;
<a name="2222"></a>
<a name="2223"></a>/*
<a name="2224"></a> *   Equivalent object list group.  This is the default listing group for
<a name="2225"></a> *   equivalent items.  The Thing class creates an instance of this class
<a name="2226"></a> *   during initialization for each set of equivalent items.  
<a name="2227"></a> */
<a name="2228"></a>class ListGroupEquivalent: ListGroup
<a name="2229"></a>    showGroupList(pov, lister, lst, options, indent, infoTab)
<a name="2230"></a>    {
<a name="2231"></a>        /* show a count of the items */
<a name="2232"></a>        lister.showListItemCounted(lst, options, pov, infoTab);
<a name="2233"></a>    }
<a name="2234"></a>
<a name="2235"></a>    /*
<a name="2236"></a>     *   An equivalence group displays only a single noun phrase to cover
<a name="2237"></a>     *   the entire group. 
<a name="2238"></a>     */
<a name="2239"></a>    groupNounPhraseCount(lister, lst) { return 1; }
<a name="2240"></a>     
<a name="2241"></a>    /* we display as a single item, so there's no sublist */
<a name="2242"></a>    groupDisplaysSublist = nil
<a name="2243"></a>;
<a name="2244"></a>
</pre>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/6/2009 from TADS version 3.0.18.1</div>
</body>
</html>
