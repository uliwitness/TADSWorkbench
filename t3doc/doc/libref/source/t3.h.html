<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>t3.h</title></head><body>
<table class=ban><tr><td><h1>t3.h</h1><td align=right><a href="../file/t3.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/* 
<a name="4"></a> *   Copyright (c) 1999, 2006 Michael J. Roberts
<a name="5"></a> *   
<a name="6"></a> *   This file is part of TADS 3
<a name="7"></a> *   
<a name="8"></a> *   This header defines the t3vm intrinsic function set.  These functions
<a name="9"></a> *   provide access to basic features of the Virtual Machine.  
<a name="10"></a> */
<a name="11"></a>
<a name="12"></a>/*
<a name="13"></a> *   T3 intrinsic function set definition
<a name="14"></a> */
<a name="15"></a>
<a name="16"></a>#ifndef T3_H
<a name="17"></a>#define T3_H
<a name="18"></a>
<a name="19"></a>/* 
<a name="20"></a> *   include the LookupTable intrinsic class, since t3GetGlobalSymbols()
<a name="21"></a> *   returns an instance of this class 
<a name="22"></a> */
<a name="23"></a>#include "lookup.h"
<a name="24"></a>
<a name="25"></a>
<a name="26"></a>/* 
<a name="27"></a> *   define the T3 system interface 
<a name="28"></a> */
<a name="29"></a>intrinsic 't3vm/010005'
<a name="30"></a>{
<a name="31"></a>    /* 
<a name="32"></a>     *   Explicitly run garbage collection.
<a name="33"></a>     */
<a name="34"></a>    t3RunGC();
<a name="35"></a>
<a name="36"></a>    /* 
<a name="37"></a>     *   Set the default output function or method.  The return value is the
<a name="38"></a>     *   old function pointer or method, depending on which one is being set
<a name="39"></a>     *   with this call.  (If 'val' is a function pointer, the return value
<a name="40"></a>     *   will be the old function; if 'val' is a property ID, the return
<a name="41"></a>     *   value is the old method.)
<a name="42"></a>     *   
<a name="43"></a>     *   The special values T3SetSayNoFunc and T3SetSayNoMethod can be passed
<a name="44"></a>     *   to the function to remove any existing function or method,
<a name="45"></a>     *   respectively, and are returned when appropriate to indicate that
<a name="46"></a>     *   there was no previous setting.  
<a name="47"></a>     */
<a name="48"></a>    t3SetSay(val);
<a name="49"></a>
<a name="50"></a>    /* 
<a name="51"></a>     *   Get the VM version number.  Returns the version number as an integer
<a name="52"></a>     *   value, with the major version in the high-order 16 bits, the minor
<a name="53"></a>     *   version number in the next 8 bits, and the patch number ("point
<a name="54"></a>     *   release" number) in the low-order 8 bits.  For example, version
<a name="55"></a>     *   3.0.10 is encoded as 0x0003000A.  
<a name="56"></a>     */
<a name="57"></a>    t3GetVMVsn();
<a name="58"></a>
<a name="59"></a>    /* 
<a name="60"></a>     *   Get the VM identifier string.  This returns the version number as a
<a name="61"></a>     *   string, as in '3.0.10'.
<a name="62"></a>     */
<a name="63"></a>    t3GetVMID();
<a name="64"></a>
<a name="65"></a>    /* 
<a name="66"></a>     *   Get the VM banner string.  This returns a string with the name of
<a name="67"></a>     *   the VM, the version number, and a copyright string, in a format
<a name="68"></a>     *   suitable for displaying to the user to identify the VM executable.  
<a name="69"></a>     */
<a name="70"></a>    t3GetVMBanner();
<a name="71"></a>
<a name="72"></a>    /* 
<a name="73"></a>     *   Get the preinitialization mode flag.  This returns true if the VM is
<a name="74"></a>     *   running as part of the compiler's pre-initialization phase, nil if
<a name="75"></a>     *   it's running as a normal interpreter.  
<a name="76"></a>     */
<a name="77"></a>    t3GetVMPreinitMode();
<a name="78"></a>
<a name="79"></a>    /* 
<a name="80"></a>     *   Debugger trace operations.  This provides access to the interactive
<a name="81"></a>     *   debugger subsystem, if the VM is running under a debugger.  The
<a name="82"></a>     *   'mode' argument determines what the function does and what the
<a name="83"></a>     *   additional arguments, if any, are for:
<a name="84"></a>     *   
<a name="85"></a>     *   T3DebugCheck - checks to see if an interactive debugger is present.
<a name="86"></a>     *   No additional arguments; returns true if a debugger is present, nil
<a name="87"></a>     *   if not.
<a name="88"></a>     *   
<a name="89"></a>     *   T3DebugBreak - breaks into the interactive debugger, pausing
<a name="90"></a>     *   execution at the current code location so that the user can inspect
<a name="91"></a>     *   the current machine state and determine how to proceed.  No
<a name="92"></a>     *   additional arguments; after the user proceeds with execution, the
<a name="93"></a>     *   function returns true to indicate that a debugger is present.  If no
<a name="94"></a>     *   debugger is present, the function simply returns nil, and has no
<a name="95"></a>     *   other effect.  
<a name="96"></a>     */
<a name="97"></a>    t3DebugTrace(mode, ...);
<a name="98"></a>
<a name="99"></a>    /*
<a name="100"></a>     *   Get the global symbol table.  If a symbol table is available, this
<a name="101"></a>     *   returns a LookupTable object; otherwise, it returns nil.
<a name="102"></a>     *   
<a name="103"></a>     *   This call will return a valid object value when pre-initialization
<a name="104"></a>     *   is running during program building, or when the program has been
<a name="105"></a>     *   compiled for debugging.  When a program compiled for release (i.e.,
<a name="106"></a>     *   no debug information) is run under the interpreter, this will
<a name="107"></a>     *   return nil, because no symbol information is available.
<a name="108"></a>     *   
<a name="109"></a>     *   Note that programs can, if they wish, get a reference to this
<a name="110"></a>     *   object during pre-initialization, then keep the reference (by
<a name="111"></a>     *   storing it in an object property, for example) so that it is
<a name="112"></a>     *   available during normal execution under the interpreter.  If the
<a name="113"></a>     *   program is compiled for release, and it does not keep a reference
<a name="114"></a>     *   in this manner, the garbage collector will automatically delete the
<a name="115"></a>     *   object when pre-initialization is completed.  This allows programs
<a name="116"></a>     *   that wish to keep the symbol information around at run-time to do
<a name="117"></a>     *   so, while not burdening programs that don't need the information
<a name="118"></a>     *   with the extra memory the symbols consume.  
<a name="119"></a>     */
<a name="120"></a>    t3GetGlobalSymbols();
<a name="121"></a>
<a name="122"></a>    /*
<a name="123"></a>     *   Allocate a new property.  Returns a new property not yet used
<a name="124"></a>     *   anywhere in the program.  Note that property ID's are a somewhat
<a name="125"></a>     *   limited resource - only approximately 65,000 total are available,
<a name="126"></a>     *   including all of the properties that the program defines
<a name="127"></a>     *   statically.  
<a name="128"></a>     */
<a name="129"></a>    t3AllocProp();
<a name="130"></a>
<a name="131"></a>    /*
<a name="132"></a>     *   Get a stack trace.  This returns a list of T3StackInfo objects.
<a name="133"></a>     *   Each object represents a nesting level in the call stack.  The first
<a name="134"></a>     *   element in the list represents the currently active level (i.e., the
<a name="135"></a>     *   level that called this function), the second element represents the
<a name="136"></a>     *   caller of the first element, and so on.
<a name="137"></a>     *   
<a name="138"></a>     *   If 'level' is specified, we'll return a single T3StackInfo object
<a name="139"></a>     *   giving the context at the given stack level - 1 is the active level,
<a name="140"></a>     *   2 is its caller, and so on, so 'level' would simply be the index in
<a name="141"></a>     *   the returned list when this argument is omitted.  
<a name="142"></a>     */
<a name="143"></a>    t3GetStackTrace(level?);
<a name="144"></a>}
<a name="145"></a>
<a name="146"></a>/*
<a name="147"></a> *   t3DebugTrace() mode flags 
<a name="148"></a> */
<a name="149"></a>
<a name="150"></a>/* check to see if the debugger is present */
<a name="151"></a>#define T3DebugCheck     1
<a name="152"></a>
<a name="153"></a>/* break into the debugger */
<a name="154"></a>#define T3DebugBreak     2
<a name="155"></a>
<a name="156"></a>/*
<a name="157"></a> *   t3SetSay() special values.  These can be passed in lieu of a function
<a name="158"></a> *   pointer or property ID when the caller wants to remove any existing
<a name="159"></a> *   function or method rather than install a new one.  
<a name="160"></a> */
<a name="161"></a>#define T3SetSayNoFunc    1
<a name="162"></a>#define T3SetSayNoMethod  2
<a name="163"></a>
<a name="164"></a>
<a name="165"></a>#endif /* T3_H */
</pre>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/6/2009 from TADS version 3.0.18.1</div>
</body>
</html>
