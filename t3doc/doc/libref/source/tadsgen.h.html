<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>tadsgen.h</title></head><body>
<table class=ban><tr><td><h1>tadsgen.h</h1><td align=right><a href="../file/tadsgen.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/* 
<a name="4"></a> *   Copyright (c) 1999, 2006 Michael J. Roberts
<a name="5"></a> *   
<a name="6"></a> *   This file is part of TADS 3
<a name="7"></a> *   
<a name="8"></a> *   This header defines the tads-gen intrinsic function set.  This function
<a name="9"></a> *   set provides some miscellaneous functions, including data conversions,
<a name="10"></a> *   object iteration, regular expressions, and state persistence operations.
<a name="11"></a> */
<a name="12"></a>
<a name="13"></a>/*
<a name="14"></a> *   TADS basic data manipulation intrinsic function set 
<a name="15"></a> */
<a name="16"></a>
<a name="17"></a>#ifndef TADSGEN_H
<a name="18"></a>#define TADSGEN_H
<a name="19"></a>
<a name="20"></a>/*
<a name="21"></a> *   The tads-gen function set 
<a name="22"></a> */
<a name="23"></a>intrinsic 'tads-gen/030006'
<a name="24"></a>{
<a name="25"></a>    /*
<a name="26"></a>     *   Get the type of the given value.  This returns a TypeXxx value.
<a name="27"></a>     */
<a name="28"></a>    dataType(val);
<a name="29"></a>
<a name="30"></a>    /*
<a name="31"></a>     *   Get the given parameter to the current function.  'idx' is 1 for the
<a name="32"></a>     *   first argument in left-to-right order, 2 for the second, and so on. 
<a name="33"></a>     */
<a name="34"></a>    getArg(idx);
<a name="35"></a>
<a name="36"></a>    /*
<a name="37"></a>     *   Get the first object in memory.  If 'cls' is provided, we return the
<a name="38"></a>     *   first object of the given class; otherwise we return the first
<a name="39"></a>     *   object of any kind.  'flags' is an optional bitwise combination of
<a name="40"></a>     *   ObjXxx values, specifying whether classes, instances, or both are
<a name="41"></a>     *   desired.  If this isn't specified, ObjAll is assumed.  This is used
<a name="42"></a>     *   in conjunction with nextObj() to iterate over all objects in memory,
<a name="43"></a>     *   or all objects of a given class.  
<a name="44"></a>     */
<a name="45"></a>    firstObj(cls?, flags?);
<a name="46"></a>
<a name="47"></a>    /*
<a name="48"></a>     *   Get the next object in memory after the given object, optionally of
<a name="49"></a>     *   the given class and optionally limiting to instances, classes, or
<a name="50"></a>     *   both.  This is used to continue an iteration started with
<a name="51"></a>     *   firstObj().  
<a name="52"></a>     */
<a name="53"></a>    nextObj(obj, cls?, flags?);
<a name="54"></a>
<a name="55"></a>    /*
<a name="56"></a>     *   Seed the random-number generator.  This uses unpredictable
<a name="57"></a>     *   information from the external operating system environment (which
<a name="58"></a>     *   might be something like the current time of day, but the exact
<a name="59"></a>     *   information used varies by system) to seed the rand() generator with
<a name="60"></a>     *   a new starting position.  Since rand() is a pseudo-random number
<a name="61"></a>     *   generator, its sequence is deterministic - each time it's started
<a name="62"></a>     *   with a given seed value, the identical sequence will result.  This
<a name="63"></a>     *   function helps produce apparent randomness by effectively
<a name="64"></a>     *   randomizing the starting point of the sequence.
<a name="65"></a>     *   
<a name="66"></a>     *   Note that if randomize() is never called, the system will use a
<a name="67"></a>     *   fixed initial seed, so rand() will return the same sequence each
<a name="68"></a>     *   time the program is run.  This is intentional, because it makes the
<a name="69"></a>     *   program's behavior exactly repeatable, even if the program calls
<a name="70"></a>     *   rand() to select random numbers.  This type of repeatable,
<a name="71"></a>     *   deterministic behavior is especially useful for testing purposes,
<a name="72"></a>     *   since it allows you to run the program through a fixed set of input
<a name="73"></a>     *   and compare the results against a fixed set of output, knowing the
<a name="74"></a>     *   the random number sequence will be the same on each run.  Typically,
<a name="75"></a>     *   what you'd want to do is check at start-up to see if you're in
<a name="76"></a>     *   "testing" mode (however you wish to define that), and call
<a name="77"></a>     *   randomize() only if you're not in testing mode.  This will create
<a name="78"></a>     *   apparently random behavior on normal runs, but produce repeatable
<a name="79"></a>     *   behavior during testing.  
<a name="80"></a>     */
<a name="81"></a>    randomize();
<a name="82"></a>
<a name="83"></a>    /*
<a name="84"></a>     *   Select a random number or a random value.
<a name="85"></a>     *   
<a name="86"></a>     *   If only one argument is supplied, and this argument is an integer
<a name="87"></a>     *   value, the function returns an integer from 0 to one less than the
<a name="88"></a>     *   argument value.  For example, rand(10) returns a number from 0 to 9
<a name="89"></a>     *   inclusive.
<a name="90"></a>     *   
<a name="91"></a>     *   If one argument is supplied, and the argument is a list, the
<a name="92"></a>     *   function randomly selects one of the values from the list and
<a name="93"></a>     *   returns it.
<a name="94"></a>     *   
<a name="95"></a>     *   If more than one argument is supplied, the function randomly selects
<a name="96"></a>     *   one of the arguments and returns it.  (Note that since this is an
<a name="97"></a>     *   ordinary function call, all of the arguments are evaluated,
<a name="98"></a>     *   triggering any side effects of those evaluations.)
<a name="99"></a>     *   
<a name="100"></a>     *   In all cases, the random number selection is uniformly distributed,
<a name="101"></a>     *   meaning that each possible return value has equal probability.  
<a name="102"></a>     */
<a name="103"></a>    rand(x, ...);
<a name="104"></a>
<a name="105"></a>    /*
<a name="106"></a>     *   Convert the given value to a string representation.  'val' can be an
<a name="107"></a>     *   integer, in which case it's converted to a string representation in
<a name="108"></a>     *   the numeric base given by 'radix' (which can be any value from 2 to
<a name="109"></a>     *   36), or base 10 (decimal) if 'radix' is omitted; nil or true, in
<a name="110"></a>     *   which case the string 'nil' or 'true' is returned; a string, which
<a name="111"></a>     *   is returned unchanged; or a BigNumber, in which case the value is
<a name="112"></a>     *   converted to a string representation in decimal.  (Note that in the
<a name="113"></a>     *   case of BigNumber, you might prefer to use BigNumber.formatString(),
<a name="114"></a>     *   as that gives you much more control over the formatting.)  
<a name="115"></a>     */
<a name="116"></a>    toString(val, radix?);
<a name="117"></a>
<a name="118"></a>    /*
<a name="119"></a>     *   Convert the given value to an integer.  If 'val' is a string, the
<a name="120"></a>     *   function parses the value as an integer value in the numeric base
<a name="121"></a>     *   given by 'radix' (which can be one of 2, 8, 10, or 16), or base 10
<a name="122"></a>     *   (decimal) if 'radix' is omitted.  If 'val' is the string 'true' or
<a name="123"></a>     *   'nil', the function returns true or nil, respectively.  If 'val' is
<a name="124"></a>     *   a BigNumber value, the value is rounded to the nearest integer; an
<a name="125"></a>     *   exception ("numeric overflow") is thrown if the number is out of
<a name="126"></a>     *   range for a 32-bit integer.  
<a name="127"></a>     */
<a name="128"></a>    toInteger(val, radix?);
<a name="129"></a>
<a name="130"></a>    /* 
<a name="131"></a>     *   Get the current local time.
<a name="132"></a>     *   
<a name="133"></a>     *   If timeType is GetTimeDateAndTime (or is omitted), this returns the
<a name="134"></a>     *   calendar date and wall-clock time, as a list: [year, month,
<a name="135"></a>     *   dayOfMonth, dayOfWeek, dayOfYear, hour, minute, second, timer].
<a name="136"></a>     *   Year is the year AD (for example, 2006); month is the current month,
<a name="137"></a>     *   from 1 (January) to 12 (December); dayOfMonth is the calendar day of
<a name="138"></a>     *   the month, from 1 to 31; dayOfWeek is the day of the week, from 1
<a name="139"></a>     *   (Sunday) to 7 (Saturday); dayOfYear is the current day of the year,
<a name="140"></a>     *   from 1 (January 1) to 366 (December 31 in a leap year); hour is the
<a name="141"></a>     *   hour on a 24-hour clock, ranging from 0 (midnight) to 23 (11pm);
<a name="142"></a>     *   minute is the minute of the hour, from 0 to 59; second is the second
<a name="143"></a>     *   of the minute, from 0 to 59; and timer is the number of seconds
<a name="144"></a>     *   elapsed since the "epoch," defined arbitrarily as midnight, January
<a name="145"></a>     *   1, 1970.
<a name="146"></a>     *   
<a name="147"></a>     *   If timeType is GetTimeTicks, this return the number of milliseconds
<a name="148"></a>     *   since an arbitrary starting time.  The first call to get this
<a name="149"></a>     *   information sets the starting time, so it will return zero;
<a name="150"></a>     *   subsequent calls will return the amount of time elapsed from that
<a name="151"></a>     *   starting time.  Note that because a signed 32-bit integer can only
<a name="152"></a>     *   hold values up to about 2 billion, the maximum elapsed time that
<a name="153"></a>     *   this value can represent is about 24.8 days; so, if your program
<a name="154"></a>     *   runs continuously for more than this, the timer value will roll
<a name="155"></a>     *   around to zero at each 24.8 day multiple.  So, it's possible for
<a name="156"></a>     *   this function to return a smaller value than on a previous
<a name="157"></a>     *   invocation, if the two invocations straddle a 24.8-day boundary.  
<a name="158"></a>     */
<a name="159"></a>    getTime(timeType?);
<a name="160"></a>
<a name="161"></a>    /*
<a name="162"></a>     *   Match a string to a regular expression pattern.  'pat' can be either
<a name="163"></a>     *   a string giving the regular expression, or can be a RexPattern
<a name="164"></a>     *   object.  'str' is the string to match, and 'index' is the starting
<a name="165"></a>     *   character index (the first character is at index 1) at which to
<a name="166"></a>     *   start matching.  Returns the length in characters of the match, or
<a name="167"></a>     *   nil if the string doesn't match the pattern.  (Note that a return
<a name="168"></a>     *   value of zero doesn't indicate failure - rather, it indicates a
<a name="169"></a>     *   successful match of the pattern to zero characters.  This is
<a name="170"></a>     *   possible for a pattern with a zero-or-more closure, such as 'x*' or
<a name="171"></a>     *   'x?'.)  
<a name="172"></a>     */
<a name="173"></a>    rexMatch(pat, str, index?);
<a name="174"></a>
<a name="175"></a>    /*
<a name="176"></a>     *   Search the given string for the given regular expression pattern.
<a name="177"></a>     *   'pat' is a string giving the regular expression, or a RexPattern
<a name="178"></a>     *   object.  'str' is the string to search, and 'index' is the optional
<a name="179"></a>     *   starting index (the first character is at index 1).  If the pattern
<a name="180"></a>     *   cannot be found, returns nil.  If the pattern is found, the return
<a name="181"></a>     *   value is a list: [index, length, string], where index is the
<a name="182"></a>     *   starting character index of the match, length is the length in
<a name="183"></a>     *   characters of the match, and string is the text of the match.  
<a name="184"></a>     */
<a name="185"></a>    rexSearch(pat, str, index?);
<a name="186"></a>
<a name="187"></a>    /*
<a name="188"></a>     *   Get the given regular expression group.  This can be called after a
<a name="189"></a>     *   successful rexMatch() or rexSearch() call to retrieve information on
<a name="190"></a>     *   the substring that matched the given "group" within the regular
<a name="191"></a>     *   expression.  A group is a parenthesized sub-pattern within the
<a name="192"></a>     *   regular expression; groups are numbered left to right by the open
<a name="193"></a>     *   parenthesis, starting at group 1.  If there is no such group in the
<a name="194"></a>     *   last regular expression searched or matched, or the group wasn't
<a name="195"></a>     *   part of the match (for example, because it was part of an
<a name="196"></a>     *   alternation that wasn't matched), the return value is nil.  If the
<a name="197"></a>     *   group is valid and was part of the match, the return value is a
<a name="198"></a>     *   list: [index, length, string], where index is the character index
<a name="199"></a>     *   within the matched or searched string of the start of the group
<a name="200"></a>     *   match, length is the character length of the group match, and string
<a name="201"></a>     *   is the text of the group match.  
<a name="202"></a>     */
<a name="203"></a>    rexGroup(groupNum);
<a name="204"></a>
<a name="205"></a>    /*
<a name="206"></a>     *   Search for the given regular expression pattern (which can be given
<a name="207"></a>     *   as a regular expression string or as a RexPattern object) within the
<a name="208"></a>     *   given string, and replace one or more occurrences of the pattern
<a name="209"></a>     *   with the given replacement text.  If 'flags' includes ReplaceAll,
<a name="210"></a>     *   all occurrences of the pattern are replaced; otherwise only the
<a name="211"></a>     *   first occurrence is replaced.  'index', if provided, is the starting
<a name="212"></a>     *   character index of the search; instances of the pattern before this
<a name="213"></a>     *   index will be ignored.  Returns the result string with all of the
<a name="214"></a>     *   desired replacements.  When an instance of the pattern is found and
<a name="215"></a>     *   then replaced, the replacement string is not rescanned for further
<a name="216"></a>     *   occurrences of the text, so there's no danger of infinite recursion;
<a name="217"></a>     *   instead, scanning proceeds from the next character after the
<a name="218"></a>     *   replacement text.
<a name="219"></a>     *   
<a name="220"></a>     *   The replacement text can use "%n" sequences to substitute group
<a name="221"></a>     *   matches from the input into the output.  %1 is replaced by the match
<a name="222"></a>     *   to the first group, %2 the second, and so on.  %* is replaced by the
<a name="223"></a>     *   entire matched input.  (Because of the special meaning of "%", you
<a name="224"></a>     *   must use "%%" to include a percent sign in the replacement text.)  
<a name="225"></a>     */
<a name="226"></a>    rexReplace(pat, str, replacement, flags, index?);
<a name="227"></a>
<a name="228"></a>    /*
<a name="229"></a>     *   Create an UNDO savepoint.  This adds a marker to the VM's internal
<a name="230"></a>     *   UNDO log, establishing a point in time for a future UNDO operation.
<a name="231"></a>     */
<a name="232"></a>    savepoint();
<a name="233"></a>
<a name="234"></a>    /*
<a name="235"></a>     *   UNDO to the most recent savepoint.  This uses the VM's internal UNDO
<a name="236"></a>     *   log to undo all changes to persistent objects, up to the most recent
<a name="237"></a>     *   savepoint.  Returns true if the operation succeeded, nil if not.  A
<a name="238"></a>     *   nil return means that there's no further UNDO information recorded,
<a name="239"></a>     *   which could be because the program has already undone everything
<a name="240"></a>     *   back to the start of the session, or because the UNDO log was
<a name="241"></a>     *   truncated due to memory size such that no savepoints are recorded.
<a name="242"></a>     *   (The system automatically limits the UNDO log's total memory
<a name="243"></a>     *   consumption, according to local system parameters.  This function
<a name="244"></a>     *   requires at least one savepoint to be present, because otherwise it
<a name="245"></a>     *   could create an inconsistent state.)  
<a name="246"></a>     */
<a name="247"></a>    undo();
<a name="248"></a>
<a name="249"></a>    /*
<a name="250"></a>     *   Save the current system state into the given file.  This uses the
<a name="251"></a>     *   VM's internal state-save mechanism to store the current state of all
<a name="252"></a>     *   persistent objects in the given file.  Any existing file is
<a name="253"></a>     *   overwritten.  
<a name="254"></a>     */
<a name="255"></a>    saveGame(filename);
<a name="256"></a>
<a name="257"></a>    /*
<a name="258"></a>     *   Restore a previously saved state file.  This loads the states of all
<a name="259"></a>     *   persistent objects stored in the given file.  The file must have
<a name="260"></a>     *   been saved by the current version of the current running program; if
<a name="261"></a>     *   not, an exception is thrown.  
<a name="262"></a>     */
<a name="263"></a>    restoreGame(filename);
<a name="264"></a>
<a name="265"></a>    /*
<a name="266"></a>     *   Restart the program from the beginning.  This resets all persistent
<a name="267"></a>     *   objects to their initial state, as they were when the program was
<a name="268"></a>     *   first started.  
<a name="269"></a>     */
<a name="270"></a>    restartGame();
<a name="271"></a>
<a name="272"></a>    /*
<a name="273"></a>     *   Get the maximum of the given arguments.  The values must be
<a name="274"></a>     *   comparable with the ordinary "&lt;" and "&gt;" operators.  Note that
<a name="275"></a>     *   because this is an ordinary function call, all of the arguments are
<a name="276"></a>     *   evaluated (which means any side effects of these evaluations will be
<a name="277"></a>     *   triggered).  
<a name="278"></a>     */
<a name="279"></a>    max(val1, ...);
<a name="280"></a>
<a name="281"></a>    /*
<a name="282"></a>     *   Get the minimum of the given arguments.  The values must be
<a name="283"></a>     *   comparable with the ordinary "&lt;" and "&gt;" operators. Note that
<a name="284"></a>     *   because this is an ordinary function call, all of the arguments are
<a name="285"></a>     *   evaluated (which means any side effects of these evaluations will be
<a name="286"></a>     *   triggered).  
<a name="287"></a>     */
<a name="288"></a>    min(val1, ...);
<a name="289"></a>
<a name="290"></a>    /*
<a name="291"></a>     *   Create a string by repeating the given value the given number of
<a name="292"></a>     *   times.  If the repeat count isn't specified, the default is 1.
<a name="293"></a>     *   'val' can be a string, in which case the string is simply repeated
<a name="294"></a>     *   the given number of times; an integer, in which case the given
<a name="295"></a>     *   Unicode character is repeated; or a list of integers, in which case
<a name="296"></a>     *   the given Unicode characters are repeated, in the order of the list.
<a name="297"></a>     *   The list format can be used to create a string from a list of
<a name="298"></a>     *   Unicode characters that you've been manipulating as a character
<a name="299"></a>     *   array, which is sometimes a more convenient or efficient way to do
<a name="300"></a>     *   certain types of string handling than using the actual string type.
<a name="301"></a>     */
<a name="302"></a>    makeString(val, repeatCount?);
<a name="303"></a>
<a name="304"></a>    /*
<a name="305"></a>     *   Get a description of the parameters to the given function.  'func'
<a name="306"></a>     *   is a function pointer.  This function returns a list: [minArgs,
<a name="307"></a>     *   optionalArgs, isVarargs], where minArgs is the minimum number of
<a name="308"></a>     *   arguments required by the function, optionalArgs is the additional
<a name="309"></a>     *   number of arguments that can be optionally provided to the function,
<a name="310"></a>     *   and isVarargs is true if the function takes any number of additional
<a name="311"></a>     *   ("varying") arguments, nil if not.  
<a name="312"></a>     */
<a name="313"></a>    getFuncParams(func);
<a name="314"></a>}
<a name="315"></a>
<a name="316"></a>/*
<a name="317"></a> *   flags for firstObj() and nextObj()
<a name="318"></a> */
<a name="319"></a>#define ObjInstances  0x0001
<a name="320"></a>#define ObjClasses    0x0002
<a name="321"></a>#define ObjAll        (ObjInstances | ObjClasses)
<a name="322"></a>
<a name="323"></a>/*
<a name="324"></a> *   rexReplace() flags 
<a name="325"></a> */
<a name="326"></a>#define ReplaceOnce  0x0000
<a name="327"></a>#define ReplaceAll   0x0001
<a name="328"></a>
<a name="329"></a>/*
<a name="330"></a> *   getTime() flags 
<a name="331"></a> */
<a name="332"></a>#define GetTimeDateAndTime  1
<a name="333"></a>#define GetTimeTicks        2
<a name="334"></a>
<a name="335"></a>
<a name="336"></a>#endif /* TADSGEN_H */
<a name="337"></a>
</pre>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/6/2009 from TADS version 3.0.18.1</div>
</body>
</html>
