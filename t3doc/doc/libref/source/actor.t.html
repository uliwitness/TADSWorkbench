<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>actor.t</title></head><body>
<table class=ban><tr><td><h1>actor.t</h1><td align=right><a href="../file/actor.t.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/* 
<a name="4"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts.  All Rights Reserved.
<a name="5"></a> *   
<a name="6"></a> *   TADS 3 Library - actors
<a name="7"></a> *   
<a name="8"></a> *   This module provides definitions related to actors, which represent
<a name="9"></a> *   characters in the game.  
<a name="10"></a> */
<a name="11"></a>
<a name="12"></a>/* include the library header */
<a name="13"></a>#include "adv3.h"
<a name="14"></a>
<a name="15"></a>
<a name="16"></a>/* ------------------------------------------------------------------------ */
<a name="17"></a>/*
<a name="18"></a> *   Implied command modes 
<a name="19"></a> */
<a name="20"></a>enum ModePlayer, ModeNPC;
<a name="21"></a>
<a name="22"></a>
<a name="23"></a>/* ------------------------------------------------------------------------ */
<a name="24"></a>/*
<a name="25"></a> *   A Topic is an object representing some piece of knowledge in the
<a name="26"></a> *   story.  Actors can use Topic objects in commands such as "ask" and
<a name="27"></a> *   "tell".
<a name="28"></a> *   
<a name="29"></a> *   A physical simulation object can be a Topic through multiple
<a name="30"></a> *   inheritance.  In addition, a game can define Topic objects for
<a name="31"></a> *   abstract conversation topics that don't correspond to simulation
<a name="32"></a> *   objects; for example, a topic could be created for "the meaning of
<a name="33"></a> *   life" to allow a command such as "ask guru about meaning of life."
<a name="34"></a> *   
<a name="35"></a> *   The key distinction between Topic objects and regular objects is that
<a name="36"></a> *   a Topic can represent an abstract, non-physical concept that isn't
<a name="37"></a> *   connected to any "physical" object in the simulation.  
<a name="38"></a> */
<a name="39"></a>class Topic: VocabObject
<a name="40"></a>    /*
<a name="41"></a>     *   Is the topic known?  If this is true, the topic is in scope for
<a name="42"></a>     *   actions that operate on topics, such as "ask about" and "tell
<a name="43"></a>     *   about."  If this is nil, the topic isn't known.  
<a name="44"></a>     *   
<a name="45"></a>     *   By default, we mark all topics as known to begin with, which
<a name="46"></a>     *   allows discussion of any topic at any time.  Some authors prefer
<a name="47"></a>     *   to keep track of which topics the player character actually has
<a name="48"></a>     *   reason to know about within the context of the game, making topics
<a name="49"></a>     *   available for conversation only after they become known for some
<a name="50"></a>     *   good reason, such as another character mentioning them in
<a name="51"></a>     *   conversation.
<a name="52"></a>     *   
<a name="53"></a>     *   Note that, as with Thing.isKnown, this is only the DEFAULT 'known'
<a name="54"></a>     *   property.  Each actor can have its own separate 'known' property
<a name="55"></a>     *   by defining the actor's 'knownProp' to a different property name.
<a name="56"></a>     */
<a name="57"></a>    isKnown = true
<a name="58"></a>
<a name="59"></a>    /* 
<a name="60"></a>     *   Topics are abstract objects, so they can't be sensed with any of
<a name="61"></a>     *   the physical senses, even if they're ever included as part of a
<a name="62"></a>     *   containment hierarchy (which might be convenient in some cases
<a name="63"></a>     *   for purposes of associating a topic with a physical object, for
<a name="64"></a>     *   example).
<a name="65"></a>     */
<a name="66"></a>    canBeSensed(sense, trans, ambient) { return nil; }
<a name="67"></a>
<a name="68"></a>    /* a topic cannot by default be used to resolve a possessive phrase */
<a name="69"></a>    canResolvePossessive = nil
<a name="70"></a>;
<a name="71"></a>
<a name="72"></a>
<a name="73"></a>/* ------------------------------------------------------------------------ */
<a name="74"></a>/*
<a name="75"></a> *   FollowInfo - this is an object that tracks an actor's knowledge of
<a name="76"></a> *   the objects that the actor can follow, which are objects that actor
<a name="77"></a> *   has witnessed leaving the current location.  We keep track of each
<a name="78"></a> *   followable object and the direction we saw it depart.  
<a name="79"></a> */
<a name="80"></a>class FollowInfo: object
<a name="81"></a>    /* the object we can follow */
<a name="82"></a>    obj = nil
<a name="83"></a>
<a name="84"></a>    /* the TravelConnector the object traversed to leave */
<a name="85"></a>    connector = nil
<a name="86"></a>
<a name="87"></a>    /* 
<a name="88"></a>     *   The source location - this is the location we saw the object
<a name="89"></a>     *   depart.  We keep track of this because an actor can follow an
<a name="90"></a>     *   object only if the actor is starting from the same location where
<a name="91"></a>     *   the actor saw the object depart.  
<a name="92"></a>     */
<a name="93"></a>    sourceLocation = nil
<a name="94"></a>;
<a name="95"></a>
<a name="96"></a>
<a name="97"></a>/* ------------------------------------------------------------------------ */
<a name="98"></a>/*
<a name="99"></a> *   Postures.  A posture describes how an actor is internally positioned:
<a name="100"></a> *   standing, lying, sitting.  We represent postures with objects of
<a name="101"></a> *   class Posture to make it easier to add new game-specific postures.  
<a name="102"></a> */
<a name="103"></a>class Posture: object
<a name="104"></a>    /* 
<a name="105"></a>     *   Try getting the current actor into this posture within the given
<a name="106"></a>     *   location, by running an appropriate implied command.  
<a name="107"></a>     */
<a name="108"></a>    tryMakingPosture(loc) { }
<a name="109"></a>
<a name="110"></a>    /* put the actor into our posture via a nested action */
<a name="111"></a>    setActorToPosture(actor, loc) { }
<a name="112"></a>;
<a name="113"></a>
<a name="114"></a>/*
<a name="115"></a> *   Standing posture - this is the default posture, which an actor
<a name="116"></a> *   normally uses for travel.  Actors are generally in this posture any
<a name="117"></a> *   time they are not sitting on something, lying on something, or
<a name="118"></a> *   similar. 
<a name="119"></a> */
<a name="120"></a>standing: Posture
<a name="121"></a>    tryMakingPosture(loc) { return tryImplicitAction(StandOn, loc); }
<a name="122"></a>    setActorToPosture(actor, loc) { nestedActorAction(actor, StandOn, loc); }
<a name="123"></a>;
<a name="124"></a>
<a name="125"></a>/*
<a name="126"></a> *   Sitting posture. 
<a name="127"></a> */
<a name="128"></a>sitting: Posture
<a name="129"></a>    tryMakingPosture(loc) { return tryImplicitAction(SitOn, loc); }
<a name="130"></a>    setActorToPosture(actor, loc) { nestedActorAction(actor, SitOn, loc); }
<a name="131"></a>;
<a name="132"></a>
<a name="133"></a>/*
<a name="134"></a> *   Lying posture. 
<a name="135"></a> */
<a name="136"></a>lying: Posture
<a name="137"></a>    tryMakingPosture(loc) { return tryImplicitAction(LieOn, loc); }
<a name="138"></a>    setActorToPosture(actor, loc) { nestedActorAction(actor, LieOn, loc); }
<a name="139"></a>;
<a name="140"></a>
<a name="141"></a>
<a name="142"></a>/* ------------------------------------------------------------------------ */
<a name="143"></a>/*
<a name="144"></a> *   Conversation manager output filter.  We look for special tags in the
<a name="145"></a> *   output stream:
<a name="146"></a> *   
<a name="147"></a> *   &lt;.reveal key&gt; - add 'key' to the knowledge token lookup table.  The
<a name="148"></a> *   'key' is an arbitrary string, which we can look up in the table to
<a name="149"></a> *   determine if the key has even been revealed.  This can be used to make
<a name="150"></a> *   a response conditional on another response having been displayed,
<a name="151"></a> *   because the key will only be added to the table when the text
<a name="152"></a> *   containing the &lt;.reveal key&gt; sequence is displayed.
<a name="153"></a> *   
<a name="154"></a> *   &lt;.convnode name&gt; - switch the current responding actor to conversation
<a name="155"></a> *   node 'name'.  
<a name="156"></a> *   
<a name="157"></a> *   &lt;.convstay&gt; - keep the responding actor in the same conversation node
<a name="158"></a> *   as it was in at the start of the current response
<a name="159"></a> *   
<a name="160"></a> *   &lt;.topics&gt; - schedule a topic inventory for the end of the turn (just
<a name="161"></a> *   before the next command prompt) 
<a name="162"></a> */
<a name="163"></a>conversationManager: OutputFilter, PreinitObject
<a name="164"></a>    /*
<a name="165"></a>     *   Custom extended tags.  Games and library extensions can add their
<a name="166"></a>     *   own tag processing as needed, by using 'modify' to extend this
<a name="167"></a>     *   object.  There are two things you have to do to add your own tags:
<a name="168"></a>     *   
<a name="169"></a>     *   First, add a 'customTags' property that defines a regular
<a name="170"></a>     *   expression for your added tags.  This will be incorporated into
<a name="171"></a>     *   the main pattern we use to look for tags.  Simply specify a
<a name="172"></a>     *   string that lists your tags separated by "|" characters, like
<a name="173"></a>     *   this:
<a name="174"></a>     *   
<a name="175"></a>     *   customTags = 'foo|bar'
<a name="176"></a>     *   
<a name="177"></a>     *   Second, define a doCustomTag() method to process the tags.  The
<a name="178"></a>     *   filter routine will call your doCustomTag() method whenever it
<a name="179"></a>     *   finds one of your custom tags in the output stream.  
<a name="180"></a>     */
<a name="181"></a>    customTags = nil
<a name="182"></a>    doCustomTag(tag, arg) { /* do nothing by default */ }
<a name="183"></a>
<a name="184"></a>    /* filter text written to the output stream */
<a name="185"></a>    filterText(ostr, txt)
<a name="186"></a>    {
<a name="187"></a>        local start;
<a name="188"></a>        
<a name="189"></a>        /* scan for our special tags */
<a name="190"></a>        for (start = 1 ; ; )
<a name="191"></a>        {
<a name="192"></a>            local match;
<a name="193"></a>            local arg;
<a name="194"></a>            local actor;
<a name="195"></a>            local sp;
<a name="196"></a>            local tag;
<a name="197"></a>            local nxtOfs;
<a name="198"></a>            
<a name="199"></a>            /* scan for the next tag */
<a name="200"></a>            match = rexSearch(tagPat, txt, start);
<a name="201"></a>
<a name="202"></a>            /* if we didn't find it, we're done */
<a name="203"></a>            if (match == nil)
<a name="204"></a>                break;
<a name="205"></a>
<a name="206"></a>            /* note the next offset */
<a name="207"></a>            nxtOfs = match[1] + match[2];
<a name="208"></a>
<a name="209"></a>            /* get the argument (the third group from the match) */
<a name="210"></a>            arg = rexGroup(3);
<a name="211"></a>            if (arg != nil)
<a name="212"></a>                arg = arg[3];
<a name="213"></a>
<a name="214"></a>            /* pick out the tag */
<a name="215"></a>            tag = rexGroup(1)[3].toLower();
<a name="216"></a>
<a name="217"></a>            /* check which tag we have */
<a name="218"></a>            switch (tag)
<a name="219"></a>            {
<a name="220"></a>            case 'reveal':
<a name="221"></a>                /* reveal the key by adding it to our database */
<a name="222"></a>                setRevealed(arg);
<a name="223"></a>                break;
<a name="224"></a>
<a name="225"></a>            case 'convbegin':
<a name="226"></a>                /* 
<a name="227"></a>                 *   Internal tag - starting a conversational response for
<a name="228"></a>                 *   an actor, identified by an index in our idToActor
<a name="229"></a>                 *   vector.  Get the actor.  
<a name="230"></a>                 */
<a name="231"></a>                actor = idToActor[toInteger(arg)];
<a name="232"></a>
<a name="233"></a>                /* 
<a name="234"></a>                 *   since we're just starting a response, clear the flag
<a name="235"></a>                 *   in the actor indicating that a ConvNode has been set
<a name="236"></a>                 *   in the course of this response 
<a name="237"></a>                 */
<a name="238"></a>                actor.responseSetConvNode = nil;
<a name="239"></a>
<a name="240"></a>                /* remember the new responding actor */
<a name="241"></a>                respondingActor = actor;
<a name="242"></a>
<a name="243"></a>                /* done */
<a name="244"></a>                break;
<a name="245"></a>
<a name="246"></a>            case 'convend':
<a name="247"></a>                /*
<a name="248"></a>                 *   Ending a conversational response for a given actor,
<a name="249"></a>                 *   identified by the first argument, which is an index in
<a name="250"></a>                 *   our idToActor vector. 
<a name="251"></a>                 */
<a name="252"></a>                sp = arg.find(' ');
<a name="253"></a>                actor = idToActor[toInteger(arg.substr(1, sp - 1))];
<a name="254"></a>
<a name="255"></a>                /* the rest of the argument is the default new ConvNode */
<a name="256"></a>                arg = arg.substr(sp + 1);
<a name="257"></a>
<a name="258"></a>                /* if the new ConvNode is empty, it means no ConvNode */
<a name="259"></a>                if (arg == '')
<a name="260"></a>                    arg = nil;
<a name="261"></a>
<a name="262"></a>                /* 
<a name="263"></a>                 *   if we didn't explicitly set a new ConvNode in the
<a name="264"></a>                 *   course of this response, apply the default 
<a name="265"></a>                 */
<a name="266"></a>                if (!actor.responseSetConvNode)
<a name="267"></a>                    actor.setConvNodeReason(arg, 'convend');
<a name="268"></a>
<a name="269"></a>                /*
<a name="270"></a>                 *   Since we've just finished showing a message that
<a name="271"></a>                 *   specifically refers to this actor, the player should
<a name="272"></a>                 *   be able to refer to this actor using a pronoun on the
<a name="273"></a>                 *   next command.  Set the responding actor as the
<a name="274"></a>                 *   antecedent for the appropriate singular pronouns for
<a name="275"></a>                 *   the player character.  Note that we do this at the end
<a name="276"></a>                 *   of the response, so that the antecedent is the last
<a name="277"></a>                 *   one if we have more than one.  
<a name="278"></a>                 */
<a name="279"></a>                gPlayerChar.setPronounObj(actor);
<a name="280"></a>
<a name="281"></a>                /* done */
<a name="282"></a>                break;
<a name="283"></a>
<a name="284"></a>            case 'convnode':
<a name="285"></a>                /* 
<a name="286"></a>                 *   If there's a current responding actor, set its current
<a name="287"></a>                 *   conversation node.
<a name="288"></a>                 */
<a name="289"></a>                if (respondingActor != nil)
<a name="290"></a>                {
<a name="291"></a>                    /* 
<a name="292"></a>                     *   Set the new node.  While we're working, capture
<a name="293"></a>                     *   any output that occurs so that we can insert it
<a name="294"></a>                     *   into the output stream just after the &lt;.convnode&gt;
<a name="295"></a>                     *   tag, so that any text displayed within the
<a name="296"></a>                     *   ConvNode's activation method (noteActive) is
<a name="297"></a>                     *   displayed in the proper order.  
<a name="298"></a>                     */
<a name="299"></a>                    local ctxt = mainOutputStream.captureOutput(
<a name="300"></a>                        {: respondingActor.setConvNodeReason(arg, 'convnode') });
<a name="301"></a>
<a name="302"></a>                    /* re-insert any text we captured */
<a name="303"></a>                    txt = txt.substr(1, nxtOfs - 1)
<a name="304"></a>                        + ctxt
<a name="305"></a>                        + txt.substr(nxtOfs);
<a name="306"></a>                }
<a name="307"></a>                break;
<a name="308"></a>
<a name="309"></a>            case 'convstay':
<a name="310"></a>                /* 
<a name="311"></a>                 *   leave the responding actor in the old conversation
<a name="312"></a>                 *   node - we don't need to change the ConvNode, but we do
<a name="313"></a>                 *   need to note that we've explicitly set it 
<a name="314"></a>                 */
<a name="315"></a>                if (respondingActor != nil)
<a name="316"></a>                    respondingActor.responseSetConvNode = true;
<a name="317"></a>                break;
<a name="318"></a>
<a name="319"></a>            case 'topics':
<a name="320"></a>                /* schedule a topic inventory listing */
<a name="321"></a>                scheduleTopicInventory();
<a name="322"></a>                break;
<a name="323"></a>
<a name="324"></a>            default:
<a name="325"></a>                /* check for an extended tag */
<a name="326"></a>                doCustomTag(tag, arg);
<a name="327"></a>                break;
<a name="328"></a>            }
<a name="329"></a>
<a name="330"></a>            /* continue the search after this match */
<a name="331"></a>            start = nxtOfs;
<a name="332"></a>        }
<a name="333"></a>
<a name="334"></a>        /* 
<a name="335"></a>         *   remove the tags from the text by replacing every occurrence
<a name="336"></a>         *   with an empty string, and return the result 
<a name="337"></a>         */
<a name="338"></a>        return rexReplace(tagPat, txt, '', ReplaceAll);
<a name="339"></a>    }
<a name="340"></a>
<a name="341"></a>    /* regular expression pattern for our tags */
<a name="342"></a>    tagPat = static new RexPattern(
<a name="343"></a>        '&lt;nocase&gt;&lt;langle&gt;&lt;dot&gt;'
<a name="344"></a>        + '(reveal|convbegin|convend|convnode|convstay|topics'
<a name="345"></a>        + (customTags != nil ? '|' + customTags : '')
<a name="346"></a>        + ')'
<a name="347"></a>        + '(&lt;space&gt;+(&lt;^rangle&gt;+))?'
<a name="348"></a>        + '&lt;rangle&gt;')
<a name="349"></a>
<a name="350"></a>    /*
<a name="351"></a>     *   Schedule a topic inventory request.  Game code can call this at
<a name="352"></a>     *   any time to request that the player character's topic inventory
<a name="353"></a>     *   be shown automatically just before the next command prompt.  In
<a name="354"></a>     *   most cases, game code won't call this directly, but will request
<a name="355"></a>     *   the same effect using the &lt;.topics&gt; tag in topic response text.  
<a name="356"></a>     */
<a name="357"></a>    scheduleTopicInventory()
<a name="358"></a>    {
<a name="359"></a>        /* note that we have a request for a prompt-time topic inventory */
<a name="360"></a>        pendingTopicInventory = true;
<a name="361"></a>    }
<a name="362"></a>
<a name="363"></a>    /*
<a name="364"></a>     *   Show or schedule a topic inventory request.  If the current
<a name="365"></a>     *   action has a non-default command report, schedule it; otherwise,
<a name="366"></a>     *   show it now.
<a name="367"></a>     *   
<a name="368"></a>     *   If there's a non-default report, don't suggest the topics now;
<a name="369"></a>     *   instead, schedule a topic inventory for the end of the turn.
<a name="370"></a>     *   When we have a non-default report, the report could change the
<a name="371"></a>     *   ConvNode for the actor, so we don't want to show the topic
<a name="372"></a>     *   inventory until we've had a chance to process all of the reports.
<a name="373"></a>     */
<a name="374"></a>    showOrScheduleTopicInventory(actor, otherActor)
<a name="375"></a>    {
<a name="376"></a>        /* check for a non-default command report in the current action */
<a name="377"></a>        if (gTranscript.currentActionHasReport(
<a name="378"></a>            {x: x.ofKind(MainCommandReport)}))
<a name="379"></a>        {
<a name="380"></a>            /* we have a non-default report - defer the topic inventory */
<a name="381"></a>            scheduleTopicInventory();
<a name="382"></a>        }
<a name="383"></a>        else
<a name="384"></a>        {
<a name="385"></a>            /* we have only a default report, so show the inventory now */
<a name="386"></a>            actor.suggestTopicsFor(otherActor, nil);
<a name="387"></a>        }
<a name="388"></a>    }
<a name="389"></a>
<a name="390"></a>    /*
<a name="391"></a>     *   Note that an actor is about to give a response through a
<a name="392"></a>     *   TopicEntry object.  We'll remember the actor so that we'll know
<a name="393"></a>     *   which actor is involved in a &lt;.convnode&gt; operation.  
<a name="394"></a>     */
<a name="395"></a>    beginResponse(actor)
<a name="396"></a>    {
<a name="397"></a>        /* if the actor doesn't have an ID yet, assign one */
<a name="398"></a>        if (actor.convMgrID == nil)
<a name="399"></a>        {
<a name="400"></a>            /* add the actor to our vector of actors */
<a name="401"></a>            idToActor.append(actor);
<a name="402"></a>
<a name="403"></a>            /* the ID is simply the index in this vector */
<a name="404"></a>            actor.convMgrID = idToActor.length();
<a name="405"></a>        }
<a name="406"></a>
<a name="407"></a>        /* output a &lt;.convbegin&gt; for the actor */
<a name="408"></a>        gTranscript.addReport(new ConvBeginReport(actor.convMgrID));
<a name="409"></a>    }
<a name="410"></a>
<a name="411"></a>    /* 
<a name="412"></a>     *   Finish the response - call this after we finish handling the
<a name="413"></a>     *   response.  There must be a subsequent matching call to this
<a name="414"></a>     *   routine whenever beginResponse() is called.
<a name="415"></a>     *   
<a name="416"></a>     *   'node' is the default new ConvNode the actor for the responding
<a name="417"></a>     *   actor.  If another ConvNode was explicitly set in the course of
<a name="418"></a>     *   handling the response, this is ignored, since the explicit
<a name="419"></a>     *   setting overrides this default.  
<a name="420"></a>     */
<a name="421"></a>    finishResponse(actor, node)
<a name="422"></a>    {
<a name="423"></a>        local prv;
<a name="424"></a>        local oldNode;
<a name="425"></a>        
<a name="426"></a>        /* if the node is a ConvNode object, use its name */
<a name="427"></a>        if (node != nil &amp;&amp; node.ofKind(ConvNode))
<a name="428"></a>            node = node.name;
<a name="429"></a>
<a name="430"></a>        /* 
<a name="431"></a>         *   if the previous report was our ConvBeginReport, the
<a name="432"></a>         *   conversation display was empty, so ignore the whole thing 
<a name="433"></a>         */
<a name="434"></a>        if ((prv = gTranscript.getLastReport()) != nil
<a name="435"></a>            &amp;&amp; prv.ofKind(ConvBeginReport)
<a name="436"></a>            &amp;&amp; prv.actorID == actor.convMgrID)
<a name="437"></a>        {
<a name="438"></a>            /* remove the &lt;.convbegin&gt; report - we're canceling it out */
<a name="439"></a>            gTranscript.deleteLastReport();
<a name="440"></a>
<a name="441"></a>            /* we're done - do not generate the &lt;.convend&gt; */
<a name="442"></a>            return;
<a name="443"></a>        }
<a name="444"></a>
<a name="445"></a>        /* 
<a name="446"></a>         *   if the actor has a current ConvNode, and our default next
<a name="447"></a>         *   node is nil, and the current node is marked as "sticky," stay
<a name="448"></a>         *   in the current node rather than switching to a nil default 
<a name="449"></a>         */
<a name="450"></a>        if (node == nil
<a name="451"></a>            &amp;&amp; (oldNode = actor.curConvNode) != nil
<a name="452"></a>            &amp;&amp; oldNode.isSticky)
<a name="453"></a>        {
<a name="454"></a>            /* it's sticky, so stay at this node */
<a name="455"></a>            node = oldNode.name;
<a name="456"></a>        }
<a name="457"></a>
<a name="458"></a>        /* output a &lt;.convend&gt; for the actor */
<a name="459"></a>        gTranscript.addReport(new ConvEndReport(actor.convMgrID, node));
<a name="460"></a>    }
<a name="461"></a>
<a name="462"></a>    /* 
<a name="463"></a>     *   The current responding actor.  Actors should set this when they're
<a name="464"></a>     *   about to show a response to an ASK, TELL, etc. 
<a name="465"></a>     */
<a name="466"></a>    respondingActor = nil
<a name="467"></a>
<a name="468"></a>    /*
<a name="469"></a>     *   Mark a tag as revealed.  This adds an entry for the tag to the
<a name="470"></a>     *   revealedNameTab table.  We simply set the table entry to 'true';
<a name="471"></a>     *   the presence of the tag in the table constitutes the indication
<a name="472"></a>     *   that the tag has been revealed.
<a name="473"></a>     *   
<a name="474"></a>     *   (Games and library extensions can use 'modify' to override this
<a name="475"></a>     *   and store more information in the table entry.  For example, you
<a name="476"></a>     *   could store the time when the information was first revealed, or
<a name="477"></a>     *   the location where it was learned.  If you do override this, just
<a name="478"></a>     *   be sure to set the revealedNameTab entry for the tag to a non-nil
<a name="479"></a>     *   and non-zero value, so that any code testing the presence of the
<a name="480"></a>     *   table entry will see that the slot is indeed set.)  
<a name="481"></a>     */
<a name="482"></a>    setRevealed(tag)
<a name="483"></a>    {
<a name="484"></a>        revealedNameTab[tag] = true;
<a name="485"></a>    }
<a name="486"></a>
<a name="487"></a>    /* 
<a name="488"></a>     *   The global lookup table of all revealed keys.  This table is keyed
<a name="489"></a>     *   by the string naming the revelation; the value associated with
<a name="490"></a>     *   each key is not used (we always just set it to true).  
<a name="491"></a>     */
<a name="492"></a>    revealedNameTab = static new LookupTable(32, 32)
<a name="493"></a>
<a name="494"></a>    /* a vector of actors, indexed by their convMgrID values */
<a name="495"></a>    idToActor = static new Vector(32)
<a name="496"></a>
<a name="497"></a>    /* preinitialize */
<a name="498"></a>    execute()
<a name="499"></a>    {
<a name="500"></a>        /* add every ConvNode object to our master table */
<a name="501"></a>        forEachInstance(ConvNode,
<a name="502"></a>                        { obj: obj.getActor().convNodeTab[obj.name] = obj });
<a name="503"></a>
<a name="504"></a>        /* 
<a name="505"></a>         *   set up the prompt daemon that makes automatic topic inventory
<a name="506"></a>         *   suggestions when appropriate 
<a name="507"></a>         */
<a name="508"></a>        new PromptDaemon(self, &amp;topicInventoryDaemon);
<a name="509"></a>    }
<a name="510"></a>
<a name="511"></a>    /*
<a name="512"></a>     *   Prompt daemon: show topic inventory when appropriate.  When a
<a name="513"></a>     *   response explicitly asks us to show a topic inventory using the
<a name="514"></a>     *   &lt;.topics&gt; tag, or when other game code asks us to show topic
<a name="515"></a>     *   inventory by calling scheduleTopicInventory(), we'll show the
<a name="516"></a>     *   inventory just before the command input prompt.  
<a name="517"></a>     */
<a name="518"></a>    topicInventoryDaemon()
<a name="519"></a>    {
<a name="520"></a>        /* if we have a topic inventory scheduled, show it now */
<a name="521"></a>        if (pendingTopicInventory)
<a name="522"></a>        {
<a name="523"></a>            /* 
<a name="524"></a>             *   Show the player character's topic inventory.  This is not
<a name="525"></a>             *   an explicit inventory request, since the player didn't ask
<a name="526"></a>             *   for it.  
<a name="527"></a>             */
<a name="528"></a>            gPlayerChar.suggestTopics(nil);
<a name="529"></a>
<a name="530"></a>            /* we no longer have a pending inventory request */
<a name="531"></a>            pendingTopicInventory = nil;
<a name="532"></a>        }
<a name="533"></a>    }
<a name="534"></a>
<a name="535"></a>    /* flag: we have a pending prompt-time topic inventory request */
<a name="536"></a>    pendingTopicInventory = nil
<a name="537"></a>;
<a name="538"></a>
<a name="539"></a>/* ------------------------------------------------------------------------ */
<a name="540"></a>/*
<a name="541"></a> *   A plug-in topic database.  The topic database is a set of TopicEntry
<a name="542"></a> *   objects that specify the responses to queries on particular topics.
<a name="543"></a> *   The exact nature of the queries that a particular topic database
<a name="544"></a> *   handles is up to the database subclass to define; we just provide the
<a name="545"></a> *   abstract mechanism for finding and displaying responses.
<a name="546"></a> *   
<a name="547"></a> *   This is a "plug-in" database in that it's meant to be added into other
<a name="548"></a> *   classes using multiple inheritance.  This isn't meant to be used as a
<a name="549"></a> *   stand-alone abstract topic entry container.  
<a name="550"></a> */
<a name="551"></a>class TopicDatabase: object
<a name="552"></a>    /* 
<a name="553"></a>     *   Is the topic group active?  A TopicEntry always checks with its
<a name="554"></a>     *   container to see if the children of the container are active.  By
<a name="555"></a>     *   default, everything in the database is active.  
<a name="556"></a>     */
<a name="557"></a>    topicGroupActive = true
<a name="558"></a>
<a name="559"></a>    /*
<a name="560"></a>     *   Get the score adjustment for all topic entries contained within.
<a name="561"></a>     *   The default adjustment is zero; TopicGroup objects can use this to
<a name="562"></a>     *   adjust the score for their nested entries.  
<a name="563"></a>     */
<a name="564"></a>    topicGroupScoreAdjustment = 0
<a name="565"></a>
<a name="566"></a>    /*
<a name="567"></a>     *   Handle a topic.  Look up the topic in our topic list for the
<a name="568"></a>     *   given conversational action type.  If we find a match, we'll
<a name="569"></a>     *   invoke the matching topic list entry to handle it.  We'll return
<a name="570"></a>     *   true if we find a match, nil if not.  
<a name="571"></a>     */
<a name="572"></a>    handleTopic(fromActor, topic, convType, path)
<a name="573"></a>    {
<a name="574"></a>        local resp;
<a name="575"></a>
<a name="576"></a>        /* find the best response */
<a name="577"></a>        resp = findTopicResponse(fromActor, topic, convType, path);
<a name="578"></a>        
<a name="579"></a>        /* if we found a match, let it handle the topic */
<a name="580"></a>        if (resp != nil)
<a name="581"></a>        {
<a name="582"></a>            /* show the response */
<a name="583"></a>            showTopicResponse(fromActor, topic, resp);
<a name="584"></a>            
<a name="585"></a>            /* tell the caller we handled it */
<a name="586"></a>            return true;
<a name="587"></a>        }
<a name="588"></a>        else
<a name="589"></a>        {
<a name="590"></a>            /* tell the caller we didn't handle it */
<a name="591"></a>            return nil;
<a name="592"></a>        }
<a name="593"></a>    }
<a name="594"></a>
<a name="595"></a>    /* show the response we found for a topic */
<a name="596"></a>    showTopicResponse(fromActor, topic, resp)
<a name="597"></a>    {
<a name="598"></a>        /* let the response object handle it */
<a name="599"></a>        resp.handleTopic(fromActor, topic);
<a name="600"></a>    }
<a name="601"></a>
<a name="602"></a>    /* find the best response (a TopicEntry object) for the given topic */
<a name="603"></a>    findTopicResponse(fromActor, topic, convType, path)
<a name="604"></a>    {
<a name="605"></a>        local topicList;
<a name="606"></a>        local best, bestScore;
<a name="607"></a>
<a name="608"></a>        /* 
<a name="609"></a>         *   Get the list of possible topics for this conversation type.
<a name="610"></a>         *   The topic list is contained in one of our properties; exactly
<a name="611"></a>         *   which property is determined by the conversation type. 
<a name="612"></a>         */
<a name="613"></a>        topicList = self.(convType.topicListProp);
<a name="614"></a>        
<a name="615"></a>        /* if the topic list is nil, we obviously won't find the topic */
<a name="616"></a>        if (topicList == nil)
<a name="617"></a>            return nil;
<a name="618"></a>
<a name="619"></a>        /* scan our topic list for the best match */
<a name="620"></a>        best = nil;
<a name="621"></a>        foreach (local cur in topicList)
<a name="622"></a>        {
<a name="623"></a>            /* get this item's score */
<a name="624"></a>            local score = cur.adjustScore(cur.matchTopic(fromActor, topic));
<a name="625"></a>
<a name="626"></a>            /* 
<a name="627"></a>             *   If this item has a score at all, and the topic entry is
<a name="628"></a>             *   marked as active, and it's best (or only) score so far,
<a name="629"></a>             *   note it.  Ignore topics marked as not active, since
<a name="630"></a>             *   they're in the topic database only provisionally.  
<a name="631"></a>             */
<a name="632"></a>            if (score != nil
<a name="633"></a>                &amp;&amp; cur.checkIsActive()
<a name="634"></a>                &amp;&amp; (best == nil || score &gt; bestScore))
<a name="635"></a>            {
<a name="636"></a>                best = cur;
<a name="637"></a>                bestScore = score;
<a name="638"></a>            }
<a name="639"></a>        }
<a name="640"></a>
<a name="641"></a>        /*
<a name="642"></a>         *   If there's a hierarchical search path, AND this topic entry
<a name="643"></a>         *   defines a deferToEntry() method, look for matches in the
<a name="644"></a>         *   inferior databases on the path and check to see if we want to
<a name="645"></a>         *   defer to one of them.  
<a name="646"></a>         */
<a name="647"></a>        if (best != nil &amp;&amp; path != nil &amp;&amp; best.propDefined(&amp;deferToEntry))
<a name="648"></a>        {
<a name="649"></a>            /* look for a match in each inferior database */
<a name="650"></a>            for (local i = 1, local len = path.length() ; i &lt;= len ; ++i)
<a name="651"></a>            {
<a name="652"></a>                local inf;
<a name="653"></a>                
<a name="654"></a>                /* 
<a name="655"></a>                 *   Look up an entry in this inferior database.  Pass in
<a name="656"></a>                 *   the remainder of the path, so that the inferior
<a name="657"></a>                 *   database can consider further deferral to its own
<a name="658"></a>                 *   inferior databases.  
<a name="659"></a>                 */
<a name="660"></a>                inf = path[i].findTopicResponse(fromActor, topic, convType,
<a name="661"></a>                                                path.sublist(i + 1));
<a name="662"></a>
<a name="663"></a>                /* 
<a name="664"></a>                 *   if we found an entry in this inferior database, and
<a name="665"></a>                 *   our entry defers to the inferior entry, then ignore
<a name="666"></a>                 *   the match in our own database 
<a name="667"></a>                 */
<a name="668"></a>                if (inf != nil &amp;&amp; best.deferToEntry(inf))
<a name="669"></a>                    return nil;
<a name="670"></a>            }
<a name="671"></a>        }
<a name="672"></a>
<a name="673"></a>        /* return the best matching response object, if any */
<a name="674"></a>        return best;
<a name="675"></a>    }
<a name="676"></a>
<a name="677"></a>    /* show our suggested topic list */
<a name="678"></a>    showSuggestedTopicList(lst, asker, askee, explicit)
<a name="679"></a>    {
<a name="680"></a>        /* get the asking actor's scope list for use later */
<a name="681"></a>        scopeList = asker.scopeList();
<a name="682"></a>        
<a name="683"></a>        /* remove items that have redundant list groups and full names */
<a name="684"></a>        for (local i = 1, local len = lst.length() ; i &lt;= len ; ++i)
<a name="685"></a>        {
<a name="686"></a>            local a = lst[i];
<a name="687"></a>            
<a name="688"></a>            /* check for redundant elements */
<a name="689"></a>            for (local j = i + 1 ; j &lt;= len ; ++j)
<a name="690"></a>            {
<a name="691"></a>                local b = lst[j];
<a name="692"></a>                
<a name="693"></a>                /* 
<a name="694"></a>                 *   If item 'a' matches item 'b', and both are active,
<a name="695"></a>                 *   remove item 'b'.  We only need to remove redundant
<a name="696"></a>                 items if they're both active, since inactive items
<a name="697"></a>                 */
<a name="698"></a>                if (a.suggestionGroup == b.suggestionGroup
<a name="699"></a>                    &amp;&amp; a.fullName == b.fullName
<a name="700"></a>                    &amp;&amp; a.isSuggestionActive(asker, scopeList)
<a name="701"></a>                    &amp;&amp; b.isSuggestionActive(asker, scopeList))
<a name="702"></a>                {
<a name="703"></a>                    /* delete item 'b' from the list */
<a name="704"></a>                    lst.removeElementAt(j);
<a name="705"></a>
<a name="706"></a>                    /* adjust our indices for the deletion */
<a name="707"></a>                    --j;
<a name="708"></a>                    --len;
<a name="709"></a>                }
<a name="710"></a>            }
<a name="711"></a>        }
<a name="712"></a>
<a name="713"></a>        /* show our list */
<a name="714"></a>        new SuggestedTopicLister(asker, askee, explicit)
<a name="715"></a>            .showList(asker, nil, lst, 0, 0, nil, nil);
<a name="716"></a>    }
<a name="717"></a>
<a name="718"></a>    /*
<a name="719"></a>     *   Flag: this database level should limit topic suggestions (for the
<a name="720"></a>     *   TOPICS and TALK TO commands) to its own topics, excluding any
<a name="721"></a>     *   topics inherited from the "broader" context.  If this property is
<a name="722"></a>     *   set to true, then we won't include suggestions from any lower
<a name="723"></a>     *   level of the database hierarchy.  If this property is nil, we'll
<a name="724"></a>     *   also include any topic suggestions from the broader context.
<a name="725"></a>     *   
<a name="726"></a>     *   Topic databases are arranged into a fixed hierarchy for an actor.
<a name="727"></a>     *   At the top level is the current ConvNode object; at the next level
<a name="728"></a>     *   is the ActorState; and at the bottom level is the Actor itself.
<a name="729"></a>     *   So, if the ConvNode's limitSuggestions property is set to true,
<a name="730"></a>     *   then the suggestions for the actor will include ONLY the ConvNode.
<a name="731"></a>     *   If the ConvNode has the property set to nil, but the ActorState
<a name="732"></a>     *   has it set to true, then we'll include the ConvNode and the
<a name="733"></a>     *   ActorState suggestions.
<a name="734"></a>     *   
<a name="735"></a>     *   By default, we set this to nil.  This should usually be set to
<a name="736"></a>     *   true for any ConvNode or ActorState where the NPC won't allow the
<a name="737"></a>     *   player to stray from the subject.  For example, if a ConvNode only
<a name="738"></a>     *   accepts a YES or NO response to a question, then this property
<a name="739"></a>     *   should probably be set to true in the ConvNode, since other
<a name="740"></a>     *   suggested topics won't be accepted as conversation topics as long
<a name="741"></a>     *   as the ConvNode is active.  
<a name="742"></a>     */
<a name="743"></a>    limitSuggestions = nil
<a name="744"></a>
<a name="745"></a>    /*
<a name="746"></a>     *   Add a topic to our topic database.  We'll add it to the
<a name="747"></a>     *   appropriate list or lists as indicated in the topic itself.
<a name="748"></a>     *   'topic' is a TopicEntry object.  
<a name="749"></a>     */
<a name="750"></a>    addTopic(topic)
<a name="751"></a>    {
<a name="752"></a>        /* add the topic to each list indicated in the topic */
<a name="753"></a>        foreach (local cur in topic.includeInList)
<a name="754"></a>            addTopicToList(topic, cur);
<a name="755"></a>    }
<a name="756"></a>
<a name="757"></a>    /* remove a topic from our topic database */
<a name="758"></a>    removeTopic(topic)
<a name="759"></a>    {
<a name="760"></a>        /* remove the topic from each of its lists */
<a name="761"></a>        foreach (local cur in topic.includeInList)
<a name="762"></a>            removeTopicFromList(topic, cur);
<a name="763"></a>    }
<a name="764"></a>
<a name="765"></a>    /* add a suggested topic */
<a name="766"></a>    addSuggestedTopic(topic)
<a name="767"></a>    {
<a name="768"></a>        /* add the topic to our suggestion list */
<a name="769"></a>        addTopicToList(topic, &amp;suggestedTopics);
<a name="770"></a>    }
<a name="771"></a>
<a name="772"></a>    /* remove a suggested topic */
<a name="773"></a>    removeSuggestedTopic(topic)
<a name="774"></a>    {
<a name="775"></a>        /* add the topic to our suggestion list */
<a name="776"></a>        removeTopicFromList(topic, &amp;suggestedTopics);
<a name="777"></a>    }
<a name="778"></a>
<a name="779"></a>    /*
<a name="780"></a>     *   Add a topic to the given topic list.  The topic list is given as a
<a name="781"></a>     *   property point; for example, we'd specify &amp;askTopics to add the
<a name="782"></a>     *   topic to our ASK list. 
<a name="783"></a>     */
<a name="784"></a>    addTopicToList(topic, listProp)
<a name="785"></a>    {
<a name="786"></a>        /* if we haven't created this topic list vector yet, create it now */
<a name="787"></a>        if (self.(listProp) == nil)
<a name="788"></a>            self.(listProp) = new Vector(8);
<a name="789"></a>
<a name="790"></a>        /* add the topic */
<a name="791"></a>        self.(listProp).append(topic);
<a name="792"></a>    }
<a name="793"></a>
<a name="794"></a>    /* remove a topic from the given topic list */
<a name="795"></a>    removeTopicFromList(topic, listProp)
<a name="796"></a>    {
<a name="797"></a>        /* if the list exists, remove the topic from it */
<a name="798"></a>        if (self.(listProp) != nil)
<a name="799"></a>            self.(listProp).removeElement(topic);
<a name="800"></a>    }
<a name="801"></a>
<a name="802"></a>    /*
<a name="803"></a>     *   Our list of suggested topics.  These are SuggestedTopic objects
<a name="804"></a>     *   that describe things that another actor wants to ask or tell this
<a name="805"></a>     *   actor about.  
<a name="806"></a>     */
<a name="807"></a>    suggestedTopics = nil
<a name="808"></a>
<a name="809"></a>    /*
<a name="810"></a>     *   Get the "owner" of the topics in this database.  The meaning of
<a name="811"></a>     *   "owner" varies according to the topic database type; for actor
<a name="812"></a>     *   topic databases, for example, this is the actor.  Generally, the
<a name="813"></a>     *   owner is the object being queried about the topic, from the
<a name="814"></a>     *   player's perspective.  Each type of database should define this
<a name="815"></a>     *   method to return the appropriate object.  
<a name="816"></a>     */
<a name="817"></a>    getTopicOwner() { return nil; }
<a name="818"></a>;
<a name="819"></a>
<a name="820"></a>/*
<a name="821"></a> *   A TopicDatabase for an Actor.  This is used not only directly for an
<a name="822"></a> *   Actor but also for an actor's sub-databases, in ActorState and
<a name="823"></a> *   ConvNode.
<a name="824"></a> *   
<a name="825"></a> *   Actor topic databases field queries for the various types of
<a name="826"></a> *   topic-based interactions an actor can participate in: ASK, TELL, SHOW,
<a name="827"></a> *   GIVE, and so on.
<a name="828"></a> *   
<a name="829"></a> *   Each actor has its own topic database, which means each actor can have
<a name="830"></a> *   its own set of responses.  Actor states can also have their own
<a name="831"></a> *   separate topic databases; this makes it easy to make an actor's
<a name="832"></a> *   response to a particular question vary according to the actor's state.
<a name="833"></a> *   Conversation nodes can also have their own separate databases, which
<a name="834"></a> *   allows for things like threaded conversations.
<a name="835"></a> */
<a name="836"></a>class ActorTopicDatabase: TopicDatabase
<a name="837"></a>    /*
<a name="838"></a>     *   Initiate conversation on the given simulation object.  If we can
<a name="839"></a>     *   find an InitiateTopic matching the given object, we'll show its
<a name="840"></a>     *   topic response and return true; if we can't find a topic to
<a name="841"></a>     *   initiate, we'll simply return nil.  
<a name="842"></a>     */
<a name="843"></a>    initiateTopic(obj)
<a name="844"></a>    {
<a name="845"></a>        /* find an initiate topic for the given object */
<a name="846"></a>        if (handleTopic(gPlayerChar, obj, initiateConvType, nil))
<a name="847"></a>        {
<a name="848"></a>            /* 
<a name="849"></a>             *   we handled the topic, so note that we're in conversation
<a name="850"></a>             *   with the player character now 
<a name="851"></a>             */
<a name="852"></a>            getTopicOwner().noteConversation(gPlayerChar);
<a name="853"></a>
<a name="854"></a>            /* indicate that we found a topic to initiate */
<a name="855"></a>            return true;
<a name="856"></a>        }
<a name="857"></a>
<a name="858"></a>        /* we didn't find a topic to initiate */
<a name="859"></a>        return nil;
<a name="860"></a>    }
<a name="861"></a>
<a name="862"></a>    /* show a topic response */
<a name="863"></a>    showTopicResponse(fromActor, topic, resp)
<a name="864"></a>    {
<a name="865"></a>        local actor = getTopicOwner();
<a name="866"></a>        local newNode;
<a name="867"></a>
<a name="868"></a>        /* 
<a name="869"></a>         *   note whether the response is conversational - we need to do
<a name="870"></a>         *   this ahead of time, since invoking the response can sometimes
<a name="871"></a>         *   have the side effect of changing the response's status
<a name="872"></a>         */
<a name="873"></a>        local isConv = resp.isConversational;
<a name="874"></a>        
<a name="875"></a>        /* tell the conversation manager we're starting a response */
<a name="876"></a>        conversationManager.beginResponse(actor);
<a name="877"></a>            
<a name="878"></a>        /* let the response object handle it */
<a name="879"></a>        resp.handleTopic(fromActor, topic);
<a name="880"></a>
<a name="881"></a>        /* 
<a name="882"></a>         *   By default, after showing a response, we want to leave the
<a name="883"></a>         *   conversation node tree entirely if we didn't explicitly set
<a name="884"></a>         *   the next node in the course of the response.  So, set the
<a name="885"></a>         *   default new node to 'nil'.  However, if the topic is
<a name="886"></a>         *   non-conversational, it shouldn't affect the conversation
<a name="887"></a>         *   thread at all, so leave the current node unchanged.  
<a name="888"></a>         */
<a name="889"></a>        if (isConv)
<a name="890"></a>            newNode = nil;
<a name="891"></a>        else
<a name="892"></a>            newNode = actor.curConvNode;
<a name="893"></a>
<a name="894"></a>        /* tell the conversation manager we're done with the response */
<a name="895"></a>        conversationManager.finishResponse(actor, newNode);
<a name="896"></a>    }
<a name="897"></a>
<a name="898"></a>    /* 
<a name="899"></a>     *   Our 'ask about', 'ask for', 'tell about', 'give', 'show',
<a name="900"></a>     *   miscellaneous, command, and self-initiated topic databases - these
<a name="901"></a>     *   are vectors we initialize as needed.  Since every actor and every
<a name="902"></a>     *   actor state has its own separate topic database, it's likely that
<a name="903"></a>     *   the bulk of these databases will be empty, so we don't bother even
<a name="904"></a>     *   creating a vector for a topic list until the first topic is added.
<a name="905"></a>     *   This means we have to be able to cope with these being nil
<a name="906"></a>     *   anywhere we use them.  
<a name="907"></a>     */
<a name="908"></a>    askTopics = nil
<a name="909"></a>    askForTopics = nil
<a name="910"></a>    tellTopics = nil
<a name="911"></a>    showTopics = nil
<a name="912"></a>    giveTopics = nil
<a name="913"></a>    miscTopics = nil
<a name="914"></a>    commandTopics = nil
<a name="915"></a>    initiateTopics = nil
<a name="916"></a>
<a name="917"></a>    /* our special command database */
<a name="918"></a>    specialTopics = nil
<a name="919"></a>;
<a name="920"></a>
<a name="921"></a>/* ------------------------------------------------------------------------ */
<a name="922"></a>/*
<a name="923"></a> *   A "suggested" topic.  These provide suggestions for things the player
<a name="924"></a> *   might want to ASK or TELL another actor about.  At certain times
<a name="925"></a> *   (specifically, when starting a conversation with HELLO or TALK TO, or
<a name="926"></a> *   when the player enters a TOPICS command to explicitly ask for a list
<a name="927"></a> *   of topic suggestions), we'll look for these objects in the actor or
<a name="928"></a> *   actor state for the actor to whom we're talking.  We'll show a list
<a name="929"></a> *   of each currently active suggestion we find.  This gives the player
<a name="930"></a> *   some guidance of what to talk about.  For example:
<a name="931"></a> *   
<a name="932"></a> *   &gt;talk to bob
<a name="933"></a> *.  "Excuse me," you say.
<a name="934"></a> *   
<a name="935"></a> *   Bob looks up from his newspaper.  "Yes?  Oh, you again."
<a name="936"></a> *   
<a name="937"></a> *   (You'd like to ask him about the black book, the candle, and the
<a name="938"></a> *   bell, and tell him about the crypt.)
<a name="939"></a> *   
<a name="940"></a> *   Topic suggestions are entirely optional.  Some authors don't like the
<a name="941"></a> *   idea, since they think it's too much like a menu system, and just
<a name="942"></a> *   gives away the solution to the game.  If you don't want to have
<a name="943"></a> *   anything to do with topic suggestions, we won't force you - simply
<a name="944"></a> *   don't define any SuggestedTopic objects, and the library will never
<a name="945"></a> *   offer suggestions and will even disable the TOPICS command.
<a name="946"></a> *   
<a name="947"></a> *   If you do want to use topic suggestions, the easiest way to use this
<a name="948"></a> *   class is to combine it using multiple inheritance with a TopicEntry
<a name="949"></a> *   object.  You just have to add SuggestedTopic to the superclass list
<a name="950"></a> *   for your topic entry object, and give the suggested topic a name
<a name="951"></a> *   string (using a property and format defined by the language-specific
<a name="952"></a> *   library) to display in suggestions lists.  Doing this, the suggestion
<a name="953"></a> *   will automatically be enabled whenever the topic entry is available,
<a name="954"></a> *   and will automatically be removed from the suggestions when the topic
<a name="955"></a> *   is invoked in conversation (in other words, we'll only suggest asking
<a name="956"></a> *   about the topic until it's been asked about once).
<a name="957"></a> *   
<a name="958"></a> *   Topic suggestions can be associated with an actor or an actor state;
<a name="959"></a> *   these are topics that a given character would like to talk to the
<a name="960"></a> *   associated actor about.  The association is a bit tricky: suggested
<a name="961"></a> *   topic objects are stored with the actor being *talked to*.  For
<a name="962"></a> *   example, if we want to suggest topics that the player character might
<a name="963"></a> *   want to ASK BILL ABOUT, we store these suggestions with *Bill*.  We
<a name="964"></a> *   do NOT store the suggestions with the player character.  This might
<a name="965"></a> *   seem backwards at first glance, since fundamentally the suggestions
<a name="966"></a> *   belong in the player character's "brain" - they are, after all,
<a name="967"></a> *   things the player character wants to talk about.  In practice,
<a name="968"></a> *   though, there are two things that make it easier to keep the
<a name="969"></a> *   information with the character being asked.  First, in most games,
<a name="970"></a> *   there's just one player character, so one of the two actors in each
<a name="971"></a> *   association will always be the player character; by storing the
<a name="972"></a> *   objects with the NPC, we can just let the PC be assumed as the other
<a name="973"></a> *   actor as a default, saving us some typing that would be necessary if
<a name="974"></a> *   we had to specify each object in the other direction.  Second, we
<a name="975"></a> *   keep the *response* objects associated with the character being asked
<a name="976"></a> *   - that association is intuitive, at least.  The thing is, we can
<a name="977"></a> *   usually combine the suggestion and response into a single object,
<a name="978"></a> *   saving another bunch of typing; if we didn't keep the suggestion with
<a name="979"></a> *   the character being asked, we couldn't combine the suggestions and
<a name="980"></a> *   responses this way, since they'd have to be associated with different
<a name="981"></a> *   actors.  
<a name="982"></a> */
<a name="983"></a>class SuggestedTopic: object
<a name="984"></a>    /*
<a name="985"></a>     *   The name of the suggestion.  The rules for setting this vary by
<a name="986"></a>     *   language; in the English version, we'll display the fullName when
<a name="987"></a>     *   we show a stand-alone item, and the groupName when we appear in a
<a name="988"></a>     *   list group (such as a group of ASK ABOUT or TELL ABOUT
<a name="989"></a>     *   suggestions).
<a name="990"></a>     *   
<a name="991"></a>     *   In English, the fullName should be suitable for use after
<a name="992"></a>     *   'could': "You could &lt;fullName&gt;, &lt;fullName&gt;, or &lt;fullName&gt;".
<a name="993"></a>     *   
<a name="994"></a>     *   In English, the phrasing where the 'name' property is used
<a name="995"></a>     *   depends on the specific subclass, but it should usually be a
<a name="996"></a>     *   qualified noun phrase (that is, it should include a qualifier
<a name="997"></a>     *   such as "a" or "the" or a possessive).  For ASK and TELL, for
<a name="998"></a>     *   example, the 'name' should be suitable for use after ABOUT: "You
<a name="999"></a>     *   could ask him about &lt;the lighthouse&gt;, &lt;Bob's black book&gt;, or &lt;the
<a name="1000"></a>     *   weather&gt;."
<a name="1001"></a>     *   
<a name="1002"></a>     *   By default, we'll walk up our 'location' tree looking for another
<a name="1003"></a>     *   suggested topic; if we find one, we'll use its corresponding name
<a name="1004"></a>     *   values.  
<a name="1005"></a>     */
<a name="1006"></a>    fullName = (fromEnclosingSuggestedTopic(&amp;fullName, ''))
<a name="1007"></a>    name = (fromEnclosingSuggestedTopic(&amp;name, ''))
<a name="1008"></a>
<a name="1009"></a>    /*
<a name="1010"></a>     *   Our associated topic.  In most cases, this will be initialized
<a name="1011"></a>     *   automatically: if this suggested topic object is also a
<a name="1012"></a>     *   TopicEntry object (using multiple inheritance), we'll set this
<a name="1013"></a>     *   during start-up to 'self', or if our location is a TopicEntry,
<a name="1014"></a>     *   we'll set this to our location.  This only needs to be
<a name="1015"></a>     *   initialized manually if neither of those conditions is true.  
<a name="1016"></a>     */
<a name="1017"></a>    associatedTopic = nil
<a name="1018"></a>
<a name="1019"></a>    /*
<a name="1020"></a>     *   Set the location to the actor to ask or tell about this topic.
<a name="1021"></a>     *   This is the target of the ASK ABOUT or TELL ABOUT command, NOT
<a name="1022"></a>     *   the actor who's doing the asking.  This can also be set to a
<a name="1023"></a>     *   TopicEntry object, in which case we'll be associated with the
<a name="1024"></a>     *   actor with which the topic entry is associated, and we'll also
<a name="1025"></a>     *   automatically tie the topic entry to this suggestion.
<a name="1026"></a>     *   
<a name="1027"></a>     *   Because we're using the location property, you can use the '+'
<a name="1028"></a>     *   notation to add a suggested topic to the target actor, state
<a name="1029"></a>     *   objects, or topic entry.  
<a name="1030"></a>     */
<a name="1031"></a>    location = nil
<a name="1032"></a>
<a name="1033"></a>    /*
<a name="1034"></a>     *   The actor who *wants* to ask or tell about this topic.  Our
<a name="1035"></a>     *   location property gives the actor to be asked or told, because
<a name="1036"></a>     *   we're associated with the target actor - the same actor who has
<a name="1037"></a>     *   the TopicEntry information for the topic.  This property, in
<a name="1038"></a>     *   contrast, gives the actor who's doing the asking.
<a name="1039"></a>     *   
<a name="1040"></a>     *   By default, we return the player character; in most cases, you
<a name="1041"></a>     *   won't have to override this.  In most games, only the player
<a name="1042"></a>     *   character uses the suggested topic mechanism, because there's no
<a name="1043"></a>     *   reason to suggest topics for NPC's - they're just automata, after
<a name="1044"></a>     *   all, so if we want them to ask something, we can just program
<a name="1045"></a>     *   them to ask it directly.  Also, most games have only one player
<a name="1046"></a>     *   character.  Games that meet these criteria won't ever have to
<a name="1047"></a>     *   override this.  If you do have multiple player characters, you'll
<a name="1048"></a>     *   probably want to override this for each suggested topic to
<a name="1049"></a>     *   indicate which character wants to ask about the topic, as the
<a name="1050"></a>     *   different player characters might have different things they'd
<a name="1051"></a>     *   want to talk about.  
<a name="1052"></a>     */
<a name="1053"></a>    suggestTo = (gPlayerChar)
<a name="1054"></a>
<a name="1055"></a>    /* the ListGroup with which we're to list this suggestion */
<a name="1056"></a>    suggestionGroup = []
<a name="1057"></a>
<a name="1058"></a>    /* find the nearest enclosing SuggestedTopic parent */
<a name="1059"></a>    findEnclosingSuggestedTopic()
<a name="1060"></a>    {
<a name="1061"></a>        /* walk up our location list */
<a name="1062"></a>        for (local loc = location ; loc != nil ; loc = loc.location)
<a name="1063"></a>        {
<a name="1064"></a>            /* if this is a suggested topic, it's what we're looking for */
<a name="1065"></a>            if (loc.ofKind(SuggestedTopic))
<a name="1066"></a>                return loc;
<a name="1067"></a>        }
<a name="1068"></a>
<a name="1069"></a>        /* didn't find anything */
<a name="1070"></a>        return nil;
<a name="1071"></a>    }
<a name="1072"></a>
<a name="1073"></a>    /* find the outermost enclosing SuggestedTopic parent */
<a name="1074"></a>    findOuterSuggestedTopic()
<a name="1075"></a>    {
<a name="1076"></a>        local outer;
<a name="1077"></a>        
<a name="1078"></a>        /* walk up our location list */
<a name="1079"></a>        for (local loc = self, outer = nil ; loc != nil ; loc = loc.location)
<a name="1080"></a>        {
<a name="1081"></a>            /* if this is a suggested topic, it's the outermost so far */
<a name="1082"></a>            if (loc.ofKind(SuggestedTopic))
<a name="1083"></a>                outer = loc;
<a name="1084"></a>        }
<a name="1085"></a>
<a name="1086"></a>        /* return the outermost suggested topic we found */
<a name="1087"></a>        return outer;
<a name="1088"></a>    }
<a name="1089"></a>
<a name="1090"></a>    /* 
<a name="1091"></a>     *   get a property from the nearest enclosing SuggestedTopic, or
<a name="1092"></a>     *   return the given default value if there is no enclosing
<a name="1093"></a>     *   SuggestedTopic 
<a name="1094"></a>     */
<a name="1095"></a>    fromEnclosingSuggestedTopic(prop, defaultVal)
<a name="1096"></a>    {
<a name="1097"></a>        /* look for the nearest enclosing suggested topic */
<a name="1098"></a>        local enc = findEnclosingSuggestedTopic();
<a name="1099"></a>
<a name="1100"></a>        /* 
<a name="1101"></a>         *   return the desired property from the enclosing suggested
<a name="1102"></a>         *   topic object if we found one, or the default if there is no
<a name="1103"></a>         *   enclosing object 
<a name="1104"></a>         */
<a name="1105"></a>        return (enc != nil ? enc.(prop) : defaultVal);
<a name="1106"></a>    }
<a name="1107"></a>
<a name="1108"></a>    /*
<a name="1109"></a>     *   Should we suggest this topic to the given actor?  We'll return
<a name="1110"></a>     *   true if the actor is the same actor for which this suggestion is
<a name="1111"></a>     *   intended, and the associated topic entry is currently active, and
<a name="1112"></a>     *   we haven't already satisfied our curiosity about the topic.  
<a name="1113"></a>     */
<a name="1114"></a>    isSuggestionActive(actor, scopeList)
<a name="1115"></a>    {
<a name="1116"></a>        /* 
<a name="1117"></a>         *   Check to see if this is our target actor; that the associated
<a name="1118"></a>         *   topic itself is active; that our curiosity hasn't already been
<a name="1119"></a>         *   satisfied; and that it's at least possible to match the
<a name="1120"></a>         *   associated topic right now.  If all of these conditions are
<a name="1121"></a>         *   met, we can make this suggestion.  
<a name="1122"></a>         */
<a name="1123"></a>        return (actor == suggestTo
<a name="1124"></a>                &amp;&amp; associatedTopicIsActive()
<a name="1125"></a>                &amp;&amp; associatedTopicCanMatch(actor, scopeList)
<a name="1126"></a>                &amp;&amp; !curiositySatisfied);
<a name="1127"></a>    }
<a name="1128"></a>
<a name="1129"></a>    /* 
<a name="1130"></a>     *   The number of times to suggest asking about our topic.  When
<a name="1131"></a>     *   we've asked about our associated topic this many times, we'll
<a name="1132"></a>     *   have satisfied our curiosity.  In most cases, we'll only want to
<a name="1133"></a>     *   suggest a topic until it's asked about once, since most topics
<a name="1134"></a>     *   only have a single meaningful response, so we'll use 1 as the
<a name="1135"></a>     *   default.  This should be overridden in cases where a topic will
<a name="1136"></a>     *   reveal more information when asked several times.  If this is
<a name="1137"></a>     *   nil, it means that there's no limit to the number of times to
<a name="1138"></a>     *   suggest asking about this.  
<a name="1139"></a>     */
<a name="1140"></a>    timesToSuggest = 1
<a name="1141"></a>
<a name="1142"></a>    /* 
<a name="1143"></a>     *   Have we satisfied our curiosity about this topic?  Returns true
<a name="1144"></a>     *   if so, nil if not.  We'll never suggest a topic when this returns
<a name="1145"></a>     *   true, because this means that the player no longer feels the need
<a name="1146"></a>     *   to ask about the topic.
<a name="1147"></a>     */
<a name="1148"></a>    curiositySatisfied = (timesToSuggest != nil
<a name="1149"></a>                          &amp;&amp; associatedTopicTalkCount() &gt;= timesToSuggest)
<a name="1150"></a>
<a name="1151"></a>    /* initialize - this is called automatically during pre-initialization */
<a name="1152"></a>    initializeSuggestedTopic()
<a name="1153"></a>    {
<a name="1154"></a>        /* if we have a location, link up with our location */
<a name="1155"></a>        if (location != nil)
<a name="1156"></a>            location.addSuggestedTopic(self);
<a name="1157"></a>
<a name="1158"></a>        /* 
<a name="1159"></a>         *   if we're also a TopicEntry (using multiple inheritance), then
<a name="1160"></a>         *   we are our own associated topic object 
<a name="1161"></a>         */
<a name="1162"></a>        if (ofKind(TopicEntry))
<a name="1163"></a>            associatedTopic = self;
<a name="1164"></a>    }
<a name="1165"></a>
<a name="1166"></a>    /*
<a name="1167"></a>     *   Methods that rely on the associated topic.  We isolate these in a
<a name="1168"></a>     *   few methods here so that the rest of class doesn't depend on the
<a name="1169"></a>     *   exact nature of our topic association.  In particular, this allows
<a name="1170"></a>     *   for subclasses that don't have an associated topic at all, or that
<a name="1171"></a>     *   have multiple associated topics.  Subclasses with specialized
<a name="1172"></a>     *   topic relationships can simply override these methods to define
<a name="1173"></a>     *   these methods appropriately.  
<a name="1174"></a>     */
<a name="1175"></a>
<a name="1176"></a>    /* is the associated topic active? */
<a name="1177"></a>    associatedTopicIsActive() { return associatedTopic.checkIsActive(); }
<a name="1178"></a>
<a name="1179"></a>    /* get the number of previous invocations of the associated topic */
<a name="1180"></a>    associatedTopicTalkCount() { return associatedTopic.talkCount; }
<a name="1181"></a>
<a name="1182"></a>    /* is it possible to match the associated topic? */
<a name="1183"></a>    associatedTopicCanMatch(actor, scopeList)
<a name="1184"></a>        { return associatedTopic.isMatchPossible(actor, scopeList); }
<a name="1185"></a>
<a name="1186"></a>    /* 
<a name="1187"></a>     *   Note that we're being shown in a topic inventory listing.  By
<a name="1188"></a>     *   default, we don't do anything here, but subclasses can use this to
<a name="1189"></a>     *   do any extra work they want to do on being listed.  
<a name="1190"></a>     */
<a name="1191"></a>    noteSuggestion() { }
<a name="1192"></a>;
<a name="1193"></a>
<a name="1194"></a>/*
<a name="1195"></a> *   A suggested topic that applies to an entire AltTopic group.
<a name="1196"></a> *   
<a name="1197"></a> *   Normally, a suggestion is tied to an individual TopicEntry.  This
<a name="1198"></a> *   means that when a topic has several AltTopic alternatives, each
<a name="1199"></a> *   AltTopic can be its own separate, independent suggestion.  A
<a name="1200"></a> *   particular alternative can be a suggestion or not, independently of
<a name="1201"></a> *   the other alternatives for the same TopicEntry.  Since each AltTopic
<a name="1202"></a> *   is a separate suggestion, asking about one of the alternatives won't
<a name="1203"></a> *   have any effect on the "curiosity" about the other alternatives - in
<a name="1204"></a> *   other words, the other alternatives will be separately suggested when
<a name="1205"></a> *   they become active.
<a name="1206"></a> *   
<a name="1207"></a> *   In many cases, it's better for an entire set of alternatives to be
<a name="1208"></a> *   treated as a single suggested topic.  That is, we want to suggest the
<a name="1209"></a> *   topic when ANY of the alternatives is active, and asking about any one
<a name="1210"></a> *   of the alternatives will satisfy the PC's curiosity for ALL of the
<a name="1211"></a> *   alternatives.  This sort of arrangement is usually better for cases
<a name="1212"></a> *   where the conditions that trigger the different alternatives aren't
<a name="1213"></a> *   things that ought to make the PC think to ask the same question again.
<a name="1214"></a> *   
<a name="1215"></a> *   Use this class by associating it with the *root* TopicEntry of the
<a name="1216"></a> *   group of alternatives.  You can do this most simply by mixing this
<a name="1217"></a> *   class into the superclass list of the root TopicEntry:
<a name="1218"></a> *   
<a name="1219"></a> *.  + AskTellTopic, SuggestedTopicTree, SuggestedAskTopic
<a name="1220"></a> *.     // ...
<a name="1221"></a> *.  ;
<a name="1222"></a> *   ++ AltTopic ... ;
<a name="1223"></a> *   ++ AltTopic ... ;
<a name="1224"></a> *   
<a name="1225"></a> *   This makes the entire group of AltTopics part of the same suggestion.
<a name="1226"></a> *   Note that you must *also* include SuggestedAsk, SuggestedTellTopic, or
<a name="1227"></a> *   one of the other specialized types among the superclass, to indicate
<a name="1228"></a> *   which kind of suggestion this is.  
<a name="1229"></a> */
<a name="1230"></a>class SuggestedTopicTree: SuggestedTopic
<a name="1231"></a>    /* is the associated topic active? */
<a name="1232"></a>    associatedTopicIsActive()
<a name="1233"></a>    {
<a name="1234"></a>        /* the topic is active if anything in the AltTopic group is active */
<a name="1235"></a>        return associatedTopic.anyAltIsActive;
<a name="1236"></a>    }
<a name="1237"></a>
<a name="1238"></a>    /* get the number of previous invocations of the associated topic */
<a name="1239"></a>    associatedTopicTalkCount()
<a name="1240"></a>    {
<a name="1241"></a>        /* return the number of invocations of any alternative */
<a name="1242"></a>        return associatedTopic.altTalkCount;
<a name="1243"></a>    }
<a name="1244"></a>;
<a name="1245"></a>
<a name="1246"></a>/* 
<a name="1247"></a> *   A suggested ASK ABOUT topic.  We'll list ASK ABOUT topics together in
<a name="1248"></a> *   a subgroup ("you'd like to ask him about the book, the candle, and
<a name="1249"></a> *   the bell...").  
<a name="1250"></a> */
<a name="1251"></a>class SuggestedAskTopic: SuggestedTopic
<a name="1252"></a>    suggestionGroup = [suggestionAskGroup]
<a name="1253"></a>;
<a name="1254"></a>
<a name="1255"></a>/*
<a name="1256"></a> *   A suggested TELL ABOUT topic.  We'll list TELL ABOUT topics together
<a name="1257"></a> *   in a subgroup. 
<a name="1258"></a> */
<a name="1259"></a>class SuggestedTellTopic: SuggestedTopic
<a name="1260"></a>    suggestionGroup = [suggestionTellGroup]
<a name="1261"></a>;
<a name="1262"></a>
<a name="1263"></a>/*
<a name="1264"></a> *   A suggested ASK FOR topic.  We'll list ASK FOR topics together as a
<a name="1265"></a> *   group. 
<a name="1266"></a> */
<a name="1267"></a>class SuggestedAskForTopic: SuggestedTopic
<a name="1268"></a>    suggestionGroup = [suggestionAskForGroup]
<a name="1269"></a>;
<a name="1270"></a>
<a name="1271"></a>/*
<a name="1272"></a> *   A suggested GIVE TO topic. 
<a name="1273"></a> */
<a name="1274"></a>class SuggestedGiveTopic: SuggestedTopic
<a name="1275"></a>    suggestionGroup = [suggestionGiveGroup]
<a name="1276"></a>;
<a name="1277"></a>
<a name="1278"></a>/*
<a name="1279"></a> *   A suggested SHOW TO topic. 
<a name="1280"></a> */
<a name="1281"></a>class SuggestedShowTopic: SuggestedTopic
<a name="1282"></a>    suggestionGroup = [suggestionShowGroup]
<a name="1283"></a>;
<a name="1284"></a>
<a name="1285"></a>/*
<a name="1286"></a> *   A suggested YES/NO topic 
<a name="1287"></a> */
<a name="1288"></a>class SuggestedYesTopic: SuggestedTopic
<a name="1289"></a>    suggestionGroup = [suggestionYesNoGroup]
<a name="1290"></a>;
<a name="1291"></a>class SuggestedNoTopic: SuggestedTopic
<a name="1292"></a>    suggestionGroup = [suggestionYesNoGroup]
<a name="1293"></a>;
<a name="1294"></a>
<a name="1295"></a>/* ------------------------------------------------------------------------ */
<a name="1296"></a>/*
<a name="1297"></a> *   A conversation node.  Conversation nodes are supplemental topic
<a name="1298"></a> *   databases that represent a point in time in a conversation - a
<a name="1299"></a> *   particular context that arises from what came immediately before in
<a name="1300"></a> *   the conversation.  A conversation node is used to set up a group of
<a name="1301"></a> *   special responses that make sense only in a momentary context within a
<a name="1302"></a> *   conversation.
<a name="1303"></a> *   
<a name="1304"></a> *   A ConvNode object must be nested (via the 'location' property) within
<a name="1305"></a> *   an actor or an ActorState.  This is how we associate the ConvNode with
<a name="1306"></a> *   its actor.  Note that putting a ConvNode inside an ActorState doesn't
<a name="1307"></a> *   do anything different from putting the node directly inside the
<a name="1308"></a> *   ActorState's actor - we allow it only for convenience, to allow
<a name="1309"></a> *   greater flexibility arranging source code.  
<a name="1310"></a> */
<a name="1311"></a>class ConvNode: ActorTopicDatabase
<a name="1312"></a>    /*
<a name="1313"></a>     *   Every ConvNode must have a name property.  This is a string
<a name="1314"></a>     *   identifying the object.  Use this name string instead of a regular
<a name="1315"></a>     *   object name (so ConvNode instances can essentially always be
<a name="1316"></a>     *   anonymous, as far as the compiler is concerned).  This string is
<a name="1317"></a>     *   used to find the ConvNode in the master ConvNode database
<a name="1318"></a>     *   maintained in the conversationManager object.
<a name="1319"></a>     *   
<a name="1320"></a>     *   A ConvNode name should be unique with respect to all other
<a name="1321"></a>     *   ConvNode objects - no two ConvNode objects should have the same
<a name="1322"></a>     *   name string.  Other than this, the name strings are arbitrary.
<a name="1323"></a>     *   (However, they shouldn't contain any '&gt;' characters, because this
<a name="1324"></a>     *   would prevent them from being used in &lt;.convnode&gt; tags, which is
<a name="1325"></a>     *   the main place ConvNode's are usually used.)  
<a name="1326"></a>     */
<a name="1327"></a>    name = ''
<a name="1328"></a>
<a name="1329"></a>    /*
<a name="1330"></a>     *   Is this node "sticky"?  If so, we'll stick to this node if we
<a name="1331"></a>     *   show a response that doesn't set a new node.  By default, we're
<a name="1332"></a>     *   not sticky, so if we show a response that doesn't set a new node
<a name="1333"></a>     *   and doesn't use a &lt;.convstay&gt; tag, we'll simply forget the node
<a name="1334"></a>     *   and set the actor to no current ConvNode.
<a name="1335"></a>     *   
<a name="1336"></a>     *   Sticky nodes are useful when you want the actor to stay
<a name="1337"></a>     *   on-subject even when the player digresses to talk about other
<a name="1338"></a>     *   things.  This is useful when the actor has a particular thread
<a name="1339"></a>     *   they want to drive the conversation along.  
<a name="1340"></a>     */
<a name="1341"></a>    isSticky = nil
<a name="1342"></a>
<a name="1343"></a>    /*
<a name="1344"></a>     *   Show our NPC-initiated greeting.  This is invoked when our actor's
<a name="1345"></a>     *   initiateConversation() method is called to cause our actor to
<a name="1346"></a>     *   initiate a conversation with the player character.  This method
<a name="1347"></a>     *   should show what our actor says to initiate the conversation.  By
<a name="1348"></a>     *   default, we'll invoke our npcGreetingList's script, if the
<a name="1349"></a>     *   property is non-nil.
<a name="1350"></a>     *   
<a name="1351"></a>     *   A greeting should always be defined for any ConvNode that's used
<a name="1352"></a>     *   in an initiateConversation() call.
<a name="1353"></a>     *   
<a name="1354"></a>     *   To define a greeting when defining a ConvNode, you can override
<a name="1355"></a>     *   this method with a simple double-quoted string message, or you can
<a name="1356"></a>     *   define an npcGreetingList property as an EventList of some kind.  
<a name="1357"></a>     */
<a name="1358"></a>    npcGreetingMsg()
<a name="1359"></a>    {
<a name="1360"></a>        /* if we have an npcGreetingList property, invoke the script */
<a name="1361"></a>        if (npcGreetingList != nil)
<a name="1362"></a>            npcGreetingList.doScript();
<a name="1363"></a>    }
<a name="1364"></a>
<a name="1365"></a>    /* an optional EventList containing our NPC-initiated greetings */
<a name="1366"></a>    npcGreetingList = nil
<a name="1367"></a>
<a name="1368"></a>    /*
<a name="1369"></a>     *   Our NPC-initiated conversation continuation message.  This is
<a name="1370"></a>     *   invoked on each turn (during the NPC's takeTurn() daemon
<a name="1371"></a>     *   processing) that we're in this conversation node and the player
<a name="1372"></a>     *   character doesn't do anything conversational.  This allows the NPC
<a name="1373"></a>     *   to carry on the conversation of its own volition.  Define this as
<a name="1374"></a>     *   a double-quoted string if you want the NPC to say something to
<a name="1375"></a>     *   continue the conversation.  
<a name="1376"></a>     */
<a name="1377"></a>    npcContinueMsg = nil
<a name="1378"></a>
<a name="1379"></a>    /* 
<a name="1380"></a>     *   An optional EventList containing NPC-initiated continuation
<a name="1381"></a>     *   messages.  You can define an EventList here instead of defining
<a name="1382"></a>     *   npcContinueMsg, if you want more than one continuation message.  
<a name="1383"></a>     */
<a name="1384"></a>    npcContinueList = nil
<a name="1385"></a>
<a name="1386"></a>    /*
<a name="1387"></a>     *   Flag: automatically show a topic inventory on activating this
<a name="1388"></a>     *   conversation node.  Some conversation nodes have sufficiently
<a name="1389"></a>     *   obscure entries that it's desirable to show a topic inventory
<a name="1390"></a>     *   automatically when the node becomes active.
<a name="1391"></a>     *   
<a name="1392"></a>     *   By default, we automatically show a topic inventory if the node
<a name="1393"></a>     *   contains an active SpecialTopic entry.  Since special topics are
<a name="1394"></a>     *   inherently obscure, in that they use non-standard commands, we
<a name="1395"></a>     *   always want to show topics when one of these becomes active.  
<a name="1396"></a>     */
<a name="1397"></a>    autoShowTopics()
<a name="1398"></a>    {
<a name="1399"></a>        /* if we have an active special topic, show the topic inventory */
<a name="1400"></a>        return (specialTopics != nil
<a name="1401"></a>                &amp;&amp; specialTopics.indexWhich({x: x.checkIsActive()}) != nil);
<a name="1402"></a>    }
<a name="1403"></a>
<a name="1404"></a>    /* our NPC is initiating a conversation starting with this node */
<a name="1405"></a>    npcInitiateConversation()
<a name="1406"></a>    {
<a name="1407"></a>        local actor = getActor();
<a name="1408"></a>        
<a name="1409"></a>        /* tell the conversation manager we're the actor who's talking */
<a name="1410"></a>        conversationManager.beginResponse(actor);
<a name="1411"></a>
<a name="1412"></a>        /* note that we're in conversation with the player character now */
<a name="1413"></a>        getActor().noteConversation(gPlayerChar);
<a name="1414"></a>        
<a name="1415"></a>        /* show our NPC greeting */
<a name="1416"></a>        npcGreetingMsg();
<a name="1417"></a>
<a name="1418"></a>        /* look for an ActorHelloTopic within the node */
<a name="1419"></a>        handleTopic(gPlayerChar, actorHelloTopicObj, helloConvType, nil);
<a name="1420"></a>
<a name="1421"></a>        /* end the response, staying in the current ConvNode by default */
<a name="1422"></a>        conversationManager.finishResponse(actor, self);
<a name="1423"></a>    }
<a name="1424"></a>
<a name="1425"></a>    /* 
<a name="1426"></a>     *   Continue the conversation of the NPC's own volition.  Returns
<a name="1427"></a>     *   true if we displayed anything, nil if not. 
<a name="1428"></a>     */
<a name="1429"></a>    npcContinueConversation()
<a name="1430"></a>    {
<a name="1431"></a>        local actor = getActor();
<a name="1432"></a>        local disp;
<a name="1433"></a>        
<a name="1434"></a>        /* tell the conversation manager we're starting a response */
<a name="1435"></a>        conversationManager.beginResponse(actor);
<a name="1436"></a>
<a name="1437"></a>        /* show our text, watching to see if we generate any output */
<a name="1438"></a>        disp = outputManager.curOutputStream.watchForOutput(new function()
<a name="1439"></a>        {
<a name="1440"></a>            /* 
<a name="1441"></a>             *   if we have a continuation list, invoke it; otherwise if we
<a name="1442"></a>             *   have a continuation message, show it; otherwise, just
<a name="1443"></a>             *   return nil to let the caller know we have nothing to add 
<a name="1444"></a>             */
<a name="1445"></a>            if (npcContinueList != nil)
<a name="1446"></a>                npcContinueList.doScript();
<a name="1447"></a>            else
<a name="1448"></a>                npcContinueMsg;
<a name="1449"></a>        });
<a name="1450"></a>
<a name="1451"></a>        /* end the response, staying in the current ConvNode by default */
<a name="1452"></a>        conversationManager.finishResponse(actor, self);
<a name="1453"></a>
<a name="1454"></a>        /* 
<a name="1455"></a>         *   if we actually said anything, note that we're in conversation
<a name="1456"></a>         *   with the player character 
<a name="1457"></a>         */
<a name="1458"></a>        if (disp)
<a name="1459"></a>            getActor().noteConversation(gPlayerChar);
<a name="1460"></a>
<a name="1461"></a>        /* return the display indication */
<a name="1462"></a>        return disp;
<a name="1463"></a>    }
<a name="1464"></a>
<a name="1465"></a>    /* our actor is our location, or our location's actor */
<a name="1466"></a>    getActor()
<a name="1467"></a>    {
<a name="1468"></a>        /* if our location is an actor state, return the state's actor */
<a name="1469"></a>        if (location.ofKind(ActorState))
<a name="1470"></a>            return location.getActor();
<a name="1471"></a>
<a name="1472"></a>        /* otherwise, our location must be our actor */
<a name="1473"></a>        return location;
<a name="1474"></a>    }
<a name="1475"></a>
<a name="1476"></a>    /* our actor is the "owner" of our topics */
<a name="1477"></a>    getTopicOwner() { return getActor(); }
<a name="1478"></a>
<a name="1479"></a>    /*
<a name="1480"></a>     *   Handle a conversation topic.  The actor state object will call
<a name="1481"></a>     *   this to give the ConvNode the first crack at handling a
<a name="1482"></a>     *   conversation command.  We'll return true if we handle the command,
<a name="1483"></a>     *   nil if not.  Our default handling is to look up the topic in the
<a name="1484"></a>     *   given database list property, and handle it through the TopicEntry
<a name="1485"></a>     *   we find there, if any.  
<a name="1486"></a>     */
<a name="1487"></a>    handleConversation(otherActor, topic, convType, path)
<a name="1488"></a>    {
<a name="1489"></a>        /* try handling it, returning the handled/not-handled result */
<a name="1490"></a>        return handleTopic(otherActor, topic, convType, path);
<a name="1491"></a>    }
<a name="1492"></a>
<a name="1493"></a>    /*
<a name="1494"></a>     *   Can we end the conversation?  If so, return true; our caller will
<a name="1495"></a>     *   invoke our endConversation() to let us know that the conversation
<a name="1496"></a>     *   is over.
<a name="1497"></a>     *   
<a name="1498"></a>     *   To prevent the conversation from ending, simply return nil.
<a name="1499"></a>     *   
<a name="1500"></a>     *   In most cases, you won't want to force the conversation to keep
<a name="1501"></a>     *   going without any comment.  Instead, you'll want to display some
<a name="1502"></a>     *   message to let the player know what's going on - something like
<a name="1503"></a>     *   "Hey! We're not through here!"  If you do display a message, then
<a name="1504"></a>     *   rather than returning nil, return the special value blockEndConv -
<a name="1505"></a>     *   this tells the caller that the actor said something, so the caller
<a name="1506"></a>     *   will call noteConvAction() to prevent further generated
<a name="1507"></a>     *   conversation output on this same turn.
<a name="1508"></a>     *   
<a name="1509"></a>     *   'reason' gives the reason the conversation is ending, as an
<a name="1510"></a>     *   endConvXxx enum code.  
<a name="1511"></a>     */
<a name="1512"></a>    canEndConversation(actor, reason) { return true; }
<a name="1513"></a>
<a name="1514"></a>    /*
<a name="1515"></a>     *   Receive notification that our actor is ending a stateful
<a name="1516"></a>     *   conversation.  This is called before the normal
<a name="1517"></a>     *   InConversationState disengagement operations.  'reason' is one of
<a name="1518"></a>     *   the endConvXxx enums, indicating why the conversation is ending.
<a name="1519"></a>     *   
<a name="1520"></a>     *   Instances can override this for special behavior on terminating a
<a name="1521"></a>     *   conversation.  For example, an actor who just asked a question
<a name="1522"></a>     *   could say something to indicate that the other actor is being
<a name="1523"></a>     *   rude.  By default, we do nothing.
<a name="1524"></a>     *   
<a name="1525"></a>     *   Note that there's no way to block the ending of the conversation
<a name="1526"></a>     *   here.  If you want to prevent the conversation from ending, use
<a name="1527"></a>     *   canEndConversation() instead.  
<a name="1528"></a>     */
<a name="1529"></a>    endConversation(actor, reason) { }
<a name="1530"></a>
<a name="1531"></a>    /*
<a name="1532"></a>     *   Process a special command.  Check the given command line string
<a name="1533"></a>     *   against all of our topics, and see if we have a match to any topic
<a name="1534"></a>     *   that takes a special command syntax.  If we find a matching
<a name="1535"></a>     *   special topic, we'll note the match, and turn the command into our
<a name="1536"></a>     *   secret internal pseudo-command "XSPCLTOPIC".  That command will
<a name="1537"></a>     *   then go through the parser, which will recognize it and process it
<a name="1538"></a>     *   using the normal conversational mechanisms, which will find the
<a name="1539"></a>     *   SpecialTopic we noted earlier (in this method) and display its
<a name="1540"></a>     *   response.
<a name="1541"></a>     *   
<a name="1542"></a>     *   'str' is the original input string, exactly as entered by the
<a name="1543"></a>     *   player, and 'procStr' is the "processed" version of the input
<a name="1544"></a>     *   string.  The nature of the processing varies by language, but
<a name="1545"></a>     *   generally this involves things like removing punctuation marks and
<a name="1546"></a>     *   any "noise words" that don't usually change the meaning of the
<a name="1547"></a>     *   input, at least for the purposes of matching a special topic.  
<a name="1548"></a>     */
<a name="1549"></a>    processSpecialCmd(str, procStr)
<a name="1550"></a>    {
<a name="1551"></a>        local match;
<a name="1552"></a>        local cnt;
<a name="1553"></a>
<a name="1554"></a>        /* we don't have an active special topic yet */
<a name="1555"></a>        activeSpecialTopic = nil;
<a name="1556"></a>
<a name="1557"></a>        /* 
<a name="1558"></a>         *   if we have no special topics, there's definitely no special
<a name="1559"></a>         *   processing we need to do 
<a name="1560"></a>         */
<a name="1561"></a>        if (specialTopics == nil)
<a name="1562"></a>            return str;
<a name="1563"></a>        
<a name="1564"></a>        /* scan our special topics for a match */
<a name="1565"></a>        cnt = 0;
<a name="1566"></a>        foreach (local cur in specialTopics)
<a name="1567"></a>        {
<a name="1568"></a>            /* if this one is active, and it matches the string, note it */
<a name="1569"></a>            if (cur.checkIsActive() &amp;&amp; cur.matchPreParse(str, procStr))
<a name="1570"></a>            {
<a name="1571"></a>                /* remember it as the last match */
<a name="1572"></a>                match = cur;
<a name="1573"></a>
<a name="1574"></a>                /* count the match */
<a name="1575"></a>                ++cnt;
<a name="1576"></a>            }
<a name="1577"></a>        }
<a name="1578"></a>
<a name="1579"></a>        /*
<a name="1580"></a>         *   If we found exactly one match, then activate it.  If we found
<a name="1581"></a>         *   zero or more than one, ignore any special topics and proceed
<a name="1582"></a>         *   on the assumption that this is a normal command.  (We ignore
<a name="1583"></a>         *   ambiguous matches because this probably means that the entire
<a name="1584"></a>         *   command is some very common word that happens to be acceptable
<a name="1585"></a>         *   as a keyword in one or more of our matches.  In these cases,
<a name="1586"></a>         *   the common word was probably meant as an ordinary command,
<a name="1587"></a>         *   since the player would likely have been more specific if a
<a name="1588"></a>         *   special topic were really desired.)  
<a name="1589"></a>         */
<a name="1590"></a>        if (cnt == 1)
<a name="1591"></a>        {
<a name="1592"></a>            /* 
<a name="1593"></a>             *   remember the active SpecialTopic - we'll use this memory
<a name="1594"></a>             *   to find it again when we get through the full command
<a name="1595"></a>             *   processing 
<a name="1596"></a>             */
<a name="1597"></a>            activeSpecialTopic = match;
<a name="1598"></a>
<a name="1599"></a>            /* 
<a name="1600"></a>             *   Change the command to our special internal pseudo-command
<a name="1601"></a>             *   that triggers the active special topic.  Include the
<a name="1602"></a>             *   original string as a literal phrase, enclosed in double
<a name="1603"></a>             *   quotes and specially coded to ensure that the tokenizer
<a name="1604"></a>             *   doesn't become confused by any embedded quotes.  
<a name="1605"></a>             */
<a name="1606"></a>            return 'xspcltopic "' + SpecialTopicAction.encodeOrig(str) + '"';
<a name="1607"></a>        }
<a name="1608"></a>        else
<a name="1609"></a>        {
<a name="1610"></a>            /* proceed, treating the original input as an ordinary command */
<a name="1611"></a>            return str;
<a name="1612"></a>        }
<a name="1613"></a>    }
<a name="1614"></a>
<a name="1615"></a>    patWhitespace = static new RexPattern('&lt;space&gt;+')
<a name="1616"></a>    patDelim = static new RexPattern('&lt;punct|space&gt;')
<a name="1617"></a>
<a name="1618"></a>    /*
<a name="1619"></a>     *   Handle an XSPCLTOPIC command from the given actor.  This is part
<a name="1620"></a>     *   two of the two-phase processing of SpecialTopic matches.  Our
<a name="1621"></a>     *   pre-parser checks each SpecialTopic's custom syntax for a match
<a name="1622"></a>     *   to the player's text input, and if it finds a match, it sets our
<a name="1623"></a>     *   activeSpecialTopic property to the matching SpecialTopic, and
<a name="1624"></a>     *   changes the user's command to XSPCLTOPIC for processing by the
<a name="1625"></a>     *   regular parser.  The regular parser sees the XSPCLTOPIC command,
<a name="1626"></a>     *   which is a valid verb that calls the issuing actor's
<a name="1627"></a>     *   saySpecialTopic() routine, which in turn forwards the request to
<a name="1628"></a>     *   the issuing actor's interlocutor's current conversation node -
<a name="1629"></a>     *   which is to say, 'self'.  We complete the two-step procedure by
<a name="1630"></a>     *   going back to the active special topic object that we previously
<a name="1631"></a>     *   noted and showing its response.  
<a name="1632"></a>     */
<a name="1633"></a>    saySpecialTopic(fromActor)
<a name="1634"></a>    {
<a name="1635"></a>        /* make sure we have an active special topic object */
<a name="1636"></a>        if (activeSpecialTopic != nil)
<a name="1637"></a>        {
<a name="1638"></a>            local actor = getTopicOwner();
<a name="1639"></a>            
<a name="1640"></a>            /* tell the conversation manager we're starting a response */
<a name="1641"></a>            conversationManager.beginResponse(actor);
<a name="1642"></a>
<a name="1643"></a>            /* let the SpecialTopic handle the response */
<a name="1644"></a>            activeSpecialTopic.handleTopic(fromActor, nil);
<a name="1645"></a>
<a name="1646"></a>            /* 
<a name="1647"></a>             *   Tell the conversation manager we're done.  By default, we
<a name="1648"></a>             *   want to leave the conversation tree entirely, so set the
<a name="1649"></a>             *   new default node to 'nil'.  
<a name="1650"></a>             */
<a name="1651"></a>            conversationManager.finishResponse(actor, nil);
<a name="1652"></a>
<a name="1653"></a>            /* that wraps things up for the active special topic */
<a name="1654"></a>            activeSpecialTopic = nil;
<a name="1655"></a>        }
<a name="1656"></a>        else
<a name="1657"></a>        {
<a name="1658"></a>            /* 
<a name="1659"></a>             *   There is no active special topic, so the player must have
<a name="1660"></a>             *   typed in the XSPCLTOPIC command explicitly - if we got
<a name="1661"></a>             *   here through the normal two-step procedure then this
<a name="1662"></a>             *   property would not be nil.  Politely decline the command,
<a name="1663"></a>             *   since it's not for the player's direct use.  
<a name="1664"></a>             */
<a name="1665"></a>            gLibMessages.commandNotPresent;
<a name="1666"></a>        }
<a name="1667"></a>    }
<a name="1668"></a>
<a name="1669"></a>    /*
<a name="1670"></a>     *   The active special topic.  This is the SpecialTopic object that
<a name="1671"></a>     *   we matched during pre-parsing, so it's the one whose response we
<a name="1672"></a>     *   wish to show while processing the command we pre-parsed.  
<a name="1673"></a>     */
<a name="1674"></a>    activeSpecialTopic = nil
<a name="1675"></a>
<a name="1676"></a>    /*
<a name="1677"></a>     *   Note that we're becoming active, with a reason code.  Our actor
<a name="1678"></a>     *   will call this method when we're becoming active, as long as we
<a name="1679"></a>     *   weren't already active.
<a name="1680"></a>     *   
<a name="1681"></a>     *   'reason' is a string giving a reason code for why we're being
<a name="1682"></a>     *   called.  For calls from the library, this will be one of these
<a name="1683"></a>     *   codes:
<a name="1684"></a>     *   
<a name="1685"></a>     *    'convnode' - processing a &lt;.convnode&gt; tag
<a name="1686"></a>     *   
<a name="1687"></a>     *    'convend' - processing a &lt;.convend&gt; tag
<a name="1688"></a>     *   
<a name="1689"></a>     *    'initiateConversation' - a call to Actor.initiateConversation()
<a name="1690"></a>     *   
<a name="1691"></a>     *    'endConversation' - a call to Actor.endConversation()
<a name="1692"></a>     *   
<a name="1693"></a>     *   The reason code is provided so that the node can adapt its action
<a name="1694"></a>     *   for different trigger conditions, if desired.  By default, we
<a name="1695"></a>     *   ignore the reason code and just call the basic noteActive()
<a name="1696"></a>     *   method.  
<a name="1697"></a>     */
<a name="1698"></a>    noteActiveReason(reason)
<a name="1699"></a>    {
<a name="1700"></a>        noteActive();
<a name="1701"></a>    }
<a name="1702"></a>    
<a name="1703"></a>    /*
<a name="1704"></a>     *   Note that we're becoming active, with a reason code.  Our actor
<a name="1705"></a>     *   will call this method when we're becoming active, as long as we
<a name="1706"></a>     *   weren't already active.
<a name="1707"></a>     *   
<a name="1708"></a>     *   Note that if you want to adapt the method's behavior according to
<a name="1709"></a>     *   why the node was activated, you can override noteActiveReason()
<a name="1710"></a>     *   instead of this method.  
<a name="1711"></a>     */
<a name="1712"></a>    noteActive()
<a name="1713"></a>    {
<a name="1714"></a>        /* if desired, schedule a topic inventory whenever we're activated */
<a name="1715"></a>        if (autoShowTopics())
<a name="1716"></a>            conversationManager.scheduleTopicInventory();
<a name="1717"></a>    }
<a name="1718"></a>
<a name="1719"></a>    /*
<a name="1720"></a>     *   Note that we're leaving this conversation node.  This doesn't do
<a name="1721"></a>     *   anything by default, but individual instances might find the
<a name="1722"></a>     *   notification useful for triggering side effects.  
<a name="1723"></a>     */
<a name="1724"></a>    noteLeaving() { }
<a name="1725"></a>;
<a name="1726"></a>
<a name="1727"></a>
<a name="1728"></a>/* ------------------------------------------------------------------------ */
<a name="1729"></a>/*
<a name="1730"></a> *   Pre-parser for special ConvNode-specific commands.  When the player
<a name="1731"></a> *   character is talking to another character, and the NPC's current
<a name="1732"></a> *   ConvNode includes topics with their own commands, we'll check the
<a name="1733"></a> *   player's input to see if it matches any of these topics.  
<a name="1734"></a> */
<a name="1735"></a>specialTopicPreParser: StringPreParser
<a name="1736"></a>    doParsing(str, which)
<a name="1737"></a>    {
<a name="1738"></a>        local actor;
<a name="1739"></a>        local node;
<a name="1740"></a>        
<a name="1741"></a>        /* 
<a name="1742"></a>         *   don't handle this on requests for missing literals - these
<a name="1743"></a>         *   responses are always interpreted as literal text, so there's
<a name="1744"></a>         *   no way this could be a special ConvNode command 
<a name="1745"></a>         */
<a name="1746"></a>        if (which == rmcAskLiteral)
<a name="1747"></a>            return str;
<a name="1748"></a>
<a name="1749"></a>        /* 
<a name="1750"></a>         *   if the player character isn't currently in conversation, or
<a name="1751"></a>         *   the actor with whom the player character is conversing doesn't
<a name="1752"></a>         *   have a current conversation node, there's nothing to do 
<a name="1753"></a>         */
<a name="1754"></a>        if ((actor = gPlayerChar.getCurrentInterlocutor()) == nil
<a name="1755"></a>            || (node = actor.curConvNode) == nil)
<a name="1756"></a>            return str;
<a name="1757"></a>
<a name="1758"></a>        /* ask the conversation node to process the string */
<a name="1759"></a>        return node.processSpecialCmd(str, processInputStr(str));
<a name="1760"></a>    }
<a name="1761"></a>    
<a name="1762"></a>    /* 
<a name="1763"></a>     *   Process the input string, as desired, for special-topic parsing.
<a name="1764"></a>     *   This method is for the language module's use; by default, we do
<a name="1765"></a>     *   nothing.
<a name="1766"></a>     *   
<a name="1767"></a>     *   Language modules should override this to remove punctuation marks
<a name="1768"></a>     *   and to do any other language-dependent processing to make the
<a name="1769"></a>     *   string parsable.  
<a name="1770"></a>     */
<a name="1771"></a>    processInputStr(str) { return str; }
<a name="1772"></a>;
<a name="1773"></a>
<a name="1774"></a>/* ------------------------------------------------------------------------ */
<a name="1775"></a>/*
<a name="1776"></a> *   A conversational action type descriptor.  This descriptor is used in
<a name="1777"></a> *   handleConversation() in Actor and ActorState to describe the type of
<a name="1778"></a> *   conversational action we're performing.  The type descriptor object
<a name="1779"></a> *   encapsulates a set of information that tells us how to handle the
<a name="1780"></a> *   action.  
<a name="1781"></a> */
<a name="1782"></a>class ConvType: object
<a name="1783"></a>    /* 
<a name="1784"></a>     *   The unknown interlocutor message property.  This is used when we
<a name="1785"></a>     *   try this conversational action without knowing whom we're talking
<a name="1786"></a>     *   to.  For example, if we just say HELLO, and there's no one around
<a name="1787"></a>     *   to talk to, we'll use this as the default response.  This can be a
<a name="1788"></a>     *   library message property, or simply a single-quoted string to
<a name="1789"></a>     *   display.  
<a name="1790"></a>     */
<a name="1791"></a>    unknownMsg = nil
<a name="1792"></a>
<a name="1793"></a>    /*
<a name="1794"></a>     *   The TopicDatabase topic-list property.  This is the property of
<a name="1795"></a>     *   the TopicDatabase object that we evaluate to get this list of
<a name="1796"></a>     *   topic entries to search for a match to the topic.  
<a name="1797"></a>     */
<a name="1798"></a>    topicListProp = nil
<a name="1799"></a>
<a name="1800"></a>    /* the default response property for this action */
<a name="1801"></a>    defaultResponseProp = nil
<a name="1802"></a>
<a name="1803"></a>    /* 
<a name="1804"></a>     *   Call the default response property on the given topic database.
<a name="1805"></a>     *   This invokes the property given by defaultResponseProp().  We have
<a name="1806"></a>     *   both the property and the method to call the property because this
<a name="1807"></a>     *   allows us to test for the existence of the property and to call it
<a name="1808"></a>     *   with the appropriate argument list. 
<a name="1809"></a>     */
<a name="1810"></a>    defaultResponse(db, otherActor, topic) { }
<a name="1811"></a>
<a name="1812"></a>    /*
<a name="1813"></a>     *   Perform any special follow-up action for this type of
<a name="1814"></a>     *   conversational action. 
<a name="1815"></a>     */
<a name="1816"></a>    afterResponse(actor, otherActor) { }
<a name="1817"></a>;
<a name="1818"></a>
<a name="1819"></a>helloConvType: ConvType
<a name="1820"></a>    unknownMsg = &amp;sayHelloMsg
<a name="1821"></a>    topicListProp = &amp;miscTopics
<a name="1822"></a>    defaultResponseProp = &amp;defaultGreetingResponse
<a name="1823"></a>    defaultResponse(db, other, topic)
<a name="1824"></a>        { db.defaultGreetingResponse(other); }
<a name="1825"></a>
<a name="1826"></a>    /* after an explicit HELLO, show any suggested topics */
<a name="1827"></a>    afterResponse(actor, otherActor)
<a name="1828"></a>    {
<a name="1829"></a>        /* show or schedule a topic inventory, as appropriate */
<a name="1830"></a>        conversationManager.showOrScheduleTopicInventory(actor, otherActor);
<a name="1831"></a>    }
<a name="1832"></a>;
<a name="1833"></a>
<a name="1834"></a>byeConvType: ConvType
<a name="1835"></a>    unknownMsg = &amp;sayGoodbyeMsg
<a name="1836"></a>    topicListProp = &amp;miscTopics
<a name="1837"></a>    defaultResponseProp = &amp;defaultGoodbyeResponse
<a name="1838"></a>    defaultResponse(db, other, topic)
<a name="1839"></a>        { db.defaultGoodbyeResponse(other); }
<a name="1840"></a>;
<a name="1841"></a>
<a name="1842"></a>yesConvType: ConvType
<a name="1843"></a>    unknownMsg = &amp;sayYesMsg
<a name="1844"></a>    topicListProp = &amp;miscTopics
<a name="1845"></a>    defaultResponseProp = &amp;defaultYesResponse
<a name="1846"></a>    defaultResponse(db, other, topic)
<a name="1847"></a>        { db.defaultYesResponse(other); }
<a name="1848"></a>;
<a name="1849"></a>
<a name="1850"></a>noConvType: ConvType
<a name="1851"></a>    unknownMsg = &amp;sayNoMsg
<a name="1852"></a>    topicListProp = &amp;miscTopics
<a name="1853"></a>    defaultResponseProp = &amp;defaultNoResponse
<a name="1854"></a>    defaultResponse(db, other, topic)
<a name="1855"></a>        { db.defaultNoResponse(other); }
<a name="1856"></a>;
<a name="1857"></a>
<a name="1858"></a>askAboutConvType: ConvType
<a name="1859"></a>    topicListProp = &amp;askTopics
<a name="1860"></a>    defaultResponseProp = &amp;defaultAskResponse
<a name="1861"></a>    defaultResponse(db, other, topic)
<a name="1862"></a>        { db.defaultAskResponse(other, topic); }
<a name="1863"></a>;
<a name="1864"></a>
<a name="1865"></a>askForConvType: ConvType
<a name="1866"></a>    topicListProp = &amp;askForTopics
<a name="1867"></a>    defaultResponseProp = &amp;defaultAskForResponse
<a name="1868"></a>    defaultResponse(db, other, topic)
<a name="1869"></a>        { db.defaultAskForResponse(other, topic); }
<a name="1870"></a>;
<a name="1871"></a>
<a name="1872"></a>tellAboutConvType: ConvType
<a name="1873"></a>    topicListProp = &amp;tellTopics
<a name="1874"></a>    defaultResponseProp = &amp;defaultTellResponse
<a name="1875"></a>    defaultResponse(db, other, topic)
<a name="1876"></a>        { db.defaultTellResponse(other, topic); }
<a name="1877"></a>;
<a name="1878"></a>
<a name="1879"></a>giveConvType: ConvType
<a name="1880"></a>    topicListProp = &amp;giveTopics
<a name="1881"></a>    defaultResponseProp = &amp;defaultGiveResponse
<a name="1882"></a>    defaultResponse(db, other, topic)
<a name="1883"></a>        { db.defaultGiveResponse(other, topic); }
<a name="1884"></a>;
<a name="1885"></a>
<a name="1886"></a>showConvType: ConvType
<a name="1887"></a>    topicListProp = &amp;showTopics
<a name="1888"></a>    defaultResponseProp = &amp;defaultShowResponse
<a name="1889"></a>    defaultResponse(db, other, topic)
<a name="1890"></a>        { db.defaultShowResponse(other, topic); }
<a name="1891"></a>;
<a name="1892"></a>
<a name="1893"></a>commandConvType: ConvType
<a name="1894"></a>    topicListProp = &amp;commandTopics
<a name="1895"></a>    defaultResponseProp = &amp;defaultCommandResponse
<a name="1896"></a>    defaultResponse(db, other, topic)
<a name="1897"></a>        { db.defaultCommandResponse(other, topic); }
<a name="1898"></a>;
<a name="1899"></a>
<a name="1900"></a>/* 
<a name="1901"></a> *   This type is for NPC-initiated conversations.  It's not a normal
<a name="1902"></a> *   conversational action, since it doesn't involve handling a player
<a name="1903"></a> *   command, but is usually instead triggered by an agenda item,
<a name="1904"></a> *   takeTurn(), or other background activity.  
<a name="1905"></a> */
<a name="1906"></a>initiateConvType: ConvType
<a name="1907"></a>    topicListProp = &amp;initiateTopics
<a name="1908"></a>;
<a name="1909"></a>
<a name="1910"></a>/* 
<a name="1911"></a> *   CONSULT ABOUT isn't a true conversational action, since it's applied
<a name="1912"></a> *   to inanimate objects (such as books); but it's handled through the
<a name="1913"></a> *   conversation system, so it needs a conversation type object 
<a name="1914"></a> */
<a name="1915"></a>consultConvType: ConvType
<a name="1916"></a>    topicListProp = &amp;consultTopics
<a name="1917"></a>;
<a name="1918"></a>
<a name="1919"></a>/* ------------------------------------------------------------------------ */
<a name="1920"></a>/*
<a name="1921"></a> *   A topic database entry.  Actors and actor state objects store topic
<a name="1922"></a> *   databases; a topic database is essentially a set of these entries.
<a name="1923"></a> *   
<a name="1924"></a> *   A TopicEntry can go directly inside an Actor, in which case it's part
<a name="1925"></a> *   of the actor's global set of topics; or, it can go inside an
<a name="1926"></a> *   ActorState, in which case it's part of the state's database and is
<a name="1927"></a> *   only active when the state is active; or, it can go inside a
<a name="1928"></a> *   TopicGroup, which is a set of topics with a common controlling
<a name="1929"></a> *   condition; or, it can go inside a ConvNode, in which case it's in
<a name="1930"></a> *   effect only when the conversation node is active.
<a name="1931"></a> *   
<a name="1932"></a> *   Each entry is a relationship between a topic, which is something that
<a name="1933"></a> *   can come up in an ASK or TELL action, and a handling for the topic.
<a name="1934"></a> *   In addition, each entry determines what kind or kinds of actions it
<a name="1935"></a> *   responds to.
<a name="1936"></a> *   
<a name="1937"></a> *   Note that TopicEntry objects are *not* simulation objects.  Rather,
<a name="1938"></a> *   these are abstract objects; they can be associated with simulation
<a name="1939"></a> *   objects via the matching mechanism, but these are separate from the
<a name="1940"></a> *   actual simulation objects.  The reason for this separation is that a
<a name="1941"></a> *   given simulation object might have many different response - the
<a name="1942"></a> *   response could vary according to who's being asked the question, who's
<a name="1943"></a> *   asking, and what else is happening in the game.
<a name="1944"></a> *   
<a name="1945"></a> *   An entry decides for itself if it matches a topic.  By default, an
<a name="1946"></a> *   entry can match based on either a simulation object, which we'll match
<a name="1947"></a> *   to anything in the topic's "in scope" or "likely" match lists, or
<a name="1948"></a> *   based on a regular expression string, which we'll match to the actual
<a name="1949"></a> *   topic text entered in the player's command.
<a name="1950"></a> *   
<a name="1951"></a> *   An entry can decide how strongly it matches a topic.  The database
<a name="1952"></a> *   will choose the strongest match when multiple entries match the same
<a name="1953"></a> *   topic.  The strength of the match is given by a numeric score; the
<a name="1954"></a> *   higher the score, the stronger the match.  The match strength makes it
<a name="1955"></a> *   easy to specify a hierarchy of topics from specific to general, so
<a name="1956"></a> *   that we provide general responses to general topic areas, but can
<a name="1957"></a> *   still respond to particular topics areas more specifically.  For
<a name="1958"></a> *   example, we might want to provide a specific match to the FROBNOZ
<a name="1959"></a> *   SPELL object, talking about that particular magic spell, but provide a
<a name="1960"></a> *   generic '.* spell' pattern to response to questions about any old
<a name="1961"></a> *   spell.  We'd give the generic pattern a lower score, so that the
<a name="1962"></a> *   specific FROBNOZ SPELL response would win when it matches, but we'd
<a name="1963"></a> *   fall back on the generic pattern in other cases.  
<a name="1964"></a> */
<a name="1965"></a>class TopicEntry: object
<a name="1966"></a>    /*
<a name="1967"></a>     *   My matching simulation object or objects.  This can be either a
<a name="1968"></a>     *   single object or a list of objects. 
<a name="1969"></a>     */
<a name="1970"></a>    matchObj = nil
<a name="1971"></a>
<a name="1972"></a>    /*
<a name="1973"></a>     *   Is this topic active?  This can be used to control how an actor
<a name="1974"></a>     *   can respond without have to worry about adding and removing topics
<a name="1975"></a>     *   manually at key events, or storing the topics in state objects.
<a name="1976"></a>     *   Sometimes, it's easier to just put a topic entry in the actor's
<a name="1977"></a>     *   database from the start, and test some condition dynamically when
<a name="1978"></a>     *   the topic is actually queried.  To do this, override this method
<a name="1979"></a>     *   to test the condition that determines when the topic entry should
<a name="1980"></a>     *   become active.  We'll never show the topic's response when
<a name="1981"></a>     *   isActive returns nil.  By default, we simply return true to
<a name="1982"></a>     *   indicate that the topic entry is active.  
<a name="1983"></a>     */
<a name="1984"></a>    isActive = true
<a name="1985"></a>
<a name="1986"></a>    /*
<a name="1987"></a>     *   Flag: we are a "conversational" topic.  This is true by default.
<a name="1988"></a>     *   When this is set to nil, a ConversationReadyState will NOT show
<a name="1989"></a>     *   its greeting and will not enter its InConversationState to show
<a name="1990"></a>     *   this topic entry's response.
<a name="1991"></a>     *   
<a name="1992"></a>     *   This should be set to nil when the topic entry's response is
<a name="1993"></a>     *   non-conversational, in which case a greeting would be
<a name="1994"></a>     *   undesirable.  This is appropriate for responses like "You don't
<a name="1995"></a>     *   think he'd want to talk about that", where the response indicates
<a name="1996"></a>     *   that the player character didn't even ask a question (or
<a name="1997"></a>     *   whatever).  
<a name="1998"></a>     */
<a name="1999"></a>    isConversational = true
<a name="2000"></a>
<a name="2001"></a>    /*
<a name="2002"></a>     *   Do we imply a greeting?  By default, all conversational topics
<a name="2003"></a>     *   imply a greeting.  We separate this out so that the implied
<a name="2004"></a>     *   greeting can be controlled independently of whether or not we're
<a name="2005"></a>     *   actually conversational, if desired.  
<a name="2006"></a>     */
<a name="2007"></a>    impliesGreeting = (isConversational)
<a name="2008"></a>
<a name="2009"></a>    /*
<a name="2010"></a>     *   Get the actor associated with the topic, if any.  By default,
<a name="2011"></a>     *   we'll return our enclosing database's topic owner, if it's an
<a name="2012"></a>     *   actor - in almost all cases, if there's any actor associated with
<a name="2013"></a>     *   a topic, it's simply the owner of the database containing the
<a name="2014"></a>     *   topic.  
<a name="2015"></a>     */
<a name="2016"></a>    getActor()
<a name="2017"></a>    {
<a name="2018"></a>        local owner;
<a name="2019"></a>
<a name="2020"></a>        /* 
<a name="2021"></a>         *   if we have an owner, and it's an actor, then it's our
<a name="2022"></a>         *   associated actor; otherwise, we don't have any associated
<a name="2023"></a>         *   actor 
<a name="2024"></a>         */
<a name="2025"></a>        if ((owner = location.getTopicOwner()) != nil &amp;&amp; owner.ofKind(Actor))
<a name="2026"></a>            return owner;
<a name="2027"></a>        else
<a name="2028"></a>            return nil;
<a name="2029"></a>    }
<a name="2030"></a>
<a name="2031"></a>    /*
<a name="2032"></a>     *   Determine if this topic is active.  This checks the isActive
<a name="2033"></a>     *   property, and also takes into account our relationship to
<a name="2034"></a>     *   alternative entries for the topic.  Generally, you should *define*
<a name="2035"></a>     *   (override) isActive, and *call* this method.  
<a name="2036"></a>     */
<a name="2037"></a>    checkIsActive()
<a name="2038"></a>    {
<a name="2039"></a>        /* 
<a name="2040"></a>         *   if our isActive property indicates we're not active, we're
<a name="2041"></a>         *   definitely not active, so there's no need to check for an
<a name="2042"></a>         *   overriding alternative 
<a name="2043"></a>         */
<a name="2044"></a>        if (!isActive)
<a name="2045"></a>            return nil;
<a name="2046"></a>
<a name="2047"></a>        /* if we have an active nested alternative, it overrides us */
<a name="2048"></a>        if (altTopicList.indexWhich({x: x.isActive}) != nil)
<a name="2049"></a>            return nil;
<a name="2050"></a>
<a name="2051"></a>        /* ask our container if its topics are active */
<a name="2052"></a>        return location.topicGroupActive();
<a name="2053"></a>    }
<a name="2054"></a>
<a name="2055"></a>    /*
<a name="2056"></a>     *   Check to see if any alternative in the alternative group is
<a name="2057"></a>     *   active.  This returns true if we're active or if any of our nested
<a name="2058"></a>     *   AltTopics is active.  
<a name="2059"></a>     */
<a name="2060"></a>    anyAltIsActive()
<a name="2061"></a>    {
<a name="2062"></a>        /* 
<a name="2063"></a>         *   if all topics within our container are inactive, then there's
<a name="2064"></a>         *   definitely no active alternative 
<a name="2065"></a>         */
<a name="2066"></a>        if (!location.topicGroupActive())
<a name="2067"></a>            return nil;
<a name="2068"></a>
<a name="2069"></a>        /* 
<a name="2070"></a>         *   if we're active, or any of our nested AltTopics is active, our
<a name="2071"></a>         *   alternative group is active 
<a name="2072"></a>         */
<a name="2073"></a>        if (isActive || altTopicList.indexWhich({x: x.isActive}) != nil)
<a name="2074"></a>            return true;
<a name="2075"></a>
<a name="2076"></a>        /* we didn't find any active alternatives in the entire group */
<a name="2077"></a>        return nil;
<a name="2078"></a>    }
<a name="2079"></a>
<a name="2080"></a>    /*
<a name="2081"></a>     *   Adjust my score value for any hierarchical adjustments.  We'll add
<a name="2082"></a>     *   the score adjustment for each enclosing object.  
<a name="2083"></a>     */
<a name="2084"></a>    adjustScore(score)
<a name="2085"></a>    {
<a name="2086"></a>        /* the score is nil, it means there's no match, so don't adjust it */
<a name="2087"></a>        if (score == nil)
<a name="2088"></a>            return score;
<a name="2089"></a>
<a name="2090"></a>        /* add in the cumulative adjustment from my containers */
<a name="2091"></a>        return score + location.topicGroupScoreAdjustment;
<a name="2092"></a>    }
<a name="2093"></a>
<a name="2094"></a>    /*
<a name="2095"></a>     *   Check to see if we want to defer to the given topic from an
<a name="2096"></a>     *   inferior topic database.  By default, we never defer to a topic
<a name="2097"></a>     *   from an inferior database: we choose a matching topic from the top
<a name="2098"></a>     *   database in the hierarchy where we find a match.
<a name="2099"></a>     *   
<a name="2100"></a>     *   The database hierarchy, for most purposes, starts with the
<a name="2101"></a>     *   ConvNode at the highest level, then the ActorState, then the
<a name="2102"></a>     *   Actor.  We search those databases, in that order, and we take the
<a name="2103"></a>     *   first match we find.  By default, if there's another match in a
<a name="2104"></a>     *   lower-level database, it doesn't matter what its matchScore is: we
<a name="2105"></a>     *   always pick the one from the highest-level database where we find
<a name="2106"></a>     *   a match.  You can override this method to change this behavior.
<a name="2107"></a>     *   
<a name="2108"></a>     *   We don't actually define this method here, because the presence of
<a name="2109"></a>     *   the method is significant.  If the method isn't defined at all, we
<a name="2110"></a>     *   won't bother looking for a possible deferral, saving the trouble
<a name="2111"></a>     *   of searching the other databases in the hierarchy.  
<a name="2112"></a>     */
<a name="2113"></a>    // deferToEntry(other) { return nil; }
<a name="2114"></a>
<a name="2115"></a>    /* 
<a name="2116"></a>     *   Our match strength score.  By default, we'll use a score of 100,
<a name="2117"></a>     *   which is just an arbitrary base score.  
<a name="2118"></a>     */
<a name="2119"></a>    matchScore = 100
<a name="2120"></a>
<a name="2121"></a>    /*
<a name="2122"></a>     *   The set of database lists we're part of.  This is a list of
<a name="2123"></a>     *   property pointers, giving the TopicDatabase properties of the
<a name="2124"></a>     *   lists we participate in. 
<a name="2125"></a>     */
<a name="2126"></a>    includeInList = []
<a name="2127"></a>
<a name="2128"></a>    /*
<a name="2129"></a>     *   Our response.  This is displayed when we're the topic entry
<a name="2130"></a>     *   selected to handle an ASK or TELL.  Each topic entry must override
<a name="2131"></a>     *   this to show our response text (or, alternatively, an entry can
<a name="2132"></a>     *   override handleTopic so that it doesn't call this property).  
<a name="2133"></a>     */
<a name="2134"></a>    topicResponse = ""
<a name="2135"></a>
<a name="2136"></a>    /*
<a name="2137"></a>     *   The number of times this topic has invoked by the player.  Each
<a name="2138"></a>     *   time the player asks/tells/etc about this topic, we'll increment
<a name="2139"></a>     *   this count.  
<a name="2140"></a>     */
<a name="2141"></a>    talkCount = 0
<a name="2142"></a>
<a name="2143"></a>    /*
<a name="2144"></a>     *   The number of times this topic or any nested AltTopic has been
<a name="2145"></a>     *   invoked by the player.  Each time the player asks/tells/etc about
<a name="2146"></a>     *   this topic OR any of its AltTopic children, we'll increment this
<a name="2147"></a>     *   count.  
<a name="2148"></a>     */
<a name="2149"></a>    altTalkCount = 0
<a name="2150"></a>
<a name="2151"></a>    /* 
<a name="2152"></a>     *   the owner of any AltTopic nested within me is the same as my own
<a name="2153"></a>     *   topic owner, which we take from our location 
<a name="2154"></a>     */
<a name="2155"></a>    getTopicOwner()
<a name="2156"></a>    {
<a name="2157"></a>        if (location != nil)
<a name="2158"></a>            return location.getTopicOwner();
<a name="2159"></a>        else
<a name="2160"></a>            return nil;
<a name="2161"></a>    }
<a name="2162"></a>
<a name="2163"></a>    /*
<a name="2164"></a>     *   Initialize.  If we have a location property, we'll assume that the
<a name="2165"></a>     *   location is a topic database object, and we'll add ourselves to
<a name="2166"></a>     *   that database.  
<a name="2167"></a>     */
<a name="2168"></a>    initializeTopicEntry()
<a name="2169"></a>    {
<a name="2170"></a>        /* if we have a location, add ourselves to its topic database */
<a name="2171"></a>        if (location != nil)
<a name="2172"></a>            location.addTopic(self);
<a name="2173"></a>
<a name="2174"></a>        /* sort our list of AltTopic children */
<a name="2175"></a>        altTopicList = altTopicList.sort(
<a name="2176"></a>            SortAsc, {a, b: a.altTopicOrder - b.altTopicOrder});
<a name="2177"></a>    }
<a name="2178"></a>
<a name="2179"></a>    /* add a topic nested within us */
<a name="2180"></a>    addTopic(entry)
<a name="2181"></a>    {
<a name="2182"></a>        /* if we have a location, add the entry to its topic database */
<a name="2183"></a>        if (location != nil)
<a name="2184"></a>            location.addTopic(entry);
<a name="2185"></a>    }
<a name="2186"></a>
<a name="2187"></a>    /*
<a name="2188"></a>     *   Add an AltTopic entry.  This is called by our AltTopic children
<a name="2189"></a>     *   during initialization; we'll simply add the entry to our list of
<a name="2190"></a>     *   AltTopic children.  
<a name="2191"></a>     */
<a name="2192"></a>    addAltTopic(entry)
<a name="2193"></a>    {
<a name="2194"></a>        /* add the entry to our list of alternatives */
<a name="2195"></a>        altTopicList += entry;
<a name="2196"></a>    }
<a name="2197"></a>
<a name="2198"></a>    /* get the topic group score adjustment (for AltTopics nested within) */
<a name="2199"></a>    topicGroupScoreAdjustment = (location.topicGroupScoreAdjustment)
<a name="2200"></a>
<a name="2201"></a>    /* check the group isActive status (for AltTopics nested within) */
<a name="2202"></a>    topicGroupActive = (location.topicGroupActive)
<a name="2203"></a>
<a name="2204"></a>    /* our list of AltTopic children */
<a name="2205"></a>    altTopicList = []
<a name="2206"></a>
<a name="2207"></a>    /* 
<a name="2208"></a>     *   Match the topic.  This is abstract in this base class; it must be
<a name="2209"></a>     *   defined by each concrete subclass.  This returns nil if there's
<a name="2210"></a>     *   no match, or an integer value if there's a match.  The higher the
<a name="2211"></a>     *   number's value, the stronger the match.
<a name="2212"></a>     *   
<a name="2213"></a>     *   This is abstract in the base class because the meaning of 'topic'
<a name="2214"></a>     *   varies by subclass, according to which type of command it's used
<a name="2215"></a>     *   with.  For example, in ASK and TELL commands, 'topic' is a
<a name="2216"></a>     *   ResolvedTopic describing the topic in the player's command; for
<a name="2217"></a>     *   GIVE and SHOW commands, it's the resolved simulation object.
<a name="2218"></a>     */
<a name="2219"></a>    // matchTopic(fromActor, topic) { return nil; }
<a name="2220"></a>
<a name="2221"></a>    /*
<a name="2222"></a>     *   Check to see if a match to this topic entry is *possible* right
<a name="2223"></a>     *   now for the given actor.  For most subclasses, this is inherently
<a name="2224"></a>     *   imprecise, because the 'match' function simply isn't reversible in
<a name="2225"></a>     *   general: to know if we can be matched, we'd have to determine if
<a name="2226"></a>     *   there's a non-empty set of possible inputs that can match us.
<a name="2227"></a>     *   This method is complementary to matchTopic(), so subclasses must
<a name="2228"></a>     *   override with a corresponding implementation.
<a name="2229"></a>     *   
<a name="2230"></a>     *   'actor' is the actor to whom we're making the suggestion.
<a name="2231"></a>     *   'scopeList' is the list of objects that are in scope for the
<a name="2232"></a>     *   actor.
<a name="2233"></a>     *   
<a name="2234"></a>     *   The library only uses this to determine if a suggestion should be
<a name="2235"></a>     *   offered.  So, specialized topic instances with non-standard match
<a name="2236"></a>     *   rules don't have to worry about this unless they're used as
<a name="2237"></a>     *   suggestions, or unless the game itself needs this information for
<a name="2238"></a>     *   some other reason.  
<a name="2239"></a>     */
<a name="2240"></a>    // isMatchPossible(actor, scopeList) { return true; }
<a name="2241"></a>
<a name="2242"></a>    /*
<a name="2243"></a>     *   Set pronouns for the topic, if possible.  If the topic corresponds
<a name="2244"></a>     *   to a game-world object, then we should set the pronoun antecedent
<a name="2245"></a>     *   to the game object.  This must be handled per subclass because of
<a name="2246"></a>     *   the range of possible meanings of 'topic'.  
<a name="2247"></a>     */
<a name="2248"></a>    setTopicPronouns(fromActor, topic) { }
<a name="2249"></a>
<a name="2250"></a>    /*
<a name="2251"></a>     *   Handle the topic.  This is called when we find that this is the
<a name="2252"></a>     *   best topic entry for the current topic.
<a name="2253"></a>     *   
<a name="2254"></a>     *   By default, we'll do one of two things:
<a name="2255"></a>     *   
<a name="2256"></a>     *   - If 'self' inherits from Script, then we'll simply invoke our
<a name="2257"></a>     *   doScript() method.  This makes it especially easy to set up a
<a name="2258"></a>     *   topic entry that shows a series of responses: just add EventList
<a name="2259"></a>     *   or one of its subclasses to the base class list when defining the
<a name="2260"></a>     *   topic, and define the eventList property as a list of string
<a name="2261"></a>     *   responses.  For example:
<a name="2262"></a>     *   
<a name="2263"></a>     *.     + TopicEntry, StopEventList @blackBook
<a name="2264"></a>     *.        ['&lt;q&gt;What makes you think I know anything about it?&lt;/q&gt;
<a name="2265"></a>     *.         he says, his voice shaking. ',
<a name="2266"></a>     *.         '&lt;q&gt;No! You can\'t make me tell you!&lt;/q&gt; he wails. ',
<a name="2267"></a>     *.         '&lt;q&gt;All right, fine! I\'ll tell you, but I warn you,
<a name="2268"></a>     *.         this is knowledge mortal men were never meant to know.&lt;/q&gt; ',
<a name="2269"></a>     *.         // and so on
<a name="2270"></a>     *.        ]
<a name="2271"></a>     *.     ;
<a name="2272"></a>     *   
<a name="2273"></a>     *   - Otherwise, we'll call our topicResponse property, which should
<a name="2274"></a>     *   simply be a double-quoted string to display.  This is the simplest
<a name="2275"></a>     *   way to define a topic with just one response.
<a name="2276"></a>     *   
<a name="2277"></a>     *   Note that 'topic' will vary by subclass, depending on the type of
<a name="2278"></a>     *   command used with the topic type.  For example, for ASK and TELL
<a name="2279"></a>     *   commands, 'topic' is a ResolvedTopic object; for GIVE and SHOW,
<a name="2280"></a>     *   it's a simulation object (i.e., generally a Thing subclass).  
<a name="2281"></a>     */
<a name="2282"></a>    handleTopic(fromActor, topic)
<a name="2283"></a>    {
<a name="2284"></a>        /* note the invocation */
<a name="2285"></a>        noteInvocation(fromActor);
<a name="2286"></a>
<a name="2287"></a>        /* set pronoun antecedents if possible */
<a name="2288"></a>        setTopicPronouns(fromActor, topic);
<a name="2289"></a>        
<a name="2290"></a>        /* check to see if we're a Script */
<a name="2291"></a>        if (ofKind(Script))
<a name="2292"></a>        {
<a name="2293"></a>            /* we're a Script - invoke our script */
<a name="2294"></a>            doScript();
<a name="2295"></a>        }
<a name="2296"></a>        else
<a name="2297"></a>        {
<a name="2298"></a>            /* show our simple response string */
<a name="2299"></a>            topicResponse;
<a name="2300"></a>        }
<a name="2301"></a>    }
<a name="2302"></a>
<a name="2303"></a>    /* note that we've been invoked */
<a name="2304"></a>    noteInvocation(fromActor)
<a name="2305"></a>    {
<a name="2306"></a>        /* 
<a name="2307"></a>         *   we count as one of the alternatives in our alternative group,
<a name="2308"></a>         *   so note the invocation of the group
<a name="2309"></a>         */
<a name="2310"></a>        noteAltInvocation(fromActor, self);
<a name="2311"></a>
<a name="2312"></a>        /* count the invocation */
<a name="2313"></a>        ++talkCount;
<a name="2314"></a>    }
<a name="2315"></a>
<a name="2316"></a>    /* 
<a name="2317"></a>     *   Note that something in our entire alternative group has been
<a name="2318"></a>     *   invoked.  We count as a member of our own group, so this is
<a name="2319"></a>     *   invoked when we're invoked; this is also invoked when any AltTopic
<a name="2320"></a>     *   child of ours is invoked.  
<a name="2321"></a>     */
<a name="2322"></a>    noteAltInvocation(fromActor, alt)
<a name="2323"></a>    {
<a name="2324"></a>        local owner;
<a name="2325"></a>        
<a name="2326"></a>        /* notify our owner of the topic invocation */
<a name="2327"></a>        if ((owner = location.getTopicOwner()) != nil)
<a name="2328"></a>            owner.notifyTopicResponse(fromActor, alt);
<a name="2329"></a>        
<a name="2330"></a>        /* count the alternative invocation */
<a name="2331"></a>        ++altTalkCount;
<a name="2332"></a>    }
<a name="2333"></a>
<a name="2334"></a>    /*
<a name="2335"></a>     *   Add a suggested topic.  A suggested topic can be nested within a
<a name="2336"></a>     *   topic entry; doing this associates the suggested topic with the
<a name="2337"></a>     *   topic entry, and automatically associates the suggested topic
<a name="2338"></a>     *   with the entry's actor or actor state.  
<a name="2339"></a>     */
<a name="2340"></a>    addSuggestedTopic(t)
<a name="2341"></a>    {
<a name="2342"></a>        /* 
<a name="2343"></a>         *   If the SuggestedTopic is *directly* within us, we're the
<a name="2344"></a>         *   SuggestedTopic object's associated TopicEntry.  The nesting
<a name="2345"></a>         *   could be deeper, if we have alternative topics nested within
<a name="2346"></a>         *   us; in these cases, we're not directly associated with the
<a name="2347"></a>         *   suggested topic.  
<a name="2348"></a>         */
<a name="2349"></a>        if (t.location == self)
<a name="2350"></a>            t.associatedTopic = self;
<a name="2351"></a>
<a name="2352"></a>        /* add the suggestion to our location's topic database */
<a name="2353"></a>        if (location != nil)
<a name="2354"></a>            location.addSuggestedTopic(t);
<a name="2355"></a>    }
<a name="2356"></a>;
<a name="2357"></a>
<a name="2358"></a>/*
<a name="2359"></a> *   A TopicGroup is an abstract container for a set of TopicEntry objects.
<a name="2360"></a> *   The purpose of the group object is to apply a common "is active"
<a name="2361"></a> *   condition to all of the topics within the group.
<a name="2362"></a> *   
<a name="2363"></a> *   The isActive condition of the TopicGroup is effectively AND'ed with
<a name="2364"></a> *   any other conditions on the nested TopicEntry's.  In other words, a
<a name="2365"></a> *   TopicEntry within the TopicGroup is active if the TopicEntry would
<a name="2366"></a> *   otherwise be acive AND the TopicGroup is active.
<a name="2367"></a> *   
<a name="2368"></a> *   TopicEntry objects are associated with the group via the 'location'
<a name="2369"></a> *   property - set the location of the TopicEntry to point to the
<a name="2370"></a> *   containing TopicGroup.
<a name="2371"></a> *   
<a name="2372"></a> *   You can put a TopicGroup anywhere a TopicEntry could go - directly
<a name="2373"></a> *   inside an Actor, inside an ActorState, or within another TopicGroup.
<a name="2374"></a> *   The topic entries within a topic group act as though they were
<a name="2375"></a> *   directly in the topic group's container.  
<a name="2376"></a> */
<a name="2377"></a>class TopicGroup: object
<a name="2378"></a>    /* 
<a name="2379"></a>     *   The group "active" condition - each instance should override this
<a name="2380"></a>     *   to specify the condition that applies to all of the TopicEntry
<a name="2381"></a>     *   objects within the group.  
<a name="2382"></a>     */
<a name="2383"></a>    isActive = true
<a name="2384"></a>
<a name="2385"></a>    /*
<a name="2386"></a>     *   The *adjustment* to the match score for topic entries contained
<a name="2387"></a>     *   within this group.  This is usually a positive number, so that it
<a name="2388"></a>     *   boosts the match strength of the child topics.  
<a name="2389"></a>     */
<a name="2390"></a>    matchScoreAdjustment = 0
<a name="2391"></a>
<a name="2392"></a>    /* 
<a name="2393"></a>     *   the topic owner for any topic entries within the group is the
<a name="2394"></a>     *   topic owner taken from the group's own location 
<a name="2395"></a>     */
<a name="2396"></a>    getTopicOwner() { return location.getTopicOwner(); }
<a name="2397"></a>
<a name="2398"></a>    /* are TopicEntry objects within the group active? */
<a name="2399"></a>    topicGroupActive()
<a name="2400"></a>    {
<a name="2401"></a>        /* 
<a name="2402"></a>         *   our TopicEntry objects are active if the group condition is
<a name="2403"></a>         *   true and our container's contents are active
<a name="2404"></a>         */
<a name="2405"></a>        return isActive &amp;&amp; location.topicGroupActive();
<a name="2406"></a>    }
<a name="2407"></a>
<a name="2408"></a>    /* 
<a name="2409"></a>     *   Get my score adjustment.  We'll return our own basic score
<a name="2410"></a>     *   adjustment plus the cumulative adjustment for our containers.  
<a name="2411"></a>     */
<a name="2412"></a>    topicGroupScoreAdjustment = (matchScoreAdjustment
<a name="2413"></a>                                 + location.topicGroupScoreAdjustment)
<a name="2414"></a>
<a name="2415"></a>    /* add a topic - we'll simply add the topic directly to our container */
<a name="2416"></a>    addTopic(topic) { location.addTopic(topic); }
<a name="2417"></a>
<a name="2418"></a>    /* add a suggested topic - we'll pass this up to our container */
<a name="2419"></a>    addSuggestedTopic(topic) { location.addSuggestedTopic(topic); }
<a name="2420"></a>;
<a name="2421"></a>
<a name="2422"></a>/*
<a name="2423"></a> *   An alternative topic entry.  This makes it easy to define different
<a name="2424"></a> *   responses to a topic according to the game state; for example, we
<a name="2425"></a> *   might want to provide a different response for a topic after some
<a name="2426"></a> *   event has occurred, so that we can reflect knowledge of the event in
<a name="2427"></a> *   the response.
<a name="2428"></a> *   
<a name="2429"></a> *   A set of alternative topics is sort of like an inverted if-then-else.
<a name="2430"></a> *   You start by defining a normal TopicEntry (an AskTopic, or an
<a name="2431"></a> *   AskTellTopic, or whatever) for the basic response.  Then, you add a
<a name="2432"></a> *   nested AltTopic located within the base topic; you can add another
<a name="2433"></a> *   AltTopic nested within the base topic, and another after that, and so
<a name="2434"></a> *   on.  When we need to choose one of the topics, we'll choose the last
<a name="2435"></a> *   one that indicates it's active.  So, the order of appearance is
<a name="2436"></a> *   essentially an override order: the first AltTopic overrides its parent
<a name="2437"></a> *   TopicEntry, and each subsequent AltTopic overrides its previous
<a name="2438"></a> *   AltTopic.
<a name="2439"></a> *   
<a name="2440"></a> *   + AskTellTopic @lighthouse "It's very tall.";
<a name="2441"></a> *.  ++ AltTopic "Not really..." isActive=(...);
<a name="2442"></a> *.  ++ AltTopic "Well, maybe..." isActive=(...);
<a name="2443"></a> *.  ++ AltTopic "One more thing..." isActive=(...);
<a name="2444"></a> *   
<a name="2445"></a> *   In this example, the response we'll show for ASK ABOUT LIGHTHOUSE will
<a name="2446"></a> *   always be the LAST entry of the group that's active.  For example, if
<a name="2447"></a> *   all of the responses are active except for the very last one, then
<a name="2448"></a> *   we'll show the "Well, maybe" response, because it's the last active
<a name="2449"></a> *   response.  If the main AskTellTopic is active, but none of the
<a name="2450"></a> *   AltTopics are active, we'll show the "It's very tall" main response,
<a name="2451"></a> *   because it's the last element of the group that's active.
<a name="2452"></a> *   
<a name="2453"></a> *   Note that an AltTopic takes its matching information from its parent,
<a name="2454"></a> *   so you don't need to specify a matchObj or any other matching
<a name="2455"></a> *   information in an AltTopic.  You merely need to provide the response
<a name="2456"></a> *   text and the isActive test.  
<a name="2457"></a> */
<a name="2458"></a>class AltTopic: TopicEntry
<a name="2459"></a>    /* we match if our parent matches, and with the same score */
<a name="2460"></a>    matchTopic(fromActor, topic)
<a name="2461"></a>        { return location.matchTopic(fromActor, topic); }
<a name="2462"></a>
<a name="2463"></a>    /* we can match if our parent can match */
<a name="2464"></a>    isMatchPossible(actor, scopeList)
<a name="2465"></a>        { return location.isMatchPossible(actor, scopeList); }
<a name="2466"></a>
<a name="2467"></a>    /* we can match a pre-parse string if our parent can */
<a name="2468"></a>    matchPreParse(str, pstr) { return location.matchPreParse(str, pstr); }
<a name="2469"></a>
<a name="2470"></a>    /* set pronouns for the topic */
<a name="2471"></a>    setTopicPronouns(fromActor, topic)
<a name="2472"></a>        { location.setTopicPronouns(fromActor, topic); }
<a name="2473"></a>
<a name="2474"></a>    /* include in the same lists as our parent */
<a name="2475"></a>    includeInList = (location.includeInList)
<a name="2476"></a>
<a name="2477"></a>    /* AltTopic initialization */
<a name="2478"></a>    initializeAltTopic()
<a name="2479"></a>    {
<a name="2480"></a>        /* add myself to our parent's child list */
<a name="2481"></a>        if (location != nil)
<a name="2482"></a>            location.addAltTopic(self);
<a name="2483"></a>    }
<a name="2484"></a>
<a name="2485"></a>    /*
<a name="2486"></a>     *   Determine if this topic is active.  An AltTopic is active if its
<a name="2487"></a>     *   own isActive indicates true, AND none of its subsequent siblings
<a name="2488"></a>     *   are active.  
<a name="2489"></a>     */
<a name="2490"></a>    checkIsActive()
<a name="2491"></a>    {
<a name="2492"></a>        /* we can't be active if our own isActive says we're not */
<a name="2493"></a>        if (!isActive)
<a name="2494"></a>            return nil;
<a name="2495"></a>
<a name="2496"></a>        /* 
<a name="2497"></a>         *   Check for any active element after us in the parent's list.
<a name="2498"></a>         *   To do this, scan from the end of the parent list backwards,
<a name="2499"></a>         *   and look for an element that's active.  If we reach our own
<a name="2500"></a>         *   entry, then we'll know that there are no active entries
<a name="2501"></a>         *   following us in the list.  Note that we already know we're
<a name="2502"></a>         *   active, or we wouldn't have gotten this far, so we can simply
<a name="2503"></a>         *   look for the rightmost active element in the list.  
<a name="2504"></a>         */
<a name="2505"></a>        if (location != nil
<a name="2506"></a>            &amp;&amp; location.altTopicList.lastValWhich({x: x.isActive}) != self)
<a name="2507"></a>        {
<a name="2508"></a>            /* 
<a name="2509"></a>             *   we found an active element after ourself, so it overrides
<a name="2510"></a>             *   us - we're therefore not active 
<a name="2511"></a>             */
<a name="2512"></a>            return nil;
<a name="2513"></a>        }
<a name="2514"></a>
<a name="2515"></a>        /* ask our container if its topics are active */
<a name="2516"></a>        return location.topicGroupActive();
<a name="2517"></a>    }
<a name="2518"></a>
<a name="2519"></a>    /* take our implied-greeting status from our parent */
<a name="2520"></a>    impliesGreeting = (location.impliesGreeting)
<a name="2521"></a>
<a name="2522"></a>    /* take our conversational status from our parent */
<a name="2523"></a>    isConversational = (location.isConversational)
<a name="2524"></a>
<a name="2525"></a>    /* 
<a name="2526"></a>     *   Our relative order within our parent's list of alternatives.  By
<a name="2527"></a>     *   default, we simply return the source file ordering, which ensures
<a name="2528"></a>     *   that static AltTopic objects (i.e., those defined directly in
<a name="2529"></a>     *   source files, not dynamically created with 'new') will be ordered
<a name="2530"></a>     *   just as they're laid out in the source file.  
<a name="2531"></a>     */
<a name="2532"></a>    altTopicOrder = (sourceTextOrder)
<a name="2533"></a>
<a name="2534"></a>    /* note invocation */
<a name="2535"></a>    noteInvocation(fromActor)
<a name="2536"></a>    {
<a name="2537"></a>        /* count our own invocation */
<a name="2538"></a>        ++talkCount;
<a name="2539"></a>
<a name="2540"></a>        /* let our container know its AltTopic child is being invoked */
<a name="2541"></a>        if (location != nil)
<a name="2542"></a>            location.noteAltInvocation(fromActor, self);
<a name="2543"></a>    }
<a name="2544"></a>
<a name="2545"></a>    /* our AltTopic counter is the AltTopic counter for the enclosing topic */
<a name="2546"></a>    altTalkCount = (location != nil ? location.altTalkCount : talkCount)
<a name="2547"></a>;
<a name="2548"></a>
<a name="2549"></a>/*
<a name="2550"></a> *   A "topic match" topic entry.  This is a topic entry that matches topic
<a name="2551"></a> *   phrases in the grammar.
<a name="2552"></a> *   
<a name="2553"></a> *   Handling topic phrases is a bit tricky, because they can't be resolved
<a name="2554"></a> *   to definitive game-world objects the way ordinary noun phrases can.
<a name="2555"></a> *   Topic phrases can refer to things that aren't physically present, but
<a name="2556"></a> *   which are known to the actor performing the command; they can refer to
<a name="2557"></a> *   abstract Topic objects, that have no physical existence in the game
<a name="2558"></a> *   world at all; and they can ever be arbitrary text that doesn't match
<a name="2559"></a> *   any vocabulary defined by the game.
<a name="2560"></a> *   
<a name="2561"></a> *   Our strategy in matching topics is to first narrow the list down to
<a name="2562"></a> *   the physical and abstract game objects that both match the vocabulary
<a name="2563"></a> *   used in the command and are part of the memory of the actor performing
<a name="2564"></a> *   the command.  That much is handled by the normal topic phrase
<a name="2565"></a> *   resolution rules, and gives us a list of possible matches.  Then,
<a name="2566"></a> *   given this narrowed list of possibilities, we look through the list of
<a name="2567"></a> *   objects that we're associated with; we effectively intersect the two
<a name="2568"></a> *   lists, and if the result is non-empty, we consider it a match.
<a name="2569"></a> *   Finally, we also consider any regular expression that we're associated
<a name="2570"></a> *   with; if we have one, and the topic phrase text in the command matches
<a name="2571"></a> *   the input, we'll consider it a match.  
<a name="2572"></a> */
<a name="2573"></a>class TopicMatchTopic: TopicEntry
<a name="2574"></a>    /*  
<a name="2575"></a>     *   A regular expression pattern that we'll match to the actual topic
<a name="2576"></a>     *   text as entered in the command.  If 'matchExactCase' is true,
<a name="2577"></a>     *   we'll match the exact text in its original upper/lower case
<a name="2578"></a>     *   rendering; otherwise, we'll convert the player input to lower-case
<a name="2579"></a>     *   before matching it against the pattern.  In most cases, we'll want
<a name="2580"></a>     *   to match the input no matter what combination of upper and lower
<a name="2581"></a>     *   case the player entered, so matchExactCase is nil by default.
<a name="2582"></a>     *   
<a name="2583"></a>     *   Note that both the object (or object list) and the regular
<a name="2584"></a>     *   expression pattern can be included for a single topic entry
<a name="2585"></a>     *   object.  This allows a topic entry to match several different ways
<a name="2586"></a>     *   of entering the topic name, or to match several different topics
<a name="2587"></a>     *   with the same response.  
<a name="2588"></a>     */
<a name="2589"></a>    matchPattern = nil
<a name="2590"></a>    matchExactCase = nil
<a name="2591"></a>
<a name="2592"></a>    /* 
<a name="2593"></a>     *   Match the topic.  By default, we'll match to either the simulation
<a name="2594"></a>     *   object or objects in matchObj, or the pattern in matchPattern.
<a name="2595"></a>     *   Note that we always try both ways of matching, so a single
<a name="2596"></a>     *   AskTellTopic can define both a pattern and an object list.
<a name="2597"></a>     *   
<a name="2598"></a>     *   Subclasses can override this as desired to use other ways of
<a name="2599"></a>     *   matching.  
<a name="2600"></a>     */
<a name="2601"></a>    matchTopic(fromActor, topic)
<a name="2602"></a>    {
<a name="2603"></a>        /* 
<a name="2604"></a>         *   if we have one or more match objects, try matching to the
<a name="2605"></a>         *   topic's best simulation object match 
<a name="2606"></a>         */
<a name="2607"></a>        if (matchObj != nil)
<a name="2608"></a>        {
<a name="2609"></a>            /* 
<a name="2610"></a>             *   we have a match object or match object list - if it's a
<a name="2611"></a>             *   collection, check each element, otherwise just match the
<a name="2612"></a>             *   single object 
<a name="2613"></a>             */
<a name="2614"></a>            if (matchObj.ofKind(Collection))
<a name="2615"></a>            {
<a name="2616"></a>                /* try matching each object in the list */
<a name="2617"></a>                if (matchObj.indexWhich({x: findMatchObj(x, topic)}) != nil)
<a name="2618"></a>                    return matchScore;
<a name="2619"></a>            }
<a name="2620"></a>            else
<a name="2621"></a>            {
<a name="2622"></a>                /* match the single object */
<a name="2623"></a>                if (findMatchObj(matchObj, topic))
<a name="2624"></a>                    return matchScore;
<a name="2625"></a>            }
<a name="2626"></a>        }
<a name="2627"></a>
<a name="2628"></a>        /* 
<a name="2629"></a>         *   check for a match to the regular expression pattern, if we
<a name="2630"></a>         *   have a pattern AND the resolved topic allows literal matches 
<a name="2631"></a>         */
<a name="2632"></a>        if (matchPattern != nil &amp;&amp; topic.canMatchLiterally())
<a name="2633"></a>        {
<a name="2634"></a>            local txt;
<a name="2635"></a>
<a name="2636"></a>            /* 
<a name="2637"></a>             *   There's no match object; try matching our regular
<a name="2638"></a>             *   expression to the actual topic text.  Get the actual text.
<a name="2639"></a>             */
<a name="2640"></a>            txt = topic.getTopicText();
<a name="2641"></a>
<a name="2642"></a>            /* 
<a name="2643"></a>             *   if they don't want an exact case match, convert the
<a name="2644"></a>             *   original topic text to lower case 
<a name="2645"></a>             */
<a name="2646"></a>            if (!matchExactCase)
<a name="2647"></a>                txt = txt.toLower();
<a name="2648"></a>
<a name="2649"></a>            /* if the regular expression matches, we match */
<a name="2650"></a>            if (rexMatch(matchPattern, txt) != nil)
<a name="2651"></a>                return matchScore;
<a name="2652"></a>        }
<a name="2653"></a>
<a name="2654"></a>        /* we didn't find a match - indicate this with a nil score */
<a name="2655"></a>        return nil;
<a name="2656"></a>    }
<a name="2657"></a>
<a name="2658"></a>    /*
<a name="2659"></a>     *   Match an individual item from our match list to the given
<a name="2660"></a>     *   ResolvedTopic object.  We'll check each object in the resolved
<a name="2661"></a>     *   topic's "in scope" and "likely" lists.  
<a name="2662"></a>     */
<a name="2663"></a>    findMatchObj(obj, rt)
<a name="2664"></a>    {
<a name="2665"></a>        /* check the "in scope" list */
<a name="2666"></a>        if (rt.inScopeList.indexOf(obj) != nil)
<a name="2667"></a>            return true;
<a name="2668"></a>
<a name="2669"></a>        /* check the "likely" list */
<a name="2670"></a>        return (rt.likelyList.indexOf(obj) != nil);
<a name="2671"></a>    }
<a name="2672"></a>
<a name="2673"></a>    /*
<a name="2674"></a>     *   It's possible for us to match if any of our matchObj objects are
<a name="2675"></a>     *   known to the actor.  If we have no matchObj objects, we must be
<a name="2676"></a>     *   matching on a regular expression or on a custom condition, so we
<a name="2677"></a>     *   can't speculate on matchability; we'll simply return true in those
<a name="2678"></a>     *   cases.  
<a name="2679"></a>     */
<a name="2680"></a>    isMatchPossible(actor, scopeList)
<a name="2681"></a>    {
<a name="2682"></a>        /* check what we have in our matchObj */
<a name="2683"></a>        if (matchObj == nil)
<a name="2684"></a>        {
<a name="2685"></a>            /* 
<a name="2686"></a>             *   we have no match object, so we must match on a regular
<a name="2687"></a>             *   expression or a custom condition; we can't speculate on
<a name="2688"></a>             *   our matchability, so just return true as a default 
<a name="2689"></a>             */
<a name="2690"></a>            return true;
<a name="2691"></a>        }
<a name="2692"></a>        else if (matchObj.ofKind(Collection))
<a name="2693"></a>        {
<a name="2694"></a>            /* 
<a name="2695"></a>             *   we have a list of match objects - return true if any of
<a name="2696"></a>             *   them are known or are currently in scope 
<a name="2697"></a>             */
<a name="2698"></a>            return (matchObj.indexWhich(
<a name="2699"></a>                {x: actor.knowsAbout(x) || scopeList.indexOf(x)}) != nil);
<a name="2700"></a>        }
<a name="2701"></a>        else
<a name="2702"></a>        {
<a name="2703"></a>            /* 
<a name="2704"></a>             *   we have a single match object - return true if it's known
<a name="2705"></a>             *   or it's in scope 
<a name="2706"></a>             */
<a name="2707"></a>            return (actor.knowsAbout(matchObj)
<a name="2708"></a>                    || scopeList.indexOf(matchObj) != nil);
<a name="2709"></a>        }
<a name="2710"></a>    }
<a name="2711"></a>
<a name="2712"></a>    /* set the topic pronouns */
<a name="2713"></a>    setTopicPronouns(fromActor, topic)
<a name="2714"></a>    {
<a name="2715"></a>        /* check to see what kind of match object we have */
<a name="2716"></a>        if (matchObj == nil)
<a name="2717"></a>        {
<a name="2718"></a>            /* 
<a name="2719"></a>             *   no match object, so we must match a regular expression
<a name="2720"></a>             *   pattern; this gives us no clue what game object we might
<a name="2721"></a>             *   match, so there's nothing we can do here 
<a name="2722"></a>             */
<a name="2723"></a>        }
<a name="2724"></a>        else if (matchObj.ofKind(Collection))
<a name="2725"></a>        {
<a name="2726"></a>            local lst;
<a name="2727"></a>            
<a name="2728"></a>            /*
<a name="2729"></a>             *   We match a list of objects.  Get the subset of the
<a name="2730"></a>             *   in-scope list from the topic that we match.  Consider only
<a name="2731"></a>             *   the in-scope items for now, and consider only game-world
<a name="2732"></a>             *   objects (Things).  
<a name="2733"></a>             */
<a name="2734"></a>            lst = matchObj.subset(
<a name="2735"></a>                {x: x.ofKind(Thing) &amp;&amp; topic.inScopeList.indexOf(x) != nil});
<a name="2736"></a>
<a name="2737"></a>            /* if that didn't turn up anything, consider the likelies, too */
<a name="2738"></a>            if (lst.length() == 0)
<a name="2739"></a>                lst = matchObj.subset(
<a name="2740"></a>                    {x: (x.ofKind(Thing)
<a name="2741"></a>                         &amp;&amp; topic.likelyList.indexOf(x) != nil)});
<a name="2742"></a>
<a name="2743"></a>            /* 
<a name="2744"></a>             *   if that narrows it down to one match, make it the pronoun
<a name="2745"></a>             *   antecedent 
<a name="2746"></a>             */
<a name="2747"></a>            if (lst.length() == 1)
<a name="2748"></a>                fromActor.setPronounObj(lst[1]);
<a name="2749"></a>        }
<a name="2750"></a>        else
<a name="2751"></a>        {
<a name="2752"></a>            /* 
<a name="2753"></a>             *   we match a single object; if it's a game-world object (a
<a name="2754"></a>             *   Thing), use it as the pronoun antecedent 
<a name="2755"></a>             */
<a name="2756"></a>            if (matchObj.ofKind(Thing))
<a name="2757"></a>                fromActor.setPronounObj(matchObj);
<a name="2758"></a>        }
<a name="2759"></a>    }
<a name="2760"></a>;
<a name="2761"></a>
<a name="2762"></a>/*
<a name="2763"></a> *   A dual ASK/TELL topic database entry.  This type of topic is included
<a name="2764"></a> *   in both the ASK ABOUT and TELL ABOUT lists.
<a name="2765"></a> *   
<a name="2766"></a> *   Many authors have chosen to treat ASK and TELL as equivalent, or at
<a name="2767"></a> *   least, equivalent for most topics.  Since these verbs only very weakly
<a name="2768"></a> *   suggest what the player character is actually saying, it's frequently
<a name="2769"></a> *   the case that a given topic response makes just as much sense coming
<a name="2770"></a> *   from TELL as from ASK, or vice versa.  In these cases, it's best to
<a name="2771"></a> *   enter the topic under both ASK and TELL; which one the player tries
<a name="2772"></a> *   might simply depend on the player's frame of mind, and they might feel
<a name="2773"></a> *   cheated if one works and the other doesn't in cases where both are
<a name="2774"></a> *   equally valid.
<a name="2775"></a> */
<a name="2776"></a>class AskTellTopic: TopicMatchTopic
<a name="2777"></a>    /* include me in both the ASK and TELL lists */
<a name="2778"></a>    includeInList = [&amp;askTopics, &amp;tellTopics]
<a name="2779"></a>;
<a name="2780"></a>
<a name="2781"></a>/*
<a name="2782"></a> *   An ASK ABOUT topic database entry.  This type of topic is included in
<a name="2783"></a> *   the ASK ABOUT list only.  
<a name="2784"></a> */
<a name="2785"></a>class AskTopic: AskTellTopic
<a name="2786"></a>    includeInList = [&amp;askTopics]
<a name="2787"></a>;
<a name="2788"></a>
<a name="2789"></a>/*
<a name="2790"></a> *   A TELL ABOUT topic database entry.  This type of topic entry is
<a name="2791"></a> *   included in the TELL ABOUT list only.  
<a name="2792"></a> */
<a name="2793"></a>class TellTopic: AskTellTopic
<a name="2794"></a>    includeInList = [&amp;tellTopics]
<a name="2795"></a>;
<a name="2796"></a>
<a name="2797"></a>/*
<a name="2798"></a> *   An ASK FOR topic database entry.  This type of topic entry is
<a name="2799"></a> *   included in the ASK FOR list only. 
<a name="2800"></a> */
<a name="2801"></a>class AskForTopic: AskTellTopic
<a name="2802"></a>    includeInList = [&amp;askForTopics]
<a name="2803"></a>;
<a name="2804"></a>
<a name="2805"></a>/*
<a name="2806"></a> *   A combination ASK ABOUT and ASK FOR topic. 
<a name="2807"></a> */
<a name="2808"></a>class AskAboutForTopic: AskTellTopic
<a name="2809"></a>    includeInList = [&amp;askTopics, &amp;askForTopics]
<a name="2810"></a>;
<a name="2811"></a>
<a name="2812"></a>/* 
<a name="2813"></a> *   A combination ASK ABOUT, TELL ABOUT, and ASK FOR topic.  
<a name="2814"></a> */
<a name="2815"></a>class AskTellAboutForTopic: AskTellTopic
<a name="2816"></a>    includeInList = [&amp;askTopics, &amp;tellTopics, &amp;askForTopics]
<a name="2817"></a>;
<a name="2818"></a>
<a name="2819"></a>
<a name="2820"></a>/*
<a name="2821"></a> *   A base class for topic entries that match simple simulation objects.  
<a name="2822"></a> */
<a name="2823"></a>class ThingMatchTopic: TopicEntry
<a name="2824"></a>    /*
<a name="2825"></a>     *   Match the topic.  We'll match the simulation object in 'obj' to
<a name="2826"></a>     *   our matchObj object or list.  
<a name="2827"></a>     */
<a name="2828"></a>    matchTopic(fromActor, obj)
<a name="2829"></a>    {
<a name="2830"></a>        /* 
<a name="2831"></a>         *   if matchObj is a collection, check each element, otherwise
<a name="2832"></a>         *   just match the single object 
<a name="2833"></a>         */
<a name="2834"></a>        if (matchObj.ofKind(Collection))
<a name="2835"></a>        {
<a name="2836"></a>            /* try matching each object in the list */
<a name="2837"></a>            if (matchObj.indexOf(obj) != nil)
<a name="2838"></a>                return matchScore;
<a name="2839"></a>        }
<a name="2840"></a>        else
<a name="2841"></a>        {
<a name="2842"></a>            /* match the single object */
<a name="2843"></a>            if (matchObj == obj)
<a name="2844"></a>                return matchScore;
<a name="2845"></a>        }
<a name="2846"></a>
<a name="2847"></a>        /* didn't find a match - indicate this by returning a nil score */
<a name="2848"></a>        return nil;
<a name="2849"></a>    }
<a name="2850"></a>
<a name="2851"></a>    /*
<a name="2852"></a>     *   It's possible for us to match if any of our matchObj objects are
<a name="2853"></a>     *   in scope.
<a name="2854"></a>     */
<a name="2855"></a>    isMatchPossible(actor, scopeList)
<a name="2856"></a>    {
<a name="2857"></a>        /* check to see what kind of match object we have */
<a name="2858"></a>        if (matchObj.ofKind(Collection))
<a name="2859"></a>        {
<a name="2860"></a>            /* we can match if any of our match objects are in scope */
<a name="2861"></a>            return (matchObj.indexWhich({x: scopeList.indexOf(x)}) != nil);
<a name="2862"></a>        }
<a name="2863"></a>        else
<a name="2864"></a>        {
<a name="2865"></a>            /* we can match if our single match object is in scope */
<a name="2866"></a>            return scopeList.indexOf(matchObj);
<a name="2867"></a>        }
<a name="2868"></a>    }
<a name="2869"></a>
<a name="2870"></a>    /* set the topic pronouns */
<a name="2871"></a>    setTopicPronouns(fromActor, topic)
<a name="2872"></a>    {
<a name="2873"></a>        /* 
<a name="2874"></a>         *   the 'topic' is just an ordinary game object; as long as it's a
<a name="2875"></a>         *   Thing, set it as the antecedent 
<a name="2876"></a>         */
<a name="2877"></a>        if (topic.ofKind(Thing))
<a name="2878"></a>            fromActor.setPronounObj(topic);
<a name="2879"></a>    }
<a name="2880"></a>;
<a name="2881"></a>
<a name="2882"></a>/*
<a name="2883"></a> *   A GIVE/SHOW topic database entry.
<a name="2884"></a> *   
<a name="2885"></a> *   Note that this base class is usable for any command that refers to a
<a name="2886"></a> *   simulation object.  It's NOT suitable for ASK/TELL lists, or for other
<a name="2887"></a> *   commands that refer to topics, since we expect our 'topic' to be a
<a name="2888"></a> *   resolved simulation object.  
<a name="2889"></a> */
<a name="2890"></a>class GiveShowTopic: ThingMatchTopic
<a name="2891"></a>    /* include me in both the GIVE and SHOW lists */
<a name="2892"></a>    includeInList = [&amp;giveTopics, &amp;showTopics]
<a name="2893"></a>;
<a name="2894"></a>
<a name="2895"></a>/*
<a name="2896"></a> *   A GIVE TO topic database entry.  This type of topic entry is included
<a name="2897"></a> *   in the GIVE TO list only.  
<a name="2898"></a> */
<a name="2899"></a>class GiveTopic: GiveShowTopic
<a name="2900"></a>    includeInList = [&amp;giveTopics]
<a name="2901"></a>;
<a name="2902"></a>
<a name="2903"></a>/*
<a name="2904"></a> *   A SHOW TO topic database entry.  This type of topic entry is included
<a name="2905"></a> *   in the SHOW TO list only.  
<a name="2906"></a> */
<a name="2907"></a>class ShowTopic: GiveShowTopic
<a name="2908"></a>    includeInList = [&amp;showTopics]
<a name="2909"></a>;
<a name="2910"></a>
<a name="2911"></a>/*
<a name="2912"></a> *   A TopicEntry that can match a Thing or a Topic.  This can be used to
<a name="2913"></a> *   combine ASK/TELL-type responses and GIVE/SHOW-type responses in a
<a name="2914"></a> *   single topic entry. 
<a name="2915"></a> *   
<a name="2916"></a> *   When this kind of topic is used as a suggested topic, note that you
<a name="2917"></a> *   should name the suggestion according to the least restrictive verb.
<a name="2918"></a> *   This is important because the suggestion will be active if any of the
<a name="2919"></a> *   verbs would allow it; to ensure that we suggest a verb that will
<a name="2920"></a> *   actually work, we should thus use the least restrictive verb.  In
<a name="2921"></a> *   practice, this means you should use ASK or TELL as the suggestion
<a name="2922"></a> *   name, because an object merely has to be known to be used as a topic;
<a name="2923"></a> *   it might be possible to ASK/TELL about an object but not GIVE/SHOW the
<a name="2924"></a> *   object, because the object is known but not currently in scope.  
<a name="2925"></a> */
<a name="2926"></a>class TopicOrThingMatchTopic: ThingMatchTopic, TopicMatchTopic
<a name="2927"></a>    matchTopic(fromActor, obj)
<a name="2928"></a>    {
<a name="2929"></a>        /* 
<a name="2930"></a>         *   if we're being asked to match a ResolvedTopic, use the
<a name="2931"></a>         *   inherited TopicMatchTopic handling; otherwise, use the
<a name="2932"></a>         *   inherited ThingMatchTopic handling 
<a name="2933"></a>         */
<a name="2934"></a>        if (obj.ofKind(ResolvedTopic))
<a name="2935"></a>            return inherited TopicMatchTopic(fromActor, obj);
<a name="2936"></a>        else
<a name="2937"></a>            return inherited ThingMatchTopic(fromActor, obj);
<a name="2938"></a>    }
<a name="2939"></a>
<a name="2940"></a>    isMatchPossible(actor, scopeList)
<a name="2941"></a>    {
<a name="2942"></a>        /* if a match is possible from either subclass, allow it */
<a name="2943"></a>        return (inherited TopicMatchTopic(actor, scopeList)
<a name="2944"></a>                || inherited ThingMatchTopic(actor, scopeList));
<a name="2945"></a>    }
<a name="2946"></a>
<a name="2947"></a>    setTopicPronouns(fromActor, obj)
<a name="2948"></a>    {
<a name="2949"></a>        /* 
<a name="2950"></a>         *   if the object is a ResolvedTopic, use the inherited
<a name="2951"></a>         *   TopicMatchTopic handling, otherwise use the ThingMatchTopic
<a name="2952"></a>         *   handling 
<a name="2953"></a>         */
<a name="2954"></a>        if (obj.ofKind(ResolvedTopic))
<a name="2955"></a>            return inherited TopicMatchTopic(fromActor, obj);
<a name="2956"></a>        else
<a name="2957"></a>            return inherited ThingMatchTopic(fromActor, obj);
<a name="2958"></a>    }
<a name="2959"></a>;
<a name="2960"></a>
<a name="2961"></a>/*
<a name="2962"></a> *   A combined ASK/TELL/SHOW topic.  Players will sometimes want to point
<a name="2963"></a> *   something out when it's visible, rather than asking about it; this
<a name="2964"></a> *   allows SHOW TO to be used as a synonym for ASK ABOUT for these cases. 
<a name="2965"></a> */
<a name="2966"></a>class AskTellShowTopic: TopicOrThingMatchTopic
<a name="2967"></a>    includeInList = [&amp;askTopics, &amp;tellTopics, &amp;showTopics]
<a name="2968"></a>;
<a name="2969"></a>
<a name="2970"></a>/*
<a name="2971"></a> *   A combined ASK/TELL/GIVE/SHOW topic.
<a name="2972"></a> */
<a name="2973"></a>class AskTellGiveShowTopic: TopicOrThingMatchTopic
<a name="2974"></a>    includeInList = [&amp;askTopics, &amp;tellTopics, &amp;giveTopics, &amp;showTopics]
<a name="2975"></a>;
<a name="2976"></a>
<a name="2977"></a>/*
<a name="2978"></a> *   A command topic.  This is used to respond to orders given to an NPC,
<a name="2979"></a> *   as in "BOB, GO EAST."  The match object for this kind of topic entry
<a name="2980"></a> *   is an Action class; for example, to create a response to "BOB, LOOK",
<a name="2981"></a> *   we'd create a CommandTopic that matches LookAction.
<a name="2982"></a> *   
<a name="2983"></a> *   If you're designing a CommandTopic for a command can be accepted from
<a name="2984"></a> *   a remote location, such as by telephone, you should be aware that the
<a name="2985"></a> *   command will be running in the NPC's visual sense context.  This means
<a name="2986"></a> *   that if the player character can't see the NPC, the topic result
<a name="2987"></a> *   message will be hidden - the NPC's visual sense context hides all
<a name="2988"></a> *   messages generated while it's in effect if the PC can't see the NPC.
<a name="2989"></a> *   This is usually desirable, since most messages relay visual
<a name="2990"></a> *   information that wouldn't be visible to the player character if the PC
<a name="2991"></a> *   can't see the subject of the message.  However, if you've specifically
<a name="2992"></a> *   designed your CommandTopic to work remotely, this isn't at all what
<a name="2993"></a> *   you want, since you've already taken the remoteness into account in
<a name="2994"></a> *   the message and thus want the message to be displayed after all.  The
<a name="2995"></a> *   way to handle this is to wrap the message in a callWithSenseContext()
<a name="2996"></a> *   with a nil sense context.  For example:
<a name="2997"></a> *   
<a name="2998"></a> *   topicResponse()
<a name="2999"></a> *.     { callWithSenseContext(nil, nil, {: "Here's my message!" }); }
<a name="3000"></a> */
<a name="3001"></a>class CommandTopic: TopicEntry
<a name="3002"></a>    /* we go in the command topics list */
<a name="3003"></a>    includeInList = [&amp;commandTopics]
<a name="3004"></a>
<a name="3005"></a>    /* match the topic */
<a name="3006"></a>    matchTopic(fromActor, obj)
<a name="3007"></a>    {
<a name="3008"></a>        /* 
<a name="3009"></a>         *   Check the collection or the single object, as needed.  Note
<a name="3010"></a>         *   that our match object is an Action base class, so we must
<a name="3011"></a>         *   match if 'obj' is of the match object class. 
<a name="3012"></a>         */
<a name="3013"></a>        if (matchObj.ofKind(Collection))
<a name="3014"></a>        {
<a name="3015"></a>            /* check each entry for a match */
<a name="3016"></a>            if (matchObj.indexWhich({x: obj.ofKind(x)}) != nil)
<a name="3017"></a>                return matchScore;
<a name="3018"></a>        }
<a name="3019"></a>        else
<a name="3020"></a>        {
<a name="3021"></a>            /* check our single object */
<a name="3022"></a>            if (obj.ofKind(matchObj))
<a name="3023"></a>                return matchScore;
<a name="3024"></a>        }
<a name="3025"></a>
<a name="3026"></a>        /* didn't find a match */
<a name="3027"></a>        return nil;
<a name="3028"></a>    }
<a name="3029"></a>
<a name="3030"></a>    /* 
<a name="3031"></a>     *   we can always match, since the player can always type in any
<a name="3032"></a>     *   possible action 
<a name="3033"></a>     */
<a name="3034"></a>    isMatchPossible(actor, scopeList) { return true; }
<a name="3035"></a>
<a name="3036"></a>    /* we have no pronouns to set */
<a name="3037"></a>    setTopicPronouns(fromActor, topic) { }
<a name="3038"></a>;
<a name="3039"></a>
<a name="3040"></a>/*
<a name="3041"></a> *   A base class for simple miscellaneous topics.  These handle things
<a name="3042"></a> *   like YES, NO, HELLO, and GOODBYE, where the topic is entirely
<a name="3043"></a> *   contained in the verb, and there's no separate noun phrase needed to
<a name="3044"></a> *   indicate the topic.  
<a name="3045"></a> */
<a name="3046"></a>class MiscTopic: TopicEntry
<a name="3047"></a>    matchTopic(fromActor, obj)
<a name="3048"></a>    {
<a name="3049"></a>        /* 
<a name="3050"></a>         *   if it's one of our matching topics, return our match score,
<a name="3051"></a>         *   otherwise return a nil score to indicate failure 
<a name="3052"></a>         */
<a name="3053"></a>        return (matchList.indexOf(obj) != nil) ? matchScore : nil;
<a name="3054"></a>    }
<a name="3055"></a>
<a name="3056"></a>    /* 
<a name="3057"></a>     *   a match is always possible for simple verb topics (since the
<a name="3058"></a>     *   player could always type the verb) 
<a name="3059"></a>     */
<a name="3060"></a>    isMatchPossible(actor, scopeList) { return true; }
<a name="3061"></a>;
<a name="3062"></a>
<a name="3063"></a>/*
<a name="3064"></a> *   A greeting topic - this handles a HELLO or TALK TO command, as well
<a name="3065"></a> *   as implied greetings (the kind of greeting generated when we jump
<a name="3066"></a> *   directly into a conversation with an actor that uses stateful
<a name="3067"></a> *   conversations, by typing a command like ASK ABOUT or TELL ABOUT
<a name="3068"></a> *   without first saying HELLO explicitly).
<a name="3069"></a> */
<a name="3070"></a>class HelloTopic: MiscTopic
<a name="3071"></a>    includeInList = [&amp;miscTopics]
<a name="3072"></a>    matchList = [helloTopicObj, impHelloTopicObj]
<a name="3073"></a>
<a name="3074"></a>    /* 
<a name="3075"></a>     *   this is an explicit greeting, so it obviously shouldn't trigger
<a name="3076"></a>     *   an implied greeting, regardless of how conversational we are
<a name="3077"></a>     */
<a name="3078"></a>    impliesGreeting = nil
<a name="3079"></a>
<a name="3080"></a>    /* 
<a name="3081"></a>     *   if we use this as a greeting upon entering a ConvNode, we'll want
<a name="3082"></a>     *   to stay in the node afterward
<a name="3083"></a>     */
<a name="3084"></a>    noteInvocation(fromActor)
<a name="3085"></a>    {
<a name="3086"></a>        inherited(fromActor);
<a name="3087"></a>        "&lt;.convstay&gt;";
<a name="3088"></a>    }
<a name="3089"></a>;
<a name="3090"></a>
<a name="3091"></a>/*
<a name="3092"></a> *   An implied greeting topic.  This handles ONLY implied greetings.
<a name="3093"></a> *   
<a name="3094"></a> *   Note that we have a higher-than-normal score by default.  This makes
<a name="3095"></a> *   it easy to program two common cases for conversational states.
<a name="3096"></a> *   First, the more common case, where you want a single message for both
<a name="3097"></a> *   implied and explicit greetings: just create a HelloTopic, since that
<a name="3098"></a> *   responds to both kinds.  Second, the less common case, where we want
<a name="3099"></a> *   to differentiate, writing separate responses for implied and explicit
<a name="3100"></a> *   greetings: create a HelloTopic for the explicit kind, and ALSO create
<a name="3101"></a> *   an ImpHelloTopic for the implied kind.  Since the ImpHelloTopic has a
<a name="3102"></a> *   higher score, it'll overshadow the HelloTopic object when it matches
<a name="3103"></a> *   an implied greeting; but since ImpHelloTopic doesn't match an
<a name="3104"></a> *   explicit greeting, we'll fall back on the HelloTopic for that.  
<a name="3105"></a> */
<a name="3106"></a>class ImpHelloTopic: MiscTopic
<a name="3107"></a>    includeInList = [&amp;miscTopics]
<a name="3108"></a>    matchList = [impHelloTopicObj]
<a name="3109"></a>    matchScore = 200
<a name="3110"></a>
<a name="3111"></a>    /* 
<a name="3112"></a>     *   this is itself a greeting, so we obviously don't want to trigger
<a name="3113"></a>     *   another greeting to greet the greeting
<a name="3114"></a>     */
<a name="3115"></a>    impliesGreeting = nil
<a name="3116"></a>
<a name="3117"></a>    /* 
<a name="3118"></a>     *   if we use this as a greeting upon entering a ConvNode, we'll want
<a name="3119"></a>     *   to stay in the node afterward
<a name="3120"></a>     */
<a name="3121"></a>    noteInvocation(fromActor)
<a name="3122"></a>    {
<a name="3123"></a>        inherited(fromActor);
<a name="3124"></a>        "&lt;.convstay&gt;";
<a name="3125"></a>    }
<a name="3126"></a>;
<a name="3127"></a>
<a name="3128"></a>/*
<a name="3129"></a> *   Actor Hello topic - this handles greetings when an NPC initiates the
<a name="3130"></a> *   conversation. 
<a name="3131"></a> */
<a name="3132"></a>class ActorHelloTopic: MiscTopic
<a name="3133"></a>    includeInList = [&amp;miscTopics]
<a name="3134"></a>    matchList = [actorHelloTopicObj]
<a name="3135"></a>    matchScore = 200
<a name="3136"></a>
<a name="3137"></a>    /* this is a greeting, so we don't want to trigger another greeting */
<a name="3138"></a>    impliesGreeting = nil
<a name="3139"></a>
<a name="3140"></a>    /* 
<a name="3141"></a>     *   if we use this as a greeting upon entering a ConvNode, we'll want
<a name="3142"></a>     *   to stay in the node afterward
<a name="3143"></a>     */
<a name="3144"></a>    noteInvocation(fromActor)
<a name="3145"></a>    {
<a name="3146"></a>        inherited(fromActor);
<a name="3147"></a>        "&lt;.convstay&gt;";
<a name="3148"></a>    }
<a name="3149"></a>;
<a name="3150"></a>
<a name="3151"></a>/*
<a name="3152"></a> *   A goodbye topic - this handles both explicit GOODBYE commands and
<a name="3153"></a> *   implied goodbyes.  Implied goodbyes happen when a conversation ends
<a name="3154"></a> *   without an explicit GOODBYE command, such as when the player character
<a name="3155"></a> *   walks away from the NPC, or the NPC gets bored and wanders off, or the
<a name="3156"></a> *   NPC terminates the conversation of its own volition.  
<a name="3157"></a> */
<a name="3158"></a>class ByeTopic: MiscTopic
<a name="3159"></a>    includeInList = [&amp;miscTopics]
<a name="3160"></a>    matchList = [byeTopicObj,
<a name="3161"></a>                 leaveByeTopicObj, boredByeTopicObj, actorByeTopicObj]
<a name="3162"></a>
<a name="3163"></a>    /* 
<a name="3164"></a>     *   If we're not already in a conversation when we say GOODBYE, don't
<a name="3165"></a>     *   bother saying HELLO implicitly - if the player is saying GOODBYE
<a name="3166"></a>     *   explicitly, she probably has the impression that there's some kind
<a name="3167"></a>     *   of interaction already going on with the NPC.  If we didn't
<a name="3168"></a>     *   override this, you'd get an automatic HELLO followed by the
<a name="3169"></a>     *   explicit GOODBYE when not already in conversation, which is a
<a name="3170"></a>     *   little weird. 
<a name="3171"></a>     */
<a name="3172"></a>    impliesGreeting = nil
<a name="3173"></a>;
<a name="3174"></a>
<a name="3175"></a>/* 
<a name="3176"></a> *   An implied goodbye topic.  This handles ONLY automatic (implied)
<a name="3177"></a> *   conversation endings, which happen when we walk away from an actor
<a name="3178"></a> *   we're talking to, or the other actor ends the conversation after being
<a name="3179"></a> *   ignored for too long, or the other actor ends the conversation of its
<a name="3180"></a> *   own volition via npc.endConversation().
<a name="3181"></a> *   
<a name="3182"></a> *   We use a higher-than-default matchScore so that any time we have both
<a name="3183"></a> *   a ByeTopic and an ImpByeTopic that are both active, we'll choose the
<a name="3184"></a> *   more specific ImpByeTopic.  
<a name="3185"></a> */
<a name="3186"></a>class ImpByeTopic: MiscTopic
<a name="3187"></a>    includeInList = [&amp;miscTopics]
<a name="3188"></a>    matchList = [leaveByeTopicObj, boredByeTopicObj, actorByeTopicObj]
<a name="3189"></a>    matchScore = 200
<a name="3190"></a>;
<a name="3191"></a>
<a name="3192"></a>/*
<a name="3193"></a> *   A "bored" goodbye topic.  This handles ONLY goodbyes that happen when
<a name="3194"></a> *   the actor we're talking terminates the conversation out of boredom
<a name="3195"></a> *   (i.e., after a period of inactivity in the conversation).
<a name="3196"></a> *   
<a name="3197"></a> *   Note that this is a subset of ImpByeTopic - ImpByeTopic handles
<a name="3198"></a> *   "bored" and "leaving" goodbyes, while this one handles only the
<a name="3199"></a> *   "bored" goodbyes.  You can use this kind of topic if you want to
<a name="3200"></a> *   differentiate the responses to "bored" and "leaving" conversation
<a name="3201"></a> *   endings.  
<a name="3202"></a> */
<a name="3203"></a>class BoredByeTopic: MiscTopic
<a name="3204"></a>    includeInList = [&amp;miscTopics]
<a name="3205"></a>    matchList = [boredByeTopicObj]
<a name="3206"></a>    matchScore = 300
<a name="3207"></a>;
<a name="3208"></a>
<a name="3209"></a>/*
<a name="3210"></a> *   A "leaving" goodbye topic.  This handles ONLY goodbyes that happen
<a name="3211"></a> *   when the PC walks away from the actor they're talking to.
<a name="3212"></a> *   
<a name="3213"></a> *   Note that this is a subset of ImpByeTopic - ImpByeTopic handles
<a name="3214"></a> *   "bored" and "leaving" goodbyes, while this one handles only the
<a name="3215"></a> *   "leaving" goodbyes.  You can use this kind of topic if you want to
<a name="3216"></a> *   differentiate the responses to "bored" and "leaving" conversation
<a name="3217"></a> *   endings.  
<a name="3218"></a> */
<a name="3219"></a>class LeaveByeTopic: MiscTopic
<a name="3220"></a>    includeInList = [&amp;miscTopics]
<a name="3221"></a>    matchList = [leaveByeTopicObj]
<a name="3222"></a>    matchScore = 300
<a name="3223"></a>;
<a name="3224"></a>
<a name="3225"></a>/*
<a name="3226"></a> *   An "actor" goodbye topic.  This handles ONLY goodbyes that happen when
<a name="3227"></a> *   the NPC terminates the conversation of its own volition via
<a name="3228"></a> *   npc.endConversation(). 
<a name="3229"></a> */
<a name="3230"></a>class ActorByeTopic: MiscTopic
<a name="3231"></a>    includeInList = [&amp;miscTopics]
<a name="3232"></a>    matchList = [actorByeTopicObj]
<a name="3233"></a>    matchScore = 300
<a name="3234"></a>;
<a name="3235"></a>
<a name="3236"></a>/* a topic for both HELLO and GOODBYE */
<a name="3237"></a>class HelloGoodbyeTopic: MiscTopic
<a name="3238"></a>    includeInList = [&amp;miscTopics]
<a name="3239"></a>    matchList = [helloTopicObj, impHelloTopicObj,
<a name="3240"></a>                 byeTopicObj, boredByeTopicObj, leaveByeTopicObj,
<a name="3241"></a>                 actorByeTopicObj]
<a name="3242"></a>
<a name="3243"></a>    /* 
<a name="3244"></a>     *   since we handle greetings, we don't want to trigger a separate
<a name="3245"></a>     *   implied greeting 
<a name="3246"></a>     */
<a name="3247"></a>    impliesGreeting = nil
<a name="3248"></a>;
<a name="3249"></a>
<a name="3250"></a>/* 
<a name="3251"></a> *   Topic singletons representing HELLO and GOODBYE topics.  These are
<a name="3252"></a> *   used as the parameter to matchTopic() when we're looking for the
<a name="3253"></a> *   response to the corresponding verbs. 
<a name="3254"></a> */
<a name="3255"></a>helloTopicObj: object;
<a name="3256"></a>byeTopicObj: object;
<a name="3257"></a>
<a name="3258"></a>/* 
<a name="3259"></a> *   a topic singleton for implied greetings (the kind of greeting that
<a name="3260"></a> *   happens when we jump right into a conversation with a command like
<a name="3261"></a> *   ASK ABOUT or TELL ABOUT, rather than explicitly saying HELLO first) 
<a name="3262"></a> */
<a name="3263"></a>impHelloTopicObj: object;
<a name="3264"></a>
<a name="3265"></a>/*
<a name="3266"></a> *   a topic singleton for an NPC-initiated hello (this is the kind of
<a name="3267"></a> *   greeting that happens when the NPC is the one who initiates the
<a name="3268"></a> *   conversation, via actor.initiateConversation()) 
<a name="3269"></a> */
<a name="3270"></a>actorHelloTopicObj: object;
<a name="3271"></a>
<a name="3272"></a>
<a name="3273"></a>/* 
<a name="3274"></a> *   topic singletons for the two kinds of automatic goodbyes (the kind of
<a name="3275"></a> *   conversation ending that happens when we simply walk away from an
<a name="3276"></a> *   actor we're in conversation with, or when we ignore the other actor
<a name="3277"></a> *   for enough turns that the actor gets bored and ends the conversation
<a name="3278"></a> *   of its own volition) 
<a name="3279"></a> */
<a name="3280"></a>boredByeTopicObj: object;
<a name="3281"></a>leaveByeTopicObj: object;
<a name="3282"></a>
<a name="3283"></a>/*
<a name="3284"></a> *   a topic singleton for an NPC-initiated goodbye (this is the kind of
<a name="3285"></a> *   goodbye that happens when the NPC is the one who breaks off the
<a name="3286"></a> *   conversation, via npc.endConversation()) 
<a name="3287"></a> */
<a name="3288"></a>actorByeTopicObj: object;
<a name="3289"></a>
<a name="3290"></a>/*
<a name="3291"></a> *   A YES/NO topic.  These handle YES and/or NO, which are normally used
<a name="3292"></a> *   as responses to questions posed by the NPC.  YesNoTopic is the base
<a name="3293"></a> *   class, and can be used to create a single response for both YES and
<a name="3294"></a> *   NO; YesTopic provides a response just for YES; and NoTopic provides a
<a name="3295"></a> *   response just for NO.  The only thing an instance of these classes
<a name="3296"></a> *   should normally need to specify is the response text (or a list of
<a name="3297"></a> *   response strings, by multiply inheriting from an EventList subclass as
<a name="3298"></a> *   usual).  
<a name="3299"></a> */
<a name="3300"></a>class YesNoTopic: MiscTopic
<a name="3301"></a>    includeInList = [&amp;miscTopics]
<a name="3302"></a>
<a name="3303"></a>    /* 
<a name="3304"></a>     *   our list of matching topic objects - we'll only ever be asked to
<a name="3305"></a>     *   match 'yesTopicObj' (for YES inputs) or 'noTopicObj' (for NO
<a name="3306"></a>     *   inputs) 
<a name="3307"></a>     */
<a name="3308"></a>    matchList = [yesTopicObj, noTopicObj]
<a name="3309"></a>;
<a name="3310"></a>
<a name="3311"></a>class YesTopic: YesNoTopic
<a name="3312"></a>    matchList = [yesTopicObj]
<a name="3313"></a>;
<a name="3314"></a>
<a name="3315"></a>class NoTopic: YesNoTopic
<a name="3316"></a>    matchList = [noTopicObj]
<a name="3317"></a>;
<a name="3318"></a>
<a name="3319"></a>/*
<a name="3320"></a> *   Topic singletons representing the "topic" of YES and NO commands.  We
<a name="3321"></a> *   use these as the parameter to matchTopic() in the TopicEntry objects
<a name="3322"></a> *   when we're looking for a response to a YES or NO command.  
<a name="3323"></a> */
<a name="3324"></a>yesTopicObj: object;
<a name="3325"></a>noTopicObj: object;
<a name="3326"></a>
<a name="3327"></a>
<a name="3328"></a>/*
<a name="3329"></a> *   A default topic entry.  This is an easy way to create an entry that
<a name="3330"></a> *   will be used as a last resort, if no other entry is found.  This kind
<a name="3331"></a> *   of entry will match *any* topic, but with the lowest possible score,
<a name="3332"></a> *   so it will only be used if there's no other match for the topic.
<a name="3333"></a> *   
<a name="3334"></a> *   It's a good idea to provide some variety in a character's default
<a name="3335"></a> *   responses, because it seems that in every real game session, the
<a name="3336"></a> *   player will at some point spend a while peppering an NPC with
<a name="3337"></a> *   questions on every topic that comes to mind.  Usually, the player will
<a name="3338"></a> *   think of many things that the author didn't anticipate.  The more
<a name="3339"></a> *   things the author covers, the better, but it's unrealistic to think
<a name="3340"></a> *   that an author can reasonably anticipate every topic, or even most
<a name="3341"></a> *   topics, that players will think of.  So, we'll have a whole bunch of
<a name="3342"></a> *   ASK, ASK, ASK commands all at once, and much of the time we'll get a
<a name="3343"></a> *   bunch of default responses in a row.  It gets tedious in these cases
<a name="3344"></a> *   when the NPC repeats the same default response over and over.
<a name="3345"></a> *   
<a name="3346"></a> *   A simple but effective trick is to provide three or four random
<a name="3347"></a> *   variations on "I don't know that," customized for the character.  This
<a name="3348"></a> *   makes the NPC seem less like a totally predictable robot, and it can
<a name="3349"></a> *   also be a convenient place to flesh out the character a bit.  An easy
<a name="3350"></a> *   way to do this is to add ShuffledEventList to the superclass list of
<a name="3351"></a> *   the default topic entry, and provide a eventList list with the various
<a name="3352"></a> *   random responses.  For example:
<a name="3353"></a> *   
<a name="3354"></a> *   + DefaultAskTellTopic, ShuffledEventList
<a name="3355"></a> *.    ['Bob mutters something unintelligible and keeps fiddling with
<a name="3356"></a> *.     the radio. ',
<a name="3357"></a> *.     'Bob looks up from the radio for a second, but then goes back
<a name="3358"></a> *.     to adjusting the knobs. ',
<a name="3359"></a> *.     'Bob just keeps adjusting the radio, completely ignoring you. ']
<a name="3360"></a> *.  ;
<a name="3361"></a> *   
<a name="3362"></a> *   It's important to be rather generic in default responses; in
<a name="3363"></a> *   particular, it's a bad idea to suggest that the NPC doesn't know about
<a name="3364"></a> *   the topic.  From the author's perspective, it's easy to make the
<a name="3365"></a> *   mistake of thinking "this is a default response, so it'll only be used
<a name="3366"></a> *   for topics that are completely off in left field."  Wrong!  Sometimes
<a name="3367"></a> *   the player will indeed ask about completely random stuff, but in
<a name="3368"></a> *   *most* cases, the player is only asking because they think it's a
<a name="3369"></a> *   reasonable thing to ask about.  Defaults that say things like "I don't
<a name="3370"></a> *   know anything about that" or "What a crazy thing to ask about" or "You
<a name="3371"></a> *   must be stupid if you think I know about that!" can make a game look
<a name="3372"></a> *   poorly implemented, because these will inevitably be shown in response
<a name="3373"></a> *   to questions that the NPC really ought to know about:
<a name="3374"></a> *   
<a name="3375"></a> *.  &gt;ask bob about his mother
<a name="3376"></a> *.  "I don't know anything about that!"
<a name="3377"></a> *.  
<a name="3378"></a> *.  &gt;ask bob about his father
<a name="3379"></a> *.  "You'd have to be a moron to think I'd know about that!"
<a name="3380"></a> *   
<a name="3381"></a> *   It's better to use responses that suggest that the NPC is
<a name="3382"></a> *   uninterested, or is hostile, or is preoccupied with something else, or
<a name="3383"></a> *   doesn't understand the question, or something else appropriate to the
<a name="3384"></a> *   character.  If you can manage to make the response about the
<a name="3385"></a> *   *character*, rather than the topic, it'll reduce the chances that the
<a name="3386"></a> *   response is jarringly illogical.  
<a name="3387"></a> */
<a name="3388"></a>class DefaultTopic: TopicEntry
<a name="3389"></a>    /*
<a name="3390"></a>     *   A list of objects to exclude from the default match.  This can be
<a name="3391"></a>     *   used to create a default topic that matches everything EXCEPT a
<a name="3392"></a>     *   few specific topics that are handled in enclosing topic databases.
<a name="3393"></a>     *   For example, if you want to create a catch-all in a ConvNode's
<a name="3394"></a>     *   list of topics, but you want a particular topic to escape the
<a name="3395"></a>     *   catch-all and be sent instead to the Actor's topic database, you
<a name="3396"></a>     *   can put that topic in the exclude list for the catch-all, making
<a name="3397"></a>     *   it a catch-almost-all.  
<a name="3398"></a>     */
<a name="3399"></a>    excludeMatch = []
<a name="3400"></a>
<a name="3401"></a>    /* match anything except topics in our exclude list */
<a name="3402"></a>    matchTopic(fromActor, topic)
<a name="3403"></a>    {
<a name="3404"></a>        /* 
<a name="3405"></a>         *   If the topic matches anything in the exclusion list, do NOT
<a name="3406"></a>         *   match the topic.  If 'topic' is a ResolvedTopic, search its
<a name="3407"></a>         *   in-scope and 'likely' lists; otherwise search for 'topic'
<a name="3408"></a>         *   directly in the exclusion list.  
<a name="3409"></a>         */
<a name="3410"></a>        if (topic.ofKind(ResolvedTopic))
<a name="3411"></a>        {
<a name="3412"></a>            /* it's a resolved topic, so search the in-scope/likely lists */
<a name="3413"></a>            if (topic.inScopeList.intersect(excludeMatch).length() != 0
<a name="3414"></a>                || topic.likelyList.intersect(excludeMatch).length() != 0)
<a name="3415"></a>                return nil;
<a name="3416"></a>        }
<a name="3417"></a>        else if (excludeMatch.indexOf(topic) != nil)
<a name="3418"></a>            return nil;
<a name="3419"></a>
<a name="3420"></a>        /* match anything else with our score */
<a name="3421"></a>        return matchScore;
<a name="3422"></a>    }
<a name="3423"></a>
<a name="3424"></a>    /* use a low default matching score */
<a name="3425"></a>    matchScore = 1
<a name="3426"></a>
<a name="3427"></a>    /* a match is always possible for a default topic */
<a name="3428"></a>    isMatchPossible(actor, scopeList) { return true; }
<a name="3429"></a>
<a name="3430"></a>    /* set the topic pronoun */
<a name="3431"></a>    setTopicPronouns(fromActor, topic)
<a name="3432"></a>    {
<a name="3433"></a>        /*
<a name="3434"></a>         *   We're not matching anything, so we can get no guidance from
<a name="3435"></a>         *   the match object.  Instead, look at the topic itself.  If it's
<a name="3436"></a>         *   a Thing, set the Thing as the antecedent.  If it's a
<a name="3437"></a>         *   ResolvedTopic, and there's only one Thing match in scope, or
<a name="3438"></a>         *   only one Thing match in the likely list, set that.  Otherwise,
<a name="3439"></a>         *   we have no grounds for guessing.  
<a name="3440"></a>         */
<a name="3441"></a>        if (topic != nil)
<a name="3442"></a>        {
<a name="3443"></a>            if (topic.ofKind(Thing))
<a name="3444"></a>            {
<a name="3445"></a>                /* we have a Thing - use it as the antecedent */
<a name="3446"></a>                fromActor.setPronounObj(topic);
<a name="3447"></a>            }
<a name="3448"></a>            else if (topic.ofKind(ResolvedTopic))
<a name="3449"></a>            {
<a name="3450"></a>                local lst;
<a name="3451"></a>                
<a name="3452"></a>                /* 
<a name="3453"></a>                 *   if there's only one Thing in scope, or only one Thing
<a name="3454"></a>                 *   in the 'likely' list, use it 
<a name="3455"></a>                 */
<a name="3456"></a>                lst = topic.inScopeList.subset({x: x.ofKind(Thing)});
<a name="3457"></a>                if (lst.length() == 0)
<a name="3458"></a>                    lst = topic.likelyList.subset({x: x.ofKind(Thing)});
<a name="3459"></a>
<a name="3460"></a>                /* if we got exactly one object, it's the antecedent */
<a name="3461"></a>                if (lst.length() == 1)
<a name="3462"></a>                    fromActor.setPronounObj(lst[1]);
<a name="3463"></a>            }
<a name="3464"></a>        }
<a name="3465"></a>    }
<a name="3466"></a>;
<a name="3467"></a>
<a name="3468"></a>/* 
<a name="3469"></a> *   Default topic entries for different uses.  We'll use a hierarchy of
<a name="3470"></a> *   low match scores, in descending order of specificity: 3 for
<a name="3471"></a> *   single-type defaults (ASK only, for example), 2 for multi-type
<a name="3472"></a> *   defaults (ASK/TELL), and 1 for the ANY default.  
<a name="3473"></a> */
<a name="3474"></a>class DefaultCommandTopic: DefaultTopic
<a name="3475"></a>    includeInList = [&amp;commandTopics]
<a name="3476"></a>    matchScore = 3
<a name="3477"></a>;
<a name="3478"></a>class DefaultAskTopic: DefaultTopic
<a name="3479"></a>    includeInList = [&amp;askTopics]
<a name="3480"></a>    matchScore = 3
<a name="3481"></a>;
<a name="3482"></a>class DefaultTellTopic: DefaultTopic
<a name="3483"></a>    includeInList = [&amp;tellTopics]
<a name="3484"></a>    matchScore = 3
<a name="3485"></a>;
<a name="3486"></a>class DefaultAskTellTopic: DefaultTopic
<a name="3487"></a>    includeInList = [&amp;askTopics, &amp;tellTopics]
<a name="3488"></a>    matchScore = 2
<a name="3489"></a>;
<a name="3490"></a>class DefaultGiveTopic: DefaultTopic
<a name="3491"></a>    includeInList = [&amp;giveTopics]
<a name="3492"></a>    matchScore = 3
<a name="3493"></a>;
<a name="3494"></a>class DefaultShowTopic: DefaultTopic
<a name="3495"></a>    includeInList = [&amp;showTopics]
<a name="3496"></a>    matchScore = 3
<a name="3497"></a>;
<a name="3498"></a>class DefaultGiveShowTopic: DefaultTopic
<a name="3499"></a>    includeInList = [&amp;giveTopics, &amp;showTopics]
<a name="3500"></a>    matchScore = 2
<a name="3501"></a>;
<a name="3502"></a>class DefaultAskForTopic: DefaultTopic
<a name="3503"></a>    includeInList = [&amp;askForTopics]
<a name="3504"></a>    matchScore = 3
<a name="3505"></a>;
<a name="3506"></a>class DefaultAnyTopic: DefaultTopic
<a name="3507"></a>    includeInList = [&amp;askTopics, &amp;tellTopics, &amp;showTopics, &amp;giveTopics,
<a name="3508"></a>                     &amp;askForTopics, &amp;miscTopics, &amp;commandTopics]
<a name="3509"></a>
<a name="3510"></a>    /* 
<a name="3511"></a>     *   exclude these from actor-initiated hellos &amp; goodbyes - those
<a name="3512"></a>     *   should only match topics explicitly 
<a name="3513"></a>     */
<a name="3514"></a>    excludeMatch = [actorHelloTopicObj, actorByeTopicObj]
<a name="3515"></a>    matchScore = 1
<a name="3516"></a>;
<a name="3517"></a>
<a name="3518"></a>
<a name="3519"></a>/*
<a name="3520"></a> *   A "special" topic.  This is a topic that responds to its own unique,
<a name="3521"></a> *   custom command input.  In other words, rather than responding to a
<a name="3522"></a> *   normal command like ASK ABOUT or SHOW TO, we'll respond to a command
<a name="3523"></a> *   for which we define our own syntax.  Our special syntax doesn't have
<a name="3524"></a> *   to follow any of the ordinary parsing conventions, because whenever
<a name="3525"></a> *   our ConvNode is active, we get a shot at parsing player input before
<a name="3526"></a> *   the regular parser gets to see it.
<a name="3527"></a> *   
<a name="3528"></a> *   A special topic MUST be part of a ConvNode, because these are
<a name="3529"></a> *   inherently meaningful only in context.  A special topic is active
<a name="3530"></a> *   only when its conversation node is active.
<a name="3531"></a> *   
<a name="3532"></a> *   Special topics are automatically Suggested Topics as well as Topic
<a name="3533"></a> *   Entries.  Because special topics use their own custom grammar, it's
<a name="3534"></a> *   unreasonable to expect a player to guess at the custom grammar, so we
<a name="3535"></a> *   should always provide a topic inventory suggestion for every special
<a name="3536"></a> *   topic.  
<a name="3537"></a> */
<a name="3538"></a>class SpecialTopic: TopicEntry, SuggestedTopicTree
<a name="3539"></a>    /*
<a name="3540"></a>     *   Our keyword list.  Each special topic instance must define a list
<a name="3541"></a>     *   of strings giving the keywords we match.  The special topic will
<a name="3542"></a>     *   match user input if the user input consists exclusively of words
<a name="3543"></a>     *   from this keyword list.  The user input doesn't have to include
<a name="3544"></a>     *   all of the words defined here, but all of the words in the user's
<a name="3545"></a>     *   input have to appear here to match.
<a name="3546"></a>     *   
<a name="3547"></a>     *   Alternatively, an instance can specifically define its own custom
<a name="3548"></a>     *   regular expression pattern instead of using the keyword list; the
<a name="3549"></a>     *   regular expression allows the instance to include punctuation in
<a name="3550"></a>     *   the syntax, or apply more restrictive criteria than simply
<a name="3551"></a>     *   matching the keywords.  
<a name="3552"></a>     */
<a name="3553"></a>    keywordList = []
<a name="3554"></a>
<a name="3555"></a>    /*
<a name="3556"></a>     *   Initialize the special topic.  This runs during
<a name="3557"></a>     *   pre-initialization, to give us a chance to do pre-game set-up.
<a name="3558"></a>     *   
<a name="3559"></a>     *   This routine adds the topic's keywords to the global dictionary,
<a name="3560"></a>     *   under the 'special' token type.  Since a special topic's keywords
<a name="3561"></a>     *   are accepted when the special topic is active, it would be wrong
<a name="3562"></a>     *   for the parser to claim that the words are unknown when the
<a name="3563"></a>     *   special topic isn't active.  By adding the keywords to the
<a name="3564"></a>     *   dictionary, we let the parser know that they're valid words, so
<a name="3565"></a>     *   that it won't claim that they're unknown.  
<a name="3566"></a>     */
<a name="3567"></a>    initializeSpecialTopic()
<a name="3568"></a>    {
<a name="3569"></a>        /* add each keyword */
<a name="3570"></a>        foreach (local cur in keywordList)
<a name="3571"></a>        {
<a name="3572"></a>            /* 
<a name="3573"></a>             *   Add the keyword.  Since we don't actually need the
<a name="3574"></a>             *   word-to-object association that the dictionary stores,
<a name="3575"></a>             *   simply associate the word with the SpecialTopic class
<a name="3576"></a>             *   rather than with this particular special topic instance.
<a name="3577"></a>             *   The dictionary only stores a given word-obj-prop
<a name="3578"></a>             *   association once, even if it's entered repeatedly, so
<a name="3579"></a>             *   tying all of the special topic keywords to the
<a name="3580"></a>             *   SpecialTopic class ensures that we won't store redundant
<a name="3581"></a>             *   entries if the same keyword is used in multiple special
<a name="3582"></a>             *   topics.  
<a name="3583"></a>             */
<a name="3584"></a>            cmdDict.addWord(SpecialTopic, cur, &amp;specialTopicWord);
<a name="3585"></a>        }
<a name="3586"></a>    }
<a name="3587"></a>
<a name="3588"></a>    /* 
<a name="3589"></a>     *   our regular expression pattern - we'll build this automatically
<a name="3590"></a>     *   from the keyword list if this isn't otherwise defined 
<a name="3591"></a>     */
<a name="3592"></a>    matchPat = nil
<a name="3593"></a>    
<a name="3594"></a>    /* our suggestion (topic inventory) base name */
<a name="3595"></a>    name = ''
<a name="3596"></a>
<a name="3597"></a>    /* 
<a name="3598"></a>     *   our suggestion (topic inventory) full name is usually the same as
<a name="3599"></a>     *   the base name; special topics usually aren't grouped in topic
<a name="3600"></a>     *   suggestion listings, since each topic usually has its own unique,
<a name="3601"></a>     *   custom syntax 
<a name="3602"></a>     */
<a name="3603"></a>    fullName = (name)
<a name="3604"></a>
<a name="3605"></a>    /* on being suggested, update the special topic history */
<a name="3606"></a>    noteSuggestion() { specialTopicHistory.noteListing(self); }
<a name="3607"></a>
<a name="3608"></a>    /* include in the specialTopics list of our parent topic database */
<a name="3609"></a>    includeInList = [&amp;specialTopics]
<a name="3610"></a>
<a name="3611"></a>    /* 
<a name="3612"></a>     *   By default, don't limit the number of times we'll suggest this
<a name="3613"></a>     *   topic.  Since a special topic is valid only in a particular
<a name="3614"></a>     *   ConvNode context, we normally want all of the topics in that
<a name="3615"></a>     *   context to be available, even if they've been used before. 
<a name="3616"></a>     */
<a name="3617"></a>    timesToSuggest = nil
<a name="3618"></a>
<a name="3619"></a>    /* check for a match */
<a name="3620"></a>    matchTopic(fromActor, topic)
<a name="3621"></a>    {
<a name="3622"></a>        /* 
<a name="3623"></a>         *   We match if and only if we're the current active topic for
<a name="3624"></a>         *   our conversation node, as designated during our pre-parsing.
<a name="3625"></a>         *   Because we're activated exclusively by our special syntax,
<a name="3626"></a>         *   the only way we can ever match is by matching our special
<a name="3627"></a>         *   syntax in pre-parsing; when that happens, the pre-parser
<a name="3628"></a>         *   notes the matching SpecialTopic and sends a pseudo-command to
<a name="3629"></a>         *   the parser to let it know to invoke the special topic's
<a name="3630"></a>         *   response.  We take this circuitous route to showing the
<a name="3631"></a>         *   response because we do our actual matching in the pre-parse
<a name="3632"></a>         *   step, but we want to do the actual command processing
<a name="3633"></a>         *   normally; we can only accomplish both needs using this
<a name="3634"></a>         *   two-step process, with the two steps tied together via our
<a name="3635"></a>         *   memory of the topic selected in pre-parse.  
<a name="3636"></a>         */
<a name="3637"></a>        if (getConvNode().activeSpecialTopic == self)
<a name="3638"></a>            return matchScore;
<a name="3639"></a>        else
<a name="3640"></a>            return nil;
<a name="3641"></a>    }
<a name="3642"></a>
<a name="3643"></a>    /* 
<a name="3644"></a>     *   a special topic is always matchable, since we match on literal
<a name="3645"></a>     *   text 
<a name="3646"></a>     */
<a name="3647"></a>    isMatchPossible(actor, scopeList) { return true; }
<a name="3648"></a>
<a name="3649"></a>    /*
<a name="3650"></a>     *   Match a string during pre-parsing.  By default, we'll match the
<a name="3651"></a>     *   string if all of its words (as defined by the regular expression
<a name="3652"></a>     *   parser) match our keywords.  
<a name="3653"></a>     */
<a name="3654"></a>    matchPreParse(str, procStr)
<a name="3655"></a>    {
<a name="3656"></a>        /* build the regular expression pattern if there isn't one */
<a name="3657"></a>        if (matchPat == nil)
<a name="3658"></a>        {
<a name="3659"></a>            local pat;
<a name="3660"></a>
<a name="3661"></a>            /* start with the base pattern string */
<a name="3662"></a>            pat = '&lt;nocase&gt;&lt;space&gt;*(%&lt;';
<a name="3663"></a>
<a name="3664"></a>            /* add the keywords */
<a name="3665"></a>            for (local i = 1, local len = keywordList.length() ;
<a name="3666"></a>                 i &lt;= len ; ++i)
<a name="3667"></a>            {
<a name="3668"></a>                /* add this keyword to the pattern */
<a name="3669"></a>                pat += keywordList[i];
<a name="3670"></a>
<a name="3671"></a>                /* add the separator or terminator, as appropriate */
<a name="3672"></a>                if (i == len)
<a name="3673"></a>                    pat += '%&gt;&lt;space&gt;*)+';
<a name="3674"></a>                else
<a name="3675"></a>                    pat += '%&gt;&lt;space&gt;*|%&lt;';
<a name="3676"></a>            }
<a name="3677"></a>
<a name="3678"></a>            /* create the pattern object */
<a name="3679"></a>            matchPat = new RexPattern(pat);
<a name="3680"></a>        }
<a name="3681"></a>
<a name="3682"></a>        /* we have a match if the pattern matches the processed input */
<a name="3683"></a>        return rexMatch(matchPat, procStr) == procStr.length();
<a name="3684"></a>    }
<a name="3685"></a>
<a name="3686"></a>    /* find our enclosing ConvNode object */
<a name="3687"></a>    getConvNode()
<a name="3688"></a>    {
<a name="3689"></a>        /* scan up the containment tree for a ConvNode */
<a name="3690"></a>        for (local loc = location ; loc != nil ; loc = loc.location)
<a name="3691"></a>        {
<a name="3692"></a>            /* if this is a ConvNode, it's what we're looking for */
<a name="3693"></a>            if (loc.ofKind(ConvNode))
<a name="3694"></a>                return loc;
<a name="3695"></a>        }
<a name="3696"></a>
<a name="3697"></a>        /* not found */
<a name="3698"></a>        return nil;
<a name="3699"></a>    }
<a name="3700"></a>;
<a name="3701"></a>
<a name="3702"></a>/*
<a name="3703"></a> *   A history of special topics listed in topic inventories.  This keeps
<a name="3704"></a> *   track of special topics that we've recently offered, so that we can
<a name="3705"></a> *   provide better feedback if the player tries to use a recently-listed
<a name="3706"></a> *   special topic after it's gone out of context.
<a name="3707"></a> *   
<a name="3708"></a> *   When the player types a command that the parser doesn't recognize, the
<a name="3709"></a> *   parser will check the special topic history to see if the command
<a name="3710"></a> *   matches a special topic that was suggested recently.  If so, we'll
<a name="3711"></a> *   explain that the command isn't usable right now, rather than claiming
<a name="3712"></a> *   that the command is completely invalid.  A player might justifiably
<a name="3713"></a> *   find it confusing to have the game suggest a command one minute, and
<a name="3714"></a> *   then claim that the very same command is invalid a minute later.
<a name="3715"></a> *   
<a name="3716"></a> *   Ideally, we'd search *every* special topic for a match each time the
<a name="3717"></a> *   player enters an invalid command, but that could take a long time in a
<a name="3718"></a> *   conversation-heavy game with a large number of special topics.  As a
<a name="3719"></a> *   compromise, we keep track of the last few special commands that were
<a name="3720"></a> *   actually suggested, so that we can scan those.  The reasoning is that
<a name="3721"></a> *   a player is more likely to try a recently-offered special command; the
<a name="3722"></a> *   player will probably eventually forget older suggestions, and in any
<a name="3723"></a> *   case it's much more jarring to see a "command not understood" response
<a name="3724"></a> *   to a suggestion that's still fresh in the player's memory.
<a name="3725"></a> *   
<a name="3726"></a> *   This is a transient object because we're interested in the special
<a name="3727"></a> *   topics that have been offered in the current session, irrespective of
<a name="3728"></a> *   things like 'undo' and 'restore'.  From the player's perspective, the
<a name="3729"></a> *   recency of a special topic suggestion is a function of the transcript,
<a name="3730"></a> *   not of the internal story timeline.  For example, if the game suggests
<a name="3731"></a> *   a special topic, then the player types UNDO, the player might still
<a name="3732"></a> *   think to try the special topic on the next turn simply because it's
<a name="3733"></a> *   right there on the screen a few lines up.  
<a name="3734"></a> */
<a name="3735"></a>transient specialTopicHistory: object
<a name="3736"></a>    /* 
<a name="3737"></a>     *   Maximum number of topics to keep in our inventory.  When the
<a name="3738"></a>     *   history exceeds this number, we'll throw away the oldest entry
<a name="3739"></a>     *   each time we need to add a new entry - thus, we'll always have the
<a name="3740"></a>     *   N most recent suggestions.
<a name="3741"></a>     *   
<a name="3742"></a>     *   This can be configured as desired.  The default setting tries to
<a name="3743"></a>     *   strike a balance between speed and good feedback - we try to keep
<a name="3744"></a>     *   track of enough entries that most players wouldn't think to try
<a name="3745"></a>     *   anything that's aged out of the list, but not so many that it
<a name="3746"></a>     *   takes a long time to scan them all.
<a name="3747"></a>     *   
<a name="3748"></a>     *   If you set this to nil, we won't keep a history at all, but
<a name="3749"></a>     *   instead simply scan every special topic in the entire game when we
<a name="3750"></a>     *   need to look for a match to an entered command - in a game with a
<a name="3751"></a>     *   small number of special topics (on the order of, say, 30 or 40),
<a name="3752"></a>     *   there should be no problem using this approach.  Note that this
<a name="3753"></a>     *   changes the behavior in one important way: when there's no history
<a name="3754"></a>     *   limit, we can topics that *haven't even been offered yet*.  In
<a name="3755"></a>     *   some ways this is more desirable than only scanning past
<a name="3756"></a>     *   suggestions, since it avoids weird situations where the game
<a name="3757"></a>     *   claims that a command is unrecognized at one point, but later
<a name="3758"></a>     *   suggests and then accepts the exact same command.  It's
<a name="3759"></a>     *   conceivably less desirable in that it could accidentally give away
<a name="3760"></a>     *   information to the player, by letting them know that a randomly
<a name="3761"></a>     *   typed command will be meaningful at some point in the game - but
<a name="3762"></a>     *   the odds of this even happening seem minuscule, and the
<a name="3763"></a>     *   possibility that it would give away meaningful information even if
<a name="3764"></a>     *   it did happen seems very remote.  
<a name="3765"></a>     */
<a name="3766"></a>    maxEntries = 20
<a name="3767"></a>
<a name="3768"></a>    /* note that a special topic 't' is being listed in a topic inventory */
<a name="3769"></a>    noteListing(t)
<a name="3770"></a>    {
<a name="3771"></a>        /* 
<a name="3772"></a>         *   If t's already in the list, delete it from its current
<a name="3773"></a>         *   position, so that we can add it back at the end of the list,
<a name="3774"></a>         *   reflecting its status as the most recent entry.  
<a name="3775"></a>         */
<a name="3776"></a>        historyList.removeElement(t);
<a name="3777"></a>
<a name="3778"></a>        /* 
<a name="3779"></a>         *   if the list is already at capacity, remove the oldest entry,
<a name="3780"></a>         *   which is the first entry in the list 
<a name="3781"></a>         */
<a name="3782"></a>        if (maxEntries != nil &amp;&amp; historyList.length() &gt;= maxEntries)
<a name="3783"></a>            historyList.removeElementAt(1);
<a name="3784"></a>
<a name="3785"></a>        /* add the new entry at the end of the list */
<a name="3786"></a>        historyList.append(t);
<a name="3787"></a>    }
<a name="3788"></a>
<a name="3789"></a>    /*
<a name="3790"></a>     *   Scan the history list (or, if there's no limit to the history,
<a name="3791"></a>     *   scan all of the special topics in the entire game) for a match to
<a name="3792"></a>     *   an unrecognized command.  Returns true if we find a match, nil if
<a name="3793"></a>     *   not.  
<a name="3794"></a>     */
<a name="3795"></a>    checkHistory(toks)
<a name="3796"></a>    {
<a name="3797"></a>        local str, procStr;
<a name="3798"></a>        
<a name="3799"></a>        /* get the original and processed version of the input string */
<a name="3800"></a>        str = cmdTokenizer.buildOrigText(toks);
<a name="3801"></a>        procStr = specialTopicPreParser.processInputStr(str);
<a name="3802"></a>        
<a name="3803"></a>        /* 
<a name="3804"></a>         *   scan each special topic in the history - or, if the history is
<a name="3805"></a>         *   unlimited, scan every special topic 
<a name="3806"></a>         */
<a name="3807"></a>        if (maxEntries != nil)
<a name="3808"></a>        {
<a name="3809"></a>            /* scan each entry in our history list */
<a name="3810"></a>            for (local l = historyList, local i = 1, local len = l.length() ;
<a name="3811"></a>                 i &lt;= len ; ++i)
<a name="3812"></a>            {
<a name="3813"></a>                /* check this entry */
<a name="3814"></a>                if (l[i].matchPreParse(str, procStr))
<a name="3815"></a>                    return true;
<a name="3816"></a>            }
<a name="3817"></a>        }
<a name="3818"></a>        else
<a name="3819"></a>        {
<a name="3820"></a>            /* no history limit - scan every special topic in the game */
<a name="3821"></a>            for (local o = firstObj(SpecialTopic) ; o != nil ;
<a name="3822"></a>                 o = nextObj(o, SpecialTopic))
<a name="3823"></a>            {
<a name="3824"></a>                /* check this entry */
<a name="3825"></a>                if (o.matchPreParse(str, procStr))
<a name="3826"></a>                    return true;
<a name="3827"></a>            }
<a name="3828"></a>        }
<a name="3829"></a>
<a name="3830"></a>        /* we didn't find a match */
<a name="3831"></a>        return nil;
<a name="3832"></a>    }
<a name="3833"></a>
<a name="3834"></a>    /* 
<a name="3835"></a>     *   The list of entries.  Create it when we first need it, which
<a name="3836"></a>     *   perInstance does for us.  
<a name="3837"></a>     */
<a name="3838"></a>    historyList = perInstance(new transient Vector(maxEntries))
<a name="3839"></a>;
<a name="3840"></a>
<a name="3841"></a>/*
<a name="3842"></a> *   An "initiate" topic entry.  This is a rather different kind of topic
<a name="3843"></a> *   entry from the ones we've defined so far; an initiate topic is for
<a name="3844"></a> *   cases where the NPC itself wants to initiate a conversation in
<a name="3845"></a> *   response to something in the environment.
<a name="3846"></a> *   
<a name="3847"></a> *   One way to use initiate topics is to use the current location as the
<a name="3848"></a> *   topic key.  This lets the NPC say something appropriate to the current
<a name="3849"></a> *   room, and can be coded simply as
<a name="3850"></a> *   
<a name="3851"></a> *.     actor.initiateTopic(location);
<a name="3852"></a> */
<a name="3853"></a>class InitiateTopic: ThingMatchTopic
<a name="3854"></a>    /* include in the initiateTopics list */
<a name="3855"></a>    includeInList = [&amp;initiateTopics]
<a name="3856"></a>
<a name="3857"></a>    /* 
<a name="3858"></a>     *   since this kind of topic is triggered by internal calculations in
<a name="3859"></a>     *   the game, and not on anything the player is doing, there's no
<a name="3860"></a>     *   reason that our match object should be a pronoun antecedent 
<a name="3861"></a>     */
<a name="3862"></a>    setTopicPronouns(fromActor, topic) { }
<a name="3863"></a>;
<a name="3864"></a>
<a name="3865"></a>/* a catch-all default initiate topic */
<a name="3866"></a>class DefaultInitiateTopic: DefaultTopic
<a name="3867"></a>    includeInList = [&amp;initiateTopics]
<a name="3868"></a>;
<a name="3869"></a>
<a name="3870"></a>
<a name="3871"></a>/* ------------------------------------------------------------------------ */
<a name="3872"></a>/*
<a name="3873"></a> *   An ActorState represents the current state of an Actor.
<a name="3874"></a> *   
<a name="3875"></a> *   The main thing that makes actors special is that they're supposed to
<a name="3876"></a> *   be living, breathing people or creatures.  That substantially
<a name="3877"></a> *   complicates the programming of one of these objects, because in order
<a name="3878"></a> *   to create the appearance of animation, many things about an actor have
<a name="3879"></a> *   to change over time.
<a name="3880"></a> *   
<a name="3881"></a> *   The ActorState is designed to make it easier to program this
<a name="3882"></a> *   variability that's needed to make an actor seem life-like.  The idea
<a name="3883"></a> *   is to separate the parts of an actor that tend to change according to
<a name="3884"></a> *   what the actor is doing, moving all of those out of the Actor object
<a name="3885"></a> *   and into an ActorState object instead.  Each ActorState object
<a name="3886"></a> *   represents one state of an actor (i.e., one thing the actor can be
<a name="3887"></a> *   doing).  The Actor object becomes easier to program, because we've
<a name="3888"></a> *   reduced the Actor object to the character's constant, unchanging
<a name="3889"></a> *   features.  The stateful part is also easier to program, because we
<a name="3890"></a> *   don't have to make it conditional on anything; we simply define all of
<a name="3891"></a> *   the stateful parts in an ActorState, and we define separate ActorState
<a name="3892"></a> *   objects for the different states.
<a name="3893"></a> *   
<a name="3894"></a> *   For example, suppose we want a shopkeeper actor, whose activities
<a name="3895"></a> *   include waiting behind the counter, sweeping the floor, and stacking
<a name="3896"></a> *   cans.  We'd define one ActorState object for each of these activities.
<a name="3897"></a> *   When the shopkeeper switches from standing behind the counter to
<a name="3898"></a> *   sweeping, for example, we simply set the "curState" property in the
<a name="3899"></a> *   shopkeeper object so that it points to the "sweeping" state object.
<a name="3900"></a> *   When it's time to stack cans, we change "curState" to it points to the
<a name="3901"></a> *   "stacking cans" state object.  
<a name="3902"></a> */
<a name="3903"></a>class ActorState: TravelMessageHandler, ActorTopicDatabase
<a name="3904"></a>    construct(actor) { location = actor; }
<a name="3905"></a>
<a name="3906"></a>    /*
<a name="3907"></a>     *   Activate the state - this is called when we're about to become
<a name="3908"></a>     *   the active state for an actor.  We do nothing by default.
<a name="3909"></a>     */
<a name="3910"></a>    activateState(actor, oldState) { }
<a name="3911"></a>
<a name="3912"></a>    /* 
<a name="3913"></a>     *   Deactivate the state - this is called when we're the active state
<a name="3914"></a>     *   for an actor, and the actor is about to switch to a new state.
<a name="3915"></a>     *   We do nothing by default.  
<a name="3916"></a>     */
<a name="3917"></a>    deactivateState(actor, newState) { }
<a name="3918"></a>
<a name="3919"></a>    /* 
<a name="3920"></a>     *   Is this the actor's initial state?  If so, we'll automatically
<a name="3921"></a>     *   set the actor's curState to point to 'self' during
<a name="3922"></a>     *   pre-initialization.  For obvious reasons, this should be set to
<a name="3923"></a>     *   true for only one state for each actor; if multiple states are
<a name="3924"></a>     *   all flagged as initial for the same actor, we'll pick on
<a name="3925"></a>     *   arbitrarily as the actual initial state.  
<a name="3926"></a>     */
<a name="3927"></a>    isInitState = nil
<a name="3928"></a>
<a name="3929"></a>    /*
<a name="3930"></a>     *   Should we automatically suggest topics when the player greets our
<a name="3931"></a>     *   actor?  By default, we show our "topic inventory" (the list of
<a name="3932"></a>     *   currently active topics marked as "suggested").  This can be set
<a name="3933"></a>     *   to nil to suppress this automatic suggestion list.
<a name="3934"></a>     *   
<a name="3935"></a>     *   Some authors might not like the idea of automatically suggesting
<a name="3936"></a>     *   topics every time we greet a character, but nonetheless wish to
<a name="3937"></a>     *   keep the TOPICS command as a sort of hint mechanism.  This flag
<a name="3938"></a>     *   can be used for this purpose.  Authors who don't like suggested
<a name="3939"></a>     *   topics at all can simply skip defining any SuggestedTopic entries,
<a name="3940"></a>     *   in which case there will never be anything to suggest, rendering
<a name="3941"></a>     *   this flag moot.  
<a name="3942"></a>     */
<a name="3943"></a>    autoSuggest = true
<a name="3944"></a>
<a name="3945"></a>    /*
<a name="3946"></a>     *   The 'location' is the actor that we're associated with.
<a name="3947"></a>     *   
<a name="3948"></a>     *   ActorState objects aren't actual simulation objects, so the
<a name="3949"></a>     *   'location' property isn't used for containment.  For convenience,
<a name="3950"></a>     *   though, use it to indicate which actor we're associated with; this
<a name="3951"></a>     *   lets us use the '+' notation to define the state objects
<a name="3952"></a>     *   associated with an actor.  
<a name="3953"></a>     */
<a name="3954"></a>    location = nil
<a name="3955"></a>
<a name="3956"></a>    /* 
<a name="3957"></a>     *   Get the actor associated with the state - this is simply the
<a name="3958"></a>     *   'location' property.  If we're nested inside another ActorState,
<a name="3959"></a>     *   then our actor is our enclosing ActorState's actor.  
<a name="3960"></a>     */
<a name="3961"></a>    getActor()
<a name="3962"></a>    {
<a name="3963"></a>        if (location.ofKind(ActorState))
<a name="3964"></a>            return location.getActor();
<a name="3965"></a>        else
<a name="3966"></a>            return location;
<a name="3967"></a>    }
<a name="3968"></a>
<a name="3969"></a>    /* the owner of any topic entries within the state is just my actor */
<a name="3970"></a>    getTopicOwner() { return getActor(); }
<a name="3971"></a>
<a name="3972"></a>    /* initialize the actor state */
<a name="3973"></a>    initializeActorState()
<a name="3974"></a>    {
<a name="3975"></a>        /* 
<a name="3976"></a>         *   if we're the initial state for our actor, set the actor's
<a name="3977"></a>         *   current state property to point to me 
<a name="3978"></a>         */
<a name="3979"></a>        if (isInitState)
<a name="3980"></a>            getActor().setCurState(self);
<a name="3981"></a>    }
<a name="3982"></a>
<a name="3983"></a>    /*
<a name="3984"></a>     *   Show the special description for the actor when the actor is
<a name="3985"></a>     *   associated with this state.  By default, we use the actor's
<a name="3986"></a>     *   actorHereDesc message, which usually shows a generic message
<a name="3987"></a>     *   (something like "Bob is here" or "Bob is sitting on the chair") to
<a name="3988"></a>     *   indicate that the actor is present.
<a name="3989"></a>     *   
<a name="3990"></a>     *   States representing scripted activities should override these to
<a name="3991"></a>     *   indicate what the actor is doing: "Bob is sweeping the floor," for
<a name="3992"></a>     *   example.
<a name="3993"></a>     */
<a name="3994"></a>    specialDesc() { getActor().actorHereDesc; }
<a name="3995"></a>
<a name="3996"></a>    /* show the special description for the actor at a distance */
<a name="3997"></a>    distantSpecialDesc() { getActor().actorThereDesc; }
<a name="3998"></a>
<a name="3999"></a>    /* show the special description for the actor in a remote location */
<a name="4000"></a>    remoteSpecialDesc(actor) { getActor().actorThereDesc; }
<a name="4001"></a>
<a name="4002"></a>    /*
<a name="4003"></a>     *   The list group(s) for the special description.  By default, if
<a name="4004"></a>     *   our specialDesc isn't overridden, we'll keep this in sync with
<a name="4005"></a>     *   the specialDesc by returning our actor's actorListWith.  And if
<a name="4006"></a>     *   specialDesc *is* overridden, we'll just return an empty list to
<a name="4007"></a>     *   indicate that we're not part of any list group.  If you want to
<a name="4008"></a>     *   provide your own listing group special to the state, simply
<a name="4009"></a>     *   override this and speicfy the custom list group.  
<a name="4010"></a>     */
<a name="4011"></a>    specialDescListWith()
<a name="4012"></a>    {
<a name="4013"></a>        /* 
<a name="4014"></a>         *   if specialDesc is inherited from ActorState, then use the
<a name="4015"></a>         *   default handling from the actor; otherwise, use no grouping at
<a name="4016"></a>         *   all by default 
<a name="4017"></a>         */
<a name="4018"></a>        if (!overrides(self, ActorState, &amp;specialDesc))
<a name="4019"></a>            return getActor().actorListWith;
<a name="4020"></a>        else
<a name="4021"></a>            return [];
<a name="4022"></a>    }
<a name="4023"></a>
<a name="4024"></a>    /* show the special description when we appear in a contents listing */
<a name="4025"></a>    showSpecialDescInContents(actor, cont)
<a name="4026"></a>    {
<a name="4027"></a>        /* by default, just show our posture in our container */
<a name="4028"></a>        getActor().listActorPosture(actor);
<a name="4029"></a>    }
<a name="4030"></a>
<a name="4031"></a>    /* 
<a name="4032"></a>     *   Our "state" description.  This shows information on what the actor
<a name="4033"></a>     *   is *currently* doing; we display this after the static part of the
<a name="4034"></a>     *   actor's description on EXAMINE &lt;ACTOR&gt;.  By default, we add
<a name="4035"></a>     *   nothing here, but state objects that represent scripted activies
<a name="4036"></a>     *   should override this to describe their scripted activities.
<a name="4037"></a>     */
<a name="4038"></a>    stateDesc = ""
<a name="4039"></a>
<a name="4040"></a>    /*
<a name="4041"></a>     *   Should we obey an action?  If so, returns true; if not, displays
<a name="4042"></a>     *   an appropriate response and returns nil.  This will only be
<a name="4043"></a>     *   called when the issuing actor is different from our actor, since
<a name="4044"></a>     *   a command to oneself is implicitly always obeyed.
<a name="4045"></a>     */
<a name="4046"></a>    obeyCommand(issuingActor, action)
<a name="4047"></a>    {
<a name="4048"></a>        /* 
<a name="4049"></a>         *   By default, we ignore all orders.  We do need to generate a
<a name="4050"></a>         *   response, though, so for this purpose, treat the order as a
<a name="4051"></a>         *   conversational action, with the 'action' object as the topic.
<a name="4052"></a>         */
<a name="4053"></a>        handleConversation(issuingActor, action, commandConvType);
<a name="4054"></a>
<a name="4055"></a>        /* indicate that the order is refused */
<a name="4056"></a>        return nil;
<a name="4057"></a>    }
<a name="4058"></a>
<a name="4059"></a>    /*
<a name="4060"></a>     *   Suggest topics for the given actor to talk to us about.  This is
<a name="4061"></a>     *   called when the given actor enters a TOPICS command (in which
<a name="4062"></a>     *   case 'explicit' will be true) or enters a conversation with us
<a name="4063"></a>     *   via TALK TO or the like (in which case 'explicit' will be nil).
<a name="4064"></a>     */
<a name="4065"></a>    suggestTopicsFor(actor, explicit)
<a name="4066"></a>    {
<a name="4067"></a>        /* 
<a name="4068"></a>         *   if this is not an explicit TOPICS request, and we're not in
<a name="4069"></a>         *   "auto suggest" mode, don't show anything - we don't want any
<a name="4070"></a>         *   automatic suggestions in this mode  
<a name="4071"></a>         */
<a name="4072"></a>        if (!explicit &amp;&amp; !autoSuggest)
<a name="4073"></a>            return;
<a name="4074"></a>
<a name="4075"></a>        /* 
<a name="4076"></a>         *   show a paragraph break, in case we're being tacked on to
<a name="4077"></a>         *   another report; but make it cosmetic, so that this by itself
<a name="4078"></a>         *   doesn't suppress a default report, in case we don't end up
<a name="4079"></a>         *   displaying any topics 
<a name="4080"></a>         */
<a name="4081"></a>        cosmeticSpacingReport('&lt;.p&gt;');
<a name="4082"></a>
<a name="4083"></a>        /* show our suggestion list */
<a name="4084"></a>        showSuggestedTopicList(getSuggestedTopicList(),
<a name="4085"></a>                               actor, getActor(), explicit);
<a name="4086"></a>    }
<a name="4087"></a>
<a name="4088"></a>    /*
<a name="4089"></a>     *   Get our suggested topic list.  The suggested topic list consists
<a name="4090"></a>     *   of the union of the current ConvNode's suggestion list, the
<a name="4091"></a>     *   ActorState list, and the Actor's suggestion list.  In each case,
<a name="4092"></a>     *   the suggestion list is the list of all SuggestedTopic objects at
<a name="4093"></a>     *   each database level.
<a name="4094"></a>     *   
<a name="4095"></a>     *   The suggestions are arranged in a hierarchy, and each hierarchy
<a name="4096"></a>     *   level can prevent suggestions from a lower level from being
<a name="4097"></a>     *   included.  The top level of the hierarchy is the ConvNode; the
<a name="4098"></a>     *   next level is the ActorState; and the last level is the Actor.
<a name="4099"></a>     *   Suggestions are limited at each level with the 'limitSuggestions'
<a name="4100"></a>     *   property: if true, suggestions from lower levels are not included.
<a name="4101"></a>     */
<a name="4102"></a>    getSuggestedTopicList()
<a name="4103"></a>    {
<a name="4104"></a>        local v = new Vector(16);
<a name="4105"></a>        local node;
<a name="4106"></a>        local lst;
<a name="4107"></a>
<a name="4108"></a>        /* add the actor's current conversation node topics */
<a name="4109"></a>        if ((node = getActor().curConvNode) != nil)
<a name="4110"></a>        {
<a name="4111"></a>            /* if there are any suggested topics in the node, include them */
<a name="4112"></a>            if ((lst = node.suggestedTopics) != nil)
<a name="4113"></a>                v.appendAll(lst);
<a name="4114"></a>
<a name="4115"></a>            /* 
<a name="4116"></a>             *   if this ConvNode is marked as limiting suggestions to
<a name="4117"></a>             *   those defined within the node, return what we have
<a name="4118"></a>             *   without adding anything from the broader context 
<a name="4119"></a>             */
<a name="4120"></a>            if (node.limitSuggestions)
<a name="4121"></a>                return v;
<a name="4122"></a>        }
<a name="4123"></a>
<a name="4124"></a>        /* add our own topics */
<a name="4125"></a>        if ((lst = stateSuggestedTopics) != nil)
<a name="4126"></a>            v.appendAll(lst);
<a name="4127"></a>
<a name="4128"></a>        /* 
<a name="4129"></a>         *   if the ActorState is limiting suggestions, don't include any
<a name="4130"></a>         *   suggestions from the broader context (i.e., from the Actor
<a name="4131"></a>         *   itself) 
<a name="4132"></a>         */
<a name="4133"></a>        if (limitSuggestions)
<a name="4134"></a>            return v;
<a name="4135"></a>
<a name="4136"></a>        /* if our actor has its own list, add those as well */
<a name="4137"></a>        if ((lst = getActor().suggestedTopics) != nil)
<a name="4138"></a>            v.appendAll(lst);
<a name="4139"></a>
<a name="4140"></a>        /* return the combined list */
<a name="4141"></a>        return v;
<a name="4142"></a>    }
<a name="4143"></a>
<a name="4144"></a>    /* 
<a name="4145"></a>     *   get the topic suggestions for this state - by default, we just
<a name="4146"></a>     *   return our own suggestedTopics list 
<a name="4147"></a>     */
<a name="4148"></a>    stateSuggestedTopics = (suggestedTopics)
<a name="4149"></a>
<a name="4150"></a>    /*
<a name="4151"></a>     *   Get my implied in-conversation state.  This is used when our actor
<a name="4152"></a>     *   initiates a conversation without specifying a particular
<a name="4153"></a>     *   conversation state to enter (i.e., actor.initiateConversation() is
<a name="4154"></a>     *   called with 'state' set to nil).  By default, we don't have an
<a name="4155"></a>     *   implied conversation state, so we just return 'self' to indicate
<a name="4156"></a>     *   that we want to stay in the current state.  States that are
<a name="4157"></a>     *   coupled with separate in-conversation states, such as
<a name="4158"></a>     *   ConversationReadyState, should return their associated
<a name="4159"></a>     *   conversation states here.  
<a name="4160"></a>     */
<a name="4161"></a>    getImpliedConvState = (self)
<a name="4162"></a>
<a name="4163"></a>    /*
<a name="4164"></a>     *   General conversation handler.  This can be used to process most
<a name="4165"></a>     *   conversational commands - ASK, TELL, GIVE, SHOW, etc.  The
<a name="4166"></a>     *   standard sequence of processing is as follows:
<a name="4167"></a>     *   
<a name="4168"></a>     *   - If our actor has a non-nil current conversation node (ConvNode)
<a name="4169"></a>     *   object, and the ConvNode wants to handle the event, let the
<a name="4170"></a>     *   ConvNode handle it.
<a name="4171"></a>     *   
<a name="4172"></a>     *   - Otherwise, check our own topic database to see if we can find a
<a name="4173"></a>     *   TopicEntry that matches the topic; if we can find one, let the
<a name="4174"></a>     *   TopicEntry handle it.
<a name="4175"></a>     *   
<a name="4176"></a>     *   - Otherwise, let the actor handle it.
<a name="4177"></a>     *   
<a name="4178"></a>     *   'otherActor' is the actor who originated the conversation command
<a name="4179"></a>     *   (usually the player character). 'topic' is the subject being
<a name="4180"></a>     *   discussed (the indirect object of ASK ABOUT, for example).
<a name="4181"></a>     *   convType' is a ConvType describing the type of conversational
<a name="4182"></a>     *   action we're performing.  
<a name="4183"></a>     */
<a name="4184"></a>    handleConversation(otherActor, topic, convType)
<a name="4185"></a>    {
<a name="4186"></a>        local actor = getActor();
<a name="4187"></a>        local hasDefault;
<a name="4188"></a>        local node;
<a name="4189"></a>        local path;
<a name="4190"></a>
<a name="4191"></a>        /* determine if I have a default response handler */
<a name="4192"></a>        hasDefault = propDefined(convType.defaultResponseProp);
<a name="4193"></a>
<a name="4194"></a>        /*
<a name="4195"></a>         *   Figure the database search path for looking up the topics.
<a name="4196"></a>         *   We'll start in the ConvNode database, then continue to the
<a name="4197"></a>         *   ActorState database, then finally to the Actor database.
<a name="4198"></a>         *   However, we won't reach the Actor database if there's a
<a name="4199"></a>         *   default response handler in the state, because if we fail to
<a name="4200"></a>         *   find it at the state, we'll take the default.
<a name="4201"></a>         *   
<a name="4202"></a>         *   Since the path we need to provide at each point is the
<a name="4203"></a>         *   *remaining* path, don't bother including the ConvNode, since
<a name="4204"></a>         *   we'd just have to take it right back out to get the remaining
<a name="4205"></a>         *   path after the ConvNode.  
<a name="4206"></a>         */
<a name="4207"></a>        path = [self];
<a name="4208"></a>        if (!hasDefault)
<a name="4209"></a>            path += actor;
<a name="4210"></a>
<a name="4211"></a>        /* 
<a name="4212"></a>         *   If our actor has a current conversation node, check to see if
<a name="4213"></a>         *   the conversation node wants to handle it.  If not, check our
<a name="4214"></a>         *   own topic database, then the actor's.  
<a name="4215"></a>         */
<a name="4216"></a>        if ((node = actor.curConvNode) == nil
<a name="4217"></a>            || !node.handleConversation(otherActor, topic, convType, path))
<a name="4218"></a>        {
<a name="4219"></a>            /* get the remaining database search path */
<a name="4220"></a>            path = path.sublist(2);
<a name="4221"></a>            
<a name="4222"></a>            /* 
<a name="4223"></a>             *   Either we don't have a ConvNode, or the ConvNode isn't
<a name="4224"></a>             *   interested in handling the operation.  Check to see if we
<a name="4225"></a>             *   can handle it through our own topic database.  
<a name="4226"></a>             */
<a name="4227"></a>            if (!handleTopic(otherActor, topic, convType, path))
<a name="4228"></a>            {
<a name="4229"></a>                /*
<a name="4230"></a>                 *   We couldn't find anything in our topic database that's
<a name="4231"></a>                 *   interested in handling it.  Check to see if the state
<a name="4232"></a>                 *   object defines the default response handler method,
<a name="4233"></a>                 *   and use that as the response if so. 
<a name="4234"></a>                 */
<a name="4235"></a>                if (hasDefault)
<a name="4236"></a>                {
<a name="4237"></a>                    /* 
<a name="4238"></a>                     *   the state object (i.e., self) does define the
<a name="4239"></a>                     *   default response method, so invoke that 
<a name="4240"></a>                     */
<a name="4241"></a>                    convType.defaultResponse(self, otherActor, topic);
<a name="4242"></a>                }
<a name="4243"></a>                else
<a name="4244"></a>                {
<a name="4245"></a>                    /* 
<a name="4246"></a>                     *   We don't have a topic database entry and we don't
<a name="4247"></a>                     *   have our own definition of the default response
<a name="4248"></a>                     *   handler.  All that remains is to let our actor
<a name="4249"></a>                     *   handle it.  
<a name="4250"></a>                     */
<a name="4251"></a>                    actor.handleConversation(otherActor, topic, convType);
<a name="4252"></a>                }
<a name="4253"></a>            }
<a name="4254"></a>        }
<a name="4255"></a>
<a name="4256"></a>        /* whatever happened, run the appropriate after-response handling */
<a name="4257"></a>        convType.afterResponse(actor, otherActor);
<a name="4258"></a>    }
<a name="4259"></a>
<a name="4260"></a>    /*
<a name="4261"></a>     *   Receive notification that a TopicEntry is being used (via its
<a name="4262"></a>     *   handleTopic method) to respond to a command.  The TopicEntry will
<a name="4263"></a>     *   call this before it shows its message or takes any other action.
<a name="4264"></a>     *   By default, we do nothing.  
<a name="4265"></a>     */
<a name="4266"></a>    notifyTopicResponse(fromActor, entry) { }
<a name="4267"></a>
<a name="4268"></a>    /* 
<a name="4269"></a>     *   Handle a before-action notification for our actor.  By default,
<a name="4270"></a>     *   we do nothing.  
<a name="4271"></a>     */
<a name="4272"></a>    beforeAction()
<a name="4273"></a>    {
<a name="4274"></a>        /* do nothing by default */
<a name="4275"></a>    }
<a name="4276"></a>
<a name="4277"></a>    /* handle an after-action notification for our actor */
<a name="4278"></a>    afterAction()
<a name="4279"></a>    {
<a name="4280"></a>    }
<a name="4281"></a>
<a name="4282"></a>    /* handle a before-travel notification */
<a name="4283"></a>    beforeTravel(traveler, connector)
<a name="4284"></a>    {
<a name="4285"></a>        local other = getActor().getCurrentInterlocutor();
<a name="4286"></a>        
<a name="4287"></a>        /* 
<a name="4288"></a>         *   if our conversational partner is departing, break off the
<a name="4289"></a>         *   conversation
<a name="4290"></a>         */
<a name="4291"></a>        if (connector != nil
<a name="4292"></a>            &amp;&amp; other != nil
<a name="4293"></a>            &amp;&amp; traveler.isActorTraveling(other))
<a name="4294"></a>        {
<a name="4295"></a>            /* end the conversation */
<a name="4296"></a>            if (!endConversation(gActor, endConvTravel))
<a name="4297"></a>            {
<a name="4298"></a>                /* 
<a name="4299"></a>                 *   they don't want to allow the conversation to end, so
<a name="4300"></a>                 *   abort the travel action 
<a name="4301"></a>                 */
<a name="4302"></a>                exit;
<a name="4303"></a>            }
<a name="4304"></a>        }
<a name="4305"></a>    }
<a name="4306"></a>
<a name="4307"></a>    /* handle an after-travel notification */
<a name="4308"></a>    afterTravel(traveler, connector)
<a name="4309"></a>    {
<a name="4310"></a>    }
<a name="4311"></a>
<a name="4312"></a>    /*
<a name="4313"></a>     *   End the current conversation.  'reason' indicates why we're
<a name="4314"></a>     *   leaving the conversation - this is one of the endConvXxx enums
<a name="4315"></a>     *   defined in adv3.h.  beforeTravel() calls this automatically when
<a name="4316"></a>     *   the other party is trying to depart, and they're talking to us.
<a name="4317"></a>     *   
<a name="4318"></a>     *   This returns true if we wish to allow the conversation to end,
<a name="4319"></a>     *   nil if not.  
<a name="4320"></a>     */
<a name="4321"></a>    endConversation(actor, reason)
<a name="4322"></a>    {
<a name="4323"></a>        local ourActor = getActor();
<a name="4324"></a>        local node;
<a name="4325"></a>
<a name="4326"></a>        /* tell the current ConvNode about it */
<a name="4327"></a>        if ((node = ourActor.curConvNode) != nil)
<a name="4328"></a>        {
<a name="4329"></a>            local ret;
<a name="4330"></a>
<a name="4331"></a>            /* the can-end call might show a response, so set our actor */
<a name="4332"></a>            conversationManager.beginResponse(ourActor);
<a name="4333"></a>
<a name="4334"></a>            /* ask the node if it's okay to end the conversation */
<a name="4335"></a>            ret = node.canEndConversation(actor, reason);
<a name="4336"></a>
<a name="4337"></a>            /* 
<a name="4338"></a>             *   If the result is blockEndConv, it means that the actor
<a name="4339"></a>             *   said something to force the conversation to keep going.
<a name="4340"></a>             *   Make a note that the other actor already said something on
<a name="4341"></a>             *   this turn so that we don't generate another scripted
<a name="4342"></a>             *   message later, and flag this as preventing the
<a name="4343"></a>             *   conversation ending. 
<a name="4344"></a>             */
<a name="4345"></a>            if (ret == blockEndConv)
<a name="4346"></a>            {
<a name="4347"></a>                /* flag that the other actor said something this turn */
<a name="4348"></a>                ourActor.noteConvAction(actor);
<a name="4349"></a>
<a name="4350"></a>                /* we're unable to end the conversation now */
<a name="4351"></a>                ret = nil;
<a name="4352"></a>            }
<a name="4353"></a>
<a name="4354"></a>            /* end the response, leaving the node unchanged by default */
<a name="4355"></a>            conversationManager.finishResponse(
<a name="4356"></a>                ourActor, ourActor.curConvNode);
<a name="4357"></a>
<a name="4358"></a>            /* 
<a name="4359"></a>             *   if the node said no, tell the caller we can't end the
<a name="4360"></a>             *   conversation right now 
<a name="4361"></a>             */
<a name="4362"></a>            if (!ret)
<a name="4363"></a>                return nil;
<a name="4364"></a>            
<a name="4365"></a>            /* tell the node we are indeed ending the conversation */
<a name="4366"></a>            node.endConversation(actor, reason);
<a name="4367"></a>        }
<a name="4368"></a>
<a name="4369"></a>        /* forget any conversation tree position */
<a name="4370"></a>        ourActor.setConvNodeReason(nil, 'endConversation');
<a name="4371"></a>
<a name="4372"></a>        /* indicate that we are allowing the conversation to end */
<a name="4373"></a>        return true;
<a name="4374"></a>    }
<a name="4375"></a>
<a name="4376"></a>    /*
<a name="4377"></a>     *   Take a turn.  This is called when it's the actor's turn and
<a name="4378"></a>     *   there's not something else the actor needs to be doing (such as
<a name="4379"></a>     *   following another actor, or carrying out a command in the actor's
<a name="4380"></a>     *   pending command queue).
<a name="4381"></a>     *   
<a name="4382"></a>     *   By default, we perform several steps automatically.
<a name="4383"></a>     *   
<a name="4384"></a>     *   First, we check to see if the actor is in a ConvNode.  If so, the
<a name="4385"></a>     *   ConvNode takes precedence.  If we haven't been addressed already
<a name="4386"></a>     *   in conversation on this turn, we'll let the ConvNode perform its
<a name="4387"></a>     *   "continuation," which lets the NPC advance the conversation of its
<a name="4388"></a>     *   own volition.  In any case, if we have a current ConvNode, we're
<a name="4389"></a>     *   done with the turn, since we assume the actor will want to proceed
<a name="4390"></a>     *   with the conversation before pursuing its agenda or performing a
<a name="4391"></a>     *   background action.
<a name="4392"></a>     *   
<a name="4393"></a>     *   Second, assuming there's no active ConvNode, we check for an
<a name="4394"></a>     *   "agenda" item that's ready to execute.  If we find one, we execute
<a name="4395"></a>     *   it, and we're done.  The agenda item takes precedence over any
<a name="4396"></a>     *   other scripting we might have.
<a name="4397"></a>     *   
<a name="4398"></a>     *   Finally, if we also inherit from Script, and we didn't find an
<a name="4399"></a>     *   active ConvNode or an agenda item that was ready to execute, we
<a name="4400"></a>     *   invoke our doScript() method.  This makes it especially easy to
<a name="4401"></a>     *   define random background messages for the actor - just add an
<a name="4402"></a>     *   EventList class (ShuffledEventList is usually the right one) to
<a name="4403"></a>     *   the state's superclass list, and define a list of background
<a name="4404"></a>     *   message strings.  
<a name="4405"></a>     */
<a name="4406"></a>    takeTurn()
<a name="4407"></a>    {
<a name="4408"></a>        local actor = getActor();
<a name="4409"></a>
<a name="4410"></a>        /* 
<a name="4411"></a>         *   Check to see if we want to continue a conversation.  If so,
<a name="4412"></a>         *   and we haven't already conversed this turn, try the
<a name="4413"></a>         *   continuing conversation.  If that displays anything, consider
<a name="4414"></a>         *   the turn done.
<a name="4415"></a>         *   
<a name="4416"></a>         *   Otherwise, try executing an agenda item.  If we do, consider
<a name="4417"></a>         *   the turn done.
<a name="4418"></a>         *   
<a name="4419"></a>         *   Otherwise, if we're of class Script, execute our scripted
<a name="4420"></a>         *   action.  
<a name="4421"></a>         */
<a name="4422"></a>        if (actor.curConvNode != nil
<a name="4423"></a>            &amp;&amp; !actor.conversedThisTurn()
<a name="4424"></a>            &amp;&amp; actor.curConvNode.npcContinueConversation())
<a name="4425"></a>        {
<a name="4426"></a>            /* 
<a name="4427"></a>             *   we displayed an NPC-motivated conversation continuation,
<a name="4428"></a>             *   so we're done with this turn 
<a name="4429"></a>             */
<a name="4430"></a>        }
<a name="4431"></a>        else if (actor.executeAgenda())
<a name="4432"></a>        {
<a name="4433"></a>            /* we executed an agenda item, so we need do nothing more */
<a name="4434"></a>        }
<a name="4435"></a>        else if (ofKind(Script))
<a name="4436"></a>        {
<a name="4437"></a>            /* we're a Script, so invoke our scripted action */
<a name="4438"></a>            doScript();
<a name="4439"></a>        }
<a name="4440"></a>    }
<a name="4441"></a>
<a name="4442"></a>    /*
<a name="4443"></a>     *   Receive notification that we just followed another actor as part
<a name="4444"></a>     *   of our programmed following behavior (in other words, due to our
<a name="4445"></a>     *   'followingActor' property, not due to an explicit FOLLOW command
<a name="4446"></a>     *   directed to us).  'success' is true if we ended up in the actor's
<a name="4447"></a>     *   location, nil if not.
<a name="4448"></a>     *   
<a name="4449"></a>     *   This can be used to update the actor's state after a 'follow'
<a name="4450"></a>     *   operation occurs; for example, if the actor's state depends on
<a name="4451"></a>     *   the actor's location, this can update the state accordingly.  We
<a name="4452"></a>     *   don't do anything by default.  
<a name="4453"></a>     */
<a name="4454"></a>    justFollowed(success)
<a name="4455"></a>    {
<a name="4456"></a>        /* do nothing by default */
<a name="4457"></a>    }
<a name="4458"></a>
<a name="4459"></a>    /*
<a name="4460"></a>     *   Our group-travel arrival description.  By default, when we perform
<a name="4461"></a>     *   an accompanying travel with another actor as the lead actor, the
<a name="4462"></a>     *   accompanying travel state will display this message instead of our
<a name="4463"></a>     *   specialDesc when the lead actor first arrives in the new location.
<a name="4464"></a>     *   We'll just display our own specialDesc by default, but this should
<a name="4465"></a>     *   usually be overridden to say something specific to the group
<a name="4466"></a>     *   travel arrival.  The actual message is entirely dependent on the
<a name="4467"></a>     *   nature of the group travel, which is why we don't provide a
<a name="4468"></a>     *   special message by default.
<a name="4469"></a>     *   
<a name="4470"></a>     *   For scripted behavior, it's sometimes better to use arrivingTurn()
<a name="4471"></a>     *   rather than this method to describe the behavior.
<a name="4472"></a>     *   arrivingWithDesc() is called as part of the room description, so
<a name="4473"></a>     *   it's best for any message shown here to fit well into the usual
<a name="4474"></a>     *   room description format.  For more complex transitions into the
<a name="4475"></a>     *   new room state, arrivingTurn() is sometimes more appropriate,
<a name="4476"></a>     *   since it runs like a daemon, after the arrival (and thus the new
<a name="4477"></a>     *   room description) is completed.  
<a name="4478"></a>     */
<a name="4479"></a>    arrivingWithDesc() { specialDesc(); }
<a name="4480"></a>
<a name="4481"></a>    /*
<a name="4482"></a>     *   Perform any special action on a group-travel arrival.  When group
<a name="4483"></a>     *   travel is performed using the AccompanyingInTravelState class,
<a name="4484"></a>     *   this is essentially called in lieu of the regular takeTurn()
<a name="4485"></a>     *   method on the state that is coming into effect after the group
<a name="4486"></a>     *   travel.  (Not really, but effectively: the accompanying travel
<a name="4487"></a>     *   state will still be in effect, so its takeTurn() method is what's
<a name="4488"></a>     *   really called, but that method will call this method explicitly.)
<a name="4489"></a>     *   By default, we do nothing.  Since this runs on our turn, it's a
<a name="4490"></a>     *   good place to put any scripted behavior we perform on arriving at
<a name="4491"></a>     *   our new destination after the group travel.  
<a name="4492"></a>     */
<a name="4493"></a>    arrivingTurn() { }
<a name="4494"></a>
<a name="4495"></a>    /* 
<a name="4496"></a>     *   For our TravelMessageHandler implementation, the nominal traveler
<a name="4497"></a>     *   is our actor.  Note that this is all we need to implement for
<a name="4498"></a>     *   travel message handling, since we simply inherit the default
<a name="4499"></a>     *   handling for all of the arrival/departure messages.  
<a name="4500"></a>     */
<a name="4501"></a>    getNominalTraveler() { return getActor(); }
<a name="4502"></a>;
<a name="4503"></a>
<a name="4504"></a>/*
<a name="4505"></a> *   A "ready for conversation" state.  This can be used as the base class
<a name="4506"></a> *   for actor states when the actor is receptive to conversation, and we
<a name="4507"></a> *   want to have the sense of a conversational context.  The key feature
<a name="4508"></a> *   that this class provides is the ability to provide messages when
<a name="4509"></a> *   engaging and disengaging the conversation.
<a name="4510"></a> *   
<a name="4511"></a> *   Note that this state is NOT required for conversation, since the basic
<a name="4512"></a> *   ActorState object accepts conversational commands like ASK, TELL,
<a name="4513"></a> *   GIVE, and TAKE.  The special feature of the "conversation ready" state
<a name="4514"></a> *   is that we explicitly move the actor to a separate state when
<a name="4515"></a> *   conversation begins.  This is especially appropriate for states in
<a name="4516"></a> *   which the NPC is actively carrying on some other activity; the
<a name="4517"></a> *   conversation should interrupt those states, so that the actor stops
<a name="4518"></a> *   the other activity and gives us its full attention.
<a name="4519"></a> *   
<a name="4520"></a> *   This type of state can be associated with its in-conversation state
<a name="4521"></a> *   object in one of two ways.  First, the inConvState property can be
<a name="4522"></a> *   explicitly set to point to the in-conversation state object.  Second,
<a name="4523"></a> *   this object can be nested inside its in-conversation state object via
<a name="4524"></a> *   the 'location' property (so you can use the '+' syntax to put this
<a name="4525"></a> *   object inside its in-conversation state object).  The 'ready' object
<a name="4526"></a> *   goes inside the 'conversing' object because a single 'conversing'
<a name="4527"></a> *   object can frequently be shared among several 'ready' states.  
<a name="4528"></a> */
<a name="4529"></a>class ConversationReadyState: ActorState
<a name="4530"></a>    /*
<a name="4531"></a>     *   The associated in-conversation state.  This should be set to an
<a name="4532"></a>     *   InConversationState object that controls the actor's behavior
<a name="4533"></a>     *   while carrying on a conversation.  Note that the library will
<a name="4534"></a>     *   automatically set this if the instance is nested (via its
<a name="4535"></a>     *   'location' property) inside an InConversationState object.  
<a name="4536"></a>     */
<a name="4537"></a>    inConvState = nil
<a name="4538"></a>
<a name="4539"></a>    /* my implied conversational state is my in-conversation state */
<a name="4540"></a>    getImpliedConvState = (inConvState)
<a name="4541"></a>
<a name="4542"></a>    /*
<a name="4543"></a>     *   Show our greeting message.  If 'explicit' is true, it means that
<a name="4544"></a>     *   the player character is greeting us through an explicit greeting
<a name="4545"></a>     *   command, such as HELLO or TALK TO.  Otherwise, the greeting is
<a name="4546"></a>     *   implied by some other conversational action, such a ASK ABOUT or
<a name="4547"></a>     *   SHOW TO.  We do nothing by default; this should be overridden in
<a name="4548"></a>     *   most cases to show some sort of exchange of pleasantries -
<a name="4549"></a>     *   something like this:
<a name="4550"></a>     *   
<a name="4551"></a>     *.  &gt;bob, hello
<a name="4552"></a>     *.  "Hi, there," you say.
<a name="4553"></a>     *   
<a name="4554"></a>     *   Bob looks up over his newspaper.  "Oh, hello," he says, putting
<a name="4555"></a>     *   down the paper.  "What can I do for you?"
<a name="4556"></a>     *   
<a name="4557"></a>     *   Note that games shouldn't usually override this method.  Instead,
<a name="4558"></a>     *   you should simply create a HelloTopic entry and put it inside the
<a name="4559"></a>     *   state object; we'll find the HelloTopic and show its message as
<a name="4560"></a>     *   our greeting.
<a name="4561"></a>     *   
<a name="4562"></a>     *   If you want to distinguish between explicit and implicit
<a name="4563"></a>     *   greetings, you can create an ImpHelloTopic entry for implied
<a name="4564"></a>     *   greetings (i.e., the kind of greeting that occurs automatically
<a name="4565"></a>     *   when the player jumps right into a conversation with our actor
<a name="4566"></a>     *   using ASK ABOUT or the like, without explicitly saying HELLO
<a name="4567"></a>     *   first).  The regular HelloTopic will handle explicit greetings,
<a name="4568"></a>     *   and the ImpHelloTopic will handle the implied kind.  
<a name="4569"></a>     */
<a name="4570"></a>    showGreetingMsg(actor, explicit)
<a name="4571"></a>    {
<a name="4572"></a>        /* look for a HelloTopic in our topic database */
<a name="4573"></a>        if (handleTopic(actor, explicit ? helloTopicObj : impHelloTopicObj,
<a name="4574"></a>                        helloConvType, nil))
<a name="4575"></a>            "&lt;.p&gt;";
<a name="4576"></a>    }
<a name="4577"></a>
<a name="4578"></a>    /*
<a name="4579"></a>     *   Enter this state from a conversation.  This should show any
<a name="4580"></a>     *   message we want to display when we're ending a conversation and
<a name="4581"></a>     *   switching from the conversation to this state.  'reason' is the
<a name="4582"></a>     *   endConvXxx enum indicating what triggered the termination of the
<a name="4583"></a>     *   conversation.  'oldNode' is the ConvNode we were in just before we
<a name="4584"></a>     *   initiated the termination - we need this information because we
<a name="4585"></a>     *   want to look in the ConvNode for a Bye topic message to display,
<a name="4586"></a>     *   but we can't just look in the actor for the node because it will
<a name="4587"></a>     *   already have been cleared out by the time we get here.
<a name="4588"></a>     *   
<a name="4589"></a>     *   Games shouldn't normally override this method.  Instead, simply
<a name="4590"></a>     *   create a ByeTopic entry and put it inside the state object; we'll
<a name="4591"></a>     *   find the ByeTopic and show its message for the goodbye.
<a name="4592"></a>     *   
<a name="4593"></a>     *   If you want to distinguish between different types of goodbyes,
<a name="4594"></a>     *   you can create an ImpByeTopic for any implied goodbye (i.e., the
<a name="4595"></a>     *   kind where the other actor just walks away, or where we get bored
<a name="4596"></a>     *   of the other actor ignoring us).  You can also further
<a name="4597"></a>     *   differentiate by creating BoredByeTopic and/or LeaveByeTopic
<a name="4598"></a>     *   objects to handle just those cases.  The regular ByeTopic will
<a name="4599"></a>     *   handle explicit GOODBYE commands, and the others (ImpByeTopic,
<a name="4600"></a>     *   BoredByeTopic, LeaveByeTopic) will handle the implied kinds.  
<a name="4601"></a>     */
<a name="4602"></a>    enterFromConversation(actor, reason, oldNode)
<a name="4603"></a>    {
<a name="4604"></a>        local topic;
<a name="4605"></a>        local reasonMap = [endConvBye, byeTopicObj,
<a name="4606"></a>                           endConvTravel, leaveByeTopicObj,
<a name="4607"></a>                           endConvBoredom, boredByeTopicObj,
<a name="4608"></a>                           endConvActor, actorByeTopicObj];
<a name="4609"></a>        
<a name="4610"></a>        /* figure out which topic object we need, based on the reason code */
<a name="4611"></a>        topic = reasonMap[reasonMap.indexOf(reason) + 1];
<a name="4612"></a>        
<a name="4613"></a>        /* 
<a name="4614"></a>         *   Look for a ByeTopic in the ConvNode; failing that, try our own
<a name="4615"></a>         *   database. 
<a name="4616"></a>         */
<a name="4617"></a>        if (oldNode == nil
<a name="4618"></a>            || !oldNode.handleConversation(actor, topic, byeConvType, nil))
<a name="4619"></a>        {
<a name="4620"></a>            /* there's no node handler; try our own database */
<a name="4621"></a>            handleTopic(actor, topic, byeConvType, nil);
<a name="4622"></a>        }
<a name="4623"></a>    }
<a name="4624"></a>
<a name="4625"></a>    /* handle a conversational action directed to our actor */
<a name="4626"></a>    handleConversation(otherActor, topic, convType)
<a name="4627"></a>    {
<a name="4628"></a>        /* 
<a name="4629"></a>         *   If this is a greeting, handle it ourselves.  Otherwise, pass
<a name="4630"></a>         *   it along to our associated in-conversation state.  
<a name="4631"></a>         */
<a name="4632"></a>        if (convType == helloConvType)
<a name="4633"></a>        {
<a name="4634"></a>            /* 
<a name="4635"></a>             *   Switch to our associated in-conversation state and show a
<a name="4636"></a>             *   greeting.  Since we're explicitly entering the
<a name="4637"></a>             *   conversation, we have no topic entry.  
<a name="4638"></a>             */
<a name="4639"></a>            enterConversation(otherActor, nil);
<a name="4640"></a>
<a name="4641"></a>            /* show or schedule a topic inventory, as appropriate */
<a name="4642"></a>            conversationManager.showOrScheduleTopicInventory(
<a name="4643"></a>                getActor(), otherActor);
<a name="4644"></a>        }
<a name="4645"></a>        else
<a name="4646"></a>        {
<a name="4647"></a>            /* 
<a name="4648"></a>             *   it's not a greeting, so pass it to our in-conversation
<a name="4649"></a>             *   state for handling
<a name="4650"></a>             */
<a name="4651"></a>            inConvState.handleConversation(otherActor, topic, convType);
<a name="4652"></a>        }
<a name="4653"></a>    }
<a name="4654"></a>
<a name="4655"></a>    /*
<a name="4656"></a>     *   Initiate conversation based on the given simulation object.  This
<a name="4657"></a>     *   is an internal method that isn't usually called directly from game
<a name="4658"></a>     *   code; game code usually calls the Actor's initiateTopic(), which
<a name="4659"></a>     *   calls this routine to check for a topic that's part of the state
<a name="4660"></a>     *   object. 
<a name="4661"></a>     */
<a name="4662"></a>    initiateTopic(obj)
<a name="4663"></a>    {
<a name="4664"></a>        /* defer to our in-conversation state */
<a name="4665"></a>        return inConvState.initiateTopic(obj);
<a name="4666"></a>    }
<a name="4667"></a>
<a name="4668"></a>    /*
<a name="4669"></a>     *   Receive notification that a TopicEntry is being used (via its
<a name="4670"></a>     *   handleTopic method) to respond to a command.  If the TopicEntry is
<a name="4671"></a>     *   conversational, automatically enter our in-conversation state.  
<a name="4672"></a>     */
<a name="4673"></a>    notifyTopicResponse(fromActor, entry)
<a name="4674"></a>    {
<a name="4675"></a>        if (entry.isConversational)
<a name="4676"></a>            enterConversation(fromActor, entry);
<a name="4677"></a>    }
<a name="4678"></a>
<a name="4679"></a>    /* 
<a name="4680"></a>     *   Enter a conversation with the given actor, either explicitly (via
<a name="4681"></a>     *   HELLO or TALK TO) or implicitly (by directly asking a question,
<a name="4682"></a>     *   etc).  'entry' gives the TopicEntry that's triggering the implicit
<a name="4683"></a>     *   conversation entry; if this is nil, it means that we're being
<a name="4684"></a>     *   triggered explicitly.  
<a name="4685"></a>     */
<a name="4686"></a>    enterConversation(actor, entry)
<a name="4687"></a>    {
<a name="4688"></a>        local myActor = getActor();
<a name="4689"></a>        local explicit = (entry == nil);
<a name="4690"></a>        
<a name="4691"></a>        /* if the actor can't talk to us, we can't enter the conversation */
<a name="4692"></a>        if (!actor.canTalkTo(myActor))
<a name="4693"></a>        {
<a name="4694"></a>            /* tell them we can't talk now */
<a name="4695"></a>            reportFailure(&amp;objCannotHearActorMsg, myActor);
<a name="4696"></a>            
<a name="4697"></a>            /* terminate the command */
<a name="4698"></a>            exit;
<a name="4699"></a>        }
<a name="4700"></a>
<a name="4701"></a>        /* 
<a name="4702"></a>         *   Show our greeting, if desired.  We show a greeting if we're
<a name="4703"></a>         *   being invoked explicitly (that is, there's no TopicEntry), or
<a name="4704"></a>         *   if we're being invoked explicitly and the TopicEntry implies a
<a name="4705"></a>         *   greeting.  
<a name="4706"></a>         */
<a name="4707"></a>        if (explicit || entry.impliesGreeting)
<a name="4708"></a>            showGreetingMsg(actor, explicit);
<a name="4709"></a>
<a name="4710"></a>        /* activate the in-conversation state */
<a name="4711"></a>        myActor.setCurState(inConvState);
<a name="4712"></a>    }
<a name="4713"></a>
<a name="4714"></a>    /*
<a name="4715"></a>     *   Get this state's suggested topic list.  ConversationReady states
<a name="4716"></a>     *   shouldn't normally have topic entries of their own, since a
<a name="4717"></a>     *   ConvversationReady state usually forwards conversation handling
<a name="4718"></a>     *   to its corresponding in-conversation state.  So, simply return
<a name="4719"></a>     *   the suggestion list from our in-conversation state object.  
<a name="4720"></a>     */
<a name="4721"></a>    stateSuggestedTopics = (inConvState.suggestedTopics)
<a name="4722"></a>
<a name="4723"></a>    /* initialize the actor state object */
<a name="4724"></a>    initializeActorState()
<a name="4725"></a>    {
<a name="4726"></a>        /* inherit the default handling */
<a name="4727"></a>        inherited();
<a name="4728"></a>
<a name="4729"></a>        /* 
<a name="4730"></a>         *   if we're nested inside an in-conversation state object, the
<a name="4731"></a>         *   containing in-conversation state is the one we'll use for
<a name="4732"></a>         *   conversations 
<a name="4733"></a>         */
<a name="4734"></a>        if (location.ofKind(InConversationState))
<a name="4735"></a>            inConvState = location;
<a name="4736"></a>    }
<a name="4737"></a>;
<a name="4738"></a>
<a name="4739"></a>/*
<a name="4740"></a> *   The "in-conversation" state.  This works with ConversationReadyState
<a name="4741"></a> *   to handle transitions in and out of conversations.  In this state, we
<a name="4742"></a> *   are actively engaged in a conversation.
<a name="4743"></a> *   
<a name="4744"></a> *   Throughout this implementation, we assume that we only care about
<a name="4745"></a> *   conversations with a single character, specifically the player
<a name="4746"></a> *   character.  There's generally no good reason to fully model
<a name="4747"></a> *   conversations between NPC's, since that kind of NPC activity is in
<a name="4748"></a> *   most cases purely pre-scripted and thus requires no special state
<a name="4749"></a> *   tracking.  Since we generally only need to worry about tracking a
<a name="4750"></a> *   conversation with the player character, we don't bother with the
<a name="4751"></a> *   possibility that we're simultaneously in conversation with more than
<a name="4752"></a> *   one other character.  
<a name="4753"></a> */
<a name="4754"></a>class InConversationState: ActorState
<a name="4755"></a>    /*
<a name="4756"></a>     *   Our attention span, in turns.  This is the number of turns that
<a name="4757"></a>     *   we'll be willing to stay in the conversation while the other
<a name="4758"></a>     *   character is ignoring us.  After the conversation has been idle
<a name="4759"></a>     *   this long, we'll assume the other actor is no longer talking to
<a name="4760"></a>     *   us, so we'll terminate the conversation ourselves.
<a name="4761"></a>     *   
<a name="4762"></a>     *   If the NPC's doesn't have a limited attention span, set this
<a name="4763"></a>     *   property to nil.  This will prevent the NPC from ever disengaging
<a name="4764"></a>     *   of its own volition.    
<a name="4765"></a>     */
<a name="4766"></a>    attentionSpan = 4
<a name="4767"></a>
<a name="4768"></a>    /*
<a name="4769"></a>     *   The state to switch to when the conversation ends.  Instances can
<a name="4770"></a>     *   override this to select the next state.  By default, we'll return
<a name="4771"></a>     *   to the state that we were in immediately before the conversation
<a name="4772"></a>     *   started.  
<a name="4773"></a>     */
<a name="4774"></a>    nextState = (previousState)
<a name="4775"></a>
<a name="4776"></a>    /*
<a name="4777"></a>     *   End the current conversation.  'reason' indicates why we're
<a name="4778"></a>     *   leaving the conversation - this is one of the endConvXxx enums
<a name="4779"></a>     *   defined in adv3.h.
<a name="4780"></a>     *   
<a name="4781"></a>     *   This method is a convenience only; you aren't required to call
<a name="4782"></a>     *   this method to end the conversation, since you can simply switch
<a name="4783"></a>     *   to another actor state directly if you prefer.  This method's
<a name="4784"></a>     *   main purpose is to display an appropriate message terminating the
<a name="4785"></a>     *   conversation while switching to the new state.  If you want to
<a name="4786"></a>     *   display your own message directly from the code that's changing
<a name="4787"></a>     *   the state, there's no reason to call this.
<a name="4788"></a>     *   
<a name="4789"></a>     *   This returns true if we wish to allow the conversation to end,
<a name="4790"></a>     *   nil if not.  
<a name="4791"></a>     */
<a name="4792"></a>    endConversation(actor, reason)
<a name="4793"></a>    {
<a name="4794"></a>        local nxt;
<a name="4795"></a>        local myActor = getActor();
<a name="4796"></a>
<a name="4797"></a>        /* 
<a name="4798"></a>         *   note the current ConvNode for our actor - when we check with
<a name="4799"></a>         *   the ConvNode to see about ending the conversation, this will
<a name="4800"></a>         *   automatically exit the ConvNode, so we need to save this first
<a name="4801"></a>         *   so that we can refer to it later to check for a Bye topic
<a name="4802"></a>         */
<a name="4803"></a>        local oldNode = myActor.curConvNode;
<a name="4804"></a>
<a name="4805"></a>        /* 
<a name="4806"></a>         *   Inherit the base behavior first - if it disallows the action,
<a name="4807"></a>         *   return failure.  The inherited version will check with the
<a name="4808"></a>         *   current ConvNode to see if has any objection.  
<a name="4809"></a>         */
<a name="4810"></a>        if (!inherited(actor, reason))
<a name="4811"></a>            return nil;
<a name="4812"></a>
<a name="4813"></a>        /* get the next state */
<a name="4814"></a>        nxt = nextState;
<a name="4815"></a>
<a name="4816"></a>        /* if there isn't one, stay in the actor's current state */
<a name="4817"></a>        if (nxt == nil)
<a name="4818"></a>            nxt = myActor.curState;
<a name="4819"></a>        
<a name="4820"></a>        /* 
<a name="4821"></a>         *   If the next state is a 'conversation ready' state, tell it
<a name="4822"></a>         *   we're entering from a conversation.  We're ending the
<a name="4823"></a>         *   conversation explicitly only if 'reason' is endConvBye.  Pass
<a name="4824"></a>         *   along the ConvNode we just exited (if any), so that we can
<a name="4825"></a>         *   look for a response in the node.  
<a name="4826"></a>         */
<a name="4827"></a>        if (nxt.ofKind(ConversationReadyState))
<a name="4828"></a>            nxt.enterFromConversation(actor, reason, oldNode);
<a name="4829"></a>
<a name="4830"></a>        /* switch our actor to the next state */
<a name="4831"></a>        myActor.setCurState(nxt);
<a name="4832"></a>
<a name="4833"></a>        /* indicate that we are allowing the conversation to end */
<a name="4834"></a>        return true;
<a name="4835"></a>    }
<a name="4836"></a>
<a name="4837"></a>    /*  handle a conversational command */
<a name="4838"></a>    handleConversation(otherActor, topic, convType)
<a name="4839"></a>    {
<a name="4840"></a>        /* handle goodbyes specially */
<a name="4841"></a>        if (convType == byeConvType)
<a name="4842"></a>        {
<a name="4843"></a>            /*
<a name="4844"></a>             *   If this is an implicit goodbye, run the normal
<a name="4845"></a>             *   conversation handling in order to display any implied
<a name="4846"></a>             *   ByeTopic message - but capture the output in case we
<a name="4847"></a>             *   decide not to end the conversation after all.  Only do
<a name="4848"></a>             *   this in the case of an implicit goodbye, though - for an
<a name="4849"></a>             *   explicit goodbye, there's no need for this as the explicit
<a name="4850"></a>             *   BYE will do the same thing on its own.  
<a name="4851"></a>             */
<a name="4852"></a>            local txt = nil;
<a name="4853"></a>            if (topic != byeTopicObj)
<a name="4854"></a>            {
<a name="4855"></a>                txt = mainOutputStream.captureOutput(
<a name="4856"></a>                    {: inherited(otherActor, topic, convType) });
<a name="4857"></a>            }
<a name="4858"></a>
<a name="4859"></a>            /* 
<a name="4860"></a>             *   try to end the conversation; if we won't allow it,
<a name="4861"></a>             *   terminate the action here 
<a name="4862"></a>             */
<a name="4863"></a>            if (!endConversation(otherActor, endConvBye))
<a name="4864"></a>                exit;
<a name="4865"></a>
<a name="4866"></a>            /* show the captured ByeTopic output */
<a name="4867"></a>            if (txt != nil)
<a name="4868"></a>                say(txt);
<a name="4869"></a>        }
<a name="4870"></a>        else
<a name="4871"></a>        {
<a name="4872"></a>            /* use the inherited handling */
<a name="4873"></a>            inherited(otherActor, topic, convType);
<a name="4874"></a>        }
<a name="4875"></a>    }
<a name="4876"></a>
<a name="4877"></a>    /* 
<a name="4878"></a>     *   provide a default HELLO response, if we don't have a special
<a name="4879"></a>     *   TopicEntry for it 
<a name="4880"></a>     */
<a name="4881"></a>    defaultGreetingResponse(actor)
<a name="4882"></a>    {
<a name="4883"></a>        /* 
<a name="4884"></a>         *   As our default response, point out that we're already at the
<a name="4885"></a>         *   actor's service.  (This isn't an error, because the other
<a name="4886"></a>         *   actor might not have been talking to us, even though we
<a name="4887"></a>         *   thought we were talking to them.)  
<a name="4888"></a>         */
<a name="4889"></a>        gLibMessages.alreadyTalkingTo(getActor(), actor);
<a name="4890"></a>    }
<a name="4891"></a>
<a name="4892"></a>    takeTurn()
<a name="4893"></a>    {
<a name="4894"></a>        local actor = getActor();
<a name="4895"></a>        
<a name="4896"></a>        /* if we didn't interact this turn, increment our boredom counter */
<a name="4897"></a>        if (!actor.conversedThisTurn())
<a name="4898"></a>            actor.boredomCount++;
<a name="4899"></a>
<a name="4900"></a>        /* run the inherited handling */
<a name="4901"></a>        inherited();
<a name="4902"></a>    }
<a name="4903"></a>
<a name="4904"></a>    /* activate this state */
<a name="4905"></a>    activateState(actor, oldState)
<a name="4906"></a>    {
<a name="4907"></a>        /*
<a name="4908"></a>         *   If the previous state was a ConversationReadyState, or we
<a name="4909"></a>         *   have no other state remembered, remember the previous state -
<a name="4910"></a>         *   this is the default we'll return to at the end of the
<a name="4911"></a>         *   conversation, if the instance doesn't specify another state.
<a name="4912"></a>         *   
<a name="4913"></a>         *   We don't remember prior states that aren't conv-ready states
<a name="4914"></a>         *   to make it easier to temporarily interrupt a conversation
<a name="4915"></a>         *   with some other state, and later return to the conversation.
<a name="4916"></a>         *   If we remembered every prior state, then we'd return to the
<a name="4917"></a>         *   interrupting state when the conversation ended, which is
<a name="4918"></a>         *   usually not what's wanted.  Usually, we want to return to the
<a name="4919"></a>         *   last conv-ready state when a conversation ends, ignoring any
<a name="4920"></a>         *   other intermediate states that have been active since the
<a name="4921"></a>         *   conv-ready state was last in effect.  
<a name="4922"></a>         */
<a name="4923"></a>        if (previousState == nil || oldState.ofKind(ConversationReadyState))
<a name="4924"></a>            previousState = oldState;
<a name="4925"></a>
<a name="4926"></a>        /* 
<a name="4927"></a>         *   reset the actor's boredom counter, since we're just starting a
<a name="4928"></a>         *   new conversation, and add our boredom agenda item to the
<a name="4929"></a>         *   active list to monitor our boredom level 
<a name="4930"></a>         */
<a name="4931"></a>        actor.boredomCount = 0;
<a name="4932"></a>        actor.addToAgenda(actor.boredomAgendaItem);
<a name="4933"></a>
<a name="4934"></a>        /* remember the time of the last conversation command */
<a name="4935"></a>        actor.lastConvTime = Schedulable.gameClockTime;
<a name="4936"></a>    }
<a name="4937"></a>
<a name="4938"></a>    /* deactivate this state */
<a name="4939"></a>    deactivateState(actor, newState)
<a name="4940"></a>    {
<a name="4941"></a>        /* 
<a name="4942"></a>         *   we're leaving the conversation state, so there's no need to
<a name="4943"></a>         *   monitor our boredom level any longer 
<a name="4944"></a>         */
<a name="4945"></a>        actor.removeFromAgenda(actor.boredomAgendaItem);
<a name="4946"></a>
<a name="4947"></a>        /* do the normal work */
<a name="4948"></a>        inherited(actor, newState);
<a name="4949"></a>    }
<a name="4950"></a>
<a name="4951"></a>    /* 
<a name="4952"></a>     *   The previous state - this is the state we were in before the
<a name="4953"></a>     *   conversation began, and the one we'll return to by default when
<a name="4954"></a>     *   the conversation ends.  We'll set this automatically on
<a name="4955"></a>     *   activation.  
<a name="4956"></a>     */
<a name="4957"></a>    previousState = nil
<a name="4958"></a>;
<a name="4959"></a>
<a name="4960"></a>/*
<a name="4961"></a> *   A special kind of agenda item for monitoring "boredom" during a
<a name="4962"></a> *   conversation.  We check to see if our actor is in a conversation, and
<a name="4963"></a> *   the PC has been ignoring the conversation for too long; if so, our
<a name="4964"></a> *   actor initiates the end of the conversation, since the PC apparently
<a name="4965"></a> *   isn't paying any attention to us. 
<a name="4966"></a> */
<a name="4967"></a>class BoredomAgendaItem: AgendaItem
<a name="4968"></a>    /* we construct these dynamically during actor initialization */
<a name="4969"></a>    construct(actor)
<a name="4970"></a>    {
<a name="4971"></a>        /* remember our actor as our location */
<a name="4972"></a>        location = actor;
<a name="4973"></a>    }
<a name="4974"></a>
<a name="4975"></a>    /* 
<a name="4976"></a>     *   we're ready to run if our actor is in an InConversationState and
<a name="4977"></a>     *   its boredom count has reached the limit for the state 
<a name="4978"></a>     */
<a name="4979"></a>    isReady()
<a name="4980"></a>    {
<a name="4981"></a>        local actor = getActor();
<a name="4982"></a>        local state = actor.curState;
<a name="4983"></a>
<a name="4984"></a>        return (inherited()
<a name="4985"></a>                &amp;&amp; state.ofKind(InConversationState)
<a name="4986"></a>                &amp;&amp; state.attentionSpan != nil
<a name="4987"></a>                &amp;&amp; actor.boredomCount &gt;= state.attentionSpan);
<a name="4988"></a>    }
<a name="4989"></a>
<a name="4990"></a>    /* on invocation, end the conversation */
<a name="4991"></a>    invokeItem()
<a name="4992"></a>    {
<a name="4993"></a>        local actor = getActor();
<a name="4994"></a>        local state = actor.curState;
<a name="4995"></a>
<a name="4996"></a>        /* tell the state to end the conversation */
<a name="4997"></a>        state.endConversation(actor.getCurrentInterlocutor(), endConvBoredom);
<a name="4998"></a>    }
<a name="4999"></a>
<a name="5000"></a>    /* 
<a name="5001"></a>     *   by default, handle boredom before other agenda items - we do this
<a name="5002"></a>     *   because an ongoing conversation will be the first thing on the
<a name="5003"></a>     *   NPC's mind 
<a name="5004"></a>     */
<a name="5005"></a>    agendaOrder = 50
<a name="5006"></a>;
<a name="5007"></a>
<a name="5008"></a>
<a name="5009"></a>/*
<a name="5010"></a> *   A "hermit" actor state is a state where the actor is unresponsive to
<a name="5011"></a> *   conversational overtures (ASK ABOUT, TELL ABOUT, HELLO, GOODBYE, YES,
<a name="5012"></a> *   NO, SHOW TO, GIVE TO, and any orders directed to the actor).  Any
<a name="5013"></a> *   attempt at conversation will be met with the 'noResponse' message.  
<a name="5014"></a> */
<a name="5015"></a>class HermitActorState: ActorState
<a name="5016"></a>    /* 
<a name="5017"></a>     *   Show our response to any conversational command.  We'll simply
<a name="5018"></a>     *   show the standard "there's no response" message by default, but
<a name="5019"></a>     *   subclasses can (and usually should) override this to explain
<a name="5020"></a>     *   what's really going on.  Note that this routine will be invoked
<a name="5021"></a>     *   for any sort of conversation command, so any override needs to be
<a name="5022"></a>     *   generic enough that it's equally good for ASK, TELL, and
<a name="5023"></a>     *   everything else.
<a name="5024"></a>     *   
<a name="5025"></a>     *   Note that it's fairly easy to create a shuffled list of random
<a name="5026"></a>     *   messages, if you want to add some variety to the actor's
<a name="5027"></a>     *   responses.  To do this, use an embedded ShuffledEventList:
<a name="5028"></a>     *   
<a name="5029"></a>     *   myState: HermitActorState
<a name="5030"></a>     *.    noResponse() { myList.doScript(); }
<a name="5031"></a>     *.    myList: ShuffledEventList {
<a name="5032"></a>     *.      ['message1', 'message2', 'message3'] }
<a name="5033"></a>     *.  ;
<a name="5034"></a>     */
<a name="5035"></a>    noResponse() { mainReport(&amp;noResponseFromMsg, getActor()); }
<a name="5036"></a>
<a name="5037"></a>    /* all conversation actions get the same default response */
<a name="5038"></a>    handleConversation(otherActor, topic, convType)
<a name="5039"></a>    {
<a name="5040"></a>        /* just show our standard default response */
<a name="5041"></a>        noResponse();
<a name="5042"></a>    }
<a name="5043"></a>
<a name="5044"></a>    /* 
<a name="5045"></a>     *   Since the hermit state blocks topics from outside the state, don't
<a name="5046"></a>     *   offer suggestions for other topics while in this state.
<a name="5047"></a>     *   
<a name="5048"></a>     *   Note that you might sometimes want to override this to allow the
<a name="5049"></a>     *   usual topic suggestions (by setting this to nil).  In particular:
<a name="5050"></a>     *   
<a name="5051"></a>     *   - If it's not outwardly obvious that the actor is unresponsive,
<a name="5052"></a>     *   you'll probably want to allow suggestions.  Remember, TOPICS
<a name="5053"></a>     *   suggests topics that the *PC* wants to talk about, not things the
<a name="5054"></a>     *   NPC is interested in.  If the PC doesn't necessarily know that the
<a name="5055"></a>     *   NPC won't respond, the PC would still want to ask about those
<a name="5056"></a>     *   topics.
<a name="5057"></a>     *   
<a name="5058"></a>     *   - If the hermit state is to be short-lived, you might want to show
<a name="5059"></a>     *   the topic suggestions even in the hermit state, so that the player
<a name="5060"></a>     *   is aware that there are still useful topics to explore with the
<a name="5061"></a>     *   NPC.  The player might otherwise assume that the NPC is out of
<a name="5062"></a>     *   useful topics, and not bother trying again later when the NPC
<a name="5063"></a>     *   becomes more responsive.  
<a name="5064"></a>     */
<a name="5065"></a>    limitSuggestions = true
<a name="5066"></a>;
<a name="5067"></a>
<a name="5068"></a>/*
<a name="5069"></a> *   The basic "accompanying" state.  In this state, whenever the actor
<a name="5070"></a> *   we're accompanying travels to a location we want to follow, we'll
<a name="5071"></a> *   travel at the same time with the other actor.  
<a name="5072"></a> */
<a name="5073"></a>class AccompanyingState: ActorState
<a name="5074"></a>    /*
<a name="5075"></a>     *   Check to see if we are to accompany the given traveler on the
<a name="5076"></a>     *   given travel.  'traveler' is the Traveler performing the travel,
<a name="5077"></a>     *   and 'conn' is the connector that the traveler is about to take.
<a name="5078"></a>     *   
<a name="5079"></a>     *   Note that 'traveler' is a Traveler object.  This will simply be an
<a name="5080"></a>     *   Actor (which is a kind of Traveler) when the actor is performing
<a name="5081"></a>     *   the travel directly, but it could also be another kind of
<a name="5082"></a>     *   Traveler, such as a Vehicle.  This routine must determine whether
<a name="5083"></a>     *   to accompany other kinds of actors.
<a name="5084"></a>     *   
<a name="5085"></a>     *   By default, we'll return true to indicate that we want to
<a name="5086"></a>     *   accompany any traveler anywhere they go.  This should almost
<a name="5087"></a>     *   always be overridden in practice to be more specific.  
<a name="5088"></a>     */
<a name="5089"></a>    accompanyTravel(traveler, conn) { return true; }
<a name="5090"></a>
<a name="5091"></a>    /* 
<a name="5092"></a>     *   Get our accompanying state object.  We'll create a basic
<a name="5093"></a>     *   accompanying in-travel state object, returning to the current
<a name="5094"></a>     *   state when we're done.  'traveler' is the Traveler object that's
<a name="5095"></a>     *   performing the travel; this might be an Actor, but could also be a
<a name="5096"></a>     *   Vehicle or other Traveler subclass.  
<a name="5097"></a>     */
<a name="5098"></a>    getAccompanyingTravelState(traveler, connector)
<a name="5099"></a>    {
<a name="5100"></a>        /* 
<a name="5101"></a>         *   Create the default intermediate state for the travel.  Note
<a name="5102"></a>         *   that the lead actor is the actor performing the command - this
<a name="5103"></a>         *   won't necessarily be the traveler, since the actor could be
<a name="5104"></a>         *   steering a vehicle.  
<a name="5105"></a>         */
<a name="5106"></a>        return new AccompanyingInTravelState(
<a name="5107"></a>            getActor(), gActor, getActor().curState);
<a name="5108"></a>    }
<a name="5109"></a>
<a name="5110"></a>    /*
<a name="5111"></a>     *   handle a before-travel notification for my actor 
<a name="5112"></a>     */
<a name="5113"></a>    beforeTravel(traveler, connector)
<a name="5114"></a>    {
<a name="5115"></a>        /*
<a name="5116"></a>         *   If we want to accompany the given traveler on this travel, add
<a name="5117"></a>         *   ourselves to the initiating actor's list of accompanying
<a name="5118"></a>         *   actors.  Never set an actor to accompany itself, since doing
<a name="5119"></a>         *   so would lead to infinite recursion.  
<a name="5120"></a>         */
<a name="5121"></a>        if (accompanyTravel(traveler, connector) &amp;&amp; getActor() != gActor)
<a name="5122"></a>        {
<a name="5123"></a>            /* 
<a name="5124"></a>             *   Add me to the list of actors accompanying the actor
<a name="5125"></a>             *   initiating the travel - that actor will run a nested
<a name="5126"></a>             *   travel action on us before doing its own travel.  Note
<a name="5127"></a>             *   that the initiating actor is gActor, since that's the
<a name="5128"></a>             *   actor performing the action that led to the travel.  
<a name="5129"></a>             */
<a name="5130"></a>            gActor.addAccompanyingActor(getActor());
<a name="5131"></a>            
<a name="5132"></a>            /* put my actor into the appropriate new group travel state */
<a name="5133"></a>            getActor().setCurState(
<a name="5134"></a>                getAccompanyingTravelState(traveler, connector));
<a name="5135"></a>        }
<a name="5136"></a>
<a name="5137"></a>        /* inherit the default handling */
<a name="5138"></a>        inherited(traveler, connector);
<a name="5139"></a>    }
<a name="5140"></a>;
<a name="5141"></a>
<a name="5142"></a>/*
<a name="5143"></a> *   "Accompanying in-travel" state - this is an actor state used when an
<a name="5144"></a> *   actor is taking part in a group travel operation.  This state lasts
<a name="5145"></a> *   only as long as the single turn - which belongs to the lead actor -
<a name="5146"></a> *   that it takes to carry out the group travel.  Once our turn comes
<a name="5147"></a> *   around, we'll restore the actor to the previous state - or, we can set
<a name="5148"></a> *   the actor to a different state, if desired.  Setting the actor to a
<a name="5149"></a> *   different state is useful when the group travel triggers a new
<a name="5150"></a> *   scripted activity in the new room.  
<a name="5151"></a> */
<a name="5152"></a>class AccompanyingInTravelState: ActorState
<a name="5153"></a>    construct(actor, lead, next)
<a name="5154"></a>    {
<a name="5155"></a>        /* do the normal initialization */
<a name="5156"></a>        inherited(actor);
<a name="5157"></a>
<a name="5158"></a>        /* remember the lead actor and the next state */
<a name="5159"></a>        leadActor = lead;
<a name="5160"></a>        nextState = next;
<a name="5161"></a>    }
<a name="5162"></a>
<a name="5163"></a>    /* the lead actor of the group travel */
<a name="5164"></a>    leadActor = nil
<a name="5165"></a>
<a name="5166"></a>    /* 
<a name="5167"></a>     *   the next state - we'll switch our actor to this state after the
<a name="5168"></a>     *   travel has been completed 
<a name="5169"></a>     */
<a name="5170"></a>    nextState = nil
<a name="5171"></a>
<a name="5172"></a>    /*
<a name="5173"></a>     *   Show our "I am here" description.  By default, we'll use the
<a name="5174"></a>     *   arrivingWithDesc of the *next* state object.  
<a name="5175"></a>     */
<a name="5176"></a>    specialDesc() { nextState.arrivingWithDesc; }
<a name="5177"></a>
<a name="5178"></a>    /* take our turn */
<a name="5179"></a>    takeTurn()
<a name="5180"></a>    {
<a name="5181"></a>        /* 
<a name="5182"></a>         *   The group travel only takes the single turn in which the
<a name="5183"></a>         *   travel is initiated, so by the time our turn comes around, the
<a name="5184"></a>         *   group travel is done.  Clear out the lead actor's linkage to
<a name="5185"></a>         *   us as an accompanying actor.  
<a name="5186"></a>         */
<a name="5187"></a>        leadActor.accompanyingActors.removeElement(getActor());
<a name="5188"></a>
<a name="5189"></a>        /* switch our actor to the next state */
<a name="5190"></a>        getActor().setCurState(nextState);
<a name="5191"></a>
<a name="5192"></a>        /* 
<a name="5193"></a>         *   call our next state's on-arrival turn-taking method, so that
<a name="5194"></a>         *   it can carry out any desired scripted behavior for our arrival
<a name="5195"></a>         */
<a name="5196"></a>        nextState.arrivingTurn();
<a name="5197"></a>    }
<a name="5198"></a>
<a name="5199"></a>    /* initiate a topic - defer to the next state */
<a name="5200"></a>    initiateTopic(obj) { return nextState.initiateTopic(obj); }
<a name="5201"></a>
<a name="5202"></a>    /* 
<a name="5203"></a>     *   Override our departure messages.  When we're accompanying another
<a name="5204"></a>     *   actor on a group travel, the lead actor will, as part of its turn,
<a name="5205"></a>     *   send each accompanying actor (including us) on ahead.  This means
<a name="5206"></a>     *   that the lead actor will see us departing from the starting
<a name="5207"></a>     *   location, because we'll leave before the lead actor has itself
<a name="5208"></a>     *   departed.  Rather than using the normal "Bob leaves to the west"
<a name="5209"></a>     *   departure report, customize the departure reports to indicate
<a name="5210"></a>     *   specifically that we're going with the lead actor.  (Note that we
<a name="5211"></a>     *   only have to handle the departing messages, since group travel
<a name="5212"></a>     *   always sends accompanying actors on ahead of the main actor, hence
<a name="5213"></a>     *   the accompanying actors will always be seen departing, not
<a name="5214"></a>     *   arriving.)
<a name="5215"></a>     *   
<a name="5216"></a>     *   Note that all of these call our generic sayDeparting() method by
<a name="5217"></a>     *   default, so a subclass can catch all of the departure types at
<a name="5218"></a>     *   once just by overriding sayDeparting().  Overriding the individual
<a name="5219"></a>     *   methods is still desirable, of course, if you want separate
<a name="5220"></a>     *   messages for the different departure types.  
<a name="5221"></a>     */
<a name="5222"></a>    sayDeparting(conn)
<a name="5223"></a>        { gLibMessages.sayDepartingWith(getActor(), leadActor); }
<a name="5224"></a>    sayDepartingDir(dir, conn) { sayDeparting(conn); }
<a name="5225"></a>    sayDepartingThroughPassage(conn) { sayDeparting(conn); }
<a name="5226"></a>    sayDepartingViaPath(conn) { sayDeparting(conn); }
<a name="5227"></a>    sayDepartingUpStairs(conn) { sayDeparting(conn); }
<a name="5228"></a>    sayDepartingDownStairs(conn) { sayDeparting(conn); }
<a name="5229"></a>
<a name="5230"></a>    /*
<a name="5231"></a>     *   Describe local travel using our standard departure message as
<a name="5232"></a>     *   well.  This is used to describe our travel when our origin and
<a name="5233"></a>     *   destination locations are both visible to the PC; in these cases,
<a name="5234"></a>     *   we don't describe the departure separately because the whole
<a name="5235"></a>     *   process of travel from departure to arrival is visible to the PC
<a name="5236"></a>     *   and thus is best handled with a single message, which we generate
<a name="5237"></a>     *   here.  In our case, since the "accompanying" state describes even
<a name="5238"></a>     *   normal travel as though it were visible all along, we can use our
<a name="5239"></a>     *   standard "departing" message to describe local travel as well.  
<a name="5240"></a>     */
<a name="5241"></a>    sayArrivingLocally(dest, conn) { sayDeparting(conn); }
<a name="5242"></a>    sayDepartingLocally(dest, conn) { sayDeparting(conn); }
<a name="5243"></a>;
<a name="5244"></a>
<a name="5245"></a>/* ------------------------------------------------------------------------ */
<a name="5246"></a>/*
<a name="5247"></a> *   A pending conversation information object.  An Actor keeps a list of
<a name="5248"></a> *   these for pending conversations.  
<a name="5249"></a> */
<a name="5250"></a>class PendingConvInfo: object
<a name="5251"></a>    construct(state, node, turns)
<a name="5252"></a>    {
<a name="5253"></a>        /* remember how to start the conversation */
<a name="5254"></a>        state_ = state;
<a name="5255"></a>        node_ = node;
<a name="5256"></a>
<a name="5257"></a>        /* compute the game clock time when we can start the conversation */
<a name="5258"></a>        time_ = Schedulable.gameClockTime + turns;
<a name="5259"></a>    }
<a name="5260"></a>
<a name="5261"></a>    /* 
<a name="5262"></a>     *   our ActorState and ConvNode (or ConvNode name string), describing
<a name="5263"></a>     *   how we're to start the conversation 
<a name="5264"></a>     */
<a name="5265"></a>    state_ = nil
<a name="5266"></a>    node_ = nil
<a name="5267"></a>
<a name="5268"></a>    /* the minimum game clock time at which we can start the conversation */
<a name="5269"></a>    time_ = nil
<a name="5270"></a>;
<a name="5271"></a>
<a name="5272"></a>/* ------------------------------------------------------------------------ */
<a name="5273"></a>/*
<a name="5274"></a> *   An "agenda item."  Each actor can have its own "agenda," which is a
<a name="5275"></a> *   list of these items.  Each item represents an action that the actor
<a name="5276"></a> *   wants to perform - this is usually a goal the actor wants to achieve,
<a name="5277"></a> *   or a conversational topic the actor wants to pursue.
<a name="5278"></a> *   
<a name="5279"></a> *   On any given turn, an actor can carry out only one agenda item.
<a name="5280"></a> *   
<a name="5281"></a> *   Agenda items are a convenient way of controlling complex behavior.
<a name="5282"></a> *   Each agenda item defines its own condition for when the actor can
<a name="5283"></a> *   pursue the item, and each item defines what the actor does when
<a name="5284"></a> *   pursuing the item.  Agenda items can improve the code structure for an
<a name="5285"></a> *   NPC's behavior, since they nicely isolate a single background action
<a name="5286"></a> *   and group it with the conditions that trigger it.  But the main
<a name="5287"></a> *   benefit of agenda items is the one-per-turn pacing - by executing at
<a name="5288"></a> *   most one agenda item per turn, we ensure that the NPC will carry out
<a name="5289"></a> *   its self-initiated actions at a measured pace, rather than as a jumble
<a name="5290"></a> *   of random actions on a single turn.
<a name="5291"></a> *   
<a name="5292"></a> *   Note that NPC-initiated conversation messages override agendas.  If an
<a name="5293"></a> *   actor has an active ConvNode, AND the ConvNode displays a
<a name="5294"></a> *   "continuation message" on a given turn, then the actor will not pursue
<a name="5295"></a> *   its agenda on that turn.  In this way, ConvNode continuation messages
<a name="5296"></a> *   act rather like high-priority agenda items.  
<a name="5297"></a> */
<a name="5298"></a>class AgendaItem: object
<a name="5299"></a>    /* 
<a name="5300"></a>     *   My actor - agenda items should be nested within the actor using
<a name="5301"></a>     *   '+' so that we can find our actor.  Note that this doesn't add the
<a name="5302"></a>     *   item to the actor's agenda - that has to be done explicitly with
<a name="5303"></a>     *   actor.addToAgenda().  
<a name="5304"></a>     */
<a name="5305"></a>    getActor() { return location; }
<a name="5306"></a>
<a name="5307"></a>    /*
<a name="5308"></a>     *   Is this item active at the start of the game?  Override this to
<a name="5309"></a>     *   true to make the item initially active; we'll add it to the
<a name="5310"></a>     *   actor's agenda during the game's initialization.  
<a name="5311"></a>     */
<a name="5312"></a>    initiallyActive = nil
<a name="5313"></a>
<a name="5314"></a>    /* 
<a name="5315"></a>     *   Is this item ready to execute?  The actor will only execute an
<a name="5316"></a>     *   agenda item when this condition is met.  By default, we're ready
<a name="5317"></a>     *   to execute.  Items can override this to provide a declarative
<a name="5318"></a>     *   condition of readiness if desired.  
<a name="5319"></a>     */
<a name="5320"></a>    isReady = true
<a name="5321"></a>
<a name="5322"></a>    /*
<a name="5323"></a>     *   Is this item done?  On each turn, we'll remove any items marked as
<a name="5324"></a>     *   done from the actor's agenda list.  We remove items marked as done
<a name="5325"></a>     *   before executing any items, so done-ness overrides readiness; in
<a name="5326"></a>     *   other words, if an item is both 'done' and 'ready', it'll simply
<a name="5327"></a>     *   be removed from the list and will not be executed.
<a name="5328"></a>     *   
<a name="5329"></a>     *   By default, we simply return nil.  Items can override this to
<a name="5330"></a>     *   provide a declarative condition of done-ness, or they can simply
<a name="5331"></a>     *   set the property to true when they finish their work.  For
<a name="5332"></a>     *   example, an item that only needs to execute once can simply set
<a name="5333"></a>     *   isDone to true in its invokeItem() method; an item that's to be
<a name="5334"></a>     *   repeated until some success condition obtains can override isDone
<a name="5335"></a>     *   to return the success condition.  
<a name="5336"></a>     */
<a name="5337"></a>    isDone = nil
<a name="5338"></a>
<a name="5339"></a>    /*
<a name="5340"></a>     *   The ordering of the item relative to other agenda items.  When we
<a name="5341"></a>     *   choose an agenda item to execute, we always choose the lowest
<a name="5342"></a>     *   numbered item that's ready to run.  You can leave this with the
<a name="5343"></a>     *   default value if you don't care about the order.  
<a name="5344"></a>     */
<a name="5345"></a>    agendaOrder = 100
<a name="5346"></a>
<a name="5347"></a>    /*
<a name="5348"></a>     *   Execute this item.  This is invoked during the actor's turn when
<a name="5349"></a>     *   the item is the first item that's ready to execute in the actor's
<a name="5350"></a>     *   agenda list.  We do nothing by default.
<a name="5351"></a>     */
<a name="5352"></a>    invokeItem() { }
<a name="5353"></a>
<a name="5354"></a>    /*
<a name="5355"></a>     *   Reset the item.  This is invoked whenever the item is added to an
<a name="5356"></a>     *   actor's agenda.  By default, we'll set isDone to nil as long as
<a name="5357"></a>     *   isDone isn't a method; this makes it easier to reuse agenda
<a name="5358"></a>     *   items, since we don't have to worry about clearing out the isDone
<a name="5359"></a>     *   flag when reusing an item. 
<a name="5360"></a>     */
<a name="5361"></a>    resetItem()
<a name="5362"></a>    {
<a name="5363"></a>        /* if isDone isn't a method, reset it to nil */
<a name="5364"></a>        if (propType(&amp;isDone) != TypeCode)
<a name="5365"></a>            isDone = nil;
<a name="5366"></a>    }
<a name="5367"></a>;
<a name="5368"></a>
<a name="5369"></a>/* 
<a name="5370"></a> *   An AgendaItem initializer.  For each agenda item that's initially
<a name="5371"></a> *   active, we'll add the item to its actor's agenda.  
<a name="5372"></a> */
<a name="5373"></a>PreinitObject
<a name="5374"></a>    execute()
<a name="5375"></a>    {
<a name="5376"></a>        forEachInstance(AgendaItem, new function(item) {
<a name="5377"></a>            /* 
<a name="5378"></a>             *   If this item is initially active, add the item to its
<a name="5379"></a>             *   actor's agenda. 
<a name="5380"></a>             */
<a name="5381"></a>            if (item.initiallyActive)
<a name="5382"></a>                item.getActor().addToAgenda(item);
<a name="5383"></a>        });
<a name="5384"></a>    }
<a name="5385"></a>;
<a name="5386"></a>
<a name="5387"></a>/*
<a name="5388"></a> *   A "conversational" agenda item.  This type of item is ready to execute
<a name="5389"></a> *   only when the actor hasn't engaged in conversation during the same
<a name="5390"></a> *   turn.  This type of item is ideal for situations where we want the
<a name="5391"></a> *   actor to pursue a conversational topic, because we won't initiate the
<a name="5392"></a> *   action until we get a turn where the player didn't directly talk to
<a name="5393"></a> *   us.  
<a name="5394"></a> */
<a name="5395"></a>class ConvAgendaItem: AgendaItem
<a name="5396"></a>    isReady = (!getActor().conversedThisTurn()
<a name="5397"></a>               &amp;&amp; getActor().canTalkTo(otherActor)
<a name="5398"></a>               &amp;&amp; inherited())
<a name="5399"></a>
<a name="5400"></a>    /* 
<a name="5401"></a>     *   The actor we're planning to address - by default, this is the PC.
<a name="5402"></a>     *   If the conversational overture will be directed to another NPC,
<a name="5403"></a>     *   you can specify that other actor here. 
<a name="5404"></a>     */
<a name="5405"></a>    otherActor = (gPlayerChar)
<a name="5406"></a>;
<a name="5407"></a>
<a name="5408"></a>/*
<a name="5409"></a> *   A delayed agenda item.  This type of item becomes ready to execute
<a name="5410"></a> *   when the game clock reaches a given turn counter.  
<a name="5411"></a> */
<a name="5412"></a>class DelayedAgendaItem: AgendaItem
<a name="5413"></a>    /* we're ready if the game clock time has reached our ready time */
<a name="5414"></a>    isReady = (Schedulable.gameClockTime &gt;= readyTime &amp;&amp; inherited())
<a name="5415"></a>
<a name="5416"></a>    /* the turn counter on the game clock when we become ready */
<a name="5417"></a>    readyTime = 0
<a name="5418"></a>
<a name="5419"></a>    /*
<a name="5420"></a>     *   Set our ready time based on a delay from the current time.  We'll
<a name="5421"></a>     *   become ready after the given number of turns elapses.  For
<a name="5422"></a>     *   convenience, we return 'self', so a delayed agenda item can be
<a name="5423"></a>     *   initialized and added to an actor's agenda in one simple
<a name="5424"></a>     *   operation, like so:
<a name="5425"></a>     *   
<a name="5426"></a>     *   actor.addToAgenda(item.setDelay(1)); 
<a name="5427"></a>     */
<a name="5428"></a>    setDelay(turns)
<a name="5429"></a>    {
<a name="5430"></a>        /* 
<a name="5431"></a>         *   initialize our ready time as the given number of turns in the
<a name="5432"></a>         *   future from the current game clock time 
<a name="5433"></a>         */
<a name="5434"></a>        readyTime = Schedulable.gameClockTime + turns;
<a name="5435"></a>
<a name="5436"></a>        /* return 'self' for the caller's convenience */
<a name="5437"></a>        return self;
<a name="5438"></a>    }
<a name="5439"></a>;
<a name="5440"></a>
<a name="5441"></a>
<a name="5442"></a>/* ------------------------------------------------------------------------ */
<a name="5443"></a>/*
<a name="5444"></a> *   An Actor is a living person, animal, or other entity with a will of
<a name="5445"></a> *   its own.  Actors can usually be addressed with targeted commands
<a name="5446"></a> *   ("bob, go north"), and with commands like ASK ABOUT, TELL ABOUT, GIVE
<a name="5447"></a> *   TO, and SHOW TO.
<a name="5448"></a> *   
<a name="5449"></a> *   Note that, by default, an Actor can be picked up and moved with
<a name="5450"></a> *   commands like TAKE, PUT IN, and so on.  This is suitable for some
<a name="5451"></a> *   kinds of actors but not for others: it might make sense with a cat or
<a name="5452"></a> *   a small dog, but not with a bank guard or an orc.  For an actor that
<a name="5453"></a> *   can't be taken, use the UntakeableActor or one of its subclasses.
<a name="5454"></a> *   
<a name="5455"></a> *   An actor's contents are the things the actor is carrying or wearing.  
<a name="5456"></a> */
<a name="5457"></a>class Actor: Thing, Schedulable, Traveler, ActorTopicDatabase
<a name="5458"></a>    /* flag: we're an actor */
<a name="5459"></a>    isActor = true
<a name="5460"></a>
<a name="5461"></a>    /*
<a name="5462"></a>     *   Our current state.  This is an ActorState object representing what
<a name="5463"></a>     *   we're currently doing.  Whenever the actor changes to a new state
<a name="5464"></a>     *   (for example, because of a scripted activity), this can be changed
<a name="5465"></a>     *   to reflect the actor's new state.  The state object groups the
<a name="5466"></a>     *   parts of the actor's description and other methods that tend to
<a name="5467"></a>     *   vary according to what the actor's doing; it's easier to keep
<a name="5468"></a>     *   everything related to scripted activities together in a state
<a name="5469"></a>     *   object than it is to handle all of the variability with switch()
<a name="5470"></a>     *   statements of the like in methods directly in the actor.
<a name="5471"></a>     *   
<a name="5472"></a>     *   It's not necessary to initialize this if the actor doesn't take
<a name="5473"></a>     *   advantage of the ActorState mechanism.  If this isn't initialized
<a name="5474"></a>     *   for a particular actor, we'll automatically create a default
<a name="5475"></a>     *   ActorState object during pre-initialization.  
<a name="5476"></a>     */
<a name="5477"></a>    curState = nil
<a name="5478"></a>
<a name="5479"></a>    /* set the current state */
<a name="5480"></a>    setCurState(state)
<a name="5481"></a>    {
<a name="5482"></a>        /* if this isn't a change of state, there's nothing to do */
<a name="5483"></a>        if (state == curState)
<a name="5484"></a>            return;
<a name="5485"></a>        
<a name="5486"></a>        /* if we have a previous state, tell it it's becoming inactive */
<a name="5487"></a>        if (curState != nil)
<a name="5488"></a>            curState.deactivateState(self, state);
<a name="5489"></a>
<a name="5490"></a>        /* notify the new state it's becoming active */
<a name="5491"></a>        if (state != nil)
<a name="5492"></a>            state.activateState(self, curState);
<a name="5493"></a>
<a name="5494"></a>        /* remember the new state */
<a name="5495"></a>        curState = state;
<a name="5496"></a>    }
<a name="5497"></a>
<a name="5498"></a>    /*
<a name="5499"></a>     *   Our current conversation node.  This is a ConvNode object that
<a name="5500"></a>     *   keeps track of the flow of the conversation.  
<a name="5501"></a>     */
<a name="5502"></a>    curConvNode = nil
<a name="5503"></a>
<a name="5504"></a>    /* 
<a name="5505"></a>     *   Our table of conversation nodes.  At initialization, the
<a name="5506"></a>     *   conversation manager scans all ConvNode instances and adds each
<a name="5507"></a>     *   one to its actor's table.  This table is keyed by the name of
<a name="5508"></a>     *   node, and the value for each entry is the ConvNode object - this
<a name="5509"></a>     *   lets us look up the ConvNode object by name.  Because each actor
<a name="5510"></a>     *   has its own lookup table, ConvNode names only have to be unique
<a name="5511"></a>     *   within the actor's set of ConvNodes.  
<a name="5512"></a>     */
<a name="5513"></a>    convNodeTab = perInstance(new LookupTable(32, 32))
<a name="5514"></a>
<a name="5515"></a>    /* set the current conversation node */
<a name="5516"></a>    setConvNode(node) { setConvNodeReason(node, nil); }
<a name="5517"></a>
<a name="5518"></a>    /* set the current conversation node, with a reason code */
<a name="5519"></a>    setConvNodeReason(node, reason)
<a name="5520"></a>    {
<a name="5521"></a>        /* remember the old node */
<a name="5522"></a>        local oldNode = curConvNode;
<a name="5523"></a>        
<a name="5524"></a>        /* if the node was specified by name, look up the object */
<a name="5525"></a>        if (dataType(node) == TypeSString)
<a name="5526"></a>            node = convNodeTab[node];
<a name="5527"></a>
<a name="5528"></a>        /* remember the new node */
<a name="5529"></a>        curConvNode = node;
<a name="5530"></a>
<a name="5531"></a>        /* 
<a name="5532"></a>         *   If we're changing to a new node, notify the new and old
<a name="5533"></a>         *   nodes.  Note that these notifications occur after the new
<a name="5534"></a>         *   node has been set, which ensures that any further node change
<a name="5535"></a>         *   triggered by the node change won't redundantly issue the same
<a name="5536"></a>         *   notifications: since the old node is no longer active, it
<a name="5537"></a>         *   can't receive another departure notification, and since the
<a name="5538"></a>         *   new node is already active, it can't receive another
<a name="5539"></a>         *   activation. 
<a name="5540"></a>         */
<a name="5541"></a>        if (node != oldNode)
<a name="5542"></a>        {
<a name="5543"></a>            /* if there's an old node, note that we're leaving it */
<a name="5544"></a>            if (oldNode != nil)
<a name="5545"></a>                oldNode.noteLeaving();
<a name="5546"></a>
<a name="5547"></a>            /* let the node know that it's becoming active */
<a name="5548"></a>            if (node != nil)
<a name="5549"></a>                node.noteActiveReason(reason);
<a name="5550"></a>        }
<a name="5551"></a>
<a name="5552"></a>        /* 
<a name="5553"></a>         *   note that we've explicitly set a ConvNode (even if it's not
<a name="5554"></a>         *   actually changing), in case the conversation manager is
<a name="5555"></a>         *   tracking what's happening during a response 
<a name="5556"></a>         */
<a name="5557"></a>        responseSetConvNode = true;
<a name="5558"></a>    }
<a name="5559"></a>
<a name="5560"></a>    /* 
<a name="5561"></a>     *   conversation manager ID - this is assigned by the conversation
<a name="5562"></a>     *   manager to map to and from output stream references to the actor;
<a name="5563"></a>     *   this is only for internal use by the conversation manager
<a name="5564"></a>     */
<a name="5565"></a>    convMgrID = nil
<a name="5566"></a>
<a name="5567"></a>    /* 
<a name="5568"></a>     *   Flag indicating whether or not we've set a ConvNode in the course
<a name="5569"></a>     *   of the current response.  This is for use by the converstaion
<a name="5570"></a>     *   manager. 
<a name="5571"></a>     */
<a name="5572"></a>    responseSetConvNode = nil
<a name="5573"></a>
<a name="5574"></a>    /*
<a name="5575"></a>     *   Initiate a conversation with the player character.  This lets the
<a name="5576"></a>     *   NPC initiate a conversation, in response to something the player
<a name="5577"></a>     *   character does, or as part of the NPC's scripted activity.  This
<a name="5578"></a>     *   is only be used for situations where the NPC initiates the
<a name="5579"></a>     *   conversation - if the player character initiates conversation with
<a name="5580"></a>     *   TALK TO, ASK, TELL, etc., we handle the conversation through our
<a name="5581"></a>     *   normal handlers for those commands.
<a name="5582"></a>     *   
<a name="5583"></a>     *   'state' is the ActorState to switch to for the conversation.  This
<a name="5584"></a>     *   will normally be an InConversationState object, but doesn't have
<a name="5585"></a>     *   to be.
<a name="5586"></a>     *   
<a name="5587"></a>     *   You can pass nil for 'state' to use the current state's implied
<a name="5588"></a>     *   conversational state.  The implied conversational state of a
<a name="5589"></a>     *   ConversationReadyState is the associated InConversationState; the
<a name="5590"></a>     *   implied conversation state of any other state is simply the same
<a name="5591"></a>     *   state.
<a name="5592"></a>     *   
<a name="5593"></a>     *   'node' is a ConvNode object, or a string naming a ConvNode object.
<a name="5594"></a>     *   We'll make this our current conversation node.  A valid
<a name="5595"></a>     *   conversation node is required because we use this to generate the
<a name="5596"></a>     *   initial NPC greeting of the conversation.  In most cases, when the
<a name="5597"></a>     *   NPC initiates a conversation, it's because the NPC wants to ask a
<a name="5598"></a>     *   question or otherwise say something specific, so there should
<a name="5599"></a>     *   always be a conversational context implied, thus the need for a
<a name="5600"></a>     *   ConvNode.  If there's no need for a conversational context, the
<a name="5601"></a>     *   NPC script code might just as well display the conversational
<a name="5602"></a>     *   exchange as a plain old message, and not bother going to all this
<a name="5603"></a>     *   trouble.  
<a name="5604"></a>     */
<a name="5605"></a>    initiateConversation(state, node)
<a name="5606"></a>    {
<a name="5607"></a>        /* 
<a name="5608"></a>         *   if there's no state provided, use the current state's implied
<a name="5609"></a>         *   conversation state 
<a name="5610"></a>         */
<a name="5611"></a>        if (state == nil)
<a name="5612"></a>            state = curState.getImpliedConvState;
<a name="5613"></a>
<a name="5614"></a>        /* 
<a name="5615"></a>         *   if there's an ActorHelloTopic for the old state, invoke it to
<a name="5616"></a>         *   show the greeting 
<a name="5617"></a>         */
<a name="5618"></a>        curState.handleTopic(self, actorHelloTopicObj, helloConvType, nil);
<a name="5619"></a>
<a name="5620"></a>        /* switch to the new state, if it's not the current state */
<a name="5621"></a>        if (state != nil &amp;&amp; state != curState)
<a name="5622"></a>            setCurState(state);
<a name="5623"></a>
<a name="5624"></a>        /* we're now talking to the player character */
<a name="5625"></a>        noteConversation(gPlayerChar);
<a name="5626"></a>
<a name="5627"></a>        /* switch to the conversation node */
<a name="5628"></a>        setConvNodeReason(node, 'initiateConversation');
<a name="5629"></a>
<a name="5630"></a>        /* tell the conversation node that the NPC is initiating it */
<a name="5631"></a>        if (node != nil)
<a name="5632"></a>            curConvNode.npcInitiateConversation();
<a name="5633"></a>    }
<a name="5634"></a>
<a name="5635"></a>    /*
<a name="5636"></a>     *   Initiate a conversation based on the given simulation object.
<a name="5637"></a>     *   We'll look for an InitiateTopic matching the given object, and if
<a name="5638"></a>     *   we can find one, we'll show its topic response.  
<a name="5639"></a>     */
<a name="5640"></a>    initiateTopic(obj)
<a name="5641"></a>    {
<a name="5642"></a>        /* try our current state first */
<a name="5643"></a>        if (curState.initiateTopic(obj))
<a name="5644"></a>            return true;
<a name="5645"></a>
<a name="5646"></a>        /* we didn't find a state object; use the default handling */
<a name="5647"></a>        return inherited(obj);
<a name="5648"></a>    }
<a name="5649"></a>
<a name="5650"></a>    /*
<a name="5651"></a>     *   Schedule initiation of conversation.  This allows the caller to
<a name="5652"></a>     *   set up a conversation to start on a future turn.  The
<a name="5653"></a>     *   conversation will start after (1) the given number of turns has
<a name="5654"></a>     *   elapsed, and (2) the player didn't target this actor with a
<a name="5655"></a>     *   conversational command on the same turn.  This allows us to set
<a name="5656"></a>     *   the NPC so that it *wants* to start a conversation, and will do
<a name="5657"></a>     *   so as soon as it has a chance to get a word in.
<a name="5658"></a>     *   
<a name="5659"></a>     *   If 'turns' is zero, the conversation can start the next time the
<a name="5660"></a>     *   actor takes a turn; so, if this is called during the PC's action
<a name="5661"></a>     *   processing, the conversation can start on the same turn.  Note
<a name="5662"></a>     *   that if this is called during the actor's takeTurn() processing,
<a name="5663"></a>     *   it won't actually start the conversation until the next turn,
<a name="5664"></a>     *   because that's the next time we'll check the queue.  If 'turns'
<a name="5665"></a>     *   is 1, then the player will get at least one more command before
<a name="5666"></a>     *   the conversation will begin, and so on with higher numbers.  
<a name="5667"></a>     */
<a name="5668"></a>    scheduleInitiateConversation(state, node, turns)
<a name="5669"></a>    {
<a name="5670"></a>        /* add a new pending conversation to our list */
<a name="5671"></a>        pendingConv.append(new PendingConvInfo(state, node, turns));
<a name="5672"></a>    }
<a name="5673"></a>
<a name="5674"></a>    /*
<a name="5675"></a>     *   Break off our current conversation, of the NPC's own volition.
<a name="5676"></a>     *   This is the opposite number of initiateConversation: this causes
<a name="5677"></a>     *   the NPC to effectively say BYE on its own, rather than waiting
<a name="5678"></a>     *   for the PC to decide to end the conversation.
<a name="5679"></a>     *   
<a name="5680"></a>     *   This call is mostly useful when the actor's current state is an
<a name="5681"></a>     *   InConversationState, since the main function of this routine is
<a name="5682"></a>     *   to switch to an out-of-conversation state.  
<a name="5683"></a>     */
<a name="5684"></a>    endConversation()
<a name="5685"></a>    {
<a name="5686"></a>        /* 
<a name="5687"></a>         *   tell the current state to end the conversation of the NPC's
<a name="5688"></a>         *   own volition 
<a name="5689"></a>         */
<a name="5690"></a>        curState.endConversation(self, endConvActor);
<a name="5691"></a>    }
<a name="5692"></a>
<a name="5693"></a>    /* 
<a name="5694"></a>     *   Our list of pending conversation initiators.  In our takeTurn()
<a name="5695"></a>     *   processing, we'll check this list for conversations that we can
<a name="5696"></a>     *   initiate. 
<a name="5697"></a>     */
<a name="5698"></a>    pendingConv = nil
<a name="5699"></a>
<a name="5700"></a>    /* 
<a name="5701"></a>     *   Hide actors from 'all' by default.  The kinds of actions that
<a name="5702"></a>     *   normally apply to 'all' and the kinds that normally apply to
<a name="5703"></a>     *   actors have pretty low overlap.
<a name="5704"></a>     *   
<a name="5705"></a>     *   If a particular actor looks a lot like an inanimate object, it
<a name="5706"></a>     *   might want to override this to participate in 'all' for most or
<a name="5707"></a>     *   all actions.  
<a name="5708"></a>     */
<a name="5709"></a>    hideFromAll(action) { return true; }
<a name="5710"></a>
<a name="5711"></a>    /* 
<a name="5712"></a>     *   don't hide actors from defaulting, though - it's frequently
<a name="5713"></a>     *   convenient and appropriate to assume an actor by default,
<a name="5714"></a>     *   especially for commands like GIVE TO and SHOW TO 
<a name="5715"></a>     */
<a name="5716"></a>    hideFromDefault(action) { return nil; }
<a name="5717"></a>
<a name="5718"></a>    /* 
<a name="5719"></a>     *   We meet the objHeld precondition for ourself - that is, for any
<a name="5720"></a>     *   verb that requires holding an object, we can be considered to be
<a name="5721"></a>     *   holding ourself. 
<a name="5722"></a>     */
<a name="5723"></a>    meetsObjHeld(actor) { return actor == self || inherited(actor); }
<a name="5724"></a>
<a name="5725"></a>    /* 
<a name="5726"></a>     *   Actors are not listed with the ordinary objects in a room's
<a name="5727"></a>     *   description.  However, an actor is listed as part of an inventory
<a name="5728"></a>     *   description.
<a name="5729"></a>     */
<a name="5730"></a>    isListed = nil
<a name="5731"></a>    isListedInContents = nil
<a name="5732"></a>    isListedInInventory = true
<a name="5733"></a>
<a name="5734"></a>    /* the contents of an actor aren't listed in a room's description */
<a name="5735"></a>    contentsListed = nil
<a name="5736"></a>
<a name="5737"></a>    /*
<a name="5738"></a>     *   Full description.  By default, we'll show either the pcDesc or
<a name="5739"></a>     *   npcDesc, depending on whether we're the current player character
<a name="5740"></a>     *   or a non-player character. 
<a name="5741"></a>     *   
<a name="5742"></a>     *   Generally, individual actors should NOT override this method.
<a name="5743"></a>     *   Instead, customize pcDesc and/or npcDesc to describe the permanent
<a name="5744"></a>     *   features of the actor.  
<a name="5745"></a>     */
<a name="5746"></a>    desc
<a name="5747"></a>    {
<a name="5748"></a>        /* 
<a name="5749"></a>         *   show the appropriate messages, depending on whether we're the
<a name="5750"></a>         *   player character or a non-player character 
<a name="5751"></a>         */
<a name="5752"></a>        if (isPlayerChar())
<a name="5753"></a>        {
<a name="5754"></a>            /* show our as-player-character description */
<a name="5755"></a>            pcDesc;
<a name="5756"></a>        }
<a name="5757"></a>        else
<a name="5758"></a>        {
<a name="5759"></a>            /* show our as-non-player-character description */
<a name="5760"></a>            npcDesc;
<a name="5761"></a>        }
<a name="5762"></a>    }
<a name="5763"></a>
<a name="5764"></a>    /* show our status */
<a name="5765"></a>    examineStatus()
<a name="5766"></a>    {
<a name="5767"></a>        /* 
<a name="5768"></a>         *   If I'm an NPC, show where I'm sitting/standing/etc.  (If I'm
<a name="5769"></a>         *   the PC, we don't usually want to show this explicitly to avoid
<a name="5770"></a>         *   redundancy.  The player is usually sufficiently aware of the
<a name="5771"></a>         *   PC's posture by virtue of being in control of the actor, and
<a name="5772"></a>         *   the information also tends to show up often enough in other
<a name="5773"></a>         *   places, such as on the status line and in the room
<a name="5774"></a>         *   description.)  
<a name="5775"></a>         */
<a name="5776"></a>        if (!isPlayerChar())
<a name="5777"></a>            postureDesc;
<a name="5778"></a>
<a name="5779"></a>        /* show the status from our state object */
<a name="5780"></a>        curState.stateDesc;
<a name="5781"></a>
<a name="5782"></a>        /* inherit the default handling to show our contents */
<a name="5783"></a>        inherited();
<a name="5784"></a>    }
<a name="5785"></a>
<a name="5786"></a>    /* 
<a name="5787"></a>     *   Show my posture, as part of the full EXAMINE description of this
<a name="5788"></a>     *   actor.  We'll let our nominal actor container handle it.  
<a name="5789"></a>     */
<a name="5790"></a>    postureDesc() { descViaActorContainer(&amp;roomActorPostureDesc, nil); }
<a name="5791"></a>    
<a name="5792"></a>    /* 
<a name="5793"></a>     *   The default description when we examine this actor and the actor
<a name="5794"></a>     *   is serving as the player character.  This should generally not
<a name="5795"></a>     *   include any temporary status information; just show constant,
<a name="5796"></a>     *   fixed features.  
<a name="5797"></a>     */
<a name="5798"></a>    pcDesc { gLibMessages.pcDesc(self); }
<a name="5799"></a>
<a name="5800"></a>    /* 
<a name="5801"></a>     *   Show the description of this actor when this actor is a non-player
<a name="5802"></a>     *   character.
<a name="5803"></a>     *   
<a name="5804"></a>     *   This description should include only the constant, fixed
<a name="5805"></a>     *   description of the character.  Do not include information on what
<a name="5806"></a>     *   the actor is doing right now, because that belongs in the
<a name="5807"></a>     *   ActorState object instead.  When we display the actor's
<a name="5808"></a>     *   description, we'll show this text, and then we'll show the
<a name="5809"></a>     *   ActorState description as well; this combination approach makes it
<a name="5810"></a>     *   easier to keep the description synchronized with any scripted
<a name="5811"></a>     *   activities the actor is performing.
<a name="5812"></a>     *   
<a name="5813"></a>     *   By default, we'll show this as a "default descriptive report,"
<a name="5814"></a>     *   since it simply says that there's nothing special to say.
<a name="5815"></a>     *   However, whenever this is overridden with an actual description,
<a name="5816"></a>     *   you shouldn't bother to use defaultDescReport - simply display the
<a name="5817"></a>     *   descriptive message directly:
<a name="5818"></a>     *   
<a name="5819"></a>     *   npcDesc = "He's wearing a gorilla costume. " 
<a name="5820"></a>     */
<a name="5821"></a>    npcDesc { defaultDescReport(&amp;npcDescMsg, self); }
<a name="5822"></a>
<a name="5823"></a>    /* examine my contents specially */
<a name="5824"></a>    examineListContents()
<a name="5825"></a>    {
<a name="5826"></a>        /* if I'm not the player character, show my inventory */
<a name="5827"></a>        if (!isPlayerChar())
<a name="5828"></a>            holdingDesc;
<a name="5829"></a>    }
<a name="5830"></a>    
<a name="5831"></a>    /*
<a name="5832"></a>     *   Always list actors specially, rather than as ordinary items in
<a name="5833"></a>     *   contents listings.  We'll send this to our current state object
<a name="5834"></a>     *   for processing, since our "I am here" description tends to vary by
<a name="5835"></a>     *   state.
<a name="5836"></a>     */
<a name="5837"></a>    specialDesc() { curState.specialDesc(); }
<a name="5838"></a>    distantSpecialDesc() { curState.distantSpecialDesc(); }
<a name="5839"></a>    remoteSpecialDesc(actor) { curState.remoteSpecialDesc(actor); }
<a name="5840"></a>    specialDescListWith() { return curState.specialDescListWith(); }
<a name="5841"></a>
<a name="5842"></a>    /*
<a name="5843"></a>     *   By default, show the special description for an actor in the group
<a name="5844"></a>     *   of special descriptions that come *after* the room's portable
<a name="5845"></a>     *   contents listing.  An actor's presence is usually a dynamic
<a name="5846"></a>     *   feature of a room, and so we don't want to suggest that the actor
<a name="5847"></a>     *   is a permanent feature of the room by describing the actor
<a name="5848"></a>     *   directly with the room's main description.  
<a name="5849"></a>     */
<a name="5850"></a>    specialDescBeforeContents = nil
<a name="5851"></a>
<a name="5852"></a>    /*
<a name="5853"></a>     *   When we're asked to show a special description as part of the
<a name="5854"></a>     *   description of a containing object (which will usually be a nested
<a name="5855"></a>     *   room of some kind), just show our posture in our container, rather
<a name="5856"></a>     *   than showing our full "I am here" description. 
<a name="5857"></a>     */
<a name="5858"></a>    showSpecialDescInContents(actor, cont)
<a name="5859"></a>    {
<a name="5860"></a>        /* show our posture to indicate our container */
<a name="5861"></a>        listActorPosture(actor);
<a name="5862"></a>    }
<a name="5863"></a>
<a name="5864"></a>    /* 
<a name="5865"></a>     *   By default, put all of the actor special descriptions after the
<a name="5866"></a>     *   special descriptions of ordinary objects, by giving actors a
<a name="5867"></a>     *   higher listing order value. 
<a name="5868"></a>     */
<a name="5869"></a>    specialDescOrder = 200
<a name="5870"></a>
<a name="5871"></a>    /*
<a name="5872"></a>     *   Get my listing group for my special description as part of a room
<a name="5873"></a>     *   description.  By default, we'll let our immediate location decide
<a name="5874"></a>     *   how we're grouped.  
<a name="5875"></a>     */
<a name="5876"></a>    actorListWith()
<a name="5877"></a>    {
<a name="5878"></a>        local group;
<a name="5879"></a>
<a name="5880"></a>        /* 
<a name="5881"></a>         *   if our special desc is overridden, don't use any grouping by
<a name="5882"></a>         *   default - this make a special description defined in the
<a name="5883"></a>         *   actor override any grouping we'd otherwise do 
<a name="5884"></a>         */
<a name="5885"></a>        if (overrides(self, Actor, &amp;specialDesc))
<a name="5886"></a>            return [];
<a name="5887"></a>
<a name="5888"></a>        /* get the group for the posture */
<a name="5889"></a>        group = location.listWithActorIn(posture);
<a name="5890"></a>
<a name="5891"></a>        /* 
<a name="5892"></a>         *   if we have a group, return a list containing the group;
<a name="5893"></a>         *   otherwise return an empty list 
<a name="5894"></a>         */
<a name="5895"></a>        return (group == nil ? [] : [group]);
<a name="5896"></a>    }
<a name="5897"></a>
<a name="5898"></a>    /*
<a name="5899"></a>     *   Actor "I am here" description.  This is displayed as part of the
<a name="5900"></a>     *   description of a room - it describes the actor as being present in
<a name="5901"></a>     *   the room.  By default, we let the "nominal actor container"
<a name="5902"></a>     *   provide the description.  
<a name="5903"></a>     */
<a name="5904"></a>    actorHereDesc { descViaActorContainer(&amp;roomActorHereDesc, nil); }
<a name="5905"></a>
<a name="5906"></a>    /*
<a name="5907"></a>     *   Actor's "I am over there" description.  This is displayed in the
<a name="5908"></a>     *   room description when the actor is visible, but is either in a
<a name="5909"></a>     *   separate top-level room or is at a distance.  By default, we let
<a name="5910"></a>     *   the "nominal actor container" provide the description.  
<a name="5911"></a>     */
<a name="5912"></a>    actorThereDesc { descViaActorContainer(&amp;roomActorThereDesc, nil); }
<a name="5913"></a>
<a name="5914"></a>    /*
<a name="5915"></a>     *   Show our status, as an addendum to the given room's name (this is
<a name="5916"></a>     *   the room title, shown at the start of a room description and on
<a name="5917"></a>     *   the status line).  By default, we'll let our nominal actor
<a name="5918"></a>     *   container provide the status, to indicate when we're
<a name="5919"></a>     *   standing/sitting/lying in a nested room.
<a name="5920"></a>     *   
<a name="5921"></a>     *   In concrete terms, this generally adds a message such as "(sitting
<a name="5922"></a>     *   on the chair)" to the name of a room if we're in a nested room
<a name="5923"></a>     *   within the room.  When we're standing in the main room, this
<a name="5924"></a>     *   generally adds nothing.
<a name="5925"></a>     *   
<a name="5926"></a>     *   Note that we pass the room we're describing as the "container to
<a name="5927"></a>     *   ignore" parameter, because we don't want to say something like
<a name="5928"></a>     *   "Phone Booth (standing in the phone booth)" - that is, we don't
<a name="5929"></a>     *   want to mention the nominal container again if the nominal
<a name="5930"></a>     *   container is what we're naming in the first place.  
<a name="5931"></a>     */
<a name="5932"></a>    actorRoomNameStatus(room)
<a name="5933"></a>        { descViaActorContainer(&amp;roomActorStatus, room); }
<a name="5934"></a>
<a name="5935"></a>    /*
<a name="5936"></a>     *   Describe the actor via the "nominal actor container."  The nominal
<a name="5937"></a>     *   container is determined by our direct location.
<a name="5938"></a>     *   
<a name="5939"></a>     *   'contToIgnore' is a container to ignore.  If our nominal container
<a name="5940"></a>     *   is the same as this object, we'll generate a description without a
<a name="5941"></a>     *   mention of a container at all.
<a name="5942"></a>     *   
<a name="5943"></a>     *   The reason we have the 'contToIgnore' parameter is that the caller
<a name="5944"></a>     *   might already have reported our general location, and now merely
<a name="5945"></a>     *   wants to add that we're standing or standing or whatever.  In
<a name="5946"></a>     *   these cases, if we were to say that we're sitting on or standing
<a name="5947"></a>     *   on that same object, it would be redundant information: "Bob is in
<a name="5948"></a>     *   the garden, sitting in the garden."  The 'contToIgnore' parameter
<a name="5949"></a>     *   tells us the object that the caller has already mentioned as our
<a name="5950"></a>     *   general location so that we don't re-report the same thing.  We
<a name="5951"></a>     *   need to know the actual object, rather than just the fact that the
<a name="5952"></a>     *   caller mentioned a general location, because our general location
<a name="5953"></a>     *   and the specific place we're standing or sitting or whatever might
<a name="5954"></a>     *   not be the same: "Bob is in the garden, sitting in the lawn
<a name="5955"></a>     *   chair."
<a name="5956"></a>     *   
<a name="5957"></a>     */
<a name="5958"></a>    descViaActorContainer(prop, contToIgnore)
<a name="5959"></a>    {
<a name="5960"></a>        local pov;
<a name="5961"></a>        local cont;
<a name="5962"></a>        
<a name="5963"></a>        /* get our nominal container for our current posture */
<a name="5964"></a>        cont = location.getNominalActorContainer(posture);
<a name="5965"></a>
<a name="5966"></a>        /* get the point of view, using the player character by default */
<a name="5967"></a>        if ((pov = getPOV()) == nil)
<a name="5968"></a>            pov = gPlayerChar;
<a name="5969"></a>        
<a name="5970"></a>        /* 
<a name="5971"></a>         *   if we have a nominal container, and it's not the one to
<a name="5972"></a>         *   ignore, and the player character can see it, generate the
<a name="5973"></a>         *   description via the container; otherwise, use a generic
<a name="5974"></a>         *   library message that doesn't mention the container 
<a name="5975"></a>         */
<a name="5976"></a>        if (cont not in (nil, contToIgnore) &amp;&amp; pov.canSee(cont))
<a name="5977"></a>        {
<a name="5978"></a>            /* describe via the container */
<a name="5979"></a>            cont.(prop)(self);
<a name="5980"></a>        }
<a name="5981"></a>        else
<a name="5982"></a>        {
<a name="5983"></a>            /* use the generic library message */
<a name="5984"></a>            gLibMessages.(prop)(self);
<a name="5985"></a>        }
<a name="5986"></a>    }
<a name="5987"></a>    
<a name="5988"></a>    /* 
<a name="5989"></a>     *   Describe my inventory as part of my description - this is only
<a name="5990"></a>     *   called when we examine an NPC.  If an NPC doesn't wish to have
<a name="5991"></a>     *   its inventory listed as part of its description, it can simply
<a name="5992"></a>     *   override this to do nothing.  
<a name="5993"></a>     */
<a name="5994"></a>    holdingDesc
<a name="5995"></a>    {
<a name="5996"></a>        /* 
<a name="5997"></a>         *   show our contents as for a normal "examine", but using the
<a name="5998"></a>         *   special contents lister for what an actor is holding 
<a name="5999"></a>         */
<a name="6000"></a>        examineListContentsWith(holdingDescInventoryLister);
<a name="6001"></a>    }
<a name="6002"></a>
<a name="6003"></a>    /*
<a name="6004"></a>     *   refer to the player character with my player character referral
<a name="6005"></a>     *   person, and refer to all other characters in the third person 
<a name="6006"></a>     */
<a name="6007"></a>    referralPerson { return isPlayerChar() ? pcReferralPerson : ThirdPerson; }
<a name="6008"></a>
<a name="6009"></a>    /* by default, refer to the player character in the second person */
<a name="6010"></a>    pcReferralPerson = SecondPerson
<a name="6011"></a>
<a name="6012"></a>    /*
<a name="6013"></a>     *   The referral person of the current command targeting the actor.
<a name="6014"></a>     *   This is meaningful only when a command is being directed to this
<a name="6015"></a>     *   actor, and this actor is an NPC.
<a name="6016"></a>     *   
<a name="6017"></a>     *   The referral person depends on the specifics of the language.  In
<a name="6018"></a>     *   English, a command like "bob, go north" is a second-person
<a name="6019"></a>     *   command, while "tell bob to go north" is a third-person command.
<a name="6020"></a>     *   The only reason this is important is in interpreting what "you"
<a name="6021"></a>     *   means if it's used as an object in the command.  "tell bob to hit
<a name="6022"></a>     *   you" probably means that Bob should hit the player character,
<a name="6023"></a>     *   while "bob, hit you" probably means that Bob should hit himself.  
<a name="6024"></a>     */
<a name="6025"></a>    commandReferralPerson = nil
<a name="6026"></a>
<a name="6027"></a>    /* determine if I'm the player character */
<a name="6028"></a>    isPlayerChar() { return libGlobal.playerChar == self; }
<a name="6029"></a>
<a name="6030"></a>    /*
<a name="6031"></a>     *   Implicit command handling style for this actor.  There are two
<a name="6032"></a>     *   styles for handling implied commands: "player" and "NPC",
<a name="6033"></a>     *   indicated by the enum codes ModePlayer and ModeNPC, respectively.
<a name="6034"></a>     *   
<a name="6035"></a>     *   In "player" mode, each implied command is announced with a
<a name="6036"></a>     *   description of the command to be performed; DEFAULT responses are
<a name="6037"></a>     *   suppressed; and failures are shown.  Furthermore, interactive
<a name="6038"></a>     *   requests for more information from the parser are allowed.
<a name="6039"></a>     *   Transcripts like this result:
<a name="6040"></a>     *   
<a name="6041"></a>     *   &gt;open door
<a name="6042"></a>     *.  (first opening the door)
<a name="6043"></a>     *.  (first unlocking the door)
<a name="6044"></a>     *.  What do you want to unlock it with?
<a name="6045"></a>     *   
<a name="6046"></a>     *   In "NPC" mode, implied commands are treated as complete and
<a name="6047"></a>     *   separate commands.  They are not announced; default responses are
<a name="6048"></a>     *   shown; failures are NOT shown; and interactive requests for more
<a name="6049"></a>     *   information are not allowed.  When an implied command fails in NPC
<a name="6050"></a>     *   mode, the parser acts as though the command had never been
<a name="6051"></a>     *   attempted.
<a name="6052"></a>     *   
<a name="6053"></a>     *   By default, we return ModePlayer if we're the player character,
<a name="6054"></a>     *   ModeNPC if not (thus the respective names of the modes).  Some
<a name="6055"></a>     *   authors might prefer to use "player mode" for NPC's as well as for
<a name="6056"></a>     *   the player character, which is why the various parts of the parser
<a name="6057"></a>     *   that care about this mode consult this method rather than simply
<a name="6058"></a>     *   testing the PC/NPC status of the actor.  
<a name="6059"></a>     */
<a name="6060"></a>    impliedCommandMode() { return isPlayerChar() ? ModePlayer : ModeNPC; }
<a name="6061"></a>
<a name="6062"></a>    /*
<a name="6063"></a>     *   Try moving the given object into this object.  For an actor, this
<a name="6064"></a>     *   will do one of two things.  If 'self' is the actor performing the
<a name="6065"></a>     *   action that's triggering this implied command, then we can achieve
<a name="6066"></a>     *   the goal simply by taking the object.  Otherwise, the way to get
<a name="6067"></a>     *   an object into my possession is to have the actor performing the
<a name="6068"></a>     *   command give me the object.  
<a name="6069"></a>     */
<a name="6070"></a>    tryMovingObjInto(obj)
<a name="6071"></a>    {
<a name="6072"></a>        if (gActor == self)
<a name="6073"></a>        {
<a name="6074"></a>            /* 
<a name="6075"></a>             *   I'm performing the triggering action, so I merely need to
<a name="6076"></a>             *   pick up the object 
<a name="6077"></a>             */
<a name="6078"></a>            return tryImplicitAction(Take, obj);
<a name="6079"></a>        }
<a name="6080"></a>        else
<a name="6081"></a>        {
<a name="6082"></a>            /* 
<a name="6083"></a>             *   another actor is performing the action; since that actor
<a name="6084"></a>             *   is the one who must perform the implied action, the way to
<a name="6085"></a>             *   get an object into my inventory is for that actor to give
<a name="6086"></a>             *   it to me 
<a name="6087"></a>             */
<a name="6088"></a>            return tryImplicitAction(GiveTo, obj, self);
<a name="6089"></a>        }
<a name="6090"></a>    }
<a name="6091"></a>
<a name="6092"></a>    /* desribe our containment of an object as carrying the object */
<a name="6093"></a>    mustMoveObjInto(obj) { reportFailure(&amp;mustBeCarryingMsg, obj, self); }
<a name="6094"></a>
<a name="6095"></a>    /*
<a name="6096"></a>     *   You can limit the cumulative amount of bulk an actor can hold, and
<a name="6097"></a>     *   the maximum bulk of any one object the actor can hold, using
<a name="6098"></a>     *   bulkCapacity and maxSingleBulk.  These properties are analogous to
<a name="6099"></a>     *   the same ones in Container.
<a name="6100"></a>     *   
<a name="6101"></a>     *   A word of caution on these is in order.  Many authors worry that
<a name="6102"></a>     *   it's unrealistic if the player character can carry too much at one
<a name="6103"></a>     *   time, so they'll fiddle with these properties to impose a carrying
<a name="6104"></a>     *   limit that seems realistic.  Be advised that authors love this
<a name="6105"></a>     *   sort of "realism" a whole lot more than players do.  Players
<a name="6106"></a>     *   almost universally don't care about it, and in fact tend to hate
<a name="6107"></a>     *   the inventory juggling it inevitably leads to.  Juggling inventory
<a name="6108"></a>     *   isn't any fun for the player.  Don't fool yourself about this -
<a name="6109"></a>     *   the thoughts in the mind of a player who's tediously carting
<a name="6110"></a>     *   objects back and forth three at a time will not include admiration
<a name="6111"></a>     *   of your prowess at simulational realism.  In contrast, if you set
<a name="6112"></a>     *   the carrying limit to infinity, it's a rare player who will even
<a name="6113"></a>     *   notice, and a much rarer player who'll complain about it.
<a name="6114"></a>     *   
<a name="6115"></a>     *   If you really must insist on inventory limits, refer to the
<a name="6116"></a>     *   BagOfHolding class for a solution that can salvage most of the
<a name="6117"></a>     *   "realism" that the accountancy-inclined author craves, without
<a name="6118"></a>     *   creating undue inconvenience for the player.  BagOfHolding makes
<a name="6119"></a>     *   inventory limits palatable for the player by essentially
<a name="6120"></a>     *   automating the required inventory juggling.  In fact, for most
<a name="6121"></a>     *   players, an inventory limit in conjunction with a bag of holding
<a name="6122"></a>     *   is actually better than an unlimited inventory, since it improves
<a name="6123"></a>     *   readability by keeping the direct inventory list to a manageable
<a name="6124"></a>     *   size.  
<a name="6125"></a>     */
<a name="6126"></a>    bulkCapacity = 10000
<a name="6127"></a>    maxSingleBulk = 10
<a name="6128"></a>
<a name="6129"></a>    /*
<a name="6130"></a>     *   An actor can limit the cumulative amount of weight being held,
<a name="6131"></a>     *   using weightCapacity.  By default we make this so large that
<a name="6132"></a>     *   there is effectively no limit to how much weight an actor can
<a name="6133"></a>     *   carry.  
<a name="6134"></a>     */
<a name="6135"></a>    weightCapacity = 10000
<a name="6136"></a>
<a name="6137"></a>    /*
<a name="6138"></a>     *   Can I own the given object?  By default, an actor can own
<a name="6139"></a>     *   anything.  
<a name="6140"></a>     */
<a name="6141"></a>    canOwn(obj) { return true; }
<a name="6142"></a>
<a name="6143"></a>    /*
<a name="6144"></a>     *   Get the preconditions for travel.  By default, we'll add the
<a name="6145"></a>     *   standard preconditions that the connector requires for actors.
<a name="6146"></a>     *   
<a name="6147"></a>     *   Note that these preconditions apply only when the actor is the
<a name="6148"></a>     *   traveler.  If the actor is in a vehicle, so that the vehicle is
<a name="6149"></a>     *   the traveler in a given travel operation, the vehicle's
<a name="6150"></a>     *   travelerPreCond conditions are used instead of ours.  
<a name="6151"></a>     */
<a name="6152"></a>    travelerPreCond(conn) { return conn.actorTravelPreCond(self); }
<a name="6153"></a>
<a name="6154"></a>    /* by default, actors are listed when they arrive aboard a vehicle */
<a name="6155"></a>    isListedAboardVehicle = true
<a name="6156"></a>
<a name="6157"></a>    /*
<a name="6158"></a>     *   Get the object that's actually going to move when this actor
<a name="6159"></a>     *   travels via the given connector.  In most cases this is simply the
<a name="6160"></a>     *   actor; but when the actor is in a vehicle, travel commands move
<a name="6161"></a>     *   the vehicle, not the actor: the actor stays in the vehicle while
<a name="6162"></a>     *   the vehicle moves to a new location.  We determine this by asking
<a name="6163"></a>     *   our immediate location what it thinks about the situation.
<a name="6164"></a>     *   
<a name="6165"></a>     *   If we have a special traveler explicitly set, it overrides the
<a name="6166"></a>     *   traveler indicated by the location.  
<a name="6167"></a>     */
<a name="6168"></a>    getTraveler(conn)
<a name="6169"></a>    {
<a name="6170"></a>        /* 
<a name="6171"></a>         *   Return our special traveler if we have one; otherwise, if we
<a name="6172"></a>         *   have a location, return the traveler indicated by our
<a name="6173"></a>         *   location; otherwise, we're the traveler. 
<a name="6174"></a>         */
<a name="6175"></a>        if (specialTraveler != nil)
<a name="6176"></a>            return specialTraveler;
<a name="6177"></a>        else if (location != nil)
<a name="6178"></a>            return location.getLocTraveler(self, conn);
<a name="6179"></a>        else
<a name="6180"></a>            return self;
<a name="6181"></a>    }
<a name="6182"></a>
<a name="6183"></a>    /*
<a name="6184"></a>     *   Get the "push traveler" for the actor.  This is the nominal
<a name="6185"></a>     *   traveler that we want to use when the actor enters a command like
<a name="6186"></a>     *   PUSH BOX NORTH.  'obj' is the object we're trying to push.  
<a name="6187"></a>     */
<a name="6188"></a>    getPushTraveler(obj)
<a name="6189"></a>    {
<a name="6190"></a>        /* 
<a name="6191"></a>         *   If we already have a special traveler, just use the special
<a name="6192"></a>         *   traveler.  Otherwise, if we have a location, ask the location
<a name="6193"></a>         *   what it thinks.  Otherwise, we're the traveler. 
<a name="6194"></a>         */
<a name="6195"></a>        if (specialTraveler != nil)
<a name="6196"></a>            return specialTraveler;
<a name="6197"></a>        else if (location != nil)
<a name="6198"></a>            return location.getLocPushTraveler(self, obj);
<a name="6199"></a>        else
<a name="6200"></a>            return self;
<a name="6201"></a>    }
<a name="6202"></a>
<a name="6203"></a>    /* is an actor traveling with us? */
<a name="6204"></a>    isActorTraveling(actor)
<a name="6205"></a>    {
<a name="6206"></a>        /* we're the only actor traveling when we're the traveler */
<a name="6207"></a>        return (actor == self);
<a name="6208"></a>    }
<a name="6209"></a>
<a name="6210"></a>    /* invoke a callback on each actor traveling with the traveler */
<a name="6211"></a>    forEachTravelingActor(func)
<a name="6212"></a>    {
<a name="6213"></a>        /* we're the only actor, so simply invoke the callback on myself */
<a name="6214"></a>        (func)(self);
<a name="6215"></a>    }
<a name="6216"></a>
<a name="6217"></a>    /* 
<a name="6218"></a>     *   Get the actors involved in travel, when we're acting in our role
<a name="6219"></a>     *   as a Traveler.  When the Traveler is simply the Actor, the only
<a name="6220"></a>     *   actor involved in the travel is 'self'. 
<a name="6221"></a>     */
<a name="6222"></a>    getTravelerActors = [self]
<a name="6223"></a>
<a name="6224"></a>    /* we're the self-motive actor doing the travel */
<a name="6225"></a>    getTravelerMotiveActors = [self]
<a name="6226"></a>
<a name="6227"></a>    /*
<a name="6228"></a>     *   Set the "special traveler."  When this is set, we explicitly
<a name="6229"></a>     *   perform travel through this object rather than through the
<a name="6230"></a>     *   traveler indicated by our location.  Returns the old value, so
<a name="6231"></a>     *   that the old value can be restored when the caller has finished
<a name="6232"></a>     *   its need for the special traveler.  
<a name="6233"></a>     */
<a name="6234"></a>    setSpecialTraveler(traveler)
<a name="6235"></a>    {
<a name="6236"></a>        local oldVal;
<a name="6237"></a>
<a name="6238"></a>        /* remember the old value so that we can return it */
<a name="6239"></a>        oldVal = specialTraveler;
<a name="6240"></a>
<a name="6241"></a>        /* remember the new value */
<a name="6242"></a>        specialTraveler = traveler;
<a name="6243"></a>
<a name="6244"></a>        /* return the old value */
<a name="6245"></a>        return oldVal;
<a name="6246"></a>    }
<a name="6247"></a>
<a name="6248"></a>    /* our special traveler */
<a name="6249"></a>    specialTraveler = nil
<a name="6250"></a>
<a name="6251"></a>    /*
<a name="6252"></a>     *   Try moving the actor into the given room in preparation for
<a name="6253"></a>     *   travel, using pre-condition rules. 
<a name="6254"></a>     */
<a name="6255"></a>    checkMovingTravelerInto(room, allowImplicit)
<a name="6256"></a>    {
<a name="6257"></a>        /* try moving the actor into the room */
<a name="6258"></a>        return room.checkMovingActorInto(allowImplicit);
<a name="6259"></a>    }
<a name="6260"></a>
<a name="6261"></a>    /*
<a name="6262"></a>     *   Check to ensure the actor is ready to enter the given nested
<a name="6263"></a>     *   room, using pre-condition rules.  By default, we'll ask the given
<a name="6264"></a>     *   nested room to handle it.  
<a name="6265"></a>     */
<a name="6266"></a>    checkReadyToEnterNestedRoom(dest, allowImplicit)
<a name="6267"></a>    {
<a name="6268"></a>        /* ask the destination to do the work */
<a name="6269"></a>        return dest.checkActorReadyToEnterNestedRoom(allowImplicit);
<a name="6270"></a>    }
<a name="6271"></a>
<a name="6272"></a>    /*
<a name="6273"></a>     *   Travel within a location, as from a room to a contained nested
<a name="6274"></a>     *   room.  This should generally be used in lieu of travelTo when
<a name="6275"></a>     *   traveling between locations that are related directly by
<a name="6276"></a>     *   containment rather than with TravelConnector objects.
<a name="6277"></a>     *   
<a name="6278"></a>     *   Travel within a location is not restricted by darkness; we assume
<a name="6279"></a>     *   that if the nested objects are in scope at all, travel among them
<a name="6280"></a>     *   is allowed.
<a name="6281"></a>     *   
<a name="6282"></a>     *   This type of travel does not trigger calls to travelerLeaving()
<a name="6283"></a>     *   or travelerArriving().  To mitigate this loss of notification, we
<a name="6284"></a>     *   call actorTravelingWithin() on the source and destination
<a name="6285"></a>     *   objects.  
<a name="6286"></a>     */
<a name="6287"></a>    travelWithin(dest)
<a name="6288"></a>    {
<a name="6289"></a>        /* if I'm not going anywhere, ignore the operation */
<a name="6290"></a>        if (dest == location)
<a name="6291"></a>            return;
<a name="6292"></a>
<a name="6293"></a>        /* 
<a name="6294"></a>         *   Notify the traveler.  Note that since this is local travel
<a name="6295"></a>         *   within a single top-level location, there's no connector. 
<a name="6296"></a>         */
<a name="6297"></a>        getTraveler(nil).travelerTravelWithin(self, dest);
<a name="6298"></a>    }
<a name="6299"></a>
<a name="6300"></a>    /*
<a name="6301"></a>     *   Traveler interface: perform local travel, between nested rooms
<a name="6302"></a>     *   within a single top-level location. 
<a name="6303"></a>     */
<a name="6304"></a>    travelerTravelWithin(actor, dest)
<a name="6305"></a>    {
<a name="6306"></a>        local origin;
<a name="6307"></a>
<a name="6308"></a>        /* remember my origin */
<a name="6309"></a>        origin = location;
<a name="6310"></a>        
<a name="6311"></a>        /* notify the source that we're traveling within a room */
<a name="6312"></a>        if (origin != nil)
<a name="6313"></a>            origin.actorTravelingWithin(origin, dest);
<a name="6314"></a>
<a name="6315"></a>        /* 
<a name="6316"></a>         *   if our origin and destination have different effective follow
<a name="6317"></a>         *   locations, track the follow 
<a name="6318"></a>         */
<a name="6319"></a>        if (origin != nil
<a name="6320"></a>            &amp;&amp; dest != nil
<a name="6321"></a>            &amp;&amp; origin.effectiveFollowLocation != dest.effectiveFollowLocation)
<a name="6322"></a>        {
<a name="6323"></a>            /* 
<a name="6324"></a>             *   notify observing objects of the travel; we're not moving
<a name="6325"></a>             *   along a connector, so there is no connector associated
<a name="6326"></a>             *   with the tracking information 
<a name="6327"></a>             */
<a name="6328"></a>            connectionTable().forEachAssoc(
<a name="6329"></a>                {obj, val: obj.beforeTravel(self, nil)});
<a name="6330"></a>        }
<a name="6331"></a>
<a name="6332"></a>        /* move me to the destination */
<a name="6333"></a>        moveInto(dest);
<a name="6334"></a>
<a name="6335"></a>        /* 
<a name="6336"></a>         *   recalculate the global sense context for message generation
<a name="6337"></a>         *   purposes, since we've moved to a new location 
<a name="6338"></a>         */
<a name="6339"></a>        if (gAction != nil)
<a name="6340"></a>            gAction.recalcSenseContext();
<a name="6341"></a>
<a name="6342"></a>        /* notify the destination of the interior travel */
<a name="6343"></a>        if (dest != nil)
<a name="6344"></a>            dest.actorTravelingWithin(origin, dest);
<a name="6345"></a>    }
<a name="6346"></a>
<a name="6347"></a>    /*
<a name="6348"></a>     *   Check for travel in the dark.  If we're in a dark room, and our
<a name="6349"></a>     *   destination is a dark room, ask the connector for guidance.
<a name="6350"></a>     *   
<a name="6351"></a>     *   Travel connectors normally call this before invoking our
<a name="6352"></a>     *   travelTo() method to carry out the travel.  The darkness check
<a name="6353"></a>     *   usually must be made before any barrier checks.  
<a name="6354"></a>     */
<a name="6355"></a>    checkDarkTravel(dest, connector)
<a name="6356"></a>    {
<a name="6357"></a>        local origin;
<a name="6358"></a>        
<a name="6359"></a>        /* 
<a name="6360"></a>         *   If we're not in the dark in the current location, there's no
<a name="6361"></a>         *   need to check for dark-to-dark travel; light-to-dark travel
<a name="6362"></a>         *   is always allowed. 
<a name="6363"></a>         */
<a name="6364"></a>        if (isLocationLit())
<a name="6365"></a>            return;
<a name="6366"></a>
<a name="6367"></a>        /* get the origin - this is the traveler's location */
<a name="6368"></a>        origin = getTraveler(connector).location;
<a name="6369"></a>
<a name="6370"></a>        /*
<a name="6371"></a>         *   Check to see if the connector itself is visible in the dark.
<a name="6372"></a>         *   If it is, then allow the travel without restriction.  
<a name="6373"></a>         */
<a name="6374"></a>        if (connector.isConnectorVisibleInDark(origin, self))
<a name="6375"></a>            return;
<a name="6376"></a>
<a name="6377"></a>        /*
<a name="6378"></a>         *   We are attempting dark-to-dark travel.  We allow or disallow
<a name="6379"></a>         *   this type of travel on a per-connector basis, so ask the
<a name="6380"></a>         *   connector to handle it.  If the connector wishes to disallow
<a name="6381"></a>         *   the travel, it will display an appropriate failure report and
<a name="6382"></a>         *   terminate the command with 'exit'.  
<a name="6383"></a>         */
<a name="6384"></a>        connector.darkTravel(self, dest);
<a name="6385"></a>    }
<a name="6386"></a>
<a name="6387"></a>    /*
<a name="6388"></a>     *   Travel to a new location. 
<a name="6389"></a>     */
<a name="6390"></a>    travelTo(dest, connector, backConnector)
<a name="6391"></a>    {
<a name="6392"></a>        /* send the request to the traveler */
<a name="6393"></a>        getTraveler(connector)
<a name="6394"></a>            .travelerTravelTo(dest, connector, backConnector);
<a name="6395"></a>    }
<a name="6396"></a>
<a name="6397"></a>    /*
<a name="6398"></a>     *   Perform scripted travel to the given adjacent location.  This
<a name="6399"></a>     *   looks for a directional connector in our current location whose
<a name="6400"></a>     *   destination is the given location, and for a corresponding
<a name="6401"></a>     *   back-connector in the destination location.  If we can find the
<a name="6402"></a>     *   connectors, we'll perform the travel using travelTo().
<a name="6403"></a>     *   
<a name="6404"></a>     *   The purpose of this routine is to simplify scripted travel for
<a name="6405"></a>     *   simple cases where directional connectors are available for the
<a name="6406"></a>     *   desired travel.  This routine is NOT suitable for intelligent
<a name="6407"></a>     *   goal-seeking NPC's who automatically try to find their own routes,
<a name="6408"></a>     *   for two reasons.  First, this routine only lets an NPC move to an
<a name="6409"></a>     *   *adjacent* location; it won't try to find a path between arbitrary
<a name="6410"></a>     *   locations.  Second, this routine is "omniscient": it doesn't take
<a name="6411"></a>     *   into account what the NPC knows about the connections between
<a name="6412"></a>     *   locations, but simply finds a connector that actually provides the
<a name="6413"></a>     *   desired travel.
<a name="6414"></a>     *   
<a name="6415"></a>     *   What this routine *is* suitable for are cases where we have a
<a name="6416"></a>     *   pre-scripted series of NPC travel actions, where we have a list of
<a name="6417"></a>     *   rooms we want the NPC to visit in order.  This routine simplifies
<a name="6418"></a>     *   this type of scripting by automatically finding the connectors;
<a name="6419"></a>     *   the script only has to specify the next location for the NPC to
<a name="6420"></a>     *   visit.  
<a name="6421"></a>     */
<a name="6422"></a>    scriptedTravelTo(dest)
<a name="6423"></a>    {
<a name="6424"></a>        local conn;
<a name="6425"></a>
<a name="6426"></a>        /* find a connector from the current location to the new location */
<a name="6427"></a>        conn = location.getConnectorTo(self, dest);
<a name="6428"></a>
<a name="6429"></a>        /* if we found the connector, perform the travel */
<a name="6430"></a>        if (conn != nil)
<a name="6431"></a>            nestedActorAction(self, TravelVia, conn);
<a name="6432"></a>    }
<a name="6433"></a>
<a name="6434"></a>    /*
<a name="6435"></a>     *   Remember the last door I traveled through.  We use this
<a name="6436"></a>     *   information for disambiguation, to boost the likelihood that an
<a name="6437"></a>     *   actor that just traveled through a door is referring to the same
<a name="6438"></a>     *   door in a subsequent "close" command.  
<a name="6439"></a>     */
<a name="6440"></a>    rememberLastDoor(obj) { lastDoorTraversed = obj; }
<a name="6441"></a>
<a name="6442"></a>    /*
<a name="6443"></a>     *   Remember our most recent travel.  If we know the back connector
<a name="6444"></a>     *   (i.e., the connector that reverses the travel we're performing),
<a name="6445"></a>     *   then we'll be able to accept a GO BACK command to attempt to
<a name="6446"></a>     *   return to the previous location.  
<a name="6447"></a>     */
<a name="6448"></a>    rememberTravel(origin, dest, backConnector)
<a name="6449"></a>    {
<a name="6450"></a>        /* remember the destination of the travel, and the connector back */
<a name="6451"></a>        lastTravelDest = dest;
<a name="6452"></a>        lastTravelBack = backConnector;
<a name="6453"></a>    }
<a name="6454"></a>
<a name="6455"></a>    /*
<a name="6456"></a>     *   Reverse the most recent travel.  If we're still within the same
<a name="6457"></a>     *   destination we reached in the last travel, and we know the
<a name="6458"></a>     *   connector we arrived through (i.e., the "back connector" for the
<a name="6459"></a>     *   last travel, which reverses the connector we took to get here),
<a name="6460"></a>     *   then try traveling via the connector.  
<a name="6461"></a>     */
<a name="6462"></a>    reverseLastTravel()
<a name="6463"></a>    {
<a name="6464"></a>        /* 
<a name="6465"></a>         *   If we don't know the connector back to our previous location,
<a name="6466"></a>         *   we obviously can't reverse the travel.  If we're not still in
<a name="6467"></a>         *   the same location as the previous travel's destination, then
<a name="6468"></a>         *   we can't reverse the travel either, because the back
<a name="6469"></a>         *   connector isn't applicable to our current location.  (This
<a name="6470"></a>         *   latter condition could only happen if we've been moved
<a name="6471"></a>         *   somewhere without ordinary travel occurring, but this is a
<a name="6472"></a>         *   possibility.) 
<a name="6473"></a>         */
<a name="6474"></a>        if (lastTravelBack == nil
<a name="6475"></a>            || lastTravelDest == nil
<a name="6476"></a>            || !isIn(lastTravelDest))
<a name="6477"></a>        {
<a name="6478"></a>            reportFailure(&amp;cannotGoBackMsg);
<a name="6479"></a>            exit;
<a name="6480"></a>        }
<a name="6481"></a>
<a name="6482"></a>        /* attempt travel via our back connector */
<a name="6483"></a>        nestedAction(TravelVia, lastTravelBack);
<a name="6484"></a>    }
<a name="6485"></a>
<a name="6486"></a>    /* the last door I traversed */
<a name="6487"></a>    lastDoorTraversed = nil
<a name="6488"></a>
<a name="6489"></a>    /* the destination and back connector for our last travel */
<a name="6490"></a>    lastTravelDest = nil
<a name="6491"></a>    lastTravelBack = nil
<a name="6492"></a>
<a name="6493"></a>    /* 
<a name="6494"></a>     *   use a custom message for cases where we're holding a destination
<a name="6495"></a>     *   object for BOARD, ENTER, etc 
<a name="6496"></a>     */
<a name="6497"></a>    checkStagingLocation(dest)
<a name="6498"></a>    {
<a name="6499"></a>        /* 
<a name="6500"></a>         *   if the destination is within us, explain specifically that
<a name="6501"></a>         *   this is the problem 
<a name="6502"></a>         */
<a name="6503"></a>        if (dest.isIn(self))
<a name="6504"></a>            reportFailure(&amp;invalidStagingContainerActorMsg, self, dest);
<a name="6505"></a>        else
<a name="6506"></a>            inherited(dest);
<a name="6507"></a>
<a name="6508"></a>        /* terminate the command */
<a name="6509"></a>        exit;
<a name="6510"></a>    }
<a name="6511"></a>
<a name="6512"></a>    /* 
<a name="6513"></a>     *   Travel arrival/departure messages.  Defer to the current state
<a name="6514"></a>     *   object on all of these.  
<a name="6515"></a>     */
<a name="6516"></a>    sayArriving(conn)
<a name="6517"></a>        { curState.sayArriving(conn); }
<a name="6518"></a>    sayDeparting(conn)
<a name="6519"></a>        { curState.sayDeparting(conn); }
<a name="6520"></a>    sayArrivingLocally(dest, conn)
<a name="6521"></a>        { curState.sayArrivingLocally(dest, conn); }
<a name="6522"></a>    sayDepartingLocally(dest, conn)
<a name="6523"></a>        { curState.sayDepartingLocally(dest, conn); }
<a name="6524"></a>    sayTravelingRemotely(dest, conn)
<a name="6525"></a>        { curState.sayTravelingRemotely(dest, conn); }
<a name="6526"></a>    sayArrivingDir(dir, conn)
<a name="6527"></a>        { curState.sayArrivingDir(dir, conn); }
<a name="6528"></a>    sayDepartingDir(dir, conn)
<a name="6529"></a>        { curState.sayDepartingDir(dir, conn); }
<a name="6530"></a>    sayArrivingThroughPassage(conn)
<a name="6531"></a>        { curState.sayArrivingThroughPassage(conn); }
<a name="6532"></a>    sayDepartingThroughPassage(conn)
<a name="6533"></a>        { curState.sayDepartingThroughPassage(conn); }
<a name="6534"></a>    sayArrivingViaPath(conn)
<a name="6535"></a>        { curState.sayArrivingViaPath(conn); }
<a name="6536"></a>    sayDepartingViaPath(conn)
<a name="6537"></a>        { curState.sayDepartingViaPath(conn); }
<a name="6538"></a>    sayArrivingUpStairs(conn)
<a name="6539"></a>        { curState.sayArrivingUpStairs(conn); }
<a name="6540"></a>    sayArrivingDownStairs(conn)
<a name="6541"></a>        { curState.sayArrivingDownStairs(conn); }
<a name="6542"></a>    sayDepartingUpStairs(conn)
<a name="6543"></a>        { curState.sayDepartingUpStairs(conn); }
<a name="6544"></a>    sayDepartingDownStairs(conn)
<a name="6545"></a>        { curState.sayDepartingDownStairs(conn); }
<a name="6546"></a>
<a name="6547"></a>    /*
<a name="6548"></a>     *   Get the current interlocutor.  By default, we'll address new
<a name="6549"></a>     *   conversational commands (ASK ABOUT, TELL ABOUT, SHOW TO) to the
<a name="6550"></a>     *   last conversational partner, if that actor is still within range.
<a name="6551"></a>     */
<a name="6552"></a>    getCurrentInterlocutor()
<a name="6553"></a>    {
<a name="6554"></a>        /* 
<a name="6555"></a>         *   if we've talked to someone before, and we can still talk to
<a name="6556"></a>         *   them now, return that actor; otherwise we have no default 
<a name="6557"></a>         */
<a name="6558"></a>        if (lastInterlocutor != nil &amp;&amp; canTalkTo(lastInterlocutor))
<a name="6559"></a>            return lastInterlocutor;
<a name="6560"></a>        else
<a name="6561"></a>            return nil;
<a name="6562"></a>    }
<a name="6563"></a>
<a name="6564"></a>    /*
<a name="6565"></a>     *   Get the default interlocutor.  If there's a current interlocutor,
<a name="6566"></a>     *   and we can still talk to that actor, then that's the default
<a name="6567"></a>     *   interlocutor.  If not, we'll return whatever actor is the default
<a name="6568"></a>     *   for a TALK TO command.  Note that TALK TO won't necessarily have a
<a name="6569"></a>     *   default actor; if it doesn't, we'll simply return nil.  
<a name="6570"></a>     */
<a name="6571"></a>    getDefaultInterlocutor()
<a name="6572"></a>    {
<a name="6573"></a>        local actor;
<a name="6574"></a>        
<a name="6575"></a>        /* check for a current interlocutor */
<a name="6576"></a>        actor = getCurrentInterlocutor();
<a name="6577"></a>
<a name="6578"></a>        /* 
<a name="6579"></a>         *   if we're not talking to anyone, or if the person we were
<a name="6580"></a>         *   talking to can no longer hear us, look for a default object
<a name="6581"></a>         *   for a TALK TO command and use it instead as the default 
<a name="6582"></a>         */
<a name="6583"></a>        if (actor == nil || !canTalkTo(actor))
<a name="6584"></a>        {
<a name="6585"></a>            local tt;
<a name="6586"></a>            local res;
<a name="6587"></a>            
<a name="6588"></a>            /* set up a TALK TO command and a resolver */
<a name="6589"></a>            tt = new TalkToAction();
<a name="6590"></a>            res = new Resolver(tt, gIssuingActor, gActor);
<a name="6591"></a>            
<a name="6592"></a>            /* get the default direct object */
<a name="6593"></a>            actor = tt.getDefaultDobj(new EmptyNounPhraseProd(), res);
<a name="6594"></a>            
<a name="6595"></a>            /* if that worked, get the object from the resolve info */
<a name="6596"></a>            if (actor != nil)
<a name="6597"></a>                actor = actor[1].obj_;
<a name="6598"></a>        }
<a name="6599"></a>
<a name="6600"></a>        /* return what we found */
<a name="6601"></a>        return actor;
<a name="6602"></a>    }
<a name="6603"></a>
<a name="6604"></a>    /* 
<a name="6605"></a>     *   The most recent actor that we've interacted with through a
<a name="6606"></a>     *   conversational command (ASK, TELL, GIVE, SHOW, etc).
<a name="6607"></a>     */
<a name="6608"></a>    lastInterlocutor = nil
<a name="6609"></a>
<a name="6610"></a>    /* 
<a name="6611"></a>     *   Our conversational "boredom" counter.  While we're in a
<a name="6612"></a>     *   conversation, this tracks the number of turns since the last
<a name="6613"></a>     *   conversational command from the actor we're talking to.
<a name="6614"></a>     *   
<a name="6615"></a>     *   Note that this state is part of the actor, even though it's
<a name="6616"></a>     *   usually managed by the InConversationState object.  The state is
<a name="6617"></a>     *   stored with the actor rather than with the state object because
<a name="6618"></a>     *   it really describes the condition of the actor, not of the state
<a name="6619"></a>     *   object.  
<a name="6620"></a>     */
<a name="6621"></a>    boredomCount = 0
<a name="6622"></a>
<a name="6623"></a>    /* 
<a name="6624"></a>     *   game-clock time (Schedulable.gameClockTime) of the last
<a name="6625"></a>     *   conversational command addressed to us by the player character 
<a name="6626"></a>     */
<a name="6627"></a>    lastConvTime = -1
<a name="6628"></a>
<a name="6629"></a>    /* 
<a name="6630"></a>     *   Did we engage in any conversation on the current turn?  This can
<a name="6631"></a>     *   be used as a quick check in background activity scripts when we
<a name="6632"></a>     *   want to run a step only in the absence of any conversation on the
<a name="6633"></a>     *   same turn. 
<a name="6634"></a>     */
<a name="6635"></a>    conversedThisTurn() { return lastConvTime == Schedulable.gameClockTime; }
<a name="6636"></a>
<a name="6637"></a>    /* 
<a name="6638"></a>     *   Note that we're performing a conversational command targeting the
<a name="6639"></a>     *   given actor.  We'll make the actors point at each other with their
<a name="6640"></a>     *   'lastInterlocutor' properties.  This is called on the character
<a name="6641"></a>     *   performing the conversation command: if the player types ASK BOB
<a name="6642"></a>     *   ABOUT BOOK, this will be called on the player character actor,
<a name="6643"></a>     *   with 'other' set to Bob.  
<a name="6644"></a>     */
<a name="6645"></a>    noteConversation(other)
<a name="6646"></a>    {
<a name="6647"></a>        /* note that we're part of a conversational action */
<a name="6648"></a>        noteConvAction(other);
<a name="6649"></a>
<a name="6650"></a>        /* let the other actor know we're conversing with them */
<a name="6651"></a>        other.noteConversationFrom(self);
<a name="6652"></a>    }
<a name="6653"></a>
<a name="6654"></a>    /*
<a name="6655"></a>     *   Note that another actor is issuing a conversational command
<a name="6656"></a>     *   targeting us.  For example, if the player types ASK BOB ABOUT
<a name="6657"></a>     *   BOOK, then this will be called on Bob, with the player character
<a name="6658"></a>     *   actor as 'other'. 
<a name="6659"></a>     */
<a name="6660"></a>    noteConversationFrom(other)
<a name="6661"></a>    {
<a name="6662"></a>        /* note that we're part of a conversational action */
<a name="6663"></a>        noteConvAction(other);
<a name="6664"></a>    }
<a name="6665"></a>
<a name="6666"></a>    /* 
<a name="6667"></a>     *   Note that we're taking part in a conversational action with
<a name="6668"></a>     *   another character.  This is symmetrical - it could mean we're the
<a name="6669"></a>     *   initiator of the conversation action or the target.  We'll
<a name="6670"></a>     *   remember the person we're talking to, and reset our conversation
<a name="6671"></a>     *   time counters so we know we've conversed on this turn.  
<a name="6672"></a>     */
<a name="6673"></a>    noteConvAction(other)
<a name="6674"></a>    {
<a name="6675"></a>        /* note our last conversational partner */
<a name="6676"></a>        lastInterlocutor = other;
<a name="6677"></a>
<a name="6678"></a>        /* set the actor to be the pronoun antecedent */
<a name="6679"></a>        setPronounObj(other);
<a name="6680"></a>
<a name="6681"></a>        /* 
<a name="6682"></a>         *   reset our boredom counter, as the other actor has just spoken
<a name="6683"></a>         *   to us 
<a name="6684"></a>         */
<a name="6685"></a>        boredomCount = 0;
<a name="6686"></a>
<a name="6687"></a>        /* remember the time of our last conversation from the PC */
<a name="6688"></a>        lastConvTime = Schedulable.gameClockTime;
<a name="6689"></a>    }
<a name="6690"></a>
<a name="6691"></a>    /* note that we're consulting an item */
<a name="6692"></a>    noteConsultation(obj) { lastConsulted = obj; }
<a name="6693"></a>
<a name="6694"></a>    /*
<a name="6695"></a>     *   Receive notification that a TopicEntry response in our database is
<a name="6696"></a>     *   being invoked.  We'll just pass this along to our current state.  
<a name="6697"></a>     */
<a name="6698"></a>    notifyTopicResponse(fromActor, entry)
<a name="6699"></a>    {
<a name="6700"></a>        /* let our current state handle it */
<a name="6701"></a>        curState.notifyTopicResponse(fromActor, entry);
<a name="6702"></a>    }
<a name="6703"></a>
<a name="6704"></a>    /* the object we most recently consulted */
<a name="6705"></a>    lastConsulted = nil
<a name="6706"></a>
<a name="6707"></a>    /*
<a name="6708"></a>     *   The actor's "agenda."  This is a list of AgendaItem objects that
<a name="6709"></a>     *   describe things the actor wants to do of its own volition on its
<a name="6710"></a>     *   own turn. 
<a name="6711"></a>     */
<a name="6712"></a>    agendaList = nil
<a name="6713"></a>
<a name="6714"></a>    /* 
<a name="6715"></a>     *   our special "boredom" agenda item - this makes us initiate an end
<a name="6716"></a>     *   to an active conversation when the PC has ignored us for a given
<a name="6717"></a>     *   number of consecutive turns 
<a name="6718"></a>     */
<a name="6719"></a>    boredomAgendaItem = perInstance(new BoredomAgendaItem(self))
<a name="6720"></a>
<a name="6721"></a>    /* add an agenda item */
<a name="6722"></a>    addToAgenda(item)
<a name="6723"></a>    {
<a name="6724"></a>        /* if we don't have an agenda list yet, create one */
<a name="6725"></a>        if (agendaList == nil)
<a name="6726"></a>            agendaList = new Vector(10);
<a name="6727"></a>
<a name="6728"></a>        /* add the item */
<a name="6729"></a>        agendaList.append(item);
<a name="6730"></a>
<a name="6731"></a>        /* 
<a name="6732"></a>         *   keep the list in ascending order of agendaOrder values - this
<a name="6733"></a>         *   will ensure that we'll always choose the earliest item that's
<a name="6734"></a>         *   ready to run 
<a name="6735"></a>         */
<a name="6736"></a>        agendaList.sort(SortAsc, {a, b: a.agendaOrder - b.agendaOrder});
<a name="6737"></a>
<a name="6738"></a>        /* reset the agenda item */
<a name="6739"></a>        item.resetItem();
<a name="6740"></a>    }
<a name="6741"></a>
<a name="6742"></a>    /* remove an agenda item */
<a name="6743"></a>    removeFromAgenda(item)
<a name="6744"></a>    {
<a name="6745"></a>        /* if we have an agenda list, remove the item */
<a name="6746"></a>        if (agendaList != nil)
<a name="6747"></a>            agendaList.removeElement(item);
<a name="6748"></a>    }
<a name="6749"></a>
<a name="6750"></a>    /*
<a name="6751"></a>     *   Execute the next item in our agenda, if there are any items in the
<a name="6752"></a>     *   agenda that are ready to execute.  We'll return true if we found
<a name="6753"></a>     *   an item to execute, nil if not.  
<a name="6754"></a>     */
<a name="6755"></a>    executeAgenda()
<a name="6756"></a>    {
<a name="6757"></a>        local item;
<a name="6758"></a>
<a name="6759"></a>        /* if we don't have an agenda, there are obviously no items */
<a name="6760"></a>        if (agendaList == nil)
<a name="6761"></a>            return nil;
<a name="6762"></a>        
<a name="6763"></a>        /* remove any items that are marked as done */
<a name="6764"></a>        while ((item = agendaList.lastValWhich({x: x.isDone})) != nil)
<a name="6765"></a>            agendaList.removeElement(item);
<a name="6766"></a>
<a name="6767"></a>        /* 
<a name="6768"></a>         *   Scan for an item that's ready to execute.  Since we keep the
<a name="6769"></a>         *   list sorted in ascending order of agendaOrder values, we can
<a name="6770"></a>         *   just pick the earliest item in the list that's ready to run,
<a name="6771"></a>         *   since that will be the ready-to-run item with the lowest
<a name="6772"></a>         *   agendaOrder number. 
<a name="6773"></a>         */
<a name="6774"></a>        item = agendaList.valWhich({x: x.isReady});
<a name="6775"></a>
<a name="6776"></a>        /* if we found an item, execute it */
<a name="6777"></a>        if (item != nil)
<a name="6778"></a>        {
<a name="6779"></a>            try
<a name="6780"></a>            {
<a name="6781"></a>                /* execute the item */
<a name="6782"></a>                item.invokeItem();
<a name="6783"></a>            }
<a name="6784"></a>            catch (RuntimeError err)
<a name="6785"></a>            {
<a name="6786"></a>                /* 
<a name="6787"></a>                 *   If an error occurs while executing the item, mark the
<a name="6788"></a>                 *   item as done.  This will ensure that we won't get
<a name="6789"></a>                 *   stuck in a loop trying to execute the same item over
<a name="6790"></a>                 *   and over, which will probably just run into the same
<a name="6791"></a>                 *   error on each attempt.  
<a name="6792"></a>                 */
<a name="6793"></a>                item.isDone = true;
<a name="6794"></a>
<a name="6795"></a>                /* re-throw the exception */
<a name="6796"></a>                throw err;
<a name="6797"></a>            }
<a name="6798"></a>
<a name="6799"></a>            /* tell the caller we found an item to execute */
<a name="6800"></a>            return true;
<a name="6801"></a>        }
<a name="6802"></a>        else
<a name="6803"></a>        {
<a name="6804"></a>            /* tell the caller we found no agenda item */
<a name="6805"></a>            return nil;
<a name="6806"></a>        }
<a name="6807"></a>    }
<a name="6808"></a>
<a name="6809"></a>    /*
<a name="6810"></a>     *   Calculate the amount of bulk I'm holding directly.  By default,
<a name="6811"></a>     *   we'll simply add up the "actor-encumbering bulk" of each of our
<a name="6812"></a>     *   direct contents.
<a name="6813"></a>     *   
<a name="6814"></a>     *   Note that we don't differentiate here based on whether or not an
<a name="6815"></a>     *   item is being worn, or anything else - we deliberately leave such
<a name="6816"></a>     *   distinctions up to the getEncumberingBulk routine, so that only
<a name="6817"></a>     *   the objects are in the business of deciding how bulky they are
<a name="6818"></a>     *   under different circumstances.  
<a name="6819"></a>     */
<a name="6820"></a>    getBulkHeld()
<a name="6821"></a>    {
<a name="6822"></a>        local total;
<a name="6823"></a>
<a name="6824"></a>        /* start with nothing */
<a name="6825"></a>        total = 0;
<a name="6826"></a>
<a name="6827"></a>        /* add the bulks of directly-contained items */
<a name="6828"></a>        foreach (local cur in contents)
<a name="6829"></a>            total += cur.getEncumberingBulk(self);
<a name="6830"></a>
<a name="6831"></a>        /* return the total */
<a name="6832"></a>        return total;
<a name="6833"></a>    }
<a name="6834"></a>
<a name="6835"></a>    /*
<a name="6836"></a>     *   Calculate the total weight I'm holding.  By default, we'll add up
<a name="6837"></a>     *   the "actor-encumbering weight" of each of our direct contents.
<a name="6838"></a>     *   
<a name="6839"></a>     *   Note that we deliberately only consider our direct contents.  If
<a name="6840"></a>     *   any of the items we are directly holding contain further items,
<a name="6841"></a>     *   getEncumberingWeight will take their weights into account; this
<a name="6842"></a>     *   frees us from needing any special knowledge of the internal
<a name="6843"></a>     *   structure of any items we're holding, and puts that knowledge in
<a name="6844"></a>     *   the individual items where it belongs.  
<a name="6845"></a>     */
<a name="6846"></a>    getWeightHeld()
<a name="6847"></a>    {
<a name="6848"></a>        local total;
<a name="6849"></a>
<a name="6850"></a>        /* start with nothing */
<a name="6851"></a>        total = 0;
<a name="6852"></a>
<a name="6853"></a>        /* add the weights of directly-contained items */
<a name="6854"></a>        foreach (local cur in contents)
<a name="6855"></a>            total += cur.getEncumberingWeight(self);
<a name="6856"></a>
<a name="6857"></a>        /* return the total */
<a name="6858"></a>        return total;
<a name="6859"></a>    }
<a name="6860"></a>
<a name="6861"></a>    /*
<a name="6862"></a>     *   Try making room to hold the given object.  This is called when
<a name="6863"></a>     *   checking the "room to hold object" pre-condition, such as for the
<a name="6864"></a>     *   "take" verb.  
<a name="6865"></a>     *   
<a name="6866"></a>     *   If holding the new object would exceed the our maximum holding
<a name="6867"></a>     *   capacity, we'll go through our inventory looking for objects that
<a name="6868"></a>     *   can reduce our held bulk with implicit commands.  Objects with
<a name="6869"></a>     *   holding affinities - "bags of holding", keyrings, and the like -
<a name="6870"></a>     *   can implicitly shuffle the actor's possessions in a manner that
<a name="6871"></a>     *   is neutral as far as the actor is concerned, thereby reducing our
<a name="6872"></a>     *   active holding load.
<a name="6873"></a>     *   
<a name="6874"></a>     *   Returns true if an implicit command was attempted, nil if not.  
<a name="6875"></a>     */
<a name="6876"></a>    tryMakingRoomToHold(obj, allowImplicit)
<a name="6877"></a>    {
<a name="6878"></a>        local objWeight;
<a name="6879"></a>        local objBulk;
<a name="6880"></a>        local aff;
<a name="6881"></a>        
<a name="6882"></a>        /* get the amount of weight this will add if taken */
<a name="6883"></a>        objWeight = obj.getEncumberingWeight(self);
<a name="6884"></a>
<a name="6885"></a>        /* 
<a name="6886"></a>         *   If this object alone is too heavy for us, give up.  We
<a name="6887"></a>         *   distinguish this case from the case where the total (of
<a name="6888"></a>         *   everything held plus the new item) is too heavy: in the
<a name="6889"></a>         *   latter case we can tell the actor that they can pick this up
<a name="6890"></a>         *   by dropping something else first, whereas if this item alone
<a name="6891"></a>         *   is too heavy, no such advice is warranted. 
<a name="6892"></a>         */
<a name="6893"></a>        if (objWeight &gt; weightCapacity)
<a name="6894"></a>        {
<a name="6895"></a>            reportFailure(&amp;tooHeavyForActorMsg, obj);
<a name="6896"></a>            exit;
<a name="6897"></a>        }
<a name="6898"></a>
<a name="6899"></a>        /* 
<a name="6900"></a>         *   if taking the object would push our total carried weight over
<a name="6901"></a>         *   our total carrying weight limit, give up 
<a name="6902"></a>         */
<a name="6903"></a>        if (obj.whatIfHeldBy({: getWeightHeld()}, self) &gt; weightCapacity)
<a name="6904"></a>        {
<a name="6905"></a>            reportFailure(&amp;totalTooHeavyForMsg, obj);
<a name="6906"></a>            exit;
<a name="6907"></a>        }
<a name="6908"></a>
<a name="6909"></a>        /* get the amount of bulk the object will add */
<a name="6910"></a>        objBulk = obj.getEncumberingBulk(self);
<a name="6911"></a>        
<a name="6912"></a>        /* 
<a name="6913"></a>         *   if the object is simply too big to start with, we can't make
<a name="6914"></a>         *   room no matter what we do 
<a name="6915"></a>         */
<a name="6916"></a>        if (objBulk &gt; maxSingleBulk || objBulk &gt; bulkCapacity)
<a name="6917"></a>        {
<a name="6918"></a>            reportFailure(&amp;tooLargeForActorMsg, obj);
<a name="6919"></a>            exit;
<a name="6920"></a>        }
<a name="6921"></a>
<a name="6922"></a>        /*
<a name="6923"></a>         *   Test what would happen to our bulk if we were to move the
<a name="6924"></a>         *   object into our directly held inventory.  Do this by running
<a name="6925"></a>         *   a "what if" scenario to test moving the object into our
<a name="6926"></a>         *   inventory, and check what effect it has on our held bulk.  If
<a name="6927"></a>         *   it fits, we can let the caller proceed without further work.  
<a name="6928"></a>         */
<a name="6929"></a>        if (obj.whatIfHeldBy({: getBulkHeld()}, self) &lt;= bulkCapacity)
<a name="6930"></a>            return nil;
<a name="6931"></a>
<a name="6932"></a>        /* 
<a name="6933"></a>         *   if we're not allowed to run implicit commands, we won't be
<a name="6934"></a>         *   able to accomplish anything, so give up 
<a name="6935"></a>         */
<a name="6936"></a>        if (!allowImplicit)
<a name="6937"></a>        {
<a name="6938"></a>            reportFailure(&amp;handsTooFullForMsg, obj);
<a name="6939"></a>            exit;
<a name="6940"></a>        }
<a name="6941"></a>
<a name="6942"></a>        /* 
<a name="6943"></a>         *   Get "bag of holding" affinity information for my immediate
<a name="6944"></a>         *   contents.  Consider only objects with encumbering bulk, since
<a name="6945"></a>         *   it will do us no good to move objects without any encumbering
<a name="6946"></a>         *   bulk.  Also ignore objects that aren't being held (some direct
<a name="6947"></a>         *   contents aren't considered to be held, such as clothing being
<a name="6948"></a>         *   worn).  
<a name="6949"></a>         */
<a name="6950"></a>        aff = getBagAffinities(contents.subset(
<a name="6951"></a>            {x: x.getEncumberingBulk(self) != 0 &amp;&amp; x.isHeldBy(self)}));
<a name="6952"></a>
<a name="6953"></a>        /* if there are no bag affinities, we can't move anything around */
<a name="6954"></a>        if (aff.length() == 0)
<a name="6955"></a>        {
<a name="6956"></a>            reportFailure(&amp;handsTooFullForMsg, obj);
<a name="6957"></a>            exit;
<a name="6958"></a>        }
<a name="6959"></a>
<a name="6960"></a>        /*
<a name="6961"></a>         *   If we have at least four items, find the two that were picked
<a name="6962"></a>         *   up most recently (according to the "holding index" value) and
<a name="6963"></a>         *   move them to the end of the list.  In most cases, we'll only
<a name="6964"></a>         *   have to dispose of one or two items to free up enough space
<a name="6965"></a>         *   in our hands, so we'll probably never get to the last couple
<a name="6966"></a>         *   of items in our list, so we're effectively ruling out moving
<a name="6967"></a>         *   these two most recent items; but they'll be in the list if we
<a name="6968"></a>         *   do find we need to move them after all.
<a name="6969"></a>         *   
<a name="6970"></a>         *   The point of this rearrangement is to avoid annoying cases of
<a name="6971"></a>         *   moving something we just picked up, especially if we just
<a name="6972"></a>         *   picked it up in order to carry out the command that's making
<a name="6973"></a>         *   us free up more space now.  This looks especially stupid when
<a name="6974"></a>         *   we perform some command that requires picking up two items
<a name="6975"></a>         *   automatically: we pick up the first, then we put it away in
<a name="6976"></a>         *   order to pick up the second, but then we find that we need
<a name="6977"></a>         *   the first again.  
<a name="6978"></a>         */
<a name="6979"></a>        if (aff.length() &gt;= 4)
<a name="6980"></a>        {
<a name="6981"></a>            local a, b;
<a name="6982"></a>            
<a name="6983"></a>            /* remove the two most recent items from the vector */
<a name="6984"></a>            a = BagAffinityInfo.removeMostRecent(aff);
<a name="6985"></a>            b = BagAffinityInfo.removeMostRecent(aff);
<a name="6986"></a>
<a name="6987"></a>            /* re-insert them at the end of the vector */
<a name="6988"></a>            aff.append(b);
<a name="6989"></a>            aff.append(a);
<a name="6990"></a>        }
<a name="6991"></a>        
<a name="6992"></a>        /*
<a name="6993"></a>         *   Move each object in the list until we have reduced the bulk
<a name="6994"></a>         *   sufficiently. 
<a name="6995"></a>         */
<a name="6996"></a>        foreach (local cur in aff)
<a name="6997"></a>        {
<a name="6998"></a>            /* 
<a name="6999"></a>             *   Try moving this object to its bag.  If the bag is itself
<a name="7000"></a>             *   inside this object, don't even try, since that would be an
<a name="7001"></a>             *   attempt at circular containment.
<a name="7002"></a>             *   
<a name="7003"></a>             *   If the object we're trying to hold is inside this object,
<a name="7004"></a>             *   don't move the object.  That might put the object we're
<a name="7005"></a>             *   trying to hold out of reach, since moving an object into a
<a name="7006"></a>             *   bag could involve closing the object or making its
<a name="7007"></a>             *   contents not directly accessible.  
<a name="7008"></a>             */
<a name="7009"></a>            if (!cur.bag_.isIn(cur.obj_)
<a name="7010"></a>                &amp;&amp; !obj.isIn(cur.obj_)
<a name="7011"></a>                &amp;&amp; cur.bag_.tryPuttingObjInBag(cur.obj_))
<a name="7012"></a>            {
<a name="7013"></a>                /* 
<a name="7014"></a>                 *   this routine tried tried to move the object into the
<a name="7015"></a>                 *   bag - check our held bulk to see if we're in good
<a name="7016"></a>                 *   enough shape yet
<a name="7017"></a>                 */
<a name="7018"></a>                if (obj.whatIfHeldBy({: getBulkHeld()}, self) &lt;= bulkCapacity)
<a name="7019"></a>                {
<a name="7020"></a>                    /* 
<a name="7021"></a>                     *   We've met our condition - there's no need to look
<a name="7022"></a>                     *   any further.  Return, telling the caller we've
<a name="7023"></a>                     *   performed an implicit command.  
<a name="7024"></a>                     */
<a name="7025"></a>                    return true;
<a name="7026"></a>                }
<a name="7027"></a>            }
<a name="7028"></a>        }
<a name="7029"></a>        
<a name="7030"></a>        /*
<a name="7031"></a>         *   If we get this far, it means that we tried every child object
<a name="7032"></a>         *   but failed to find anything that could help.  Explain the
<a name="7033"></a>         *   problem and abort the command.  
<a name="7034"></a>         */
<a name="7035"></a>        reportFailure(&amp;handsTooFullForMsg, obj);
<a name="7036"></a>        exit;
<a name="7037"></a>    }
<a name="7038"></a>
<a name="7039"></a>    /*
<a name="7040"></a>     *   Check a bulk change of one of my direct contents. 
<a name="7041"></a>     */
<a name="7042"></a>    checkBulkChangeWithin(obj)
<a name="7043"></a>    {
<a name="7044"></a>        local objBulk;
<a name="7045"></a>        
<a name="7046"></a>        /* get the object's new bulk */
<a name="7047"></a>        objBulk = obj.getEncumberingBulk(self);
<a name="7048"></a>        
<a name="7049"></a>        /* 
<a name="7050"></a>         *   if this change would cause the object to exceed our
<a name="7051"></a>         *   single-item bulk limit, don't allow it 
<a name="7052"></a>         */
<a name="7053"></a>        if (objBulk &gt; maxSingleBulk || objBulk &gt; bulkCapacity)
<a name="7054"></a>        {
<a name="7055"></a>            reportFailure(&amp;becomingTooLargeForActorMsg, obj);
<a name="7056"></a>            exit;
<a name="7057"></a>        }
<a name="7058"></a>
<a name="7059"></a>        /* 
<a name="7060"></a>         *   If our total carrying capacity is exceeded with this change,
<a name="7061"></a>         *   don't allow it.  Note that 'obj' is already among our
<a name="7062"></a>         *   contents when this routine is called, so we can simply check
<a name="7063"></a>         *   our current total bulk within.  
<a name="7064"></a>         */
<a name="7065"></a>        if (getBulkHeld() &gt; bulkCapacity)
<a name="7066"></a>        {
<a name="7067"></a>            reportFailure(&amp;handsBecomingTooFullForMsg, obj);
<a name="7068"></a>            exit;
<a name="7069"></a>        }
<a name="7070"></a>    }
<a name="7071"></a>
<a name="7072"></a>    /* 
<a name="7073"></a>     *   Next available "holding index" value.  Each time we pick up an
<a name="7074"></a>     *   item, we'll assign it our current holding index value and then
<a name="7075"></a>     *   increment our value.  This gives us a simple way to keep track of
<a name="7076"></a>     *   the order in which we picked up items we're carrying.
<a name="7077"></a>     *   
<a name="7078"></a>     *   Note that we make the simplifying assumption that an object can
<a name="7079"></a>     *   be held by only one actor at a time (multi-location items are
<a name="7080"></a>     *   generally not portable), which means that we can use a simple
<a name="7081"></a>     *   property in each object being held to store its holding index.  
<a name="7082"></a>     */
<a name="7083"></a>    nextHoldingIndex = 1
<a name="7084"></a>
<a name="7085"></a>    /* add an object to my contents */
<a name="7086"></a>    addToContents(obj)
<a name="7087"></a>    {
<a name="7088"></a>        /* assign the new object our next holding index */
<a name="7089"></a>        obj.holdingIndex = nextHoldingIndex++;
<a name="7090"></a>
<a name="7091"></a>        /* inherit default handling */
<a name="7092"></a>        inherited(obj);
<a name="7093"></a>    }
<a name="7094"></a>
<a name="7095"></a>    /*
<a name="7096"></a>     *   Go to sleep.  This is used by the 'Sleep' action to carry out the
<a name="7097"></a>     *   command.  By default, we simply say that we're not sleepy; actors
<a name="7098"></a>     *   can override this to cause other actions.  
<a name="7099"></a>     */
<a name="7100"></a>    goToSleep()
<a name="7101"></a>    {
<a name="7102"></a>        /* simply report that we can't sleep now */
<a name="7103"></a>        mainReport(&amp;cannotSleepMsg);
<a name="7104"></a>    }
<a name="7105"></a>
<a name="7106"></a>    /*
<a name="7107"></a>     *   My current "posture," which specifies how we're positioned with
<a name="7108"></a>     *   respect to our container; this is one of the standard library
<a name="7109"></a>     *   posture enum values (Standing, etc.) or another posture added by
<a name="7110"></a>     *   the game.  
<a name="7111"></a>     */
<a name="7112"></a>    posture = standing
<a name="7113"></a>
<a name="7114"></a>    /*
<a name="7115"></a>     *   Get a default acknowledgment of a change to our posture.  This
<a name="7116"></a>     *   should acknowledge the posture so that it tells us the current
<a name="7117"></a>     *   posture.  This is used for a command such as "stand up" from a
<a name="7118"></a>     *   chair, so that we can report the appropriate posture status in
<a name="7119"></a>     *   our acknowledgment; we might end up being inside another nested
<a name="7120"></a>     *   container after standing up from the chair, so we might not
<a name="7121"></a>     *   simply be standing when we're done.   
<a name="7122"></a>     */
<a name="7123"></a>    okayPostureChange()
<a name="7124"></a>    {
<a name="7125"></a>        /* get our nominal container for our current posture */
<a name="7126"></a>        local cont = location.getNominalActorContainer(posture);
<a name="7127"></a>
<a name="7128"></a>        /* if the container is visible, let it handle it */
<a name="7129"></a>        if (cont != nil &amp;&amp; gPlayerChar.canSee(cont))
<a name="7130"></a>        {
<a name="7131"></a>            /* describe via the container */
<a name="7132"></a>            cont.roomOkayPostureChange(self);
<a name="7133"></a>        }
<a name="7134"></a>        else
<a name="7135"></a>        {
<a name="7136"></a>            /* use the generic library message */
<a name="7137"></a>            defaultReport(&amp;okayPostureChangeMsg, posture);
<a name="7138"></a>        }
<a name="7139"></a>    }
<a name="7140"></a>
<a name="7141"></a>    /*
<a name="7142"></a>     *   Describe the actor as part of the EXAMINE description of a nested
<a name="7143"></a>     *   room containing the actor.  'povActor' is the actor doing the
<a name="7144"></a>     *   looking.  
<a name="7145"></a>     */
<a name="7146"></a>    listActorPosture(povActor)
<a name="7147"></a>    {
<a name="7148"></a>        /* get our nominal container for our current posture */
<a name="7149"></a>        local cont = location.getNominalActorContainer(posture);
<a name="7150"></a>        
<a name="7151"></a>        /* if the container is visible, let it handle it */
<a name="7152"></a>        if (cont != nil &amp;&amp; povActor.canSee(cont))
<a name="7153"></a>            cont.roomListActorPosture(self);
<a name="7154"></a>    }
<a name="7155"></a>
<a name="7156"></a>    /*
<a name="7157"></a>     *   Stand up.  This is used by the 'Stand' action to carry out the
<a name="7158"></a>     *   command. 
<a name="7159"></a>     */
<a name="7160"></a>    standUp()
<a name="7161"></a>    {
<a name="7162"></a>        /* if we're already standing, say so */
<a name="7163"></a>        if (posture == standing)
<a name="7164"></a>        {
<a name="7165"></a>            reportFailure(&amp;alreadyStandingMsg);
<a name="7166"></a>            return;
<a name="7167"></a>        }
<a name="7168"></a>
<a name="7169"></a>        /* ask the location to make us stand up */
<a name="7170"></a>        location.makeStandingUp();
<a name="7171"></a>    }
<a name="7172"></a>
<a name="7173"></a>    /*
<a name="7174"></a>     *   Disembark.  This is used by the 'Get out' action to carry out the
<a name="7175"></a>     *   command.  By default, we'll let the room handle it.  
<a name="7176"></a>     */
<a name="7177"></a>    disembark()
<a name="7178"></a>    {
<a name="7179"></a>        /* let the room handle it */
<a name="7180"></a>        location.disembarkRoom();
<a name="7181"></a>    }
<a name="7182"></a>
<a name="7183"></a>    /* 
<a name="7184"></a>     *   Set our posture to the given status.  By default, we'll simply
<a name="7185"></a>     *   set our posture property to the new status, but actors can
<a name="7186"></a>     *   override this to handle side effects of the change.
<a name="7187"></a>     */
<a name="7188"></a>    makePosture(newPosture)
<a name="7189"></a>    {
<a name="7190"></a>        /* remember our new posture */
<a name="7191"></a>        posture = newPosture;
<a name="7192"></a>    }
<a name="7193"></a>
<a name="7194"></a>    /* 
<a name="7195"></a>     *   Display a description of the actor's location from the actor's
<a name="7196"></a>     *   point of view.
<a name="7197"></a>     *   
<a name="7198"></a>     *   If 'verbose' is true, then we'll show the full description in all
<a name="7199"></a>     *   cases.  Otherwise, we'll show the full description if the actor
<a name="7200"></a>     *   hasn't seen the location before, or the terse description if the
<a name="7201"></a>     *   actor has previously seen the location.  
<a name="7202"></a>     */
<a name="7203"></a>    lookAround(verbose)
<a name="7204"></a>    {
<a name="7205"></a>        /* turn on the sense cache while we're looking */
<a name="7206"></a>        libGlobal.enableSenseCache();
<a name="7207"></a>        
<a name="7208"></a>        /* show a description of my immediate location, if I have one */
<a name="7209"></a>        if (location != nil)
<a name="7210"></a>            location.lookAroundPov(self, self, verbose);
<a name="7211"></a>
<a name="7212"></a>        /* turn off the sense cache now that we're done */
<a name="7213"></a>        libGlobal.disableSenseCache();
<a name="7214"></a>    }
<a name="7215"></a>
<a name="7216"></a>    /*
<a name="7217"></a>     *   Adjust a table of visible objects for 'look around'.  By default,
<a name="7218"></a>     *   we remove any explicitly excluded objects.  
<a name="7219"></a>     */
<a name="7220"></a>    adjustLookAroundTable(tab, pov, actor)
<a name="7221"></a>    {
<a name="7222"></a>        /* remove any explicitly excluded objects */
<a name="7223"></a>        foreach (local cur in excludeFromLookAroundList)
<a name="7224"></a>            tab.removeElement(cur);
<a name="7225"></a>
<a name="7226"></a>        /* inherit the base handling */
<a name="7227"></a>        inherited(tab, pov, actor);
<a name="7228"></a>    }
<a name="7229"></a>
<a name="7230"></a>    /*
<a name="7231"></a>     *   Add an object to the 'look around' exclusion list.  Returns true
<a name="7232"></a>     *   if the object was already in the list, nil if not.  
<a name="7233"></a>     */
<a name="7234"></a>    excludeFromLookAround(obj)
<a name="7235"></a>    {
<a name="7236"></a>        /* 
<a name="7237"></a>         *   if the object is already in the list, don't add it again -
<a name="7238"></a>         *   just tell the caller it's already there
<a name="7239"></a>         */
<a name="7240"></a>        if (excludeFromLookAroundList.indexOf(obj) != nil)
<a name="7241"></a>            return true;
<a name="7242"></a>
<a name="7243"></a>        /* add it to the list and tell the caller it wasn't already there */
<a name="7244"></a>        excludeFromLookAroundList.append(obj);
<a name="7245"></a>        return nil;
<a name="7246"></a>    }
<a name="7247"></a>
<a name="7248"></a>    /* remove an object from the 'look around' exclusion list */
<a name="7249"></a>    unexcludeFromLookAround(obj)
<a name="7250"></a>    {
<a name="7251"></a>        excludeFromLookAroundList.removeElement(obj);
<a name="7252"></a>    }
<a name="7253"></a>
<a name="7254"></a>    /*
<a name="7255"></a>     *   Our list of objects explicitly excluded from 'look around'.  These
<a name="7256"></a>     *   objects will be suppressed from any sort of listing (including in
<a name="7257"></a>     *   the room's contents list and in special descriptions) in 'look
<a name="7258"></a>     *   around' when this actor is doing the looking. 
<a name="7259"></a>     */
<a name="7260"></a>    excludeFromLookAroundList = perInstance(new Vector(5))
<a name="7261"></a>
<a name="7262"></a>    /*
<a name="7263"></a>     *   Get the location into which objects should be moved when the
<a name="7264"></a>     *   actor drops them with an explicit 'drop' command.  By default, we
<a name="7265"></a>     *   return the drop destination of our current container.  
<a name="7266"></a>     */
<a name="7267"></a>    getDropDestination(objToDrop, path)
<a name="7268"></a>    {
<a name="7269"></a>        return (location != nil
<a name="7270"></a>                ? location.getDropDestination(objToDrop, path)
<a name="7271"></a>                : nil);
<a name="7272"></a>    }
<a name="7273"></a>
<a name="7274"></a>    /*
<a name="7275"></a>     *   The senses that determine scope for this actor.  An actor might
<a name="7276"></a>     *   possess only a subset of the defined sense.
<a name="7277"></a>     *   
<a name="7278"></a>     *   By default, we give each actor all of the human senses that we
<a name="7279"></a>     *   define, except touch.  In general, merely being able to touch an
<a name="7280"></a>     *   object doesn't put the object in scope, because if an object
<a name="7281"></a>     *   isn't noticed through some other sense, touch would only make an
<a name="7282"></a>     *   object accessible if it's within arm's reach, which for our
<a name="7283"></a>     *   purposes means that the object is being held directly by the
<a name="7284"></a>     *   actor.  Imagine an actor in a dark room: lots of things might be
<a name="7285"></a>     *   touchable in the sense that there's no physical barrier to
<a name="7286"></a>     *   touching them, but without some other sense to locate the
<a name="7287"></a>     *   objects, the actor wouldn't have any way of knowing where to
<a name="7288"></a>     *   reach to touch things, so they're not in scope.  So, touch isn't
<a name="7289"></a>     *   a scope sense.  
<a name="7290"></a>     */
<a name="7291"></a>    scopeSenses = [sight, sound, smell]
<a name="7292"></a>
<a name="7293"></a>    /*
<a name="7294"></a>     *   "Sight-like" senses: these are the senses that operate like sight
<a name="7295"></a>     *   for the actor, and which the actor can use to determine the names
<a name="7296"></a>     *   of objects and the spatial relationships between objects.  These
<a name="7297"></a>     *   senses should operate passively, in the sense that they should
<a name="7298"></a>     *   tend to collect sensory input continuously and without explicit
<a name="7299"></a>     *   action by the actor, the way sight does and the way touch, for
<a name="7300"></a>     *   example, does not.  These senses should also operate instantly,
<a name="7301"></a>     *   in the sense that the sense can reasonably take in most or all of
<a name="7302"></a>     *   a location at one time.
<a name="7303"></a>     *   
<a name="7304"></a>     *   These senses are used to determine what objects should be listed
<a name="7305"></a>     *   in room descriptions, for example.
<a name="7306"></a>     *   
<a name="7307"></a>     *   By default, the only sight-like sense is sight, since other human
<a name="7308"></a>     *   senses don't normally provide a clear picture of the spatial
<a name="7309"></a>     *   relationships among objects.  (Touch could with some degree of
<a name="7310"></a>     *   effort, but it can't operate passively or instantly, since
<a name="7311"></a>     *   deliberate and time-consuming action would be necessary.)
<a name="7312"></a>     *   
<a name="7313"></a>     *   An actor can have more than one sight-like sense, in which case
<a name="7314"></a>     *   the senses will act effectively as one sense that can reach the
<a name="7315"></a>     *   union of objects reachable through the individual senses.  
<a name="7316"></a>     */
<a name="7317"></a>    sightlikeSenses = [sight]
<a name="7318"></a>
<a name="7319"></a>    /* 
<a name="7320"></a>     *   Hearing-like senses.  These are senses that the actor can use to
<a name="7321"></a>     *   hear objects. 
<a name="7322"></a>     */
<a name="7323"></a>    hearinglikeSenses = [sound]
<a name="7324"></a>
<a name="7325"></a>    /*
<a name="7326"></a>     *   Smell-like senses.  These are senses that the actor can use to
<a name="7327"></a>     *   smell objects. 
<a name="7328"></a>     */
<a name="7329"></a>    smelllikeSenses = [smell]
<a name="7330"></a>
<a name="7331"></a>    /*
<a name="7332"></a>     *   Communication senses: these are the senses through which the
<a name="7333"></a>     *   actor can communicate directly with other actors through commands
<a name="7334"></a>     *   and messages.
<a name="7335"></a>     *   
<a name="7336"></a>     *   Conceptually, these senses are intended to be only those senses
<a name="7337"></a>     *   that the actors would *naturally* use to communicate, because
<a name="7338"></a>     *   senses in this list allow direct communications via the most
<a name="7339"></a>     *   ordinary game commands, such as "bob, go east".
<a name="7340"></a>     *   
<a name="7341"></a>     *   If some form of indirect communication is possible via a sense,
<a name="7342"></a>     *   but that form is not something the actor would think of as the
<a name="7343"></a>     *   most natural, default form of communication, it should *not* be
<a name="7344"></a>     *   in this list.  For example, two sighted persons who can see one
<a name="7345"></a>     *   another but cannot hear one another could still communicate by
<a name="7346"></a>     *   writing messages on pieces of paper, but they would ordinarily
<a name="7347"></a>     *   communicate by talking.  In such a case, sound should be in the
<a name="7348"></a>     *   list but sight should not be, because sight is not a natural,
<a name="7349"></a>     *   default form of communications for the actors.  
<a name="7350"></a>     */
<a name="7351"></a>    communicationSenses = [sound]
<a name="7352"></a>    
<a name="7353"></a>    /*
<a name="7354"></a>     *   Determine if I can communicate with the given character via a
<a name="7355"></a>     *   natural, default form of communication that we share with the
<a name="7356"></a>     *   other character.  This determines if I can talk to the other
<a name="7357"></a>     *   character.  We'll return true if I can talk to the other actor,
<a name="7358"></a>     *   nil if not.
<a name="7359"></a>     *   
<a name="7360"></a>     *   In order for the player character to issue a command to a
<a name="7361"></a>     *   non-player character (as in "bob, go east"), the NPC must be able
<a name="7362"></a>     *   to sense the PC via at least one communication sense that the two
<a name="7363"></a>     *   actors have in common.
<a name="7364"></a>     *   
<a name="7365"></a>     *   Likewise, in order for a non-player character to say something to
<a name="7366"></a>     *   the player, the player must be able to sense the NPC via at least
<a name="7367"></a>     *   one communication sense that the two actors have in common.  
<a name="7368"></a>     */
<a name="7369"></a>    canTalkTo(actor)
<a name="7370"></a>    {
<a name="7371"></a>        local common;
<a name="7372"></a>        
<a name="7373"></a>        /* 
<a name="7374"></a>         *   first, get a list of the communications senses that we have
<a name="7375"></a>         *   in common with the other actor - we must have a sense channel
<a name="7376"></a>         *   via this sense 
<a name="7377"></a>         */
<a name="7378"></a>        common = communicationSenses.intersect(actor.communicationSenses);
<a name="7379"></a>
<a name="7380"></a>        /* 
<a name="7381"></a>         *   if there are no common senses, we can't communicate,
<a name="7382"></a>         *   regardless of our physical proximity 
<a name="7383"></a>         */
<a name="7384"></a>        if (common == [])
<a name="7385"></a>            return nil;
<a name="7386"></a>
<a name="7387"></a>        /* 
<a name="7388"></a>         *   Determine how well the other actor can sense me in these
<a name="7389"></a>         *   senses.  Note that all that matters it that the actor can
<a name="7390"></a>         *   hear me, because we're determine if I can talk to the other
<a name="7391"></a>         *   actor - it doesn't matter if I can hear the other actor.  
<a name="7392"></a>         */
<a name="7393"></a>        foreach (local curSense in common)
<a name="7394"></a>        {
<a name="7395"></a>            local result;
<a name="7396"></a>
<a name="7397"></a>            /* 
<a name="7398"></a>             *   determine how well the other actor can sense me in this
<a name="7399"></a>             *   sense 
<a name="7400"></a>             */
<a name="7401"></a>            result = actor.senseObj(curSense, self);
<a name="7402"></a>
<a name="7403"></a>            /* check whether or not this is good enough */
<a name="7404"></a>            if (actor.canBeTalkedTo(self, curSense, result))
<a name="7405"></a>                return true;
<a name="7406"></a>        }
<a name="7407"></a>
<a name="7408"></a>        /* 
<a name="7409"></a>         *   if we get this far, we didn't find any senses with a clear
<a name="7410"></a>         *   enough communications channel - we can't talk to the other
<a name="7411"></a>         *   actor 
<a name="7412"></a>         */
<a name="7413"></a>        return nil;
<a name="7414"></a>    }
<a name="7415"></a>
<a name="7416"></a>    /*
<a name="7417"></a>     *   Determine whether or not I can understand an attempt by another
<a name="7418"></a>     *   actor to talk to me.  'talker' is the actor doing the talking.
<a name="7419"></a>     *   'sense' is the sense we're testing; this will always be a sense
<a name="7420"></a>     *   in our communicationSenses list, and will always be a
<a name="7421"></a>     *   communications sense we have in common with the other actor.
<a name="7422"></a>     *   'info' is a SenseInfo object giving information on the clarity of
<a name="7423"></a>     *   the sense path to the other actor.
<a name="7424"></a>     *   
<a name="7425"></a>     *   We return true if we can understand the communication, nil if
<a name="7426"></a>     *   not.  There is no middle ground where we can partially
<a name="7427"></a>     *   understand; we can either understand or not.
<a name="7428"></a>     *   
<a name="7429"></a>     *   Note that this routine is concerned only with our ability to
<a name="7430"></a>     *   sense the communication.  The result here should NOT pay any
<a name="7431"></a>     *   attention to whether or not we can actually communicate given a
<a name="7432"></a>     *   clear sense path - for example, this routine should not reflect
<a name="7433"></a>     *   whether or not we have a spoken language in common with the other
<a name="7434"></a>     *   actor.
<a name="7435"></a>     *   
<a name="7436"></a>     *   This is a service method for canTalkTo.  This is broken out as a
<a name="7437"></a>     *   separate method so that individual actors can override the
<a name="7438"></a>     *   necessary conditions for communications in particular senses.  
<a name="7439"></a>     */
<a name="7440"></a>    canBeTalkedTo(talker, sense, info)
<a name="7441"></a>    {
<a name="7442"></a>        /*   
<a name="7443"></a>         *   By default, we allow communication if the sense path is
<a name="7444"></a>         *   transparent or distant.  We don't care what the sense is,
<a name="7445"></a>         *   since we know we'll never be asked about a sense that's not
<a name="7446"></a>         *   in our communicationSenses list.  
<a name="7447"></a>         */
<a name="7448"></a>        return info.trans is in (transparent, distant);
<a name="7449"></a>    }
<a name="7450"></a>
<a name="7451"></a>    /*
<a name="7452"></a>     *   Flag: we wait for commands issued to other actors to complete
<a name="7453"></a>     *   before we get another turn.  If this is true, then whenever we
<a name="7454"></a>     *   issue a command to another actor ("bob, go north"), we will not
<a name="7455"></a>     *   get another turn until the other actor has finished executing the
<a name="7456"></a>     *   full set of commands we issued.
<a name="7457"></a>     *   
<a name="7458"></a>     *   By default, this is true, which means that we wait for other
<a name="7459"></a>     *   actors to finish all of the commands we issue before we take
<a name="7460"></a>     *   another turn.  
<a name="7461"></a>     *   
<a name="7462"></a>     *   If this is set to nil, we'll continue to take turns while the
<a name="7463"></a>     *   other actor carries out our commands.  In this case, the only
<a name="7464"></a>     *   time cost to us of issuing a command is given by orderingTime(),
<a name="7465"></a>     *   which normally takes one turn for issuing a command, regardless
<a name="7466"></a>     *   of the command's complexity.  Some games might wish to use this
<a name="7467"></a>     *   mode for interesting effects with NPC's carrying out commands in
<a name="7468"></a>     *   parallel with the player, but it's an unconventional style that
<a name="7469"></a>     *   some players might find confusing, so we don't use this mode by
<a name="7470"></a>     *   default.  
<a name="7471"></a>     */
<a name="7472"></a>    issueCommandsSynchronously = true
<a name="7473"></a>
<a name="7474"></a>    /*
<a name="7475"></a>     *   Flag: the "target actor" of the command line automatically reverts
<a name="7476"></a>     *   to this actor at the end of a sentence, when this actor is the
<a name="7477"></a>     *   issuer of a command.  If this flag is nil, an explicit target
<a name="7478"></a>     *   actor stays in effect until the next explicit target actor (or the
<a name="7479"></a>     *   end of the entire command line, if no other explicit target actors
<a name="7480"></a>     *   are named); if this flag is true, a target actor is in effect only
<a name="7481"></a>     *   until the end of a sentence.
<a name="7482"></a>     *   
<a name="7483"></a>     *   Consider this command line:
<a name="7484"></a>     *   
<a name="7485"></a>     *   &gt;Bob, go north and get fuel cell. Get log tape.
<a name="7486"></a>     *   
<a name="7487"></a>     *   If this flag is nil, then the second sentence ("get log tape") is
<a name="7488"></a>     *   interpreted as a command to Bob, because Bob is explicitly
<a name="7489"></a>     *   designated as the target of the command, and this remains in
<a name="7490"></a>     *   effect until the end of the entire command line.
<a name="7491"></a>     *   
<a name="7492"></a>     *   If this flag is true, on the other hand, then the second sentence
<a name="7493"></a>     *   is interpreted as a command to the player character, because the
<a name="7494"></a>     *   target actor designation ("Bob,") lasts only until the end of the
<a name="7495"></a>     *   sentence.  Once a new sentence begins, we revert to the issuing
<a name="7496"></a>     *   actor (the player character, since the command came from the
<a name="7497"></a>     *   player via the keyboard).
<a name="7498"></a>     */
<a name="7499"></a>    revertTargetActorAtEndOfSentence = nil
<a name="7500"></a>
<a name="7501"></a>    /*
<a name="7502"></a>     *   The amount of time, in game clock units, it takes me to issue an
<a name="7503"></a>     *   order to another actor.  By default, it takes one unit (which is
<a name="7504"></a>     *   usually equal to one turn) to issue a command to another actor.
<a name="7505"></a>     *   However, if we are configured to wait for our issued commands to
<a name="7506"></a>     *   complete in full, the ordering time is zero; we don't need any
<a name="7507"></a>     *   extra wait time in this case because we'll wait the full length
<a name="7508"></a>     *   of the issued command to begin with.  
<a name="7509"></a>     */
<a name="7510"></a>    orderingTime(targetActor)
<a name="7511"></a>    {
<a name="7512"></a>        return issueCommandsSynchronously ? 0 : 1;
<a name="7513"></a>    }
<a name="7514"></a>
<a name="7515"></a>    /*
<a name="7516"></a>     *   Wait for completion of a command that we issued to another actor.
<a name="7517"></a>     *   The parser calls this routine after each time we issue a command
<a name="7518"></a>     *   to another actor.
<a name="7519"></a>     *   
<a name="7520"></a>     *   If we're configured to wait for completion of orders given to
<a name="7521"></a>     *   other actors before we get another turn, we'll set ourselves up
<a name="7522"></a>     *   in waiting mode.  Otherwise, we'll do nothing.  
<a name="7523"></a>     */
<a name="7524"></a>    waitForIssuedCommand(targetActor)
<a name="7525"></a>    {
<a name="7526"></a>        /* if we can issue commands asynchronously, there's nothing to do */
<a name="7527"></a>        if (!issueCommandsSynchronously)
<a name="7528"></a>            return;
<a name="7529"></a>
<a name="7530"></a>        /* 
<a name="7531"></a>         *   Add an empty pending command at the end of the target actor's
<a name="7532"></a>         *   queue.  This command won't do anything when executed; its
<a name="7533"></a>         *   purpose is to let us track whether or not the target is still
<a name="7534"></a>         *   working on commands we have issued up to this point, which we
<a name="7535"></a>         *   can tell by looking to see whether our empty command is still
<a name="7536"></a>         *   in the actor's queue.
<a name="7537"></a>         *   
<a name="7538"></a>         *   Note that we can't simply wait until the actor's queue is
<a name="7539"></a>         *   empty, because the actor could acquire new commands while
<a name="7540"></a>         *   it's working on our pending commands, and we wouldn't want to
<a name="7541"></a>         *   wait for those to finish.  Adding a dummy pending command is
<a name="7542"></a>         *   a reliable way of tracking the actor's queue, because any
<a name="7543"></a>         *   changes to the target actor's command queue will leave our
<a name="7544"></a>         *   dummy command in its proper place until the target actor gets
<a name="7545"></a>         *   around to executing it, at which point it will be removed.
<a name="7546"></a>         *   
<a name="7547"></a>         *   Remember the dummy pending command in a property of self, so
<a name="7548"></a>         *   that we can check later to determine when the command has
<a name="7549"></a>         *   finished.  
<a name="7550"></a>         */
<a name="7551"></a>        waitingForActor = targetActor;
<a name="7552"></a>        waitingForInfo = new PendingCommandMarker(self);
<a name="7553"></a>        targetActor.pendingCommand.append(waitingForInfo);
<a name="7554"></a>    }
<a name="7555"></a>
<a name="7556"></a>    /* 
<a name="7557"></a>     *   Synchronous command processing: the target actor and dummy
<a name="7558"></a>     *   pending command we're waiting for.  When these are non-nil, we
<a name="7559"></a>     *   won't take another turn until the given PendingCommandInfo has
<a name="7560"></a>     *   been removed from the given target actor's command queue. 
<a name="7561"></a>     */
<a name="7562"></a>    waitingForActor = nil
<a name="7563"></a>    waitingForInfo = nil
<a name="7564"></a>
<a name="7565"></a>    /*
<a name="7566"></a>     *   Add the given actor to the list of actors accompanying my travel
<a name="7567"></a>     *   on the current turn.  This does NOT set an actor in "follow mode"
<a name="7568"></a>     *   or "accompany mode" or anything like that - don't use this to make
<a name="7569"></a>     *   an actor follow me around.  Instead, this makes the given actor go
<a name="7570"></a>     *   with us for the CURRENT travel only - the travel we're already in
<a name="7571"></a>     *   the process of performing to process the current TravelVia action.
<a name="7572"></a>     */
<a name="7573"></a>    addAccompanyingActor(actor)
<a name="7574"></a>    {
<a name="7575"></a>        /* if we don't have the accompanying actor vector yet, create it */
<a name="7576"></a>        if (accompanyingActors == nil)
<a name="7577"></a>            accompanyingActors = new Vector(8);
<a name="7578"></a>
<a name="7579"></a>        /* add the actor to my list */
<a name="7580"></a>        accompanyingActors.append(actor);
<a name="7581"></a>    }
<a name="7582"></a>
<a name="7583"></a>    /* 
<a name="7584"></a>     *   My vector of actors who are accompanying me. 
<a name="7585"></a>     *   
<a name="7586"></a>     *   This is for internal bookkeeping only, and it applies to the
<a name="7587"></a>     *   current travel only.  This is NOT a general "follow mode" setting,
<a name="7588"></a>     *   and it shouldn't be used to get me to follow another actor or
<a name="7589"></a>     *   another actor to follow me.  To make me accompany another actor,
<a name="7590"></a>     *   simply override accompanyTravel() so that it returns a suitable
<a name="7591"></a>     *   ActorState object.  
<a name="7592"></a>     */
<a name="7593"></a>    accompanyingActors = nil
<a name="7594"></a>
<a name="7595"></a>    /*
<a name="7596"></a>     *   Get the list of objects I can follow.  This is a list of all of
<a name="7597"></a>     *   the objects which I have seen departing a location - these are
<a name="7598"></a>     *   all in scope for 'follow' commands.  
<a name="7599"></a>     */
<a name="7600"></a>    getFollowables()
<a name="7601"></a>    {
<a name="7602"></a>        /* return the list of the objects we know about */
<a name="7603"></a>        return followables_.mapAll({x: x.obj});
<a name="7604"></a>    }
<a name="7605"></a>
<a name="7606"></a>    /* 
<a name="7607"></a>     *   Do I track departing objects for following the given object?
<a name="7608"></a>     *   
<a name="7609"></a>     *   By default, the player character tracks everyone, and NPC's track
<a name="7610"></a>     *   only the actor they're presently tasked to follow.  Most NPC's
<a name="7611"></a>     *   will never accept 'follow' commands, so there's no need to track
<a name="7612"></a>     *   everyone all the time; for efficiency, we take advantage of this
<a name="7613"></a>     *   assumption so that we can avoid storing a bunch of tracking
<a name="7614"></a>     *   information that will never be used.
<a name="7615"></a>     */
<a name="7616"></a>    wantsFollowInfo(obj)
<a name="7617"></a>    {
<a name="7618"></a>        /* 
<a name="7619"></a>         *   by default, the player character tracks everyone, and NPC's
<a name="7620"></a>         *   track only the object (if any) they're currently tasked to
<a name="7621"></a>         *   follow 
<a name="7622"></a>         */
<a name="7623"></a>        return isPlayerChar() || followingActor == obj;
<a name="7624"></a>    }
<a name="7625"></a>
<a name="7626"></a>    /*
<a name="7627"></a>     *   Receive notification that an object is leaving its current
<a name="7628"></a>     *   location as a result of the action we're currently processing.
<a name="7629"></a>     *   Actors (and possibly other objects) will broadcast this
<a name="7630"></a>     *   notification to all Actor objects connected in any way by
<a name="7631"></a>     *   containment when they move under their own power (such as with
<a name="7632"></a>     *   Actor.travelTo) to a new location.  We'll keep tracking
<a name="7633"></a>     *   information if we are configured to keep tracking information for
<a name="7634"></a>     *   the given object and we can see the given object.  Note that this
<a name="7635"></a>     *   is called when the object is still at the source end of the travel
<a name="7636"></a>     *   - the important thing is that we see the object departing.
<a name="7637"></a>     *   
<a name="7638"></a>     *   'obj' is the object that is seen to be leaving, and 'conn' is the
<a name="7639"></a>     *   TravelConnector it is taking.
<a name="7640"></a>     *   
<a name="7641"></a>     *   'conn' is the connector being traversed.  If we're simply being
<a name="7642"></a>     *   observed in this location (as in a call to setHasSeen), rather
<a name="7643"></a>     *   than being observed to leave the location, the connector will be
<a name="7644"></a>     *   nil.
<a name="7645"></a>     *   
<a name="7646"></a>     *   'from' is the effective starting location of the travel.  This
<a name="7647"></a>     *   isn't necessarily the departing object's location, since the
<a name="7648"></a>     *   departing object could be inside a vehicle or some other kind of
<a name="7649"></a>     *   traveler object.
<a name="7650"></a>     *   
<a name="7651"></a>     *   Note that this notification is sent only to actors with some sort
<a name="7652"></a>     *   of containment connection to the object that's moving, because a
<a name="7653"></a>     *   containment connection is necessary for there to be a sense
<a name="7654"></a>     *   connection.  
<a name="7655"></a>     */
<a name="7656"></a>    trackFollowInfo(obj, conn, from)
<a name="7657"></a>    {
<a name="7658"></a>        local info;
<a name="7659"></a>        
<a name="7660"></a>        /* 
<a name="7661"></a>         *   If we're not tracking the given object, or we can't see the
<a name="7662"></a>         *   given object, ignore the notification.  In addition, we
<a name="7663"></a>         *   obviously have no need to track ourselves.x  
<a name="7664"></a>         */
<a name="7665"></a>        if (obj == self || !wantsFollowInfo(obj) || !canSee(obj))
<a name="7666"></a>            return;
<a name="7667"></a>
<a name="7668"></a>        /* 
<a name="7669"></a>         *   If we already have a FollowInfo for the given object, re-use
<a name="7670"></a>         *   the existing one; otherwise, create a new one and add it to
<a name="7671"></a>         *   our tracking list. 
<a name="7672"></a>         */
<a name="7673"></a>        info = followables_.valWhich({x: x.obj == obj});
<a name="7674"></a>        if (info == nil)
<a name="7675"></a>        {
<a name="7676"></a>            /* we don't have an existing one - create a new one */
<a name="7677"></a>            info = new FollowInfo();
<a name="7678"></a>            info.obj = obj;
<a name="7679"></a>
<a name="7680"></a>            /* add it to our list */
<a name="7681"></a>            followables_ += info;
<a name="7682"></a>        }
<a name="7683"></a>
<a name="7684"></a>        /* remember information about the travel */
<a name="7685"></a>        info.connector = conn;
<a name="7686"></a>        info.sourceLocation = from;
<a name="7687"></a>    }
<a name="7688"></a>
<a name="7689"></a>    /*
<a name="7690"></a>     *   Get information on what to do to make this actor follow the given
<a name="7691"></a>     *   object.  This returns a FollowInfo object that reports our last
<a name="7692"></a>     *   knowledge of the given object's location and departure, or nil if
<a name="7693"></a>     *   we don't know anything about how to follow the actor.  
<a name="7694"></a>     */
<a name="7695"></a>    getFollowInfo(obj)
<a name="7696"></a>    {
<a name="7697"></a>        return followables_.valWhich({x: x.obj == obj});
<a name="7698"></a>    }
<a name="7699"></a>
<a name="7700"></a>    /*
<a name="7701"></a>     *   By default, all actors are followable.
<a name="7702"></a>     */
<a name="7703"></a>    verifyFollowable()
<a name="7704"></a>    {
<a name="7705"></a>        return true;
<a name="7706"></a>    }
<a name="7707"></a>
<a name="7708"></a>    /*
<a name="7709"></a>     *   Verify a "follow" command being performed by this actor.  
<a name="7710"></a>     */
<a name="7711"></a>    actorVerifyFollow(obj)
<a name="7712"></a>    {
<a name="7713"></a>        /* 
<a name="7714"></a>         *   check to see if we're in the same effective follow location
<a name="7715"></a>         *   as the target; if we are, it makes no sense to follow the
<a name="7716"></a>         *   target, since we're already effectively at the same place 
<a name="7717"></a>         */
<a name="7718"></a>        if (obj.location != nil
<a name="7719"></a>            &amp;&amp; (location.effectiveFollowLocation
<a name="7720"></a>                == obj.location.effectiveFollowLocation))
<a name="7721"></a>        {
<a name="7722"></a>            /*
<a name="7723"></a>             *   We're in the same location as the target.  If we're the
<a name="7724"></a>             *   player character, this makes no sense, because the player
<a name="7725"></a>             *   character can't go into follow mode (as that would take
<a name="7726"></a>             *   away the player's ability to control the player
<a name="7727"></a>             *   character).  If we're an NPC, though, this simply tells
<a name="7728"></a>             *   us to go into follow mode for the target, so there's
<a name="7729"></a>             *   nothing wrong with it.  
<a name="7730"></a>             */
<a name="7731"></a>            if (isPlayerChar)
<a name="7732"></a>            {
<a name="7733"></a>                /* 
<a name="7734"></a>                 *   The target is right here, but we're the player
<a name="7735"></a>                 *   character, so it makes no sense for us to go into
<a name="7736"></a>                 *   follow mode.  If we can see the target, complain that
<a name="7737"></a>                 *   it's already here; if not, we can only assume it's
<a name="7738"></a>                 *   here, but we can't know for sure.  
<a name="7739"></a>                 */
<a name="7740"></a>                if (canSee(obj))
<a name="7741"></a>                    illogicalNow(&amp;followAlreadyHereMsg);
<a name="7742"></a>                else
<a name="7743"></a>                    illogicalNow(&amp;followAlreadyHereInDarkMsg);
<a name="7744"></a>            }
<a name="7745"></a>        }
<a name="7746"></a>        else if (!canSee(obj))
<a name="7747"></a>        {
<a name="7748"></a>            /* 
<a name="7749"></a>             *   The target isn't here, and we can't see it from here, so
<a name="7750"></a>             *   we must want to follow it to its current location.  Get
<a name="7751"></a>             *   information on how we will follow the target.  If there's
<a name="7752"></a>             *   no such information, we obviously can't do any following
<a name="7753"></a>             *   because we never saw the target go anywhere in the first
<a name="7754"></a>             *   place.  
<a name="7755"></a>             */
<a name="7756"></a>            if (getFollowInfo(obj) == nil)
<a name="7757"></a>            {
<a name="7758"></a>                /* we've never heard of the target */
<a name="7759"></a>                illogicalNow(&amp;followUnknownMsg);
<a name="7760"></a>            }
<a name="7761"></a>        }
<a name="7762"></a>    }
<a name="7763"></a>
<a name="7764"></a>    /*
<a name="7765"></a>     *   Carry out a "follow" command being performed by this actor.  
<a name="7766"></a>     */
<a name="7767"></a>    actorActionFollow(obj)
<a name="7768"></a>    {
<a name="7769"></a>        local canSeeObj;
<a name="7770"></a>
<a name="7771"></a>        /* note whether or not we can see the target */
<a name="7772"></a>        canSeeObj = canSee(obj);
<a name="7773"></a>        
<a name="7774"></a>        /* 
<a name="7775"></a>         *   If we're not the PC, check to see if this is a follow-mode
<a name="7776"></a>         *   request; otherwise, try to go to the location of the target.
<a name="7777"></a>         */
<a name="7778"></a>        if (!isPlayerChar &amp;&amp; canSeeObj)
<a name="7779"></a>        {
<a name="7780"></a>            /*
<a name="7781"></a>             *   If we're not already following this actor, acknowledge the
<a name="7782"></a>             *   request and go into 'follow' mode.  If we're already
<a name="7783"></a>             *   following this actor, and we didn't issue the command to
<a name="7784"></a>             *   ourself, let them know we're already in the requested
<a name="7785"></a>             *   mode.  Otherwise, ignore it silently - if we issued the
<a name="7786"></a>             *   command to ourself, it's because we're just executing our
<a name="7787"></a>             *   own 'follow' mode imperative. 
<a name="7788"></a>             */
<a name="7789"></a>            if (followingActor != obj)
<a name="7790"></a>            {
<a name="7791"></a>                /* let them know we're going to follow the actor now */
<a name="7792"></a>                reportAfter(&amp;okayFollowModeMsg);
<a name="7793"></a>
<a name="7794"></a>                /* go into follow mode */
<a name="7795"></a>                followingActor = obj;
<a name="7796"></a>            }
<a name="7797"></a>            else if (gIssuingActor != self)
<a name="7798"></a>            {
<a name="7799"></a>                /* let them know we're already in follow mode */
<a name="7800"></a>                reportAfter(&amp;alreadyFollowModeMsg);
<a name="7801"></a>            }
<a name="7802"></a>
<a name="7803"></a>            /* 
<a name="7804"></a>             *   if we're already in the target's effective follow
<a name="7805"></a>             *   location, that's all we need to do 
<a name="7806"></a>             */
<a name="7807"></a>            if (location.effectiveFollowLocation
<a name="7808"></a>                == obj.location.effectiveFollowLocation)
<a name="7809"></a>                return;
<a name="7810"></a>        }
<a name="7811"></a>
<a name="7812"></a>        /* 
<a name="7813"></a>         *   If we can see the target, AND we're in the same top-level
<a name="7814"></a>         *   location as the target, then simply use a "local travel"
<a name="7815"></a>         *   operation to move into the same location.  This only works
<a name="7816"></a>         *   with targets that are within the same top-level location,
<a name="7817"></a>         *   since that's the whole point of the local-travel routines.
<a name="7818"></a>         *   For non-local travel, we need to perform a full-fledged travel
<a name="7819"></a>         *   command instead.  
<a name="7820"></a>         */
<a name="7821"></a>        if (canSeeObj &amp;&amp; isIn(obj.getOutermostRoom()))
<a name="7822"></a>        {
<a name="7823"></a>            /* 
<a name="7824"></a>             *   We have no information, so we will only have made it past
<a name="7825"></a>             *   verification if we can see the other actor from our
<a name="7826"></a>             *   current location.  Try moving to the other actor's
<a name="7827"></a>             *   effective follow location.  
<a name="7828"></a>             */
<a name="7829"></a>            obj.location.effectiveFollowLocation.checkMovingActorInto(true);
<a name="7830"></a>
<a name="7831"></a>            /*
<a name="7832"></a>             *   Since checkMovingActorInto will do its work through
<a name="7833"></a>             *   implicit actions, if we're the player character, then the
<a name="7834"></a>             *   entire action will have been performed implicitly, so we
<a name="7835"></a>             *   won't have a real report for the series of generated
<a name="7836"></a>             *   actions, just implied action announcements.  If we're an
<a name="7837"></a>             *   NPC, on the other hand, we'll generate the full reports,
<a name="7838"></a>             *   since NPC implied actions simply show what the actor is
<a name="7839"></a>             *   doing.  So, if we're the PC, generate an additional
<a name="7840"></a>             *   default acknowledgment of the 'follow' action. 
<a name="7841"></a>             */
<a name="7842"></a>            if (isPlayerChar)
<a name="7843"></a>                defaultReport(&amp;okayFollowInSightMsg,
<a name="7844"></a>                              location.effectiveFollowLocation);
<a name="7845"></a>        }
<a name="7846"></a>        else
<a name="7847"></a>        {
<a name="7848"></a>            local info;
<a name="7849"></a>            local srcLoc;
<a name="7850"></a>            
<a name="7851"></a>            /* get the information on how to follow the target */
<a name="7852"></a>            info = getFollowInfo(obj);
<a name="7853"></a>
<a name="7854"></a>            /* get the effective follow location we have to be in */
<a name="7855"></a>            srcLoc = info.sourceLocation.effectiveFollowLocation;
<a name="7856"></a>
<a name="7857"></a>            /* if there's no connector, we can't go anywhere */
<a name="7858"></a>            if (info.connector == nil)
<a name="7859"></a>            {
<a name="7860"></a>                /* 
<a name="7861"></a>                 *   We have no departure information, so we can't follow
<a name="7862"></a>                 *   the actor.  If we're currently within sight of the
<a name="7863"></a>                 *   location where we last saw the actor, it means that we
<a name="7864"></a>                 *   saw the actor here, then went somewhere else, then
<a name="7865"></a>                 *   came back, and in our absence the actor itself
<a name="7866"></a>                 *   departed.  In this case, report that we don't know
<a name="7867"></a>                 *   where the actor went.
<a name="7868"></a>                 *   
<a name="7869"></a>                 *   If we're not in sight of the location where we last
<a name="7870"></a>                 *   saw the actor, then instead remind the player of where
<a name="7871"></a>                 *   that was.  
<a name="7872"></a>                 */
<a name="7873"></a>                if (canSee(srcLoc))
<a name="7874"></a>                {
<a name="7875"></a>                    /* 
<a name="7876"></a>                     *   we're where we last saw the actor, but the actor
<a name="7877"></a>                     *   must have departed while we were away - so we
<a name="7878"></a>                     *   simply don't know where the actor went 
<a name="7879"></a>                     */
<a name="7880"></a>                    reportFailure(&amp;followUnknownMsg);
<a name="7881"></a>                }
<a name="7882"></a>                else
<a name="7883"></a>                {
<a name="7884"></a>                    /* 
<a name="7885"></a>                     *   we've gone somewhere else since we last saw the
<a name="7886"></a>                     *   actor, so remind the player of where it was that
<a name="7887"></a>                     *   we saw the actor 
<a name="7888"></a>                     */
<a name="7889"></a>                    reportFailure(&amp;cannotFollowFromHereMsg, srcLoc);
<a name="7890"></a>                }
<a name="7891"></a>
<a name="7892"></a>                /* in any case, that's all we can do now */
<a name="7893"></a>                return;
<a name="7894"></a>            }
<a name="7895"></a>
<a name="7896"></a>            /*
<a name="7897"></a>             *   Before we can follow the target, we must be in the same
<a name="7898"></a>             *   effective location that the target was in when we
<a name="7899"></a>             *   observed the target leaving.
<a name="7900"></a>             */
<a name="7901"></a>            if (location.effectiveFollowLocation != srcLoc)
<a name="7902"></a>            {
<a name="7903"></a>                /* 
<a name="7904"></a>                 *   If we can't even see the effective follow location, we
<a name="7905"></a>                 *   must have last observed the other actor traveling from
<a name="7906"></a>                 *   an unrelated location.  In this case, simply say that
<a name="7907"></a>                 *   we don't know where the followee went. 
<a name="7908"></a>                 */
<a name="7909"></a>                if (!canSee(srcLoc))
<a name="7910"></a>                {
<a name="7911"></a>                    reportFailure(&amp;cannotFollowFromHereMsg, srcLoc);
<a name="7912"></a>                    return;
<a name="7913"></a>                }
<a name="7914"></a>
<a name="7915"></a>                /* 
<a name="7916"></a>                 *   Try moving into the same location, by invoking the
<a name="7917"></a>                 *   pre-condition handler for moving me into the
<a name="7918"></a>                 *   effective follow location from our memory of the
<a name="7919"></a>                 *   actor's travel.  We *could* run this as an actual
<a name="7920"></a>                 *   precondition, but it's easier to run it here now that
<a name="7921"></a>                 *   we've sorted out exactly what we want to do.  
<a name="7922"></a>                 */
<a name="7923"></a>                srcLoc.checkMovingActorInto(true);
<a name="7924"></a>            }
<a name="7925"></a>        
<a name="7926"></a>            /* perform a TravelVia action on the connector */
<a name="7927"></a>            nestedAction(TravelVia, info.connector);
<a name="7928"></a>        }
<a name="7929"></a>    }
<a name="7930"></a>
<a name="7931"></a>    /*
<a name="7932"></a>     *   Our list of followable information.  Each entry in this list is a
<a name="7933"></a>     *   FollowInfo object that tracks a particular followable.  
<a name="7934"></a>     */
<a name="7935"></a>    followables_ = []
<a name="7936"></a>
<a name="7937"></a>    /* determine if I've ever seen the given object */
<a name="7938"></a>    hasSeen(obj) { return obj.(seenProp); }
<a name="7939"></a>
<a name="7940"></a>    /* mark the object to remember that I've seen it */
<a name="7941"></a>    setHasSeen(obj) { obj.noteSeenBy(self, seenProp); }
<a name="7942"></a>
<a name="7943"></a>    /* receive notification that another actor is observing us */
<a name="7944"></a>    noteSeenBy(actor, prop)
<a name="7945"></a>    {
<a name="7946"></a>        /* do the standard work to remember that we've been seen */
<a name="7947"></a>        inherited(actor, prop);
<a name="7948"></a>
<a name="7949"></a>        /* 
<a name="7950"></a>         *   Update the follow tracking information with the latest
<a name="7951"></a>         *   observed location.  We're merely observing the fact that the
<a name="7952"></a>         *   actor is here, not that the actor is departing, so the
<a name="7953"></a>         *   connector is nil.
<a name="7954"></a>         *   
<a name="7955"></a>         *   The point of noting the actor's presence in the "follow info"
<a name="7956"></a>         *   is that we want to replace any previous memory we have of the
<a name="7957"></a>         *   actor departing from another location.  Now that we know where
<a name="7958"></a>         *   the actor is, any old memory of the actor having left another
<a name="7959"></a>         *   location is now irrelevant.  We only keep track of one "follow
<a name="7960"></a>         *   info" record per actor, so this new record will replace any
<a name="7961"></a>         *   older record.  
<a name="7962"></a>         */
<a name="7963"></a>        actor.trackFollowInfo(self, nil, location);
<a name="7964"></a>    }
<a name="7965"></a>
<a name="7966"></a>    /* 
<a name="7967"></a>     *   Determine if I know about the given object.  I know about an
<a name="7968"></a>     *   object if it's specifically marked as known to me; I also know
<a name="7969"></a>     *   about the object if I can see it now, or if I've ever seen it in
<a name="7970"></a>     *   the past.  
<a name="7971"></a>     */
<a name="7972"></a>    knowsAbout(obj) { return canSee(obj) || hasSeen(obj) || obj.(knownProp); }
<a name="7973"></a>
<a name="7974"></a>    /* mark the object as known to me */
<a name="7975"></a>    setKnowsAbout(obj) { obj.(knownProp) = true; }
<a name="7976"></a>
<a name="7977"></a>    /*
<a name="7978"></a>     *   My 'seen' property.  By default, this is simply 'seen', which
<a name="7979"></a>     *   means that we don't distinguish who's seen what - in other words,
<a name="7980"></a>     *   there's a single, global 'seen' flag per object, and if anyone's
<a name="7981"></a>     *   ever seen something, then we consider that to mean everyone has
<a name="7982"></a>     *   seen it.
<a name="7983"></a>     *   
<a name="7984"></a>     *   Some games might want to track each NPC's sight memory
<a name="7985"></a>     *   separately, or at least they might want to track it individually
<a name="7986"></a>     *   for a few specific NPC's.  You can do this by making up a new
<a name="7987"></a>     *   property name for each NPC whose sight memory you want to keep
<a name="7988"></a>     *   separate, and simply setting 'seenProp' to that property name for
<a name="7989"></a>     *   each such NPC.  For example, for Bob, you could make the property
<a name="7990"></a>     *   bobHasSeen, so in Bob you'd define 'sightProp = &amp;bobHasSeen'.  
<a name="7991"></a>     */
<a name="7992"></a>    seenProp = &amp;seen
<a name="7993"></a>
<a name="7994"></a>    /*
<a name="7995"></a>     *   My 'known' property.  By default, this is simply 'known', which
<a name="7996"></a>     *   means that we don't distinguish who knows what.
<a name="7997"></a>     *   
<a name="7998"></a>     *   As with 'seenProp' above, if you want to keep track of each NPC's
<a name="7999"></a>     *   knowledge separately, you must override this property for each
<a name="8000"></a>     *   NPC who's to have its own knowledge base to use a separate
<a name="8001"></a>     *   property name.  For example, if you want to keep track of what
<a name="8002"></a>     *   Bob knows individually, you could define 'knownProp = &amp;bobKnows'
<a name="8003"></a>     *   in Bob.  
<a name="8004"></a>     */
<a name="8005"></a>    knownProp = &amp;isKnown
<a name="8006"></a>
<a name="8007"></a>    /*
<a name="8008"></a>     *   Determine if the actor recognizes the given object as a "topic,"
<a name="8009"></a>     *   which is an object that represents some knowledge the actor can
<a name="8010"></a>     *   use in conversations, consultations, and the like.
<a name="8011"></a>     *   
<a name="8012"></a>     *   By default, we'll recognize any Topic object marked as known, and
<a name="8013"></a>     *   we'll recognize any game object for which our knowsAbout(obj)
<a name="8014"></a>     *   returns true.  Games might wish to override this in some cases to
<a name="8015"></a>     *   limit or expand an actor's knowledge according to what the actor
<a name="8016"></a>     *   has experienced of the setting or story.  Note that it's often
<a name="8017"></a>     *   easier to control actor knowledge using the lower-level
<a name="8018"></a>     *   knowsAbout() and setKnowsAbout() methods, though.  
<a name="8019"></a>     */
<a name="8020"></a>    knowsTopic(obj)
<a name="8021"></a>    {
<a name="8022"></a>        /* we know the object as a topic if we know about it at all */
<a name="8023"></a>        return knowsAbout(obj);
<a name="8024"></a>    }
<a name="8025"></a>
<a name="8026"></a>    /*
<a name="8027"></a>     *   Determine if the given object is a likely topic for a
<a name="8028"></a>     *   conversational action performed by this actor.  By default, we'll
<a name="8029"></a>     *   return true if the topic is known, nil if not.  
<a name="8030"></a>     */
<a name="8031"></a>    isLikelyTopic(obj)
<a name="8032"></a>    {
<a name="8033"></a>        /* if the object is known, it's a possible topic */
<a name="8034"></a>        return knowsTopic(obj);
<a name="8035"></a>    }
<a name="8036"></a>
<a name="8037"></a>    /* we are the owner of any TopicEntry objects contained within us */
<a name="8038"></a>    getTopicOwner() { return self; }
<a name="8039"></a>
<a name="8040"></a>    /*
<a name="8041"></a>     *   Suggest topics of conversation.  This is called by the TOPICS
<a name="8042"></a>     *   command (in which case 'explicit' is true), and whenever we first
<a name="8043"></a>     *   engage a character in a stateful conversation (in which case
<a name="8044"></a>     *   'explicit' is nil).
<a name="8045"></a>     *   
<a name="8046"></a>     *   We'll show the list of suggested topics associated with our
<a name="8047"></a>     *   current conversational partner.  If there are no topics, we'll say
<a name="8048"></a>     *   nothing unless 'explicit' is true, in which case we'll simply say
<a name="8049"></a>     *   that there are no topics that the player character is thinking
<a name="8050"></a>     *   about.
<a name="8051"></a>     *   
<a name="8052"></a>     *   The purpose of this method is to let the game author keep an
<a name="8053"></a>     *   "inventory" of topics with this actor for a given conversational
<a name="8054"></a>     *   partner.  This inventory is meant to represent the topics that on
<a name="8055"></a>     *   the player character's mind - things the player character wants to
<a name="8056"></a>     *   talk about with the other actor.  Note that we're talking about
<a name="8057"></a>     *   what the player *character* is thinking about - obviously we don't
<a name="8058"></a>     *   know what's on the player's mind.
<a name="8059"></a>     *   
<a name="8060"></a>     *   When we enter conversation, or when the player asks for advice,
<a name="8061"></a>     *   we'll show this inventory.  The idea is to help guide the player
<a name="8062"></a>     *   through a conversation without the more heavy-handed device of a
<a name="8063"></a>     *   formal conversation menu system, so that conversations have a more
<a name="8064"></a>     *   free-form feel without leaving the player hunting in the dark for
<a name="8065"></a>     *   the magic ASK ABOUT topic.
<a name="8066"></a>     *   
<a name="8067"></a>     *   The TOPICS system is entirely optional.  If a game doesn't specify
<a name="8068"></a>     *   any SuggestedTopic objects, then this routine will simply never be
<a name="8069"></a>     *   called, and the TOPICS command won't be allowed.  Some authors
<a name="8070"></a>     *   think it gives away too much to provide a list of topic
<a name="8071"></a>     *   suggestions like this, and others don't like anything that smacks
<a name="8072"></a>     *   of a menu system because they think it destroys the illusion
<a name="8073"></a>     *   created by the text-input command line that the game is boundless.
<a name="8074"></a>     *   Authors who feel this way can just ignore the TOPICS system.  But
<a name="8075"></a>     *   be aware that the illusion of boundlessness isn't always a good
<a name="8076"></a>     *   thing for players; hunting around for ASK ABOUT topics can make
<a name="8077"></a>     *   the game's limits just as obvious, if not more so, by exposing the
<a name="8078"></a>     *   vast number of inputs for which the actor doesn't have a good
<a name="8079"></a>     *   response.  Players aren't stupid - a string of variations on "I
<a name="8080"></a>     *   don't know about that" is just as obviously mechanistic as a
<a name="8081"></a>     *   numbered list of menu choices.  Using the TOPICS system might be a
<a name="8082"></a>     *   good compromise for many authors, since the topic list can help
<a name="8083"></a>     *   guide the player to the right questions without making the player
<a name="8084"></a>     *   feel straitjacketed by a menu list.  
<a name="8085"></a>     */
<a name="8086"></a>    suggestTopics(explicit)
<a name="8087"></a>    {
<a name="8088"></a>        local actor;
<a name="8089"></a>        
<a name="8090"></a>        /* 
<a name="8091"></a>         *   if we're talking to someone, look up their suggested topics;
<a name="8092"></a>         *   otherwise, we have nothing to suggest 
<a name="8093"></a>         */
<a name="8094"></a>        if ((actor = getCurrentInterlocutor()) != nil)
<a name="8095"></a>        {
<a name="8096"></a>            /* 
<a name="8097"></a>             *   we're talking to someone - suggest topics appropriate to
<a name="8098"></a>             *   the person we're talking to 
<a name="8099"></a>             */
<a name="8100"></a>            actor.suggestTopicsFor(self, explicit);
<a name="8101"></a>        }
<a name="8102"></a>        else if (explicit)
<a name="8103"></a>        {
<a name="8104"></a>            /* we're not talking to anyone, so there's nothing to suggest */
<a name="8105"></a>            gLibMessages.noTopicsNotTalking;
<a name="8106"></a>        }
<a name="8107"></a>    }
<a name="8108"></a>
<a name="8109"></a>    /*
<a name="8110"></a>     *   Suggest topics that the given actor might want to talk to us
<a name="8111"></a>     *   about.  The given actor is almost always the player character,
<a name="8112"></a>     *   since generally NPC's don't talk to one another using
<a name="8113"></a>     *   conversation commands (there'd be no point; they're simple
<a name="8114"></a>     *   programmed automata, not full-blown AI's).  
<a name="8115"></a>     */
<a name="8116"></a>    suggestTopicsFor(actor, explicit)
<a name="8117"></a>    {
<a name="8118"></a>        /* by default, let our state suggest topics */
<a name="8119"></a>        curState.suggestTopicsFor(actor, explicit);
<a name="8120"></a>    }
<a name="8121"></a>
<a name="8122"></a>    /*
<a name="8123"></a>     *   Receive notification that a command is being carried out in our
<a name="8124"></a>     *   presence. 
<a name="8125"></a>     */
<a name="8126"></a>    beforeAction()
<a name="8127"></a>    {
<a name="8128"></a>        /*
<a name="8129"></a>         *   If another actor is trying to take something in my inventory,
<a name="8130"></a>         *   by default, do not allow it. 
<a name="8131"></a>         */
<a name="8132"></a>        if (gActor != self
<a name="8133"></a>            &amp;&amp; (gActionIs(Take) || gActionIs(TakeFrom))
<a name="8134"></a>            &amp;&amp; gDobj.isIn(self))
<a name="8135"></a>        {
<a name="8136"></a>            /* check to see if we want to allow this action */
<a name="8137"></a>            checkTakeFromInventory(gActor, gDobj);
<a name="8138"></a>        }
<a name="8139"></a>
<a name="8140"></a>        /* let our state object take a look at the action */
<a name="8141"></a>        curState.beforeAction();
<a name="8142"></a>    }
<a name="8143"></a>
<a name="8144"></a>    /* 
<a name="8145"></a>     *   Perform any actor-specific processing for an action.  The main
<a name="8146"></a>     *   command processor invokes this on gActor after notifying nearby
<a name="8147"></a>     *   objects via beforeAction(), but before carrying out the main
<a name="8148"></a>     *   action of the command.  
<a name="8149"></a>     */
<a name="8150"></a>    actorAction()
<a name="8151"></a>    {
<a name="8152"></a>        /* do nothing by default */
<a name="8153"></a>    }
<a name="8154"></a>
<a name="8155"></a>    /*
<a name="8156"></a>     *   Receive notification that a command has just been carried out in
<a name="8157"></a>     *   our presence.  
<a name="8158"></a>     */
<a name="8159"></a>    afterAction()
<a name="8160"></a>    {
<a name="8161"></a>        /* let the state object handle it */
<a name="8162"></a>        curState.afterAction();
<a name="8163"></a>    }
<a name="8164"></a>
<a name="8165"></a>    /* receive a notification that someone is about to travel */
<a name="8166"></a>    beforeTravel(traveler, connector)
<a name="8167"></a>    {
<a name="8168"></a>        /* let the state object handle it */
<a name="8169"></a>        curState.beforeTravel(traveler, connector);
<a name="8170"></a>
<a name="8171"></a>        /* 
<a name="8172"></a>         *   If desired, track the departure so that we can follow the
<a name="8173"></a>         *   traveler later.  First, track the departure of each actor
<a name="8174"></a>         *   traveling with the traveler.  
<a name="8175"></a>         */
<a name="8176"></a>        traveler.forEachTravelingActor(
<a name="8177"></a>            {actor: trackFollowInfo(actor, connector, traveler.location)});
<a name="8178"></a>
<a name="8179"></a>        /* 
<a name="8180"></a>         *   if the traveler is distinct from the actors traveling, track
<a name="8181"></a>         *   it as well 
<a name="8182"></a>         */
<a name="8183"></a>        if (!traveler.isActorTraveling(traveler))
<a name="8184"></a>            trackFollowInfo(traveler, connector, traveler.location);
<a name="8185"></a>    }
<a name="8186"></a>
<a name="8187"></a>    /* receive a notification that someone has just traveled here */
<a name="8188"></a>    afterTravel(traveler, connector)
<a name="8189"></a>    {
<a name="8190"></a>        /* let the state object handle it */
<a name="8191"></a>        curState.afterTravel(traveler, connector);
<a name="8192"></a>    }
<a name="8193"></a>
<a name="8194"></a>    /*
<a name="8195"></a>     *   Receive notification that I'm initiating travel.  This is called
<a name="8196"></a>     *   on the actor performing the travel action before the travel is
<a name="8197"></a>     *   actually carried out.  
<a name="8198"></a>     */
<a name="8199"></a>    actorTravel(traveler, connector)
<a name="8200"></a>    {
<a name="8201"></a>        /*
<a name="8202"></a>         *   If other actors are accompanying me on this travel, run the
<a name="8203"></a>         *   same travel action on the accompanying actors, using nested
<a name="8204"></a>         *   actions.  
<a name="8205"></a>         */
<a name="8206"></a>        if (accompanyingActors != nil
<a name="8207"></a>            &amp;&amp; accompanyingActors.length() != 0)
<a name="8208"></a>        {
<a name="8209"></a>            /* 
<a name="8210"></a>             *   Run the same travel action as a nested action on each
<a name="8211"></a>             *   accompanying actor.  Skip this for any accompanying actor
<a name="8212"></a>             *   we're carrying, as they'll naturally go with us as a
<a name="8213"></a>             *   result of being carried.  
<a name="8214"></a>             */
<a name="8215"></a>            foreach (local cur in accompanyingActors)
<a name="8216"></a>            {
<a name="8217"></a>                /* if the actor's not being carried, run the same action */
<a name="8218"></a>                if (!cur.isIn(self))
<a name="8219"></a>                    nestedActorAction(cur, TravelVia, gDobj);
<a name="8220"></a>            }
<a name="8221"></a>
<a name="8222"></a>            /* 
<a name="8223"></a>             *   The accompanying actor list applies for this single group
<a name="8224"></a>             *   travel command, so now that we've moved everyone, we have
<a name="8225"></a>             *   no further need for the list.  Clear it out. 
<a name="8226"></a>             */
<a name="8227"></a>            accompanyingActors.removeRange(1, accompanyingActors.length());
<a name="8228"></a>        }
<a name="8229"></a>    }
<a name="8230"></a>
<a name="8231"></a>    /*
<a name="8232"></a>     *   Check to see if we want to allow another actor to take something
<a name="8233"></a>     *   from my inventory.  By default, we won't allow it - we'll always
<a name="8234"></a>     *   fail the command.  
<a name="8235"></a>     */
<a name="8236"></a>    checkTakeFromInventory(actor, obj)
<a name="8237"></a>    {
<a name="8238"></a>        /* don't allow it - show an error and terminate the command */
<a name="8239"></a>        mainReport(&amp;willNotLetGoMsg, self, obj);
<a name="8240"></a>        exit;
<a name="8241"></a>    }
<a name="8242"></a>
<a name="8243"></a>    /*
<a name="8244"></a>     *   Build a list of the objects that are explicitly registered to
<a name="8245"></a>     *   receive notification when I'm the actor in a command.
<a name="8246"></a>     */
<a name="8247"></a>    getActorNotifyList()
<a name="8248"></a>    {
<a name="8249"></a>        return actorNotifyList;
<a name="8250"></a>    }
<a name="8251"></a>
<a name="8252"></a>    /*
<a name="8253"></a>     *   Add an item to our registered notification items.  These items
<a name="8254"></a>     *   are to receive notifications when we're the actor performing a
<a name="8255"></a>     *   command.
<a name="8256"></a>     *   
<a name="8257"></a>     *   Items can be added here if they must be notified of actions
<a name="8258"></a>     *   performed by the actor even when the items aren't connected by
<a name="8259"></a>     *   containment with the actor at the time of the action.  All items
<a name="8260"></a>     *   connected to the actor by containment are automatically notified
<a name="8261"></a>     *   of each action; only items that must receive notification even
<a name="8262"></a>     *   when not in scope need to be registered here.  
<a name="8263"></a>     */
<a name="8264"></a>    addActorNotifyItem(obj)
<a name="8265"></a>    {
<a name="8266"></a>        actorNotifyList += obj;
<a name="8267"></a>    }
<a name="8268"></a>
<a name="8269"></a>    /* remove an item from the registered notification list */
<a name="8270"></a>    removeActorNotifyItem(obj)
<a name="8271"></a>    {
<a name="8272"></a>        actorNotifyList -= obj;
<a name="8273"></a>    }
<a name="8274"></a>
<a name="8275"></a>    /* our list of registered actor notification items */
<a name="8276"></a>    actorNotifyList = []
<a name="8277"></a>
<a name="8278"></a>    /*
<a name="8279"></a>     *   Get the ambient light level in the visual senses at this actor.
<a name="8280"></a>     *   This is the ambient level at the actor.  
<a name="8281"></a>     */
<a name="8282"></a>    getVisualAmbient()
<a name="8283"></a>    {
<a name="8284"></a>        local ret;
<a name="8285"></a>        local cache;
<a name="8286"></a>
<a name="8287"></a>        /* check for a cached value */
<a name="8288"></a>        if ((cache = libGlobal.actorVisualAmbientCache) != nil
<a name="8289"></a>            &amp;&amp; (ret = cache[self]) != nil)
<a name="8290"></a>        {
<a name="8291"></a>            /* found a cached entry - use it */
<a name="8292"></a>            return ret;
<a name="8293"></a>        }
<a name="8294"></a>
<a name="8295"></a>        /* get the maximum ambient level at self for my sight-like senses */
<a name="8296"></a>        ret = senseAmbientMax(sightlikeSenses);
<a name="8297"></a>
<a name="8298"></a>        /* if caching is active, cache our result for next time */
<a name="8299"></a>        if (cache != nil)
<a name="8300"></a>            cache[self] = ret;
<a name="8301"></a>
<a name="8302"></a>        /* return the result */
<a name="8303"></a>        return ret;
<a name="8304"></a>    }
<a name="8305"></a>
<a name="8306"></a>    /*
<a name="8307"></a>     *   Determine if my location is lit for my sight-like senses.
<a name="8308"></a>     */
<a name="8309"></a>    isLocationLit()
<a name="8310"></a>    {
<a name="8311"></a>        /* 
<a name="8312"></a>         *   Check for a simple, common case before doing the full
<a name="8313"></a>         *   sense-path calculation: if our location is providing its own
<a name="8314"></a>         *   light to its interior, then the location is lit.  Most simple
<a name="8315"></a>         *   rooms are always lit.  
<a name="8316"></a>         */
<a name="8317"></a>        if (sightlikeSenses.indexOf(sight) != nil
<a name="8318"></a>            &amp;&amp; location != nil
<a name="8319"></a>            &amp;&amp; location.brightness &gt; 1
<a name="8320"></a>            &amp;&amp; location.transSensingOut(sight) == transparent)
<a name="8321"></a>            return true;
<a name="8322"></a>
<a name="8323"></a>        /* 
<a name="8324"></a>         *   We don't have the simple case of light directly from our
<a name="8325"></a>         *   location, so run the full sense path check and get our
<a name="8326"></a>         *   maximum visual ambience level.  If it's above the "self-lit"
<a name="8327"></a>         *   level of 1, then we can see. 
<a name="8328"></a>         */
<a name="8329"></a>        return (getVisualAmbient() &gt; 1);
<a name="8330"></a>    }
<a name="8331"></a>
<a name="8332"></a>    /*
<a name="8333"></a>     *   Get the best (most transparent) sense information for one of our
<a name="8334"></a>     *   visual senses to the given object.  
<a name="8335"></a>     */
<a name="8336"></a>    bestVisualInfo(obj)
<a name="8337"></a>    {
<a name="8338"></a>        local best;
<a name="8339"></a>
<a name="8340"></a>        /* we don't have a best value yet */
<a name="8341"></a>        best = nil;
<a name="8342"></a>
<a name="8343"></a>        /* check each sight-like sense */
<a name="8344"></a>        foreach (local sense in sightlikeSenses)
<a name="8345"></a>        {
<a name="8346"></a>            /* 
<a name="8347"></a>             *   get the information for the object in this sense, and keep
<a name="8348"></a>             *   the best (most transparent) info we've seen so far 
<a name="8349"></a>             */
<a name="8350"></a>            best = SenseInfo.selectMoreTrans(best, senseObj(sense, obj));
<a name="8351"></a>        }
<a name="8352"></a>
<a name="8353"></a>        /* return the best one we found */
<a name="8354"></a>        return best;
<a name="8355"></a>    }
<a name="8356"></a>
<a name="8357"></a>    /*
<a name="8358"></a>     *   Build a list of all of the objects of which an actor is aware.
<a name="8359"></a>     *   
<a name="8360"></a>     *   An actor is aware of an object if the object is within reach of
<a name="8361"></a>     *   the actor's senses, and has some sort of presence in that sense.
<a name="8362"></a>     *   Note that both of these conditions must be true for at least one
<a name="8363"></a>     *   sense possessed by the actor; an object that is within earshot,
<a name="8364"></a>     *   but not within reach of any other sense, is in scope only if the
<a name="8365"></a>     *   object is making some kind of noise.
<a name="8366"></a>     *   
<a name="8367"></a>     *   In addition, objects that the actor is holding (i.e., those
<a name="8368"></a>     *   contained by the actor directly) are always in scope, regardless
<a name="8369"></a>     *   of their reachability through any sense.  
<a name="8370"></a>     */
<a name="8371"></a>    scopeList()
<a name="8372"></a>    {
<a name="8373"></a>        local lst;
<a name="8374"></a>
<a name="8375"></a>        /* we have nothing in our master list yet */
<a name="8376"></a>        lst = new Vector(32);
<a name="8377"></a>
<a name="8378"></a>        /* oneself is always in one's own scope list */
<a name="8379"></a>        lst.append(self);
<a name="8380"></a>
<a name="8381"></a>        /* iterate over each sense */
<a name="8382"></a>        foreach (local sense in scopeSenses)
<a name="8383"></a>        {
<a name="8384"></a>            /* 
<a name="8385"></a>             *   get the list of objects with a presence in this sense
<a name="8386"></a>             *   that can be sensed from our point of view, and and append
<a name="8387"></a>             *   it to our master list 
<a name="8388"></a>             */
<a name="8389"></a>            lst.appendUnique(sensePresenceList(sense));
<a name="8390"></a>        }
<a name="8391"></a>
<a name="8392"></a>        /* add all of the items we are directly holding */
<a name="8393"></a>        lst.appendUnique(contents);
<a name="8394"></a>
<a name="8395"></a>        /* 
<a name="8396"></a>         *   ask each of our direct contents to add any contents of their
<a name="8397"></a>         *   own that are in scope by virtue of their containers being in
<a name="8398"></a>         *   scope 
<a name="8399"></a>         */
<a name="8400"></a>        foreach (local cur in contents)
<a name="8401"></a>            cur.appendHeldContents(lst);
<a name="8402"></a>
<a name="8403"></a>        /* add any items that are specially in scope in the location */
<a name="8404"></a>        if (location != nil)
<a name="8405"></a>        {
<a name="8406"></a>            /* get the extra scope items */
<a name="8407"></a>            local extra = location.getExtraScopeItems(self);
<a name="8408"></a>
<a name="8409"></a>            /* if this is a non-nil list, add it to our list */
<a name="8410"></a>            if (extra.length() != 0)
<a name="8411"></a>                lst.appendUnique(extra);
<a name="8412"></a>        }
<a name="8413"></a>
<a name="8414"></a>        /* 
<a name="8415"></a>         *   Finally, add anything extra each item already in scope wants
<a name="8416"></a>         *   to add.  Note that we keep going until we've visited each
<a name="8417"></a>         *   element of the vector at its current length on each iteration,
<a name="8418"></a>         *   so if we add any new items, we'll check them to see if they
<a name="8419"></a>         *   want to add any new items, and so on.  
<a name="8420"></a>         */
<a name="8421"></a>        for (local i = 1 ; i &lt;= lst.length() ; ++i)
<a name="8422"></a>        {
<a name="8423"></a>            local extra;
<a name="8424"></a>
<a name="8425"></a>            /* get the extra scope items for this item */
<a name="8426"></a>            extra = lst[i].getExtraScopeItems(self);
<a name="8427"></a>
<a name="8428"></a>            /* if the extra item list is non-nil, add it to our list */
<a name="8429"></a>            if (extra.length() != 0)
<a name="8430"></a>                lst.appendUnique(extra);
<a name="8431"></a>        }
<a name="8432"></a>
<a name="8433"></a>        /* return the result */
<a name="8434"></a>        return lst.toList();
<a name="8435"></a>    }
<a name="8436"></a>
<a name="8437"></a>    /*
<a name="8438"></a>     *   Determine if I can see the given object.  This returns true if
<a name="8439"></a>     *   the object can be sensed at all in one of my sight-like senses,
<a name="8440"></a>     *   nil if not.  
<a name="8441"></a>     */
<a name="8442"></a>    canSee(obj)
<a name="8443"></a>    {
<a name="8444"></a>        /* try each sight-like sense */
<a name="8445"></a>        foreach (local sense in sightlikeSenses)
<a name="8446"></a>        {
<a name="8447"></a>            /* 
<a name="8448"></a>             *   if I can sense the object in this sense, I can sense the
<a name="8449"></a>             *   object 
<a name="8450"></a>             */
<a name="8451"></a>            if (senseObj(sense, obj).trans != opaque)
<a name="8452"></a>                return true;
<a name="8453"></a>        }
<a name="8454"></a>
<a name="8455"></a>        /* we didn't find any sight-like sense where we can see the object */
<a name="8456"></a>        return nil;
<a name="8457"></a>    }
<a name="8458"></a>
<a name="8459"></a>    /*
<a name="8460"></a>     *   Determine if I can hear the given object. 
<a name="8461"></a>     */
<a name="8462"></a>    canHear(obj)
<a name="8463"></a>    {
<a name="8464"></a>        /* try each hearling-like sense */
<a name="8465"></a>        foreach (local sense in hearinglikeSenses)
<a name="8466"></a>        {
<a name="8467"></a>            /* 
<a name="8468"></a>             *   if I can sense the object in this sense, I can sense the
<a name="8469"></a>             *   object 
<a name="8470"></a>             */
<a name="8471"></a>            if (senseObj(sense, obj).trans != opaque)
<a name="8472"></a>                return true;
<a name="8473"></a>        }
<a name="8474"></a>        
<a name="8475"></a>        /* we found no hearing-like sense that lets us hear the object */
<a name="8476"></a>        return nil;
<a name="8477"></a>    }
<a name="8478"></a>
<a name="8479"></a>    /*
<a name="8480"></a>     *   Determine if I can smell the given object. 
<a name="8481"></a>     */
<a name="8482"></a>    canSmell(obj)
<a name="8483"></a>    {
<a name="8484"></a>        /* try each hearling-like sense */
<a name="8485"></a>        foreach (local sense in smelllikeSenses)
<a name="8486"></a>        {
<a name="8487"></a>            /* 
<a name="8488"></a>             *   if I can sense the object in this sense, I can sense the
<a name="8489"></a>             *   object 
<a name="8490"></a>             */
<a name="8491"></a>            if (senseObj(sense, obj).trans != opaque)
<a name="8492"></a>                return true;
<a name="8493"></a>        }
<a name="8494"></a>        
<a name="8495"></a>        /* we found no smell-like sense that lets us hear the object */
<a name="8496"></a>        return nil;
<a name="8497"></a>    }
<a name="8498"></a>
<a name="8499"></a>    /*
<a name="8500"></a>     *   Find the object that prevents us from seeing the given object. 
<a name="8501"></a>     */
<a name="8502"></a>    findVisualObstructor(obj)
<a name="8503"></a>    {
<a name="8504"></a>        /* try to find an opaque obstructor in one of our visual senses */
<a name="8505"></a>        foreach (local sense in sightlikeSenses)
<a name="8506"></a>        {
<a name="8507"></a>            local obs;
<a name="8508"></a>
<a name="8509"></a>            /* cache path information for this sense */
<a name="8510"></a>            cacheSenseInfo(connectionTable(), sense);
<a name="8511"></a>            
<a name="8512"></a>            /* if we find an obstructor in this sense, return it */
<a name="8513"></a>            if ((obs = findOpaqueObstructor(sense, obj)) != nil)
<a name="8514"></a>                return obs;
<a name="8515"></a>        }
<a name="8516"></a>
<a name="8517"></a>        /* we didn't find any obstructor */
<a name="8518"></a>        return nil;
<a name="8519"></a>    }
<a name="8520"></a>
<a name="8521"></a>    /*
<a name="8522"></a>     *   Build a table of full sensory information for all of the objects
<a name="8523"></a>     *   visible to the actor through the actor's sight-like senses.
<a name="8524"></a>     *   Returns a lookup table with the same set of information as
<a name="8525"></a>     *   senseInfoTable().  
<a name="8526"></a>     */
<a name="8527"></a>    visibleInfoTable()
<a name="8528"></a>    {
<a name="8529"></a>        /* return objects visible from my own point of view */
<a name="8530"></a>        return visibleInfoTableFromPov(self);
<a name="8531"></a>    }
<a name="8532"></a>
<a name="8533"></a>    /*
<a name="8534"></a>     *   Build a table of full sensory information for all of the objects
<a name="8535"></a>     *   visible to me from a particular point of view through my
<a name="8536"></a>     *   sight-like senses.  
<a name="8537"></a>     */
<a name="8538"></a>    visibleInfoTableFromPov(pov)
<a name="8539"></a>    {
<a name="8540"></a>        local tab;
<a name="8541"></a>
<a name="8542"></a>        /* we have no master table yet */
<a name="8543"></a>        tab = nil;
<a name="8544"></a>
<a name="8545"></a>        /* iterate over each sense */
<a name="8546"></a>        foreach (local sense in sightlikeSenses)
<a name="8547"></a>        {
<a name="8548"></a>            local cur;
<a name="8549"></a>            
<a name="8550"></a>            /* get information for all objects for the current sense */
<a name="8551"></a>            cur = pov.senseInfoTable(sense);
<a name="8552"></a>
<a name="8553"></a>            /* merge the table so far with the new table */
<a name="8554"></a>            tab = mergeSenseInfoTable(cur, tab);
<a name="8555"></a>        }
<a name="8556"></a>
<a name="8557"></a>        /* return the result */
<a name="8558"></a>        return tab;
<a name="8559"></a>    }
<a name="8560"></a>
<a name="8561"></a>    /*
<a name="8562"></a>     *   Build a lookup table of the objects that can be sensed for the
<a name="8563"></a>     *   purposes of taking inventory.  We'll include everything in the
<a name="8564"></a>     *   normal visual sense table, plus everything directly held.  
<a name="8565"></a>     */
<a name="8566"></a>    inventorySenseInfoTable()
<a name="8567"></a>    {
<a name="8568"></a>        local visInfo;
<a name="8569"></a>        local cont;
<a name="8570"></a>        local ambient;
<a name="8571"></a>        local info;
<a name="8572"></a>        
<a name="8573"></a>        /*   
<a name="8574"></a>         *   Start with the objects visible to the actor through the
<a name="8575"></a>         *   actor's sight-like senses.  
<a name="8576"></a>         */
<a name="8577"></a>        visInfo = visibleInfoTable();
<a name="8578"></a>
<a name="8579"></a>        /* get the ambient light level at the actor */
<a name="8580"></a>        if ((info = visInfo[self]) != nil)
<a name="8581"></a>            ambient = info.ambient;
<a name="8582"></a>        else
<a name="8583"></a>            ambient = 0;
<a name="8584"></a>        
<a name="8585"></a>        /*   
<a name="8586"></a>         *   We'll assume that, for each item that the actor is directly
<a name="8587"></a>         *   holding AND knows about, the actor can still identify the item
<a name="8588"></a>         *   by touch, even if it's not visible.  This way, when we're in a
<a name="8589"></a>         *   dark room, we'll still be able to refer to the objects we're
<a name="8590"></a>         *   directly holding, as long as we already know about them.
<a name="8591"></a>         *   
<a name="8592"></a>         *   Likewise, add items within our direct contents that are
<a name="8593"></a>         *   considered equally held.  
<a name="8594"></a>         */
<a name="8595"></a>        cont = new Vector(32);
<a name="8596"></a>        foreach (local cur in contents)
<a name="8597"></a>        {
<a name="8598"></a>            /* add this item from our contents */
<a name="8599"></a>            cont.append(cur);
<a name="8600"></a>
<a name="8601"></a>            /* add its contents that are themselves equally as held */
<a name="8602"></a>            cur.appendHeldContents(cont);
<a name="8603"></a>        }
<a name="8604"></a>
<a name="8605"></a>        /* 
<a name="8606"></a>         *   Make a fully-sensible entry for each of our held items.  We
<a name="8607"></a>         *   can simply replace any existing entry in the table that we got
<a name="8608"></a>         *   from the visual senses, since a fully transparent entry will
<a name="8609"></a>         *   be at least as good as anything we got from the normal visual
<a name="8610"></a>         *   list.  Only include items that the actor knows about; we'll
<a name="8611"></a>         *   assume that we can identify by touch anything we're holding if
<a name="8612"></a>         *   we already know what it is, but not otherwise.  
<a name="8613"></a>         */
<a name="8614"></a>        foreach (local cur in cont)
<a name="8615"></a>        {
<a name="8616"></a>            /* if we know about the object, make it effectively visible */
<a name="8617"></a>            if (knowsAbout(cur))
<a name="8618"></a>                visInfo[cur] = new SenseInfo(cur, transparent, nil, ambient);
<a name="8619"></a>        }
<a name="8620"></a>
<a name="8621"></a>        /* return the table */
<a name="8622"></a>        return visInfo;
<a name="8623"></a>    }
<a name="8624"></a>
<a name="8625"></a>    /*
<a name="8626"></a>     *   Show what the actor is carrying.
<a name="8627"></a>     */
<a name="8628"></a>    showInventory(tall)
<a name="8629"></a>    {
<a name="8630"></a>        /* 
<a name="8631"></a>         *   show our inventory with our default listers as given by our
<a name="8632"></a>         *   inventory/wearing lister properties 
<a name="8633"></a>         */
<a name="8634"></a>        showInventoryWith(tall, inventoryLister);
<a name="8635"></a>    }
<a name="8636"></a>
<a name="8637"></a>    /*
<a name="8638"></a>     *   Show what the actor is carrying, using the given listers.
<a name="8639"></a>     *   
<a name="8640"></a>     *   Note that this method must be overridden if the actor does not
<a name="8641"></a>     *   use a conventional 'contents' list property to store its full set
<a name="8642"></a>     *   of contents.  
<a name="8643"></a>     */
<a name="8644"></a>    showInventoryWith(tall, inventoryLister)
<a name="8645"></a>    {
<a name="8646"></a>        local infoTab;
<a name="8647"></a>
<a name="8648"></a>        /* get the table of objects sensible for inventory */
<a name="8649"></a>        infoTab = inventorySenseInfoTable();
<a name="8650"></a>
<a name="8651"></a>        /* list in the appropriate mode ("wide" or "tall") */
<a name="8652"></a>        inventoryLister.showList(self, self, contents,
<a name="8653"></a>                                 ListRecurse | (tall ? ListTall : 0),
<a name="8654"></a>                                 0, infoTab, nil);
<a name="8655"></a>
<a name="8656"></a>        /* mention sounds coming from inventory items */
<a name="8657"></a>        inventorySense(sound, inventoryListenLister);
<a name="8658"></a>
<a name="8659"></a>        /* mention odors coming from inventory items */
<a name="8660"></a>        inventorySense(smell, inventorySmellLister);
<a name="8661"></a>    }
<a name="8662"></a>
<a name="8663"></a>    /*
<a name="8664"></a>     *   Add to an inventory description a list of things we notice
<a name="8665"></a>     *   through a specific sense.
<a name="8666"></a>     */
<a name="8667"></a>    inventorySense(sense, lister)
<a name="8668"></a>    {
<a name="8669"></a>        local infoTab;
<a name="8670"></a>        local presenceList;
<a name="8671"></a>        
<a name="8672"></a>        /* get the information table for the desired sense */
<a name="8673"></a>        infoTab = senseInfoTable(sense);
<a name="8674"></a>        
<a name="8675"></a>        /* 
<a name="8676"></a>         *   get the list of everything with a presence in this sense that
<a name="8677"></a>         *   I'm carrying 
<a name="8678"></a>         */
<a name="8679"></a>        presenceList = senseInfoTableSubset(infoTab,
<a name="8680"></a>            {obj, info: obj.isIn(self) &amp;&amp; obj.(sense.presenceProp)});
<a name="8681"></a>
<a name="8682"></a>        /* add a paragraph break */
<a name="8683"></a>        cosmeticSpacingReport('&lt;.p&gt;');
<a name="8684"></a>        
<a name="8685"></a>        /* list the items */
<a name="8686"></a>        lister.showList(self, nil, presenceList, 0, 0, infoTab, nil);
<a name="8687"></a>    }
<a name="8688"></a>
<a name="8689"></a>    /*
<a name="8690"></a>     *   The Lister object that we use for inventory listings.  By
<a name="8691"></a>     *   default, we use actorInventoryLister, but this can be overridden
<a name="8692"></a>     *   if desired to use a different listing style.  
<a name="8693"></a>     */
<a name="8694"></a>    inventoryLister = actorInventoryLister
<a name="8695"></a>
<a name="8696"></a>    /*
<a name="8697"></a>     *   The Lister for inventory listings, for use in a full description
<a name="8698"></a>     *   of the actor.  By default, we use the "long form" inventory
<a name="8699"></a>     *   lister, on the assumption that most actors have relatively lengthy
<a name="8700"></a>     *   descriptive text.  This can be overridden to use other formats;
<a name="8701"></a>     *   the short-form lister, for example, is useful for actors with only
<a name="8702"></a>     *   brief descriptions.  
<a name="8703"></a>     */
<a name="8704"></a>    holdingDescInventoryLister = actorHoldingDescInventoryListerLong
<a name="8705"></a>
<a name="8706"></a>    /*
<a name="8707"></a>     *   Perform library pre-initialization on the actor 
<a name="8708"></a>     */
<a name="8709"></a>    initializeActor()
<a name="8710"></a>    {
<a name="8711"></a>        /* set up an empty pending command list */
<a name="8712"></a>        pendingCommand = new Vector(5);
<a name="8713"></a>
<a name="8714"></a>        /* create a default inventory lister if we don't have one already */
<a name="8715"></a>        if (inventoryLister == nil)
<a name="8716"></a>            inventoryLister = actorInventoryLister;
<a name="8717"></a>
<a name="8718"></a>        /* create our antecedent tables */
<a name="8719"></a>        antecedentTable = new LookupTable(8, 8);
<a name="8720"></a>        possAnaphorTable = new LookupTable(8, 8);
<a name="8721"></a>
<a name="8722"></a>        /* if we don't have a state object, create a default */
<a name="8723"></a>        if (curState == nil)
<a name="8724"></a>            setCurState(new ActorState(self));
<a name="8725"></a>
<a name="8726"></a>        /* create our pending-conversation list */
<a name="8727"></a>        pendingConv = new Vector(5);
<a name="8728"></a>    }
<a name="8729"></a>
<a name="8730"></a>    /*
<a name="8731"></a>     *   Note conditions before an action or other event.  By default, we
<a name="8732"></a>     *   note our location and light/dark status, so that we comment on
<a name="8733"></a>     *   any change in the light/dark status after the event if we're
<a name="8734"></a>     *   still in the same location.  
<a name="8735"></a>     */
<a name="8736"></a>    noteConditionsBefore()
<a name="8737"></a>    {
<a name="8738"></a>        /* note our original location and light/dark status */
<a name="8739"></a>        locationBefore = location;
<a name="8740"></a>        locationLitBefore = isLocationLit();
<a name="8741"></a>    }
<a name="8742"></a>
<a name="8743"></a>    /*
<a name="8744"></a>     *   Note conditions after an action or other event.  By default, if
<a name="8745"></a>     *   we are still in the same location we were in when
<a name="8746"></a>     *   noteConditionsBefore() was last called, and the light/dark status
<a name="8747"></a>     *   has changed, we'll mention the change in light/dark status. 
<a name="8748"></a>     */
<a name="8749"></a>    noteConditionsAfter()
<a name="8750"></a>    {
<a name="8751"></a>        /* 
<a name="8752"></a>         *   If our location hasn't changed but our light/dark status has,
<a name="8753"></a>         *   note the new status.  We don't make any announcement if the
<a name="8754"></a>         *   location has changed, since the travel routine will
<a name="8755"></a>         *   presumably have shown us the new location's light/dark status
<a name="8756"></a>         *   implicitly as part of the description of the new location
<a name="8757"></a>         *   after travel. 
<a name="8758"></a>         */
<a name="8759"></a>        if (location == locationBefore
<a name="8760"></a>            &amp;&amp; isLocationLit() != locationLitBefore)
<a name="8761"></a>        {
<a name="8762"></a>            /* consider this the start of a new turn */
<a name="8763"></a>            "&lt;.commandsep&gt;";
<a name="8764"></a>
<a name="8765"></a>            /* note the change with a new 'NoteDarkness' action */
<a name="8766"></a>            newActorAction(self, NoteDarkness);
<a name="8767"></a>
<a name="8768"></a>            /* 
<a name="8769"></a>             *   start another turn, in case this occurred during an
<a name="8770"></a>             *   implicit action or the like 
<a name="8771"></a>             */
<a name="8772"></a>            "&lt;.commandsep&gt;";
<a name="8773"></a>        }
<a name="8774"></a>    }
<a name="8775"></a>
<a name="8776"></a>    /* conditions we noted in noteConditionsBefore() */
<a name="8777"></a>    locationBefore = nil
<a name="8778"></a>    locationLitBefore = nil
<a name="8779"></a>
<a name="8780"></a>    /* let the actor have a turn as soon as the game starts */
<a name="8781"></a>    nextRunTime = 0
<a name="8782"></a>
<a name="8783"></a>    /* 
<a name="8784"></a>     *   Scheduling order - this determines the order of execution when
<a name="8785"></a>     *   several items are schedulable at the same game clock time.
<a name="8786"></a>     *   
<a name="8787"></a>     *   We choose a scheduling order that schedules actors in this
<a name="8788"></a>     *   relative order:
<a name="8789"></a>     *   
<a name="8790"></a>     *   100 player character, ready to execute
<a name="8791"></a>     *.  200 NPC, ready to execute
<a name="8792"></a>     *.  300 player character, idle
<a name="8793"></a>     *.  400 NPC, idle
<a name="8794"></a>     *   
<a name="8795"></a>     *   An "idle" actor is one that is waiting for another character to
<a name="8796"></a>     *   complete a command, or an NPC with no pending commands to
<a name="8797"></a>     *   perform.  (For the player character, it doesn't matter whether or
<a name="8798"></a>     *   not there's a pending command, because if the PC has no pending
<a name="8799"></a>     *   command, we ask the player for one.)
<a name="8800"></a>     *   
<a name="8801"></a>     *   This ordering ensures that each actor gets a chance to run each
<a name="8802"></a>     *   turn, but that actors with work to do go first, and other things
<a name="8803"></a>     *   being equal, the player character goes ahead of NPC's.  
<a name="8804"></a>     */
<a name="8805"></a>    scheduleOrder = 100
<a name="8806"></a>
<a name="8807"></a>    /* calculate the scheduling order */
<a name="8808"></a>    calcScheduleOrder()
<a name="8809"></a>    {
<a name="8810"></a>        /* determine if we're ready to run */
<a name="8811"></a>        if (readyForTurn())
<a name="8812"></a>            scheduleOrder = isPlayerChar() ? 100 : 200;
<a name="8813"></a>        else
<a name="8814"></a>            scheduleOrder = isPlayerChar() ? 300 : 400;
<a name="8815"></a>
<a name="8816"></a>        /* return the scheduling order */
<a name="8817"></a>        return scheduleOrder;
<a name="8818"></a>    }
<a name="8819"></a>
<a name="8820"></a>    /*
<a name="8821"></a>     *   Determine if we're ready to do something on our turn.  We're
<a name="8822"></a>     *   ready to do something if we're not waiting for another actor to
<a name="8823"></a>     *   finish doing something and either we're the player character or
<a name="8824"></a>     *   we already have a pending command in our command queue.  
<a name="8825"></a>     */
<a name="8826"></a>    readyForTurn()
<a name="8827"></a>    {
<a name="8828"></a>        /* 
<a name="8829"></a>         *   if we're waiting for another actor, we're not ready to do
<a name="8830"></a>         *   anything 
<a name="8831"></a>         */
<a name="8832"></a>        if (checkWaitingForActor())
<a name="8833"></a>            return nil;
<a name="8834"></a>
<a name="8835"></a>        /* 
<a name="8836"></a>         *   if we're the player character, we're always ready to take a
<a name="8837"></a>         *   turn as long as we're not waiting for another actor (which we
<a name="8838"></a>         *   now know we're not), because we can either execute one of our
<a name="8839"></a>         *   previously queued commands, or we can ask for a new command
<a name="8840"></a>         *   to perform 
<a name="8841"></a>         */
<a name="8842"></a>        if (isPlayerChar())
<a name="8843"></a>            return true;
<a name="8844"></a>
<a name="8845"></a>        /* 
<a name="8846"></a>         *   if we have something other than placeholders in our command
<a name="8847"></a>         *   queue, we're ready to take a turn, because we can execute the
<a name="8848"></a>         *   next command in our queue 
<a name="8849"></a>         */
<a name="8850"></a>        if (pendingCommand.indexWhich({x: x.hasCommand}) != nil)
<a name="8851"></a>            return true;
<a name="8852"></a>
<a name="8853"></a>        /* 
<a name="8854"></a>         *   we have no specific work to do, so we're not ready for our
<a name="8855"></a>         *   next turn 
<a name="8856"></a>         */
<a name="8857"></a>        return nil;
<a name="8858"></a>    }
<a name="8859"></a>
<a name="8860"></a>    /*
<a name="8861"></a>     *   Check to see if we're waiting for another actor to do something.
<a name="8862"></a>     *   Return true if so, nil if not.  If we've been waiting for another
<a name="8863"></a>     *   actor, and the actor has finished the task we've been waiting for
<a name="8864"></a>     *   since the last time we checked, we'll clean up our internal state
<a name="8865"></a>     *   relating to the wait and return nil.  
<a name="8866"></a>     */
<a name="8867"></a>    checkWaitingForActor()
<a name="8868"></a>    {
<a name="8869"></a>        local cmdIdx;
<a name="8870"></a>        local idx;
<a name="8871"></a>
<a name="8872"></a>        /* if we're not waiting for an actor, simply return nil */
<a name="8873"></a>        if (waitingForActor == nil)
<a name="8874"></a>            return nil;
<a name="8875"></a>
<a name="8876"></a>        /* 
<a name="8877"></a>         *   We're waiting for an actor to complete a command.  Check to
<a name="8878"></a>         *   see if the completion marker is still in the actor's queue; if
<a name="8879"></a>         *   it's not, then the other actor has already completed our task.
<a name="8880"></a>         *   If the completion marker is in the other actor's queue, but
<a name="8881"></a>         *   there are no command entries before it, then we're also done
<a name="8882"></a>         *   waiting, because we're not actually waiting for the completion
<a name="8883"></a>         *   marker but instead for the tasks that were ahead of it in the
<a name="8884"></a>         *   main game execution loop.
<a name="8885"></a>         *   
<a name="8886"></a>         *   So, find the index of our marker in the queue, and find the
<a name="8887"></a>         *   index of the first real command in the queue.  If our marker
<a name="8888"></a>         *   is still in the queue, and there's a command in the queue
<a name="8889"></a>         *   before our marker, the actor we're waiting for still has
<a name="8890"></a>         *   things to do before we're ready, so we're still waiting.  
<a name="8891"></a>         */
<a name="8892"></a>        idx = waitingForActor.pendingCommand.indexOf(waitingForInfo);
<a name="8893"></a>        cmdIdx = waitingForActor.pendingCommand.indexWhich({x: x.hasCommand});
<a name="8894"></a>        if (idx != nil &amp;&amp; cmdIdx != nil &amp;&amp; idx &gt; cmdIdx)
<a name="8895"></a>        {
<a name="8896"></a>            /* 
<a name="8897"></a>             *   The marker is still in the queue, and there's at least
<a name="8898"></a>             *   one other command ahead of it, so the other actor hasn't
<a name="8899"></a>             *   finished the task we've been waiting for.  Tell the
<a name="8900"></a>             *   caller that we are indeed still waiting for someone.  
<a name="8901"></a>             */
<a name="8902"></a>            return true;
<a name="8903"></a>        }
<a name="8904"></a>
<a name="8905"></a>        /*
<a name="8906"></a>         *   The other actor has disposed of our end-marker (or is about
<a name="8907"></a>         *   to, because it's the next thing left in the actor's queue),
<a name="8908"></a>         *   so it has finished with all of the commands we have been
<a name="8909"></a>         *   waiting for.  However, if I haven't caught up in game clock
<a name="8910"></a>         *   time with the actor I've been waiting for, I'm still waiting.
<a name="8911"></a>         */
<a name="8912"></a>        if (waitingForActor.nextRunTime &gt; nextRunTime)
<a name="8913"></a>            return true;
<a name="8914"></a>
<a name="8915"></a>        /* we're done waiting - forget our wait status information */
<a name="8916"></a>        waitingForActor = nil;
<a name="8917"></a>        waitingForInfo = nil;
<a name="8918"></a>
<a name="8919"></a>        /* tell the caller we're no longer waiting for anyone */
<a name="8920"></a>        return nil;
<a name="8921"></a>    }
<a name="8922"></a>
<a name="8923"></a>    /* the action the actor performed most recently */
<a name="8924"></a>    mostRecentAction = nil
<a name="8925"></a>
<a name="8926"></a>    /*
<a name="8927"></a>     *   Add busy time.  An action calls this when we are the actor
<a name="8928"></a>     *   performing the action, and the action consumes game time.  This
<a name="8929"></a>     *   marks us as busy for the given time units.  
<a name="8930"></a>     */
<a name="8931"></a>    addBusyTime(action, units)
<a name="8932"></a>    {
<a name="8933"></a>        /* note the action being performed */
<a name="8934"></a>        mostRecentAction = action;
<a name="8935"></a>
<a name="8936"></a>        /* adjust the next run time by the busy time */
<a name="8937"></a>        nextRunTime += units;
<a name="8938"></a>    }
<a name="8939"></a>
<a name="8940"></a>    /*
<a name="8941"></a>     *   When it's our turn and we don't have any command to perform,
<a name="8942"></a>     *   we'll call this routine, which can perform a scripted operation
<a name="8943"></a>     *   if desired.  
<a name="8944"></a>     */
<a name="8945"></a>    idleTurn()
<a name="8946"></a>    {
<a name="8947"></a>        local tCur = Schedulable.gameClockTime;
<a name="8948"></a>        local origNextRunTime = nextRunTime;
<a name="8949"></a>        
<a name="8950"></a>        /* 
<a name="8951"></a>         *   if we haven't been targeted for conversation on this turn,
<a name="8952"></a>         *   see if we have a conversation we want to start 
<a name="8953"></a>         */
<a name="8954"></a>        if (lastConvTime &lt; tCur)
<a name="8955"></a>        {
<a name="8956"></a>            /* check for a conversation that's ready to go */
<a name="8957"></a>            local info = pendingConv.valWhich({x: tCur &gt;= x.time_});
<a name="8958"></a>
<a name="8959"></a>            /* if we found one, kick it off */
<a name="8960"></a>            if (info != nil)
<a name="8961"></a>            {
<a name="8962"></a>                /* remove it from the list */
<a name="8963"></a>                pendingConv.removeElement(info);
<a name="8964"></a>
<a name="8965"></a>                /* start the conversation */
<a name="8966"></a>                initiateConversation(info.state_, info.node_);
<a name="8967"></a>            }
<a name="8968"></a>        }
<a name="8969"></a>
<a name="8970"></a>        /* notify our state object that we're taking a turn */
<a name="8971"></a>        curState.takeTurn();
<a name="8972"></a>
<a name="8973"></a>        /* 
<a name="8974"></a>         *   If we haven't already adjusted our next run time, consume a
<a name="8975"></a>         *   turn, so we're not ready to run again until the next game time
<a name="8976"></a>         *   increment.  In some cases, we'll already have made this
<a name="8977"></a>         *   adjustment; for example, we might have run a nested command
<a name="8978"></a>         *   within our state object's takeTurn() method.  
<a name="8979"></a>         */
<a name="8980"></a>        if (nextRunTime == origNextRunTime)
<a name="8981"></a>            ++nextRunTime;
<a name="8982"></a>    }
<a name="8983"></a>
<a name="8984"></a>    /*
<a name="8985"></a>     *   Receive notification that this is a non-idle turn.  This is
<a name="8986"></a>     *   called whenever a command in our pending command queue is about
<a name="8987"></a>     *   to be executed.
<a name="8988"></a>     *   
<a name="8989"></a>     *   This method need not do anything at all, since the caller will
<a name="8990"></a>     *   take care of running the pending command.  The purpose of this
<a name="8991"></a>     *   method is to take care of any changes an actor wants to make when
<a name="8992"></a>     *   it receives an explicit command, as opposed to running its own
<a name="8993"></a>     *   autonomous activity.
<a name="8994"></a>     *   
<a name="8995"></a>     *   By default, we cancel follow mode if it's in effect.  It usually
<a name="8996"></a>     *   makes sense for an explicit command to interrupt follow mode;
<a name="8997"></a>     *   follow mode is usually started by an explicit command in the
<a name="8998"></a>     *   first place, so it is usually sensible for a new command to
<a name="8999"></a>     *   replace the one that started follow mode.
<a name="9000"></a>     */
<a name="9001"></a>    nonIdleTurn()
<a name="9002"></a>    {
<a name="9003"></a>        /* by default, cancel follow mode */
<a name="9004"></a>        followingActor = nil;
<a name="9005"></a>    }
<a name="9006"></a>
<a name="9007"></a>    /*
<a name="9008"></a>     *   If we're following an actor, this keeps track of the actor we're
<a name="9009"></a>     *   following.  NPC's can use this to follow around another actor
<a name="9010"></a>     *   whenever possible.  
<a name="9011"></a>     */
<a name="9012"></a>    followingActor = nil
<a name="9013"></a>
<a name="9014"></a>    /*
<a name="9015"></a>     *   Handle a situation where we're trying to follow an actor but
<a name="9016"></a>     *   can't.  By default, this simply cancels our follow mode.
<a name="9017"></a>     *   
<a name="9018"></a>     *   Actors might want to override this to be more tolerant.  For
<a name="9019"></a>     *   example, an actor might want to wait until five turns elapse to
<a name="9020"></a>     *   give up on following, in case the target actor returns after a
<a name="9021"></a>     *   brief digression; or an actor could stay in follow mode until it
<a name="9022"></a>     *   received other instructions, or found something better to do.  
<a name="9023"></a>     */
<a name="9024"></a>    cannotFollow()
<a name="9025"></a>    {
<a name="9026"></a>        /* 
<a name="9027"></a>         *   by default, simply cancel follow mode by forgetting about the
<a name="9028"></a>         *   actor we're following
<a name="9029"></a>         */
<a name="9030"></a>        followingActor = nil;
<a name="9031"></a>    }
<a name="9032"></a>
<a name="9033"></a>    /*
<a name="9034"></a>     *   Execute one "turn" - this is a unit of time passing.  The player
<a name="9035"></a>     *   character generally is allowed to execute one command in the
<a name="9036"></a>     *   course of a turn; a non-player character with a programmed task
<a name="9037"></a>     *   can perform an increment of the task.
<a name="9038"></a>     *   
<a name="9039"></a>     *   We set up an ActorTurnAction environment and invoke our
<a name="9040"></a>     *   executeActorTurn() method.  In most cases, subclasses should
<a name="9041"></a>     *   override executeActorTurn() rather than this method, since
<a name="9042"></a>     *   overriding executeTurn() directly will lose the action
<a name="9043"></a>     *   environment.  
<a name="9044"></a>     */
<a name="9045"></a>    executeTurn()
<a name="9046"></a>    {
<a name="9047"></a>        /* start a new command visually when a new actor is taking over */
<a name="9048"></a>        "&lt;.commandsep&gt;";
<a name="9049"></a>        
<a name="9050"></a>        /* 
<a name="9051"></a>         *   Execute the turn in a daemon action context, and in the sight
<a name="9052"></a>         *   context of the actor.  The sense context will ensure that we
<a name="9053"></a>         *   report the results of the action only if the actor is visible
<a name="9054"></a>         *   to the player character; in most cases, the actor's
<a name="9055"></a>         *   visibility is equivalent to the visibility of the effects, so
<a name="9056"></a>         *   this provides a simple way of ensuring that the results of
<a name="9057"></a>         *   the action are reported if and only if they're visible to the
<a name="9058"></a>         *   player character.
<a name="9059"></a>         *   
<a name="9060"></a>         *   Note that if we are the player character, don't use the sense
<a name="9061"></a>         *   context filtering -- we normally want full reports for
<a name="9062"></a>         *   everything the player character does.  
<a name="9063"></a>         */
<a name="9064"></a>        return withActionEnv(EventAction, self,
<a name="9065"></a>            {: callWithSenseContext(isPlayerChar() ? nil : self, sight,
<a name="9066"></a>                                    {: executeActorTurn() }) });
<a name="9067"></a>    }
<a name="9068"></a>
<a name="9069"></a>    /* 
<a name="9070"></a>     *   The main processing for an actor's turn.  In most cases,
<a name="9071"></a>     *   subclasses should override this method (rather than executeTurn)
<a name="9072"></a>     *   to specialize an actor's turn processing. 
<a name="9073"></a>     */
<a name="9074"></a>    executeActorTurn()
<a name="9075"></a>    {
<a name="9076"></a>        /*
<a name="9077"></a>         *   If we have a pending response, and we're in a position to
<a name="9078"></a>         *   deliver it, our next work is to deliver the pending response.
<a name="9079"></a>         */
<a name="9080"></a>        if (pendingResponse != nil &amp;&amp; canTalkTo(pendingResponse.issuer_))
<a name="9081"></a>        {
<a name="9082"></a>            /* 
<a name="9083"></a>             *   We have a pending response, and the command issuer from
<a name="9084"></a>             *   the pending response can hear us now, so we can finally
<a name="9085"></a>             *   deliver the response.
<a name="9086"></a>             *   
<a name="9087"></a>             *   If the issuer is the player character, send to the player
<a name="9088"></a>             *   using our deferred message generator; otherwise, call the
<a name="9089"></a>             *   issuer's notification routine, since it's an NPC-to-NPC
<a name="9090"></a>             *   notification.  
<a name="9091"></a>             */
<a name="9092"></a>            if (pendingResponse.issuer_.isPlayerChar())
<a name="9093"></a>            {
<a name="9094"></a>                /* 
<a name="9095"></a>                 *   we're notifying the player - use the deferred message
<a name="9096"></a>                 *   generator 
<a name="9097"></a>                 */
<a name="9098"></a>                getParserDeferredMessageObj().(pendingResponse.prop_)(
<a name="9099"></a>                    self, pendingResponse.args_...);
<a name="9100"></a>            }
<a name="9101"></a>            else
<a name="9102"></a>            {
<a name="9103"></a>                /* it's an NPC-to-NPC notification - notify the issuer */
<a name="9104"></a>                pendingResponse.issuer_.notifyIssuerParseFailure(
<a name="9105"></a>                    self, pendingResponse.prop_, pendingResponse.args_);
<a name="9106"></a>            }
<a name="9107"></a>
<a name="9108"></a>            /* 
<a name="9109"></a>             *   in either case, we've gotten this out of our system now,
<a name="9110"></a>             *   so we can forget about the pending response 
<a name="9111"></a>             */
<a name="9112"></a>            pendingResponse = nil;
<a name="9113"></a>        }
<a name="9114"></a>            
<a name="9115"></a>        /* check to see if we're waiting for another actor */
<a name="9116"></a>        if (checkWaitingForActor())
<a name="9117"></a>        {
<a name="9118"></a>            /* 
<a name="9119"></a>             *   we're still waiting, so there's nothing for us to do; take
<a name="9120"></a>             *   an idle turn and return 
<a name="9121"></a>             */
<a name="9122"></a>            idleTurn();
<a name="9123"></a>            return true;
<a name="9124"></a>        }
<a name="9125"></a>            
<a name="9126"></a>        /* 
<a name="9127"></a>         *   if we're the player character, and we have no pending commands
<a name="9128"></a>         *   to execute, our next task will be to read and execute a
<a name="9129"></a>         *   command 
<a name="9130"></a>         */
<a name="9131"></a>        if (pendingCommand.length() == 0 &amp;&amp; isPlayerChar())
<a name="9132"></a>        {
<a name="9133"></a>            local toks;
<a name="9134"></a>            
<a name="9135"></a>            /* read a command line and get the resulting token list */
<a name="9136"></a>            toks = readMainCommandTokens(rmcCommand);
<a name="9137"></a>            
<a name="9138"></a>            /* 
<a name="9139"></a>             *   re-activate the main transcript - reading the command
<a name="9140"></a>             *   line will have deactivated the transcript, but we want it
<a name="9141"></a>             *   active again now that we're about to start executing the
<a name="9142"></a>             *   command 
<a name="9143"></a>             */
<a name="9144"></a>            gTranscript.activate();
<a name="9145"></a>            
<a name="9146"></a>            /* 
<a name="9147"></a>             *   If it came back nil, it means that the input was fully
<a name="9148"></a>             *   processed in pre-parsing; this means that we don't have
<a name="9149"></a>             *   any more work to do on this turn, so we can simply end our
<a name="9150"></a>             *   turn now.  
<a name="9151"></a>             */
<a name="9152"></a>            if (toks == nil)
<a name="9153"></a>                return true;
<a name="9154"></a>            
<a name="9155"></a>            /* retrieve the token list from the command line */
<a name="9156"></a>            toks = toks[2];
<a name="9157"></a>            
<a name="9158"></a>            /* 
<a name="9159"></a>             *   Add it to our pending command queue.  Since we read the
<a name="9160"></a>             *   command from the player, and we're the player character,
<a name="9161"></a>             *   we treat the command as coming from myself.
<a name="9162"></a>             *   
<a name="9163"></a>             *   Since this is a newly-read command line, we're starting a
<a name="9164"></a>             *   new sentence.  
<a name="9165"></a>             */
<a name="9166"></a>            addPendingCommand(true, self, toks);
<a name="9167"></a>        }
<a name="9168"></a>
<a name="9169"></a>        /*
<a name="9170"></a>         *   Check to see if we have any pending command to execute.  If
<a name="9171"></a>         *   so, our next task is to execute the pending command.  
<a name="9172"></a>         */
<a name="9173"></a>        if (pendingCommand.length() != 0)
<a name="9174"></a>        {
<a name="9175"></a>            local cmd;
<a name="9176"></a>            
<a name="9177"></a>            /* remove the first pending command from our queue */
<a name="9178"></a>            cmd = pendingCommand[1];
<a name="9179"></a>            pendingCommand.removeElementAt(1);
<a name="9180"></a>            
<a name="9181"></a>            /* if this is a real command, note the non-idle turn */
<a name="9182"></a>            if (cmd.hasCommand)
<a name="9183"></a>                nonIdleTurn();
<a name="9184"></a>            
<a name="9185"></a>            /* execute the first pending command */
<a name="9186"></a>            cmd.executePending(self);
<a name="9187"></a>            
<a name="9188"></a>            /* 
<a name="9189"></a>             *   We're done with this turn.  If we no longer have any
<a name="9190"></a>             *   pending commands, tell the scheduler to refigure the
<a name="9191"></a>             *   execution order, since another object might now be ready
<a name="9192"></a>             *   to run ahead of our idle activity.  
<a name="9193"></a>             */
<a name="9194"></a>            if (pendingCommand.indexWhich({x: x.hasCommand}) == nil)
<a name="9195"></a>                return nil;
<a name="9196"></a>            else
<a name="9197"></a>                return true;
<a name="9198"></a>        }
<a name="9199"></a>        
<a name="9200"></a>        /*
<a name="9201"></a>         *   If we're following an actor, and the actor isn't in sight, see
<a name="9202"></a>         *   if we can catch up.  
<a name="9203"></a>         */
<a name="9204"></a>        if (followingActor != nil
<a name="9205"></a>            &amp;&amp; location != nil
<a name="9206"></a>            &amp;&amp; (followingActor.location.effectiveFollowLocation
<a name="9207"></a>                != location.effectiveFollowLocation))
<a name="9208"></a>        {
<a name="9209"></a>            local info;
<a name="9210"></a>            
<a name="9211"></a>            /* see if we have enough information to follow */
<a name="9212"></a>            info = getFollowInfo(followingActor);
<a name="9213"></a>                
<a name="9214"></a>            /* 
<a name="9215"></a>             *   Check to see if we have enough information to follow the
<a name="9216"></a>             *   actor.  We can only follow if we saw the actor depart at
<a name="9217"></a>             *   some point, and we're in the same location where we last
<a name="9218"></a>             *   saw the actor depart.  (We have to be in the same
<a name="9219"></a>             *   location, because we follow by performing the same command
<a name="9220"></a>             *   we saw the actor perform when we last saw the actor
<a name="9221"></a>             *   depart.  Repeating the command will obviously be
<a name="9222"></a>             *   ineffective unless we're in the same location as the actor
<a name="9223"></a>             *   was.)  
<a name="9224"></a>             */
<a name="9225"></a>            if (info != nil)
<a name="9226"></a>            {
<a name="9227"></a>                local success;
<a name="9228"></a>                
<a name="9229"></a>                /* 
<a name="9230"></a>                 *   we know how to follow the actor, so simply perform
<a name="9231"></a>                 *   the same command we saw the actor perform.  
<a name="9232"></a>                 */
<a name="9233"></a>                newActorAction(self, Follow, followingActor);
<a name="9234"></a>                
<a name="9235"></a>                /* note whether or not we succeeded */
<a name="9236"></a>                success = (location.effectiveFollowLocation ==
<a name="9237"></a>                           followingActor.location.effectiveFollowLocation);
<a name="9238"></a>                    
<a name="9239"></a>                /* notify the state object of our attempt */
<a name="9240"></a>                curState.justFollowed(success);
<a name="9241"></a>                
<a name="9242"></a>                /* 
<a name="9243"></a>                 *   if we failed to track the actor, note that we are
<a name="9244"></a>                 *   unable to follow the actor 
<a name="9245"></a>                 */
<a name="9246"></a>                if (!success)
<a name="9247"></a>                {
<a name="9248"></a>                    /* note that we failed to follow the actor */
<a name="9249"></a>                    cannotFollow();
<a name="9250"></a>                }
<a name="9251"></a>                
<a name="9252"></a>                /* we're done with this turn */
<a name="9253"></a>                return true;
<a name="9254"></a>            }
<a name="9255"></a>            else
<a name="9256"></a>            {
<a name="9257"></a>                /* 
<a name="9258"></a>                 *   we don't know how to follow this actor - call our
<a name="9259"></a>                 *   cannot-follow handler 
<a name="9260"></a>                 */
<a name="9261"></a>                cannotFollow();
<a name="9262"></a>            }
<a name="9263"></a>        }
<a name="9264"></a>
<a name="9265"></a>        /* we have no pending work to perform, so take an idle turn */
<a name="9266"></a>        idleTurn();
<a name="9267"></a>        
<a name="9268"></a>        /* no change in scheduling priority */
<a name="9269"></a>        return true;
<a name="9270"></a>    }
<a name="9271"></a>
<a name="9272"></a>    /*
<a name="9273"></a>     *   By default, all actors are likely command targets.  This should
<a name="9274"></a>     *   be overridden for actors who are obviously not likely to accept
<a name="9275"></a>     *   commands of any kind.
<a name="9276"></a>     *   
<a name="9277"></a>     *   This is used to disambiguate target actors in commands, so this
<a name="9278"></a>     *   should provide an indication of what should be obvious to a
<a name="9279"></a>     *   player, because the purpose of this information is to guess what
<a name="9280"></a>     *   the player is likely to take for granted in specifying a target
<a name="9281"></a>     *   actor.
<a name="9282"></a>     */
<a name="9283"></a>    isLikelyCommandTarget = true
<a name="9284"></a>
<a name="9285"></a>    /*
<a name="9286"></a>     *   Determine if we should accept a command.  'issuingActor' is the
<a name="9287"></a>     *   actor who issued the command: if the player typed the command on
<a name="9288"></a>     *   the command line, this will be the player character actor.
<a name="9289"></a>     *   
<a name="9290"></a>     *   This routine performs only the simplest check, since it doesn't
<a name="9291"></a>     *   have access to the specific action being performed.  This is
<a name="9292"></a>     *   intended as a first check, to allow us to bypass noun resolution
<a name="9293"></a>     *   if the actor simply won't accept any command from the issuer.
<a name="9294"></a>     *   
<a name="9295"></a>     *   Returns true to accept a command, nil to reject it.  If this
<a name="9296"></a>     *   routine returns nil, and the command came from the player
<a name="9297"></a>     *   character, a suitable message should be displayed.
<a name="9298"></a>     *   
<a name="9299"></a>     *   Note that most actors should not override this routine simply to
<a name="9300"></a>     *   express the will of the actor to accept a command, since this
<a name="9301"></a>     *   routine performs a number of checks for the physical ability of
<a name="9302"></a>     *   the actor to execute a command from the issuer.  To determine
<a name="9303"></a>     *   whether or not the actor should obey physically valid commands
<a name="9304"></a>     *   from the issuer, override obeyCommand().  
<a name="9305"></a>     */
<a name="9306"></a>    acceptCommand(issuingActor)
<a name="9307"></a>    {
<a name="9308"></a>        /* if we're the current player character, accept any command */
<a name="9309"></a>        if (isPlayerChar())
<a name="9310"></a>            return true;
<a name="9311"></a>
<a name="9312"></a>        /* if we can't hear the issuer, we can't talk to it */
<a name="9313"></a>        if (issuingActor != self &amp;&amp; !issuingActor.canTalkTo(self))
<a name="9314"></a>        {
<a name="9315"></a>            /* report that the target actor can't hear the issuer */
<a name="9316"></a>            reportFailure(&amp;objCannotHearActorMsg, self);
<a name="9317"></a>
<a name="9318"></a>            /* tell the caller that the command cannot proceed */
<a name="9319"></a>            return nil;
<a name="9320"></a>        }
<a name="9321"></a>
<a name="9322"></a>        /* if I'm busy doing something else, say so */
<a name="9323"></a>        if (nextRunTime &gt; Schedulable.gameClockTime)
<a name="9324"></a>        {
<a name="9325"></a>            /* tell the issuing actor I'm busy */
<a name="9326"></a>            notifyParseFailure(issuingActor, &amp;refuseCommandBusy,
<a name="9327"></a>                               [issuingActor]);
<a name="9328"></a>
<a name="9329"></a>            /* tell the caller to abandon the command */
<a name="9330"></a>            return nil;
<a name="9331"></a>        }
<a name="9332"></a>
<a name="9333"></a>        /* check to see if I have other work to perform first */
<a name="9334"></a>        if (!acceptCommandBusy(issuingActor))
<a name="9335"></a>            return nil;
<a name="9336"></a>
<a name="9337"></a>        /* we didn't find any reason to object, so allow the command */
<a name="9338"></a>        return true;
<a name="9339"></a>    }
<a name="9340"></a>
<a name="9341"></a>    /*
<a name="9342"></a>     *   Check to see if I'm busy with pending commands, and if so,
<a name="9343"></a>     *   whether or not I should accept a new command.  Returns true if we
<a name="9344"></a>     *   should accept a command, nil if not.  If we return nil, we must
<a name="9345"></a>     *   notify the issuer of the rejection.
<a name="9346"></a>     *   
<a name="9347"></a>     *   By default, we won't accept a command if we have any work
<a name="9348"></a>     *   pending.  
<a name="9349"></a>     */
<a name="9350"></a>    acceptCommandBusy(issuingActor)
<a name="9351"></a>    {
<a name="9352"></a>        /* if we have any pending commands, don't accept a new command */
<a name="9353"></a>        if (pendingCommand.length() != 0)
<a name="9354"></a>        {
<a name="9355"></a>            /* 
<a name="9356"></a>             *   if we have only commands from the same issuer pending,
<a name="9357"></a>             *   cancel all of the pending commands and accept the new
<a name="9358"></a>             *   command instead 
<a name="9359"></a>             */
<a name="9360"></a>            foreach (local info in pendingCommand)
<a name="9361"></a>            {
<a name="9362"></a>                /* 
<a name="9363"></a>                 *   if this is from a different issuer, don't accept a
<a name="9364"></a>                 *   new command 
<a name="9365"></a>                 */
<a name="9366"></a>                if (info.issuer_ != issuingActor)
<a name="9367"></a>                {
<a name="9368"></a>                    /* tell the other actor that we're busy */
<a name="9369"></a>                    notifyParseFailure(issuingActor, &amp;refuseCommandBusy,
<a name="9370"></a>                                       [issuingActor]);
<a name="9371"></a>
<a name="9372"></a>                    /* tell the caller to abandon the command */
<a name="9373"></a>                    return nil;
<a name="9374"></a>                }
<a name="9375"></a>            }
<a name="9376"></a>
<a name="9377"></a>            /* 
<a name="9378"></a>             *   all of the pending commands were from the same issuer, so
<a name="9379"></a>             *   presumably the issuer wants to override those commands;
<a name="9380"></a>             *   remove the old ones from our pending queue
<a name="9381"></a>             */
<a name="9382"></a>            pendingCommand.removeRange(1, pendingCommand.length());
<a name="9383"></a>        }
<a name="9384"></a>
<a name="9385"></a>        /* we didn't find any problems */
<a name="9386"></a>        return true;
<a name="9387"></a>    }
<a name="9388"></a>
<a name="9389"></a>    /*
<a name="9390"></a>     *   Determine whether or not we want to obey a command from the given
<a name="9391"></a>     *   actor to perform the given action.  We only get this far when we
<a name="9392"></a>     *   determine that it's possible for us to accept a command, given
<a name="9393"></a>     *   the sense connections between us and the issuing actor, and given
<a name="9394"></a>     *   our pending command queue.
<a name="9395"></a>     *   
<a name="9396"></a>     *   When this routine is called, the action has been determined, and
<a name="9397"></a>     *   the noun phrases have been resolved.  However, we haven't
<a name="9398"></a>     *   actually started processing the action yet, so the globals for
<a name="9399"></a>     *   the noun slots (gDobj, gIobj, etc) are NOT available.  If the
<a name="9400"></a>     *   routine needs to know which objects are involved, it must obtain
<a name="9401"></a>     *   the full list of resolved objects from the action (using, for
<a name="9402"></a>     *   example, getResolvedDobjList()).
<a name="9403"></a>     *   
<a name="9404"></a>     *   When there's a list of objects to be processed (as in GET ALL),
<a name="9405"></a>     *   we haven't started working on any one of them yet - this check is
<a name="9406"></a>     *   made once for the entire command, and applies to the entire list
<a name="9407"></a>     *   of objects.  If the actor wants to respond specially to
<a name="9408"></a>     *   individual objects, you can do that by overriding actorAction()
<a name="9409"></a>     *   instead of this routine.
<a name="9410"></a>     *   
<a name="9411"></a>     *   This routine should display an appropriate message and return nil
<a name="9412"></a>     *   if the command is not to be accepted, and should simply return
<a name="9413"></a>     *   true to accept the command.
<a name="9414"></a>     *   
<a name="9415"></a>     *   By default, we'll let our state object handle this.
<a name="9416"></a>     *   
<a name="9417"></a>     *   Note that actors that override this might also need to override
<a name="9418"></a>     *   wantsFollowInfo(), since an actor that accepts "follow" commands
<a name="9419"></a>     *   will need to keep track of the movements of other actors if it is
<a name="9420"></a>     *   to carry out any following.  
<a name="9421"></a>     */
<a name="9422"></a>    obeyCommand(issuingActor, action)
<a name="9423"></a>    {
<a name="9424"></a>        /* note that the issuing actor is targeting me in conversation */
<a name="9425"></a>        issuingActor.noteConversation(self);
<a name="9426"></a>
<a name="9427"></a>        /* let the state object handle it */
<a name="9428"></a>        return curState.obeyCommand(issuingActor, action);
<a name="9429"></a>    }
<a name="9430"></a>    
<a name="9431"></a>    /* 
<a name="9432"></a>     *   Say hello/goodbye/yes/no to the given actor.  We'll greet the
<a name="9433"></a>     *   target actor is the target actor was specified (i.e., actor !=
<a name="9434"></a>     *   self); otherwise, we'll greet our current default conversational
<a name="9435"></a>     *   partner, if we have one.  
<a name="9436"></a>     */
<a name="9437"></a>    sayHello(actor) { sayToActor(actor, helloTopicObj, helloConvType); }
<a name="9438"></a>    sayGoodbye(actor) { sayToActor(actor, byeTopicObj, byeConvType); }
<a name="9439"></a>    sayYes(actor) { sayToActor(actor, yesTopicObj, yesConvType); }
<a name="9440"></a>    sayNo(actor) { sayToActor(actor, noTopicObj, noConvType); }
<a name="9441"></a>
<a name="9442"></a>    /* handle one of the conversational addresses */
<a name="9443"></a>    sayToActor(actor, topic, convType)
<a name="9444"></a>    {
<a name="9445"></a>        /*
<a name="9446"></a>         *   If the target actor is the same as the issuing actor, then no
<a name="9447"></a>         *   target actor was specified in the command, so direct the
<a name="9448"></a>         *   address to our current conversational partner, if we have
<a name="9449"></a>         *   one. 
<a name="9450"></a>         */
<a name="9451"></a>        if (actor == self)
<a name="9452"></a>            actor = getDefaultInterlocutor();
<a name="9453"></a>
<a name="9454"></a>        /* 
<a name="9455"></a>         *   if we found an actor, send the address to the actor's state
<a name="9456"></a>         *   object; otherwise, handle it with the given default message 
<a name="9457"></a>         */
<a name="9458"></a>        if (actor != nil)
<a name="9459"></a>        {
<a name="9460"></a>            /* make sure we can talk to the other actor */
<a name="9461"></a>            if (!canTalkTo(actor))
<a name="9462"></a>            {
<a name="9463"></a>                /* can't talk to them - say so and give up */
<a name="9464"></a>                reportFailure(&amp;objCannotHearActorMsg, actor);
<a name="9465"></a>                exit;
<a name="9466"></a>            }
<a name="9467"></a>
<a name="9468"></a>            /* remember our current conversational partner */
<a name="9469"></a>            noteConversation(actor);
<a name="9470"></a>            
<a name="9471"></a>            /* handle it as a topic */
<a name="9472"></a>            actor.curState.handleConversation(self, topic, convType);
<a name="9473"></a>        }
<a name="9474"></a>        else
<a name="9475"></a>        {
<a name="9476"></a>            /* 
<a name="9477"></a>             *   we don't know whom we're addressing; just show the default
<a name="9478"></a>             *   message for an unknown interlocutor
<a name="9479"></a>             */
<a name="9480"></a>            mainReport(convType.unknownMsg);
<a name="9481"></a>        }
<a name="9482"></a>    }
<a name="9483"></a>
<a name="9484"></a>    /* 
<a name="9485"></a>     *   Handle the XSPCLTOPIC pseudo-command.  This command is generated
<a name="9486"></a>     *   by the SpecialTopic pre-parser when it recognizes the player's
<a name="9487"></a>     *   input as matching an active SpecialTopic's custom syntax.  Our
<a name="9488"></a>     *   job is to route this back to our current interlocutor's active
<a name="9489"></a>     *   ConvNode, so that it can find the SpecialTopic that it matched in
<a name="9490"></a>     *   pre-parsing and show its response. 
<a name="9491"></a>     */
<a name="9492"></a>    saySpecialTopic()
<a name="9493"></a>    {
<a name="9494"></a>        local actor;
<a name="9495"></a>        
<a name="9496"></a>        /* send it to our interlocutor */
<a name="9497"></a>        if ((actor = getCurrentInterlocutor()) == nil
<a name="9498"></a>            || actor.curConvNode == nil)
<a name="9499"></a>        {
<a name="9500"></a>            /*
<a name="9501"></a>             *   We don't seem to have a current interlocutor, or the
<a name="9502"></a>             *   interlocutor doesn't have a current conversation node.
<a name="9503"></a>             *   This is inconsistent; there's no way we could have
<a name="9504"></a>             *   generated XSPCLTOPIC from our pre-parser under these
<a name="9505"></a>             *   conditions.  The most likely thing is that the player
<a name="9506"></a>             *   tried typing in XSPCLTOPIC manually.  Politely ignore it. 
<a name="9507"></a>             */
<a name="9508"></a>            gLibMessages.commandNotPresent;
<a name="9509"></a>        }
<a name="9510"></a>        else
<a name="9511"></a>        {
<a name="9512"></a>            /* note the conversation directed to the other actor */
<a name="9513"></a>            noteConversation(actor);
<a name="9514"></a>
<a name="9515"></a>            /* send the request to the ConvNode for processing */
<a name="9516"></a>            actor.curConvNode.saySpecialTopic(self);
<a name="9517"></a>        }
<a name="9518"></a>    }
<a name="9519"></a>
<a name="9520"></a>    /* 
<a name="9521"></a>     *   Add a command to our pending command list.  The new command is
<a name="9522"></a>     *   specified as a list of tokens to be parsed, and it is added after
<a name="9523"></a>     *   any commands already in our pending list.  
<a name="9524"></a>     */
<a name="9525"></a>    addPendingCommand(startOfSentence, issuer, toks)
<a name="9526"></a>    {
<a name="9527"></a>        /* add a descriptor to the pending command list */
<a name="9528"></a>        pendingCommand.append(
<a name="9529"></a>            new PendingCommandToks(startOfSentence, issuer, toks));
<a name="9530"></a>    }
<a name="9531"></a>
<a name="9532"></a>    /* 
<a name="9533"></a>     *   Insert a command at the head of our pending command list.  The
<a name="9534"></a>     *   new command is specified as a list of tokens to parse, and it is
<a name="9535"></a>     *   inserted into our pending command list before any commands
<a name="9536"></a>     *   already in the list.  
<a name="9537"></a>     */
<a name="9538"></a>    addFirstPendingCommand(startOfSentence, issuer, toks)
<a name="9539"></a>    {
<a name="9540"></a>        /* add a descriptor to the start of our list */
<a name="9541"></a>        pendingCommand.insertAt(
<a name="9542"></a>            1, new PendingCommandToks(startOfSentence, issuer, toks));
<a name="9543"></a>    }
<a name="9544"></a>
<a name="9545"></a>    /*
<a name="9546"></a>     *   Add a resolved action to our pending command list.  The new
<a name="9547"></a>     *   command is specified as a resolved Action object; it is added
<a name="9548"></a>     *   after any commands already in our list. 
<a name="9549"></a>     */
<a name="9550"></a>    addPendingAction(startOfSentence, issuer, action, [objs])
<a name="9551"></a>    {
<a name="9552"></a>        /* add a descriptor to the pending command list */
<a name="9553"></a>        pendingCommand.append(new PendingCommandAction(
<a name="9554"></a>            startOfSentence, issuer, action, objs...));
<a name="9555"></a>    }
<a name="9556"></a>
<a name="9557"></a>    /*
<a name="9558"></a>     *   Insert a resolved action at the start of our pending command
<a name="9559"></a>     *   list.  The new command is specified as a resolved Action object;
<a name="9560"></a>     *   it is added before any commands already in our list.  
<a name="9561"></a>     */
<a name="9562"></a>    addFirstPendingAction(startOfSentence, issuer, action, [objs])
<a name="9563"></a>    {
<a name="9564"></a>        /* add a descriptor to the pending command list */
<a name="9565"></a>        pendingCommand.insertAt(1, new PendingCommandAction(
<a name="9566"></a>            startOfSentence, issuer, action, objs...));
<a name="9567"></a>    }
<a name="9568"></a>
<a name="9569"></a>
<a name="9570"></a>    /* pending commands - this is a list of PendingCommandInfo objects */
<a name="9571"></a>    pendingCommand = nil
<a name="9572"></a>
<a name="9573"></a>    /* 
<a name="9574"></a>     *   pending response - this is a single PendingResponseInfo object,
<a name="9575"></a>     *   which we'll deliver as soon as the issuing actor is in a position
<a name="9576"></a>     *   to hear us 
<a name="9577"></a>     */
<a name="9578"></a>    pendingResponse = nil
<a name="9579"></a>
<a name="9580"></a>    /* 
<a name="9581"></a>     *   get the library message object for a parser message addressed to
<a name="9582"></a>     *   the player character 
<a name="9583"></a>     */
<a name="9584"></a>    getParserMessageObj()
<a name="9585"></a>    {
<a name="9586"></a>        /* 
<a name="9587"></a>         *   If I'm the player character, use the player character message
<a name="9588"></a>         *   object; otherwise, use the default non-player character
<a name="9589"></a>         *   message object.
<a name="9590"></a>         *   
<a name="9591"></a>         *   To customize parser messages from a particular actor, create
<a name="9592"></a>         *   an object based on npcMessages, and override this routine in
<a name="9593"></a>         *   the actor so that it returns the custom object rather than
<a name="9594"></a>         *   the standard npcMessages object.  To customize messages for
<a name="9595"></a>         *   ALL of the NPC's in a game, simply modify npcMessages itself,
<a name="9596"></a>         *   since it's the default for all non-player characters.  
<a name="9597"></a>         */
<a name="9598"></a>        return isPlayerChar() ? playerMessages : npcMessages;
<a name="9599"></a>    }
<a name="9600"></a>
<a name="9601"></a>    /*
<a name="9602"></a>     *   Get the deferred library message object for a parser message
<a name="9603"></a>     *   addressed to the player character.  We only use this to generate
<a name="9604"></a>     *   messages deferred from non-player characters.  
<a name="9605"></a>     */
<a name="9606"></a>    getParserDeferredMessageObj() { return npcDeferredMessages; }
<a name="9607"></a>
<a name="9608"></a>    /*
<a name="9609"></a>     *   Get the library message object for action responses.  This is
<a name="9610"></a>     *   used to generate library responses to verbs.  
<a name="9611"></a>     */
<a name="9612"></a>    getActionMessageObj()
<a name="9613"></a>    {
<a name="9614"></a>        /* 
<a name="9615"></a>         *   return the default player character or NPC message object,
<a name="9616"></a>         *   depending on whether I'm the player or not; individual actors
<a name="9617"></a>         *   can override this to supply actor-specific messages for
<a name="9618"></a>         *   library action responses 
<a name="9619"></a>         */
<a name="9620"></a>        return isPlayerChar() ? playerActionMessages: npcActionMessages;
<a name="9621"></a>    }
<a name="9622"></a>
<a name="9623"></a>    /* 
<a name="9624"></a>     *   Notify an issuer that a command sent to us resulted in a parsing
<a name="9625"></a>     *   failure.  We are meant to reply to the issuer to let the issuer
<a name="9626"></a>     *   know about the problem.  messageProp is the libGlobal message
<a name="9627"></a>     *   property describing the error, and args is a list with the
<a name="9628"></a>     *   (varargs) arguments to the message property.  
<a name="9629"></a>     */
<a name="9630"></a>    notifyParseFailure(issuingActor, messageProp, args)
<a name="9631"></a>    {
<a name="9632"></a>        /* 
<a name="9633"></a>         *   In case the actor is in a remote location but in scope for the
<a name="9634"></a>         *   purposes of the conversation only (such as over a phone or
<a name="9635"></a>         *   radio), run this in a neutral sense context.  Since we're
<a name="9636"></a>         *   reporting a parser failure, we want the message to be
<a name="9637"></a>         *   displayed no matter what the scope situation is. 
<a name="9638"></a>         */
<a name="9639"></a>        callWithSenseContext(nil, nil, new function()
<a name="9640"></a>        {
<a name="9641"></a>            /* check who's talking to whom */
<a name="9642"></a>            if (issuingActor.isPlayerChar())
<a name="9643"></a>            {
<a name="9644"></a>                /*
<a name="9645"></a>                 *   The player issued the command.  If the command was
<a name="9646"></a>                 *   directed to an NPC (i.e., we're not the player), check
<a name="9647"></a>                 *   to see if the player character is in scope from our
<a name="9648"></a>                 *   perspective.  
<a name="9649"></a>                 */
<a name="9650"></a>                if (issuingActor != self &amp;&amp; !canTalkTo(issuingActor))
<a name="9651"></a>                {
<a name="9652"></a>                    /* 
<a name="9653"></a>                     *   The player issued the command to an NPC, but the
<a name="9654"></a>                     *   player is not capable of hearing the NPC's
<a name="9655"></a>                     *   response.  
<a name="9656"></a>                     */
<a name="9657"></a>                    cannotRespondToCommand(issuingActor, messageProp, args);
<a name="9658"></a>                }
<a name="9659"></a>                else
<a name="9660"></a>                {
<a name="9661"></a>                    /* 
<a name="9662"></a>                     *   generate a message using the appropriate message
<a name="9663"></a>                     *   generator object 
<a name="9664"></a>                     */
<a name="9665"></a>                    getParserMessageObj().(messageProp)(self, args...);
<a name="9666"></a>                }
<a name="9667"></a>            }
<a name="9668"></a>            else
<a name="9669"></a>            {
<a name="9670"></a>                /*
<a name="9671"></a>                 *   the command was issued from one NPC to another -
<a name="9672"></a>                 *   notify the issuer of the problem, but don't display
<a name="9673"></a>                 *   any messages, since this interaction is purely among
<a name="9674"></a>                 *   the NPC's 
<a name="9675"></a>                 */
<a name="9676"></a>                issuingActor.
<a name="9677"></a>                    notifyIssuerParseFailure(self, messageProp, args);
<a name="9678"></a>            }
<a name="9679"></a>        });
<a name="9680"></a>    }
<a name="9681"></a>
<a name="9682"></a>    /*
<a name="9683"></a>     *   We have a parser error to report to the player, but we cannot
<a name="9684"></a>     *   respond at the moment because the player is not capable of
<a name="9685"></a>     *   hearing us (there is no sense path for our communications senses
<a name="9686"></a>     *   from us to the player actor).  Defer reporting the message until
<a name="9687"></a>     *   later.
<a name="9688"></a>     */
<a name="9689"></a>    cannotRespondToCommand(issuingActor, messageProp, args)
<a name="9690"></a>    {
<a name="9691"></a>        /* 
<a name="9692"></a>         *   Remember the problem for later deliver.  If we already have a
<a name="9693"></a>         *   deferred response, forget it - just report the latest
<a name="9694"></a>         *   problem.  
<a name="9695"></a>         */
<a name="9696"></a>        pendingResponse =
<a name="9697"></a>            new PendingResponseInfo(issuingActor, messageProp, args);
<a name="9698"></a>
<a name="9699"></a>        /*
<a name="9700"></a>         *   Some actors might want to override this to start searching
<a name="9701"></a>         *   for the player character.  We don't have any generic
<a name="9702"></a>         *   mechanism to conduct such a search, but a game that
<a name="9703"></a>         *   implements one might want to make use of it here.  
<a name="9704"></a>         */
<a name="9705"></a>    }
<a name="9706"></a>
<a name="9707"></a>    /*
<a name="9708"></a>     *   Receive notification that a command we sent to another NPC
<a name="9709"></a>     *   failed.  This is only called when one NPC sends a command to
<a name="9710"></a>     *   another NPC; this is called on the issuer to let the issuer know
<a name="9711"></a>     *   that the target can't perform the command because of the given
<a name="9712"></a>     *   resolution failure.
<a name="9713"></a>     *   
<a name="9714"></a>     *   By default, we don't do anything here, because we don't have any
<a name="9715"></a>     *   default code to send a command from one NPC to another.  Any
<a name="9716"></a>     *   custom NPC actor that sends a command to another NPC actor might
<a name="9717"></a>     *   want to use this to deal with problems in processing those
<a name="9718"></a>     *   commands.  
<a name="9719"></a>     */
<a name="9720"></a>    notifyIssuerParseFailure(targetActor, messageProp, args)
<a name="9721"></a>    {
<a name="9722"></a>        /* by default, we do nothing */
<a name="9723"></a>    }
<a name="9724"></a>
<a name="9725"></a>    /*
<a name="9726"></a>     *   Antecedent lookup table.  Each actor keeps its own table of
<a name="9727"></a>     *   antecedents indexed by pronoun type, so that we can
<a name="9728"></a>     *   simultaneously have different antecedents for different pronouns.
<a name="9729"></a>     */
<a name="9730"></a>    antecedentTable = nil
<a name="9731"></a>
<a name="9732"></a>    /* 
<a name="9733"></a>     *   Possessive anaphor lookup table.  In almost all cases, the
<a name="9734"></a>     *   possessive anaphor for a given pronoun will be the same as the
<a name="9735"></a>     *   corresponding regular pronoun: HIS indicates possession by HIM,
<a name="9736"></a>     *   for example.  In a few cases, though, the anaphoric quality of
<a name="9737"></a>     *   possessives takes precedence, and these will differ.  For
<a name="9738"></a>     *   example, in TELL BOB TO DROP HIS BOOK, "his" refers back to Bob,
<a name="9739"></a>     *   while in TELL BOB TO HIT HIM, "him" refers to whatever it
<a name="9740"></a>     *   referred to before the command.  
<a name="9741"></a>     */
<a name="9742"></a>    possAnaphorTable = nil
<a name="9743"></a>
<a name="9744"></a>    /* 
<a name="9745"></a>     *   set the antecedent for the neuter singular pronoun ("it" in
<a name="9746"></a>     *   English) 
<a name="9747"></a>     */
<a name="9748"></a>    setIt(obj)
<a name="9749"></a>    {
<a name="9750"></a>        setPronounAntecedent(PronounIt, obj);
<a name="9751"></a>    }
<a name="9752"></a>    
<a name="9753"></a>    /* set the antecedent for the masculine singular ("him") */
<a name="9754"></a>    setHim(obj)
<a name="9755"></a>    {
<a name="9756"></a>        setPronounAntecedent(PronounHim, obj);
<a name="9757"></a>    }
<a name="9758"></a>    
<a name="9759"></a>    /* set the antecedent for the feminine singular ("her") */
<a name="9760"></a>    setHer(obj)
<a name="9761"></a>    {
<a name="9762"></a>        setPronounAntecedent(PronounHer, obj);
<a name="9763"></a>    }
<a name="9764"></a>
<a name="9765"></a>    /* set the antecedent list for the ungendered plural pronoun ("them") */
<a name="9766"></a>    setThem(lst)
<a name="9767"></a>    {
<a name="9768"></a>        setPronounAntecedent(PronounThem, lst);
<a name="9769"></a>    }
<a name="9770"></a>
<a name="9771"></a>    /* look up a pronoun's value */
<a name="9772"></a>    getPronounAntecedent(typ)
<a name="9773"></a>    {
<a name="9774"></a>        /* get the stored antecedent for this pronoun */
<a name="9775"></a>        return antecedentTable[typ];
<a name="9776"></a>    }
<a name="9777"></a>
<a name="9778"></a>    /* set a pronoun's antecedent value */
<a name="9779"></a>    setPronounAntecedent(typ, val)
<a name="9780"></a>    {
<a name="9781"></a>        /* remember the value in the antecedent table */
<a name="9782"></a>        antecedentTable[typ] = val;
<a name="9783"></a>
<a name="9784"></a>        /* set the same value for the possessive anaphor */
<a name="9785"></a>        possAnaphorTable[typ] = val;
<a name="9786"></a>    }
<a name="9787"></a>
<a name="9788"></a>    /* set a possessive anaphor value */
<a name="9789"></a>    setPossAnaphor(typ, val)
<a name="9790"></a>    {
<a name="9791"></a>        /* set the value in the possessive anaphor table only */
<a name="9792"></a>        possAnaphorTable[typ] = val;
<a name="9793"></a>    }
<a name="9794"></a>
<a name="9795"></a>    /* get a possessive anaphor value */
<a name="9796"></a>    getPossAnaphor(typ) { return possAnaphorTable[typ]; }
<a name="9797"></a>
<a name="9798"></a>    /* forget the possessive anaphors */
<a name="9799"></a>    forgetPossAnaphors()
<a name="9800"></a>    {
<a name="9801"></a>        /* copy all of the antecedents to the possessive anaphor table */
<a name="9802"></a>        antecedentTable.forEachAssoc(
<a name="9803"></a>            {key, val: possAnaphorTable[key] = val});
<a name="9804"></a>    }
<a name="9805"></a>
<a name="9806"></a>    /*
<a name="9807"></a>     *   Copy pronoun antecedents from the given actor.  This should be
<a name="9808"></a>     *   called whenever an actor issues a command to us, so that pronouns
<a name="9809"></a>     *   in the command are properly resolved relative to the issuer.  
<a name="9810"></a>     */
<a name="9811"></a>    copyPronounAntecedentsFrom(issuer)
<a name="9812"></a>    {
<a name="9813"></a>        /* copy every element from the issuer's table */
<a name="9814"></a>        issuer.antecedentTable.forEachAssoc(
<a name="9815"></a>            {key, val: setPronounAntecedent(key, val)});
<a name="9816"></a>    }
<a name="9817"></a>
<a name="9818"></a>    /* -------------------------------------------------------------------- */
<a name="9819"></a>    /*
<a name="9820"></a>     *   Verb processing 
<a name="9821"></a>     */
<a name="9822"></a>
<a name="9823"></a>    /* show a "take from" message as indicating I don't have the dobj */
<a name="9824"></a>    takeFromNotInMessage = &amp;takeFromNotInActorMsg
<a name="9825"></a>
<a name="9826"></a>    /* verify() handler to check against applying an action to 'self' */
<a name="9827"></a>    verifyNotSelf(msg)
<a name="9828"></a>    {
<a name="9829"></a>        /* check to make sure we're not trying to do this to myself */
<a name="9830"></a>        if (self == gActor)
<a name="9831"></a>            illogicalSelf(msg);
<a name="9832"></a>    }
<a name="9833"></a>
<a name="9834"></a>    /* macro to verify we're not self, and inherit the default behavior */
<a name="9835"></a>#define verifyNotSelfInherit(msg) \
<a name="9836"></a>    verify() \
<a name="9837"></a>    { \
<a name="9838"></a>        verifyNotSelf(msg); \
<a name="9839"></a>        inherited(); \
<a name="9840"></a>    }
<a name="9841"></a>    
<a name="9842"></a>    /* 
<a name="9843"></a>     *   For the basic physical manipulation verbs (TAKE, DROP, PUT ON,
<a name="9844"></a>     *   etc), it's illogical to operate on myself, so check for this in
<a name="9845"></a>     *   verify().  Otherwise, handle these as we would ordinary objects,
<a name="9846"></a>     *   since we might be able to manipulate other actors in the normal
<a name="9847"></a>     *   manner, especially actors small enough that we can pick them up. 
<a name="9848"></a>     */
<a name="9849"></a>    dobjFor(Take) { verifyNotSelfInherit(&amp;takingSelfMsg) }
<a name="9850"></a>    dobjFor(Drop) { verifyNotSelfInherit(&amp;droppingSelfMsg) }
<a name="9851"></a>    dobjFor(PutOn) { verifyNotSelfInherit(&amp;puttingSelfMsg) }
<a name="9852"></a>    dobjFor(PutUnder) { verifyNotSelfInherit(&amp;puttingSelfMsg) }
<a name="9853"></a>    dobjFor(Throw) { verifyNotSelfInherit(&amp;throwingSelfMsg) }
<a name="9854"></a>    dobjFor(ThrowAt) { verifyNotSelfInherit(&amp;throwingSelfMsg) }
<a name="9855"></a>    dobjFor(ThrowDir) { verifyNotSelfInherit(&amp;throwingSelfMsg) }
<a name="9856"></a>    dobjFor(ThrowTo) { verifyNotSelfInherit(&amp;throwingSelfMsg) }
<a name="9857"></a>
<a name="9858"></a>    /* customize the message for THROW TO &lt;actor&gt; */
<a name="9859"></a>    iobjFor(ThrowTo)
<a name="9860"></a>    {
<a name="9861"></a>        verify()
<a name="9862"></a>        {
<a name="9863"></a>            /* by default, we don't want to catch anything */
<a name="9864"></a>            illogical(&amp;willNotCatchMsg, self);
<a name="9865"></a>        }
<a name="9866"></a>    }
<a name="9867"></a>
<a name="9868"></a>    /* treat PUT SELF IN FOO as GET IN FOO */
<a name="9869"></a>    dobjFor(PutIn)
<a name="9870"></a>    {
<a name="9871"></a>        verify()
<a name="9872"></a>        {
<a name="9873"></a>            /* the target actor is always unsuitable as a default */
<a name="9874"></a>            if (gActor == self)
<a name="9875"></a>                nonObvious;
<a name="9876"></a>        }
<a name="9877"></a>
<a name="9878"></a>        check()
<a name="9879"></a>        {
<a name="9880"></a>            /* if I'm putting myself somewhere, treat it as GET IN */
<a name="9881"></a>            if (gActor == self)
<a name="9882"></a>                replaceAction(Enter, gIobj);
<a name="9883"></a>
<a name="9884"></a>            /* do the normal work */
<a name="9885"></a>            inherited();
<a name="9886"></a>        }
<a name="9887"></a>    }
<a name="9888"></a>
<a name="9889"></a>    dobjFor(Kiss)
<a name="9890"></a>    {
<a name="9891"></a>        preCond = [touchObj]
<a name="9892"></a>        verify()
<a name="9893"></a>        {
<a name="9894"></a>            /* cannot kiss oneself */
<a name="9895"></a>            verifyNotSelf(&amp;cannotKissSelfMsg);
<a name="9896"></a>        }
<a name="9897"></a>        action() { mainReport(&amp;cannotKissActorMsg); }
<a name="9898"></a>    }
<a name="9899"></a>
<a name="9900"></a>    dobjFor(AskFor)
<a name="9901"></a>    {
<a name="9902"></a>        preCond = [canTalkToObj]
<a name="9903"></a>        verify()
<a name="9904"></a>        {
<a name="9905"></a>            /* it makes no sense to ask myself for something */
<a name="9906"></a>            verifyNotSelf(&amp;cannotAskSelfForMsg);
<a name="9907"></a>        }
<a name="9908"></a>        action()
<a name="9909"></a>        {
<a name="9910"></a>            /* note that the issuer is targeting us with conversation */
<a name="9911"></a>            gActor.noteConversation(self);
<a name="9912"></a>
<a name="9913"></a>            /* let the state object handle it */
<a name="9914"></a>            curState.handleConversation(gActor, gTopic, askForConvType);
<a name="9915"></a>        }
<a name="9916"></a>    }
<a name="9917"></a>
<a name="9918"></a>    dobjFor(TalkTo)
<a name="9919"></a>    {
<a name="9920"></a>        preCond = [canTalkToObj]
<a name="9921"></a>        verify()
<a name="9922"></a>        {
<a name="9923"></a>            /* it's generally illogical to talk to oneself */
<a name="9924"></a>            verifyNotSelf(&amp;cannotTalkToSelfMsg);
<a name="9925"></a>        }
<a name="9926"></a>        action()
<a name="9927"></a>        {
<a name="9928"></a>            /* note that the issuer is targeting us in conversation */
<a name="9929"></a>            gActor.noteConversation(self);
<a name="9930"></a>
<a name="9931"></a>            /* handle it as a 'hello' topic */
<a name="9932"></a>            curState.handleConversation(gActor, helloTopicObj, helloConvType);
<a name="9933"></a>        }
<a name="9934"></a>    }
<a name="9935"></a>
<a name="9936"></a>    iobjFor(GiveTo)
<a name="9937"></a>    {
<a name="9938"></a>        verify()
<a name="9939"></a>        {
<a name="9940"></a>            /* it makes no sense to give something to myself */
<a name="9941"></a>            verifyNotSelf(&amp;cannotGiveToSelfMsg);
<a name="9942"></a>
<a name="9943"></a>            /* it also makes no sense to give something to itself */
<a name="9944"></a>            if (gDobj == gIobj)
<a name="9945"></a>                illogicalSelf(&amp;cannotGiveToItselfMsg);
<a name="9946"></a>        }
<a name="9947"></a>        action()
<a name="9948"></a>        {
<a name="9949"></a>            /* take note that I've seen the direct object */
<a name="9950"></a>            noteObjectShown(gDobj);
<a name="9951"></a>
<a name="9952"></a>            /* note that the issuer is targeting us with conversation */
<a name="9953"></a>            gActor.noteConversation(self);
<a name="9954"></a>
<a name="9955"></a>            /* let the state object handle it */
<a name="9956"></a>            curState.handleConversation(gActor, gDobj, giveConvType);
<a name="9957"></a>        }
<a name="9958"></a>    }
<a name="9959"></a>
<a name="9960"></a>    iobjFor(ShowTo)
<a name="9961"></a>    {
<a name="9962"></a>        verify()
<a name="9963"></a>        {
<a name="9964"></a>            /* it makes no sense to show something to myself */
<a name="9965"></a>            verifyNotSelf(&amp;cannotShowToSelfMsg);
<a name="9966"></a>
<a name="9967"></a>            /* it also makes no sense to show something to itself */
<a name="9968"></a>            if (gDobj == gIobj)
<a name="9969"></a>                illogicalSelf(&amp;cannotShowToItselfMsg);
<a name="9970"></a>        }
<a name="9971"></a>        action()
<a name="9972"></a>        {
<a name="9973"></a>            /* take note that I've seen the direct object */
<a name="9974"></a>            noteObjectShown(gDobj);
<a name="9975"></a>
<a name="9976"></a>            /* note that the issuer is targeting us with conversation */
<a name="9977"></a>            gActor.noteConversation(self);
<a name="9978"></a>
<a name="9979"></a>            /* let the actor state object handle it */
<a name="9980"></a>            curState.handleConversation(gActor, gDobj, showConvType);
<a name="9981"></a>        }
<a name="9982"></a>    }
<a name="9983"></a>
<a name="9984"></a>    /*
<a name="9985"></a>     *   Note that the given object has been explicitly shown to me.  By
<a name="9986"></a>     *   default, we'll mark the object and its visible contents as having
<a name="9987"></a>     *   been seen by me.  This is called whenever we're the target of a
<a name="9988"></a>     *   SHOW TO or GIVE TO, since presumably such an explicit act of
<a name="9989"></a>     *   calling our attention to an object would make us consider the
<a name="9990"></a>     *   object as having been seen in the future.  
<a name="9991"></a>     */
<a name="9992"></a>    noteObjectShown(obj)
<a name="9993"></a>    {
<a name="9994"></a>        local info;
<a name="9995"></a>
<a name="9996"></a>        /* get the table of things we can see */
<a name="9997"></a>        info = visibleInfoTable();
<a name="9998"></a>
<a name="9999"></a>        /* if the object is in the table, mark it as seen */
<a name="10000"></a>        if (info[obj] != nil)
<a name="10001"></a>            setHasSeen(obj);
<a name="10002"></a>
<a name="10003"></a>        /* also mark the visible contents of the object as having been seen */
<a name="10004"></a>        obj.setContentsSeenBy(info, self);
<a name="10005"></a>    }
<a name="10006"></a>
<a name="10007"></a>    dobjFor(AskAbout)
<a name="10008"></a>    {
<a name="10009"></a>        preCond = [canTalkToObj]
<a name="10010"></a>        verify()
<a name="10011"></a>        {
<a name="10012"></a>            /* it makes no sense to ask oneself about something */
<a name="10013"></a>            verifyNotSelf(&amp;cannotAskSelfMsg);
<a name="10014"></a>        }
<a name="10015"></a>        action()
<a name="10016"></a>        {
<a name="10017"></a>            /* note that the issuer is targeting us with conversation */
<a name="10018"></a>            gActor.noteConversation(self);
<a name="10019"></a>
<a name="10020"></a>            /* let our state object handle it */
<a name="10021"></a>            curState.handleConversation(gActor, gTopic, askAboutConvType);
<a name="10022"></a>        }
<a name="10023"></a>    }
<a name="10024"></a>
<a name="10025"></a>    dobjFor(TellAbout)
<a name="10026"></a>    {
<a name="10027"></a>        preCond = [canTalkToObj]
<a name="10028"></a>        verify()
<a name="10029"></a>        {
<a name="10030"></a>            /* it makes no sense to tell oneself about something */
<a name="10031"></a>            verifyNotSelf(&amp;cannotTellSelfMsg);
<a name="10032"></a>        }
<a name="10033"></a>        check()
<a name="10034"></a>        {
<a name="10035"></a>            /* 
<a name="10036"></a>             *   If the direct object is the issuing actor, rephrase this
<a name="10037"></a>             *   as "issuer, ask actor about iobj".
<a name="10038"></a>             *   
<a name="10039"></a>             *   Note that we do this in 'check' rather than 'action',
<a name="10040"></a>             *   because this will ensure that we'll rephrase the command
<a name="10041"></a>             *   properly even if the subclass overrides with its own
<a name="10042"></a>             *   check, AS LONG AS the overriding method inherits this base
<a name="10043"></a>             *   definition first.  If we did the rephrasing in the
<a name="10044"></a>             *   'action', then an overriding 'check' might incorrectly
<a name="10045"></a>             *   disqualify the operation on the assumption that it's an
<a name="10046"></a>             *   ordinary TELL ABOUT rather than what it really is, which
<a name="10047"></a>             *   is a rephrased ASK ABOUT.  
<a name="10048"></a>             */
<a name="10049"></a>            if (gDobj == gIssuingActor)
<a name="10050"></a>                replaceActorAction(gIssuingActor, AskAbout, gActor, gTopic);
<a name="10051"></a>
<a name="10052"></a>        }
<a name="10053"></a>        action()
<a name="10054"></a>        {
<a name="10055"></a>            /* note that the issuer is targeting us with conversation */
<a name="10056"></a>            gActor.noteConversation(self);
<a name="10057"></a>
<a name="10058"></a>            /* let the state object handle it */
<a name="10059"></a>            curState.handleConversation(gActor, gTopic, tellAboutConvType);
<a name="10060"></a>        }
<a name="10061"></a>    }
<a name="10062"></a>
<a name="10063"></a>    /*
<a name="10064"></a>     *   Handle a conversational command.  All of the conversational
<a name="10065"></a>     *   actions (HELLO, GOODBYE, YES, NO, ASK ABOUT, ASK FOR, TELL ABOUT,
<a name="10066"></a>     *   SHOW TO, GIVE TO) are routed here when we're the target of the
<a name="10067"></a>     *   action (for example, we're BOB in ASK BOB ABOUT TOPIC) AND the
<a name="10068"></a>     *   ActorState doesn't want to handle the action. 
<a name="10069"></a>     */
<a name="10070"></a>    handleConversation(actor, topic, convType)
<a name="10071"></a>    {
<a name="10072"></a>        /* try handling the topic from our topic database */
<a name="10073"></a>        if (!handleTopic(actor, topic, convType, nil))
<a name="10074"></a>        {
<a name="10075"></a>            /* the topic database didn't handle it; use a default response */
<a name="10076"></a>            defaultConvResponse(actor, topic, convType);
<a name="10077"></a>        }
<a name="10078"></a>    }
<a name="10079"></a>
<a name="10080"></a>    /*
<a name="10081"></a>     *   Show a default response to a conversational action.  By default,
<a name="10082"></a>     *   we'll show the default response for our conversation type.  
<a name="10083"></a>     */
<a name="10084"></a>    defaultConvResponse(actor, topic, convType)
<a name="10085"></a>    {
<a name="10086"></a>        /* call the appropriate default response for the ConvType */
<a name="10087"></a>        convType.defaultResponse(self, actor, topic);
<a name="10088"></a>    }
<a name="10089"></a>
<a name="10090"></a>    /* 
<a name="10091"></a>     *   Show our default greeting message - this is used when the given
<a name="10092"></a>     *   another actor greets us with HELLO or TALK TO, and we don't
<a name="10093"></a>     *   otherwise handle it (such as via a topic database entry).
<a name="10094"></a>     *   
<a name="10095"></a>     *   By default, we'll just show "there's no response" as a default
<a name="10096"></a>     *   message.  We'll show this in default mode, so that if the caller
<a name="10097"></a>     *   is going to show a list of suggested conversation topics (which
<a name="10098"></a>     *   the 'hello' and 'talk to' commands will normally try to do), the
<a name="10099"></a>     *   topic list will override the "there's no response" default.  In
<a name="10100"></a>     *   other words, we'll have one of these two types of exchanges:
<a name="10101"></a>     *   
<a name="10102"></a>     *.  &gt;talk to bob
<a name="10103"></a>     *.  There's no response
<a name="10104"></a>     *   
<a name="10105"></a>     *.  &gt;talk to bill
<a name="10106"></a>     *.  You could ask him about the candle, the book, or the bell, or
<a name="10107"></a>     *.  tell him about the crypt.
<a name="10108"></a>     */
<a name="10109"></a>    defaultGreetingResponse(actor)
<a name="10110"></a>        { defaultReport(&amp;noResponseFromMsg, self); }
<a name="10111"></a>
<a name="10112"></a>    /* show our default goodbye message */
<a name="10113"></a>    defaultGoodbyeResponse(actor)
<a name="10114"></a>        { mainReport(&amp;noResponseFromMsg, self); }
<a name="10115"></a>
<a name="10116"></a>    /*
<a name="10117"></a>     *   Show the default answer to a question - this is called when we're
<a name="10118"></a>     *   the actor in ASK &lt;actor&gt; ABOUT &lt;topic&gt;, and we can't find a more
<a name="10119"></a>     *   specific response for the given topic.
<a name="10120"></a>     *   
<a name="10121"></a>     *   By default, we'll show the basic "there's no response" message.
<a name="10122"></a>     *   This isn't a very good message in most cases, because it makes an
<a name="10123"></a>     *   actor pretty frustratingly un-interactive, which gives the actor
<a name="10124"></a>     *   the appearance of a cardboard cut-out.  But there's not much
<a name="10125"></a>     *   better that the library can do; the potential range of actors
<a name="10126"></a>     *   makes a more specific default response impossible.  If the default
<a name="10127"></a>     *   response were "I don't know about that," it wouldn't work very
<a name="10128"></a>     *   well if the actor is someone who only speaks Italian.  So, the
<a name="10129"></a>     *   best we can do is this generally rather poor default.  But that
<a name="10130"></a>     *   doesn't mean that authors should resign themselves to a poor
<a name="10131"></a>     *   default answer; instead, it means that actors should take care to
<a name="10132"></a>     *   override this when defining an actor, because it's usually
<a name="10133"></a>     *   possible to find a much better default for a *specific* actor.
<a name="10134"></a>     *   
<a name="10135"></a>     *   The *usual* way of providing a default response is to define a
<a name="10136"></a>     *   DefaultAskTopic (or a DefaultAskTellTopic) and put it in the
<a name="10137"></a>     *   actor's topic database.  
<a name="10138"></a>     */
<a name="10139"></a>    defaultAskResponse(fromActor, topic)
<a name="10140"></a>        { mainReport(&amp;noResponseFromMsg, self); }
<a name="10141"></a>
<a name="10142"></a>    /*
<a name="10143"></a>     *   Show the default response to being told of a topic - this is
<a name="10144"></a>     *   called when we're the actor in TELL &lt;actor&gt; ABOUT &lt;topic&gt;, and we
<a name="10145"></a>     *   can't find a more specific response for the topic.
<a name="10146"></a>     *   
<a name="10147"></a>     *   As with defaultAskResponse, this should almost always be
<a name="10148"></a>     *   overridden by each actor, since the default response ("there's no
<a name="10149"></a>     *   response") doesn't make the actor seem very dynamic.
<a name="10150"></a>     *   
<a name="10151"></a>     *   The usual way of providing a default response is to define a
<a name="10152"></a>     *   DefaultTellTopic (or a DefaultAskTellTopic) and put it in the
<a name="10153"></a>     *   actor's topic database.  
<a name="10154"></a>     */
<a name="10155"></a>    defaultTellResponse(fromActor, topic)
<a name="10156"></a>        { mainReport(&amp;noResponseFromMsg, self); }
<a name="10157"></a>
<a name="10158"></a>    /* the default response for SHOW TO */
<a name="10159"></a>    defaultShowResponse(byActor, topic)
<a name="10160"></a>        { mainReport(&amp;notInterestedMsg, self); }
<a name="10161"></a>
<a name="10162"></a>    /* the default response for GIVE TO */
<a name="10163"></a>    defaultGiveResponse(byActor, topic)
<a name="10164"></a>        { mainReport(&amp;notInterestedMsg, self); }
<a name="10165"></a>
<a name="10166"></a>    /* the default response for ASK FOR */
<a name="10167"></a>    defaultAskForResponse(byActor, obj)
<a name="10168"></a>        { mainReport(&amp;noResponseFromMsg, self); }
<a name="10169"></a>
<a name="10170"></a>    /* default response to being told YES */
<a name="10171"></a>    defaultYesResponse(fromActor)
<a name="10172"></a>        { mainReport(&amp;noResponseFromMsg, self); }
<a name="10173"></a>
<a name="10174"></a>    /* default response to being told NO */
<a name="10175"></a>    defaultNoResponse(fromActor)
<a name="10176"></a>        { mainReport(&amp;noResponseFromMsg, self); }
<a name="10177"></a>
<a name="10178"></a>    /* default refusal of a command */
<a name="10179"></a>    defaultCommandResponse(fromActor, topic)
<a name="10180"></a>        { mainReport(&amp;refuseCommand, self, fromActor); }
<a name="10181"></a>;
<a name="10182"></a>
<a name="10183"></a>/* ------------------------------------------------------------------------ */
<a name="10184"></a>/*
<a name="10185"></a> *   An UntakeableActor is one that can't be picked up and moved. 
<a name="10186"></a> */
<a name="10187"></a>class UntakeableActor: Actor, Immovable
<a name="10188"></a>    /* use customized messages for some 'Immovable' methods */
<a name="10189"></a>    cannotTakeMsg = &amp;cannotTakeActorMsg
<a name="10190"></a>    cannotMoveMsg = &amp;cannotMoveActorMsg
<a name="10191"></a>    cannotPutMsg = &amp;cannotPutActorMsg
<a name="10192"></a>
<a name="10193"></a>    /* TASTE tends to be a bit rude */
<a name="10194"></a>    dobjFor(Taste)
<a name="10195"></a>    {
<a name="10196"></a>        action() { mainReport(&amp;cannotTasteActorMsg); }
<a name="10197"></a>    }
<a name="10198"></a>
<a name="10199"></a>    /* 
<a name="10200"></a>     *   even though we act like an Immovable, we don't count as an
<a name="10201"></a>     *   Immovable for listing purposes 
<a name="10202"></a>     */
<a name="10203"></a>    contentsInFixedIn(loc) { return nil; }
<a name="10204"></a>;
<a name="10205"></a>
<a name="10206"></a>
<a name="10207"></a>/*
<a name="10208"></a> *   A Person is an actor that represents a human character.  This is just
<a name="10209"></a> *   an UntakeableActor with some custom versions of the messages for
<a name="10210"></a> *   taking and moving the actor.  
<a name="10211"></a> */
<a name="10212"></a>class Person: UntakeableActor
<a name="10213"></a>    /* customize the messages for trying to take or move me */
<a name="10214"></a>    cannotTakeMsg = &amp;cannotTakePersonMsg
<a name="10215"></a>    cannotMoveMsg = &amp;cannotMovePersonMsg
<a name="10216"></a>    cannotPutMsg = &amp;cannotPutPersonMsg
<a name="10217"></a>    cannotTasteActorMsg = &amp;cannotTastePersonMsg
<a name="10218"></a>
<a name="10219"></a>    /* 
<a name="10220"></a>     *   use a fairly large default bulk, since people are usually fairly
<a name="10221"></a>     *   large compared with the sorts of items that one carries around 
<a name="10222"></a>     */
<a name="10223"></a>    bulk = 10
<a name="10224"></a>;
<a name="10225"></a>
<a name="10226"></a>/* ------------------------------------------------------------------------ */
<a name="10227"></a>/*
<a name="10228"></a> *   Pending response information structure 
<a name="10229"></a> */
<a name="10230"></a>class PendingResponseInfo: object
<a name="10231"></a>    construct(issuer, prop, args)
<a name="10232"></a>    {
<a name="10233"></a>        issuer_ = issuer;
<a name="10234"></a>        prop_ = prop;
<a name="10235"></a>        args_ = args;
<a name="10236"></a>    }
<a name="10237"></a>
<a name="10238"></a>    /* the issuer of the command (and target of the response) */
<a name="10239"></a>    issuer_ = nil
<a name="10240"></a>
<a name="10241"></a>    /* the message property and argument list for the message */
<a name="10242"></a>    prop_ = nil
<a name="10243"></a>    args_ = []
<a name="10244"></a>;
<a name="10245"></a>
<a name="10246"></a>/*
<a name="10247"></a> *   Pending Command Information structure.  This is an abstract base class
<a name="10248"></a> *   that we subclass for particular ways of representing the command to be
<a name="10249"></a> *   executed.  
<a name="10250"></a> */
<a name="10251"></a>class PendingCommandInfo: object
<a name="10252"></a>    construct(issuer) { issuer_ = issuer; }
<a name="10253"></a>    
<a name="10254"></a>    /*
<a name="10255"></a>     *   Check to see if this pending command item has a command to
<a name="10256"></a>     *   perform.  This returns true if we have a command, nil if we're
<a name="10257"></a>     *   just a queue placeholder without any actual command to execute.  
<a name="10258"></a>     */
<a name="10259"></a>    hasCommand = true
<a name="10260"></a>
<a name="10261"></a>    /* execute the command */
<a name="10262"></a>    executePending(targetActor) { }
<a name="10263"></a>
<a name="10264"></a>    /* the issuer of the command */
<a name="10265"></a>    issuer_ = nil
<a name="10266"></a>
<a name="10267"></a>    /* we're at the start of a "sentence" */
<a name="10268"></a>    startOfSentence_ = nil
<a name="10269"></a>;
<a name="10270"></a>
<a name="10271"></a>/* a pending command based on a list of tokens from an input string */
<a name="10272"></a>class PendingCommandToks: PendingCommandInfo
<a name="10273"></a>    construct(startOfSentence, issuer, toks)
<a name="10274"></a>    {
<a name="10275"></a>        inherited(issuer);
<a name="10276"></a>        
<a name="10277"></a>        startOfSentence_ = startOfSentence;
<a name="10278"></a>        tokens_ = toks;
<a name="10279"></a>    }
<a name="10280"></a>
<a name="10281"></a>    /* 
<a name="10282"></a>     *   Execute the command.  We'll parse our tokens and execute the
<a name="10283"></a>     *   parsed results.
<a name="10284"></a>     */
<a name="10285"></a>    executePending(targetActor)
<a name="10286"></a>    {
<a name="10287"></a>        /* parse and execute the tokens */
<a name="10288"></a>        executeCommand(targetActor, issuer_, tokens_, startOfSentence_);
<a name="10289"></a>    }
<a name="10290"></a>    
<a name="10291"></a>    /* the token list for the command */
<a name="10292"></a>    tokens_ = nil
<a name="10293"></a>;
<a name="10294"></a>
<a name="10295"></a>/* a pending command based on a pre-resolved Action and its objects */
<a name="10296"></a>class PendingCommandAction: PendingCommandInfo
<a name="10297"></a>    construct(startOfSentence, issuer, action, [objs])
<a name="10298"></a>    {
<a name="10299"></a>        inherited(issuer);
<a name="10300"></a>        
<a name="10301"></a>        startOfSentence_ = startOfSentence;
<a name="10302"></a>        action_ = action;
<a name="10303"></a>        objs_ = objs;
<a name="10304"></a>    }
<a name="10305"></a>
<a name="10306"></a>    /* execute the pending command */
<a name="10307"></a>    executePending(targetActor)
<a name="10308"></a>    {
<a name="10309"></a>        /* invoke the action's main execution method */
<a name="10310"></a>        try
<a name="10311"></a>        {
<a name="10312"></a>            /* run the action */
<a name="10313"></a>            newActionObj(CommandTranscript, issuer_,
<a name="10314"></a>                         targetActor, action_, objs_...);
<a name="10315"></a>        }
<a name="10316"></a>        catch (TerminateCommandException tcExc)
<a name="10317"></a>        {
<a name="10318"></a>            /* 
<a name="10319"></a>             *   the command cannot proceed; simply abandon the command
<a name="10320"></a>             *   action here 
<a name="10321"></a>             */
<a name="10322"></a>        }
<a name="10323"></a>    }
<a name="10324"></a>    
<a name="10325"></a>    /* the resolved Action to perform */
<a name="10326"></a>    action_ = nil
<a name="10327"></a>
<a name="10328"></a>    /* the resolved objects for the action */
<a name="10329"></a>    objs_ = nil
<a name="10330"></a>;
<a name="10331"></a>
<a name="10332"></a>/*
<a name="10333"></a> *   A pending command marker.  This is not an actual pending command;
<a name="10334"></a> *   rather, it's just a queue marker.  We sometimes want to synchronize
<a name="10335"></a> *   some other activity with an actor's progress through its command
<a name="10336"></a> *   queue; for example, we might want one actor to wait until another
<a name="10337"></a> *   actor has executed a particular pending action.  These markers can be
<a name="10338"></a> *   used for this kind of synchronization; they move through the queue
<a name="10339"></a> *   like ordinary pending commands, so we can tell if an actor has reached
<a name="10340"></a> *   a particular command by observing the marker's progress through the
<a name="10341"></a> *   queue.  
<a name="10342"></a> */
<a name="10343"></a>class PendingCommandMarker: PendingCommandInfo
<a name="10344"></a>    /* I have no command to execute */
<a name="10345"></a>    hasCommand = nil
<a name="10346"></a>;
<a name="10347"></a>
<a name="10348"></a>/* ------------------------------------------------------------------------ */
<a name="10349"></a>/*
<a name="10350"></a> *   Set the current player character 
<a name="10351"></a> */
<a name="10352"></a>setPlayer(actor)
<a name="10353"></a>{
<a name="10354"></a>    /* remember the new player character */
<a name="10355"></a>    libGlobal.playerChar = actor;
<a name="10356"></a>
<a name="10357"></a>    /* set the root global point of view to this actor */
<a name="10358"></a>    setRootPOV(actor, actor);
<a name="10359"></a>}
<a name="10360"></a>
</pre>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/6/2009 from TADS version 3.0.18.1</div>
</body>
</html>
