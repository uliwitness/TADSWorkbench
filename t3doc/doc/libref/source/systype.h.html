<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>systype.h</title></head><body>
<table class=ban><tr><td><h1>systype.h</h1><td align=right><a href="../file/systype.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/*
<a name="4"></a> *   Copyright 2000, 2006 Michael J. Roberts.
<a name="5"></a> *   
<a name="6"></a> *   This file is part of TADS 3.
<a name="7"></a> *   
<a name="8"></a> *   This module defines the fundamental intrinsic classes, including Object,
<a name="9"></a> *   String, Collection, List, and Iterator.  
<a name="10"></a> */
<a name="11"></a>
<a name="12"></a>#ifndef _SYSTYPE_H_
<a name="13"></a>#define _SYSTYPE_H_
<a name="14"></a>
<a name="15"></a>
<a name="16"></a>/* ------------------------------------------------------------------------ */
<a name="17"></a>/*
<a name="18"></a> *   TADS datatype codes.  These values are returned by propType(), etc.  
<a name="19"></a> */
<a name="20"></a>#define TypeNil         1
<a name="21"></a>#define TypeTrue        2
<a name="22"></a>#define TypeObject      5
<a name="23"></a>#define TypeProp        6
<a name="24"></a>#define TypeInt         7
<a name="25"></a>#define TypeSString     8
<a name="26"></a>#define TypeDString     9
<a name="27"></a>#define TypeList        10
<a name="28"></a>#define TypeCode        11
<a name="29"></a>#define TypeFuncPtr     12
<a name="30"></a>#define TypeNativeCode  14
<a name="31"></a>#define TypeEnum        15
<a name="32"></a>
<a name="33"></a>
<a name="34"></a>/* ------------------------------------------------------------------------ */
<a name="35"></a>/*
<a name="36"></a> *   The root object class.  All objects descend from this class. 
<a name="37"></a> */
<a name="38"></a>intrinsic class Object 'root-object/030004'
<a name="39"></a>{
<a name="40"></a>    /* 
<a name="41"></a>     *   Determine if I'm an instance or subclass of the given class 'cls'.
<a name="42"></a>     *   Note that x.ofKind(x) returns true - an object is of its own kind.  
<a name="43"></a>     */
<a name="44"></a>    ofKind(cls);
<a name="45"></a>
<a name="46"></a>    /* get the list of direct superclasses of this object */
<a name="47"></a>    getSuperclassList();
<a name="48"></a>
<a name="49"></a>    /* determine if a property is defined or inherited by this object */
<a name="50"></a>    propDefined(prop, flags?);
<a name="51"></a>
<a name="52"></a>    /* get the type of a property defined for this object */
<a name="53"></a>    propType(prop);
<a name="54"></a>
<a name="55"></a>    /* 
<a name="56"></a>     *   Get a list of my directly-defined properties.  When called on
<a name="57"></a>     *   intrinsic class objects, this returns a list of properties defined
<a name="58"></a>     *   for instances of the class, as well as static properties of the
<a name="59"></a>     *   class.  
<a name="60"></a>     */
<a name="61"></a>    getPropList();
<a name="62"></a>
<a name="63"></a>    /* 
<a name="64"></a>     *   get parameter list information for the given method - returns a
<a name="65"></a>     *   list: [minimumArgc, optionalArgc, varargs], where minimumArgc is
<a name="66"></a>     *   the minimum number of arguments, optionalArgc is the number of
<a name="67"></a>     *   additional optional arguments, and varargs is true if the function
<a name="68"></a>     *   takes a varying number of arguments greater than or equal to the
<a name="69"></a>     *   minimum, nil if not.  
<a name="70"></a>     */
<a name="71"></a>    getPropParams(prop);
<a name="72"></a>
<a name="73"></a>    /* 
<a name="74"></a>     *   determine if I'm a "class" object - returns true if the object was
<a name="75"></a>     *   defined with the "class" keyword, nil otherwise 
<a name="76"></a>     */
<a name="77"></a>    isClass();
<a name="78"></a>
<a name="79"></a>    /* 
<a name="80"></a>     *   Determine if a property is inherited further from the given object.
<a name="81"></a>     *   definingObj is usually the value of the 'definingobj'
<a name="82"></a>     *   pseudo-variable, and origTargetObj is usually the value of the
<a name="83"></a>     *   'targetobj' pseudo-variable.  
<a name="84"></a>     */
<a name="85"></a>    propInherited(prop, origTargetObj, definingObj, flags?);
<a name="86"></a>
<a name="87"></a>    /* determine if this instance is transient */
<a name="88"></a>    isTransient();
<a name="89"></a>}
<a name="90"></a>
<a name="91"></a>/*
<a name="92"></a> *   propDefined() flags 
<a name="93"></a> */
<a name="94"></a>#define PropDefAny           1
<a name="95"></a>#define PropDefDirectly      2
<a name="96"></a>#define PropDefInherits      3
<a name="97"></a>#define PropDefGetClass      4
<a name="98"></a>
<a name="99"></a>
<a name="100"></a>/* ------------------------------------------------------------------------ */
<a name="101"></a>/*
<a name="102"></a> *   The IntrinsicClass intrinsic class.  Objects of this type represent the
<a name="103"></a> *   intrinsic classes themselves.  
<a name="104"></a> */
<a name="105"></a>intrinsic class IntrinsicClass 'intrinsic-class/030000': Object
<a name="106"></a>{
<a name="107"></a>}
<a name="108"></a>
<a name="109"></a>/*
<a name="110"></a> *   Intrinsic class modifier object (for internal compiler use only) 
<a name="111"></a> */
<a name="112"></a>intrinsic class IntrinsicClassModifier 'int-class-mod/030000'
<a name="113"></a>{
<a name="114"></a>}
<a name="115"></a>
<a name="116"></a>/* ------------------------------------------------------------------------ */
<a name="117"></a>/*
<a name="118"></a> *   The native collection type - this is the base class for lists, vectors,
<a name="119"></a> *   and other objects that represent collections of values.  
<a name="120"></a> */
<a name="121"></a>intrinsic class Collection 'collection/030000': Object
<a name="122"></a>{
<a name="123"></a>    /* 
<a name="124"></a>     *   Create an iterator for the collection.  This returns a new Iterator
<a name="125"></a>     *   object that can be used to iterate over the values in the
<a name="126"></a>     *   collection.  The Iterator will use a snapshot of the collection that
<a name="127"></a>     *   will never change, even if the collection is changed after the
<a name="128"></a>     *   iterator is created.  
<a name="129"></a>     */
<a name="130"></a>    createIterator();
<a name="131"></a>
<a name="132"></a>    /*
<a name="133"></a>     *   Create a "live iterator" for the collection.  This returns a new
<a name="134"></a>     *   Iterator object that refers directly to the original collection; if
<a name="135"></a>     *   the original collection changes, the iterator will reflect the
<a name="136"></a>     *   changes in its iteration.  As a result, the iterator is not
<a name="137"></a>     *   guaranteed to visit all of the elements in the collection if the
<a name="138"></a>     *   collection changes during the course of the iteration.  If
<a name="139"></a>     *   consistent results are required, use createIterator() instead.  
<a name="140"></a>     */
<a name="141"></a>    createLiveIterator();
<a name="142"></a>}
<a name="143"></a>
<a name="144"></a>/* ------------------------------------------------------------------------ */
<a name="145"></a>/*
<a name="146"></a> *   The native iterator type - this is the base class for all iterators.
<a name="147"></a> *   This class is abstract and is thus never directly instantiated.
<a name="148"></a> *   
<a name="149"></a> *   Note that iterators can never be created directly with the 'new'
<a name="150"></a> *   operator.  Instead, iterators must be obtained from a collection via the
<a name="151"></a> *   collection's createIterator() method.  
<a name="152"></a> */
<a name="153"></a>intrinsic class Iterator 'iterator/030001': Object
<a name="154"></a>{
<a name="155"></a>    /*
<a name="156"></a>     *   Get the next item in the collection.  This returns the next item's
<a name="157"></a>     *   value, and advances the internal state in the iterator so that a
<a name="158"></a>     *   subsequent call to getNext() returns the next item after this one.
<a name="159"></a>     *   When the iterator is first created, or after calling
<a name="160"></a>     *   resetIterator(), this returns the first item in the collection.  
<a name="161"></a>     */
<a name="162"></a>    getNext();
<a name="163"></a>
<a name="164"></a>    /*
<a name="165"></a>     *   Determine if the collection is out of items.  Returns true if
<a name="166"></a>     *   getNext() will return a valid item, nil if no more items are
<a name="167"></a>     *   available.  
<a name="168"></a>     */
<a name="169"></a>    isNextAvailable();
<a name="170"></a>
<a name="171"></a>    /*
<a name="172"></a>     *   Reset to the first item.  After calling this routine, the next call
<a name="173"></a>     *   to getNext() will return the first item in the collection.  
<a name="174"></a>     */
<a name="175"></a>    resetIterator();
<a name="176"></a>
<a name="177"></a>    /*
<a name="178"></a>     *   Get the current key.  This returns the value of the key for the
<a name="179"></a>     *   current item in the collection.  For an indexed collection, this
<a name="180"></a>     *   returns the index value; for a keyed collection, this returns the
<a name="181"></a>     *   current key value.  
<a name="182"></a>     */
<a name="183"></a>    getCurKey();
<a name="184"></a>
<a name="185"></a>    /*
<a name="186"></a>     *   Get the current value.  This returns the value of the current item
<a name="187"></a>     *   in the collection. 
<a name="188"></a>     */
<a name="189"></a>    getCurVal();
<a name="190"></a>}
<a name="191"></a>
<a name="192"></a>/*
<a name="193"></a> *   Indexed object iterator - this type of iterator is used for lists,
<a name="194"></a> *   vectors, and other indexed collection objects.  
<a name="195"></a> */
<a name="196"></a>intrinsic class IndexedIterator 'indexed-iterator/030000': Iterator
<a name="197"></a>{
<a name="198"></a>}
<a name="199"></a>
<a name="200"></a>
<a name="201"></a>/* ------------------------------------------------------------------------ */
<a name="202"></a>/*
<a name="203"></a> *   AnonFuncPtr depends on Vector 
<a name="204"></a> */
<a name="205"></a>#include "vector.h"
<a name="206"></a>
<a name="207"></a>/*
<a name="208"></a> *   Anonymous function pointer intrinsic class 
<a name="209"></a> */
<a name="210"></a>intrinsic class AnonFuncPtr 'anon-func-ptr': Vector
<a name="211"></a>{
<a name="212"></a>}
<a name="213"></a>
<a name="214"></a>
<a name="215"></a>/* ------------------------------------------------------------------------ */
<a name="216"></a>/*
<a name="217"></a> *   The "TADS Object" intrinsic class.  All objects that the program
<a name="218"></a> *   defines with the "class" or "object" statements descend from this
<a name="219"></a> *   class.  
<a name="220"></a> */
<a name="221"></a>intrinsic class TadsObject 'tads-object/030004': Object
<a name="222"></a>{
<a name="223"></a>    /* 
<a name="224"></a>     *   Create an instance of this object: in other words, create a new
<a name="225"></a>     *   object whose superclass is this object.  The arguments provided are
<a name="226"></a>     *   passed to the new object's constructor.  This method returns a
<a name="227"></a>     *   reference to the new object.  
<a name="228"></a>     */
<a name="229"></a>    createInstance(...);
<a name="230"></a>
<a name="231"></a>    /*
<a name="232"></a>     *   Create a clone of this object.  This creates an exact copy, with
<a name="233"></a>     *   the same property values, as the original.  This does not call any
<a name="234"></a>     *   constructors; it merely instantiates an exact copy of the original.
<a name="235"></a>     *   
<a name="236"></a>     *   Note that the clone is a "shallow" copy, which means that any
<a name="237"></a>     *   objects it references are not themselves cloned.
<a name="238"></a>     */
<a name="239"></a>    createClone();
<a name="240"></a>
<a name="241"></a>    /*
<a name="242"></a>     *   Create a transient instance of this object.  This works just like
<a name="243"></a>     *   createInstance(), but creates a transient instance instead of an
<a name="244"></a>     *   ordinary (persistent) instance.  
<a name="245"></a>     */
<a name="246"></a>    createTransientInstance(...);
<a name="247"></a>
<a name="248"></a>    /*
<a name="249"></a>     *   Create an instance of an object based on multiple superclasses.
<a name="250"></a>     *   Each argument gives a superclass, and optionally arguments for
<a name="251"></a>     *   invoking the superclass constructor.  If an argument is given as
<a name="252"></a>     *   simply a class, then we don't invoke that superclass's constructor;
<a name="253"></a>     *   if the argument is given as a list, the first element of the list is
<a name="254"></a>     *   the class, and the remaining elements of the list are arguments for
<a name="255"></a>     *   that superclass's constructor.  The arguments are specified in the
<a name="256"></a>     *   same order they would be to define the object, so the first argument
<a name="257"></a>     *   is the dominant superclass.
<a name="258"></a>     *   
<a name="259"></a>     *   For example, suppose we created a class definition like this:
<a name="260"></a>     *   
<a name="261"></a>     *   class D: A, B, C
<a name="262"></a>     *.    construct(x, y)
<a name="263"></a>     *.    {
<a name="264"></a>     *.      inherited A(x);
<a name="265"></a>     *.      inherited C(y);
<a name="266"></a>     *.    }
<a name="267"></a>     *.  ;
<a name="268"></a>     *   
<a name="269"></a>     *   We could obtain the same effect dynamically like so:
<a name="270"></a>     *   
<a name="271"></a>     *   local d = TadsObject.createInstanceOf([A, x], B, [C, y]); 
<a name="272"></a>     */
<a name="273"></a>    static createInstanceOf(...);
<a name="274"></a>
<a name="275"></a>    /*
<a name="276"></a>     *   Create a transient instance based on multiple superclasses.  This
<a name="277"></a>     *   works just like createInstanceOf(), but creates a transient
<a name="278"></a>     *   instance. 
<a name="279"></a>     */
<a name="280"></a>    static createTransientInstanceOf(...);
<a name="281"></a>
<a name="282"></a>    /*
<a name="283"></a>     *   Set the superclass list.  scList is a list giving the new
<a name="284"></a>     *   superclasses.  The superclasses must all be TadsObject objects, with
<a name="285"></a>     *   one exception: the list [TadsObject] may be passed to create an
<a name="286"></a>     *   object based directly on TadsObject.  No other intrinsic classes can
<a name="287"></a>     *   be used in the list, and objects of other types cannot be used in
<a name="288"></a>     *   the list.  
<a name="289"></a>     */
<a name="290"></a>    setSuperclassList(scList);
<a name="291"></a>}
<a name="292"></a>
<a name="293"></a>
<a name="294"></a>/* ------------------------------------------------------------------------ */
<a name="295"></a>/* 
<a name="296"></a> *   We need CharacterSet and ByteArray (for String.mapToByteArray).  (But
<a name="297"></a> *   wait to include these until after we've defined Object, since everything
<a name="298"></a> *   depends on Object.)  
<a name="299"></a> */
<a name="300"></a>#include "charset.h"
<a name="301"></a>#include "bytearr.h"
<a name="302"></a>
<a name="303"></a>/* ------------------------------------------------------------------------ */
<a name="304"></a>/*
<a name="305"></a> *   The native string type. 
<a name="306"></a> */
<a name="307"></a>intrinsic class String 'string/030005': Object
<a name="308"></a>{
<a name="309"></a>    /* get the length of the string */
<a name="310"></a>    length();
<a name="311"></a>
<a name="312"></a>    /* extract a substring */
<a name="313"></a>    substr(start, len?);
<a name="314"></a>
<a name="315"></a>    /* convert to upper case */
<a name="316"></a>    toUpper();
<a name="317"></a>
<a name="318"></a>    /* convert to lower case */
<a name="319"></a>    toLower();
<a name="320"></a>
<a name="321"></a>    /* find a substring */
<a name="322"></a>    find(str, index?);
<a name="323"></a>
<a name="324"></a>    /* 
<a name="325"></a>     *   convert to a list of Unicode character codes, or get the Unicode
<a name="326"></a>     *   character code for the single character at the given index 
<a name="327"></a>     */
<a name="328"></a>    toUnicode(idx?);
<a name="329"></a>
<a name="330"></a>    /* htmlify a string */
<a name="331"></a>    htmlify(flags?);
<a name="332"></a>
<a name="333"></a>    /* determine if we start with the given string */
<a name="334"></a>    startsWith(str);
<a name="335"></a>
<a name="336"></a>    /* determine if we end with the given string */
<a name="337"></a>    endsWith(str);
<a name="338"></a>
<a name="339"></a>    /* 
<a name="340"></a>     *   Map to a byte array, converting to the given character set.
<a name="341"></a>     *   'charset' must be an object of intrinsic class CharacterSet; the
<a name="342"></a>     *   characters in the string will be mapped from the internal Unicode
<a name="343"></a>     *   representation to the appropriate byte representation in the given
<a name="344"></a>     *   character set.  
<a name="345"></a>     */
<a name="346"></a>    mapToByteArray(charset);
<a name="347"></a>
<a name="348"></a>    /* 
<a name="349"></a>     *   Replace one occurrence or all occurrences of the given substring
<a name="350"></a>     *   with the given new string.  
<a name="351"></a>     */
<a name="352"></a>    findReplace(origStr, newStr, flags, index?);
<a name="353"></a>}
<a name="354"></a>
<a name="355"></a>/*
<a name="356"></a> *   Flags for String.htmlify 
<a name="357"></a> */
<a name="358"></a>
<a name="359"></a>/* 
<a name="360"></a> *   translate spaces - each space in a run of multiple spaces is converted
<a name="361"></a> *   to an &amp;nbsp; sequence 
<a name="362"></a> */
<a name="363"></a>#define HtmlifyTranslateSpaces    0x0001
<a name="364"></a>
<a name="365"></a>/* translate newlines - converts each \n character to a &lt;br&gt; tag */
<a name="366"></a>#define HtmlifyTranslateNewlines  0x0002
<a name="367"></a>
<a name="368"></a>/* translate tabs - converts each \t character to a &lt;tab&gt; tag */
<a name="369"></a>#define HtmlifyTranslateTabs      0x0004
<a name="370"></a>
<a name="371"></a>/* 
<a name="372"></a> *   Translate all whitespace characters - translate all spaces, tabs, and
<a name="373"></a> *   newlines into their HTML equivalents: each space character becomes an
<a name="374"></a> *   '&amp;nbsp sequence;', each '\n' character becomes a &lt;br&gt; tag; and each
<a name="375"></a> *   '\t' character becomes a &lt;tab&gt; tag.  
<a name="376"></a> */
<a name="377"></a>#define HtmlifyTranslateWhitespace \
<a name="378"></a>    (HtmlifyTranslateSpaces | HtmlifyTranslateNewlines | HtmlifyTranslateTabs)
<a name="379"></a>
<a name="380"></a>
<a name="381"></a>/*
<a name="382"></a> *   Flags for String.findReplace 
<a name="383"></a> */
<a name="384"></a>
<a name="385"></a>/* replace only one occurrence, or replace all occurrences */
<a name="386"></a>#define ReplaceOnce  0x0000
<a name="387"></a>#define ReplaceAll   0x0001
<a name="388"></a>
<a name="389"></a>
<a name="390"></a>/* ------------------------------------------------------------------------ */
<a name="391"></a>/*
<a name="392"></a> *   The native list type 
<a name="393"></a> */
<a name="394"></a>intrinsic class List 'list/030007': Collection
<a name="395"></a>{
<a name="396"></a>    /* 
<a name="397"></a>     *   Select a subset of the list: returns a new list consisting only
<a name="398"></a>     *   of the elements for which the callback function 'func' returns
<a name="399"></a>     *   true.  
<a name="400"></a>     */
<a name="401"></a>    subset(func);
<a name="402"></a>
<a name="403"></a>    /*
<a name="404"></a>     *   Apply the callback function to each element of this list, and
<a name="405"></a>     *   return a new list consisting of the results.  Effectively maps
<a name="406"></a>     *   the list to a new list using the given function.  Suppose the
<a name="407"></a>     *   original list is
<a name="408"></a>     *   
<a name="409"></a>     *   [x, y, z]
<a name="410"></a>     *   
<a name="411"></a>     *   Then the result list is
<a name="412"></a>     *   
<a name="413"></a>     *   [func(x), func(y), func(z)] 
<a name="414"></a>     */
<a name="415"></a>    mapAll(func);
<a name="416"></a>
<a name="417"></a>    /* get the number of elements in the list */
<a name="418"></a>    length();
<a name="419"></a>
<a name="420"></a>    /* extract a sublist */
<a name="421"></a>    sublist(start, len?);
<a name="422"></a>
<a name="423"></a>    /* intersect with another list */
<a name="424"></a>    intersect(other);
<a name="425"></a>
<a name="426"></a>    /* get the index of the first match for the given value */
<a name="427"></a>    indexOf(val);
<a name="428"></a>
<a name="429"></a>    /* car/cdr - head/tail of list */
<a name="430"></a>    car();
<a name="431"></a>    cdr();
<a name="432"></a>
<a name="433"></a>    /* 
<a name="434"></a>     *   Find the first element for which the given condition is true, and
<a name="435"></a>     *   return the index of the element.  Applies the callback function
<a name="436"></a>     *   (which encodes the condition to evaluate) to each element in
<a name="437"></a>     *   turn, starting with the first.  For each element, if the callback
<a name="438"></a>     *   returns nil, proceeds to the next element; otherwise, stops and
<a name="439"></a>     *   returns the index of the element.  If the callback never returns
<a name="440"></a>     *   true for any element, we'll return nil.  
<a name="441"></a>     */
<a name="442"></a>    indexWhich(cond);
<a name="443"></a>
<a name="444"></a>    /* 
<a name="445"></a>     *   Invoke the callback func(val) on each element, in order from first
<a name="446"></a>     *   to last.  No return value.  
<a name="447"></a>     */
<a name="448"></a>    forEach(func);
<a name="449"></a>
<a name="450"></a>    /* 
<a name="451"></a>     *   Find the first element for which the given condition is true, and
<a name="452"></a>     *   return the value of the element.  Returns nil if no item
<a name="453"></a>     *   satisfies the condition.  
<a name="454"></a>     */
<a name="455"></a>    valWhich(cond);
<a name="456"></a>
<a name="457"></a>    /* find the last element with the given value, and return its index */
<a name="458"></a>    lastIndexOf(val);
<a name="459"></a>
<a name="460"></a>    /* 
<a name="461"></a>     *   Find the last element for which the condition is true, and return
<a name="462"></a>     *   the index of the element.  Applies the callback to each element
<a name="463"></a>     *   in turn, starting with the last element and working backwards.
<a name="464"></a>     *   For each element, if the callback returns nil, proceeds to the
<a name="465"></a>     *   previous element; otherwise, stops and returns the index of the
<a name="466"></a>     *   element.  If the callback never returns true for any element,
<a name="467"></a>     *   we'll return nil.  
<a name="468"></a>     */
<a name="469"></a>    lastIndexWhich(cond);
<a name="470"></a>
<a name="471"></a>    /* 
<a name="472"></a>     *   Find the last element for which the condition is true, and return
<a name="473"></a>     *   the value of the element 
<a name="474"></a>     */
<a name="475"></a>    lastValWhich(cond);
<a name="476"></a>
<a name="477"></a>    /* count the number of elements with the given value */
<a name="478"></a>    countOf(val);
<a name="479"></a>
<a name="480"></a>    /* count the number of elements for which the callback returns true */
<a name="481"></a>    countWhich(cond);
<a name="482"></a>
<a name="483"></a>    /* get a new list consisting of the unique elements of this list */
<a name="484"></a>    getUnique();
<a name="485"></a>
<a name="486"></a>    /* 
<a name="487"></a>     *   append the elements of the list 'lst' to the elements of this
<a name="488"></a>     *   list, then remove repeated elements in the result; returns a new
<a name="489"></a>     *   list with the unique elements of the combination of the two lists 
<a name="490"></a>     */
<a name="491"></a>    appendUnique(lst);
<a name="492"></a>
<a name="493"></a>    /* 
<a name="494"></a>     *   append an element - this works almost exactly like the
<a name="495"></a>     *   concatation operator ('+'), but if the argument is a list, this
<a name="496"></a>     *   simply adds the list as a new element, rather than adding each
<a name="497"></a>     *   element of the list as a separate element 
<a name="498"></a>     */
<a name="499"></a>    append(val);
<a name="500"></a>
<a name="501"></a>    /* 
<a name="502"></a>     *   Sort the list, returning a new list.  If the 'descending' flag is
<a name="503"></a>     *   provided and is not nil, we'll sort the list in descending order
<a name="504"></a>     *   rather than ascending order.
<a name="505"></a>     *   
<a name="506"></a>     *   If the 'comparisonFunction' argument is provided, it must be a
<a name="507"></a>     *   callback function; the callback takes two arguments, and returns
<a name="508"></a>     *   an integer less than zero if the first argument value is less
<a name="509"></a>     *   than the second, zero if they're equal, and an integer greater
<a name="510"></a>     *   than zero if the first is greater than the second.  If no
<a name="511"></a>     *   'comparisonFunction' argument is provided, or it's provided and
<a name="512"></a>     *   its value is nil, we'll simply compare the list elements as
<a name="513"></a>     *   ordinary values.  The comparison function can be provided for
<a name="514"></a>     *   caller-defined orderings, such as ordering a set of objects.  
<a name="515"></a>     */
<a name="516"></a>    sort(descending?, comparisonFunction?);
<a name="517"></a>
<a name="518"></a>    /*
<a name="519"></a>     *   Prepend an element - this inserts the value before the first
<a name="520"></a>     *   existing element. 
<a name="521"></a>     */
<a name="522"></a>    prepend(val);
<a name="523"></a>
<a name="524"></a>    /* 
<a name="525"></a>     *   Insert one or more elements at the given index.  If the index is 1,
<a name="526"></a>     *   the elements will be inserted before the first existing element.
<a name="527"></a>     *   If the index is one higher than the number of elements, the
<a name="528"></a>     *   elements will be inserted after all existing elements.
<a name="529"></a>     *   
<a name="530"></a>     *   Note that a list value argument will simply be inserted as a single
<a name="531"></a>     *   element.
<a name="532"></a>     *   
<a name="533"></a>     *   Returns a new list with the value(s) inserted.  
<a name="534"></a>     */
<a name="535"></a>    insertAt(startingIndex, val, ...);
<a name="536"></a>
<a name="537"></a>    /*
<a name="538"></a>     *   Delete the element at the given index, reducing the length of the
<a name="539"></a>     *   list by one element.  Returns a new list with the given element
<a name="540"></a>     *   removed.  
<a name="541"></a>     */
<a name="542"></a>    removeElementAt(index);
<a name="543"></a>
<a name="544"></a>    /*
<a name="545"></a>     *   Delete the range of elements starting at startingIndex and ending
<a name="546"></a>     *   at endingIndex.  The elements at the ends of the range are included
<a name="547"></a>     *   in the deletion.  If startingIndex == endingIndex, only one element
<a name="548"></a>     *   is removed.  Returns a new list with the given element range
<a name="549"></a>     *   removed.  
<a name="550"></a>     */
<a name="551"></a>    removeRange(startingIndex, endingIndex);
<a name="552"></a>
<a name="553"></a>    /*
<a name="554"></a>     *   Invoke the callback func(index, val) on each element, in order from
<a name="555"></a>     *   first to last.  No return value.  
<a name="556"></a>     */
<a name="557"></a>    forEachAssoc(func);
<a name="558"></a>}
<a name="559"></a>
<a name="560"></a>/*
<a name="561"></a> *   Sorting order flags.  These can be passed in as the first argument to
<a name="562"></a> *   List.sort() (and Vector.sort() as well) to make the meaning of the
<a name="563"></a> *   argument clearer.  
<a name="564"></a> */
<a name="565"></a>#define SortAsc    nil
<a name="566"></a>#define SortDesc   true
<a name="567"></a>
<a name="568"></a>
<a name="569"></a>/* ------------------------------------------------------------------------ */
<a name="570"></a>/*
<a name="571"></a> *   'RexPattern' intrinsic class.  This class encapsulates a compiled
<a name="572"></a> *   regular expression pattern.
<a name="573"></a> *   
<a name="574"></a> *   A RexPattern object can be passed to the regular expression functions
<a name="575"></a> *   (rexMatch, rexSearch, rexReplace) in place of a string pattern.  Since
<a name="576"></a> *   compiling a regular expression takes a non-trivial amount of time, it's
<a name="577"></a> *   more efficient to compile a pattern to a RexPattern object if the same
<a name="578"></a> *   pattern will be used in multiple searches.  
<a name="579"></a> */
<a name="580"></a>intrinsic class RexPattern 'regex-pattern/030000': Object
<a name="581"></a>{
<a name="582"></a>    /*
<a name="583"></a>     *   Constructor:
<a name="584"></a>     *   
<a name="585"></a>     *   new RexPattern(patternString) - returns a RexPattern representing
<a name="586"></a>     *   the compiled pattern string.  
<a name="587"></a>     */
<a name="588"></a>
<a name="589"></a>    /* retrieve the original pattern string used to construct the object */
<a name="590"></a>    getPatternString();
<a name="591"></a>}
<a name="592"></a>
<a name="593"></a>#endif /* _SYSTYPE_H_ */
</pre>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/6/2009 from TADS version 3.0.18.1</div>
</body>
</html>
