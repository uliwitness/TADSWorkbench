<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>dict.h</title></head><body>
<table class=ban><tr><td><h1>dict.h</h1><td align=right><a href="../file/dict.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/* 
<a name="4"></a> *   Copyright (c) 2000, 2006 Michael J. Roberts
<a name="5"></a> *   
<a name="6"></a> *   This file is part of TADS 3.
<a name="7"></a> *   
<a name="8"></a> *   This header defines the Dictionary intrinsic class.  
<a name="9"></a> */
<a name="10"></a>
<a name="11"></a>#ifndef _DICT_H_
<a name="12"></a>#define _DICT_H_
<a name="13"></a>
<a name="14"></a>/* include our base class definition */
<a name="15"></a>#include "systype.h"
<a name="16"></a>
<a name="17"></a>/*
<a name="18"></a> *   The Dictionary intrinsic class is a specialized lookup table class
<a name="19"></a> *   designed for storing the vocabulary table for a parser.  Dictionary
<a name="20"></a> *   works closely with GrammarProd to supply the vocabulary tokens for the
<a name="21"></a> *   productions.
<a name="22"></a> *   
<a name="23"></a> *   The main difference between Dictionary and a more general hash table is
<a name="24"></a> *   that Dictionary tags each vocabulary word with a type; for our purposes,
<a name="25"></a> *   the type is the vocabulary property (&amp;noun, &amp;adjective, etc) that
<a name="26"></a> *   associates the word with an object.  
<a name="27"></a> */
<a name="28"></a>intrinsic class Dictionary 'dictionary2/030000': Object
<a name="29"></a>{
<a name="30"></a>    /*
<a name="31"></a>     *   Constructor:
<a name="32"></a>     *   
<a name="33"></a>     *   new Dictionary() - creates a dictionary with a default comparator,
<a name="34"></a>     *   which matches strings exactly (note that upper-case and lower-case
<a name="35"></a>     *   letters are considered distinct)
<a name="36"></a>     *   
<a name="37"></a>     *   new Dictionary(compObj) - create a dictionary with the given
<a name="38"></a>     *   comparator object.  A comparator is an object that implements the
<a name="39"></a>     *   comparator interface - see below for details.  When searching the
<a name="40"></a>     *   dictionary (with findWord, for example), we use the comparator
<a name="41"></a>     *   object to determine if the string beings sought matches a dictionary
<a name="42"></a>     *   string.  
<a name="43"></a>     */
<a name="44"></a>
<a name="45"></a>    /* 
<a name="46"></a>     *   Set the comparator object.  This defines how words are compared.
<a name="47"></a>     *   The object must provide the following methods, which comprise the
<a name="48"></a>     *   "comparator" interface.  Note that there's no class that defines
<a name="49"></a>     *   this interface; this is simply a set of methods that we define here,
<a name="50"></a>     *   and which the supplied object must define.
<a name="51"></a>     *   
<a name="52"></a>     *   calcHash(str) - returns an integer giving the hash value of the
<a name="53"></a>     *   given string.  The purpose of the hash value is to arbitrarily
<a name="54"></a>     *   partition the search space, so that we can search only a small
<a name="55"></a>     *   subset of the dictionary when looking for a particular string.  It
<a name="56"></a>     *   is desirable for hash values to distribute uniformly for a given set
<a name="57"></a>     *   of strings.  It's also highly desirable for the hash computation to
<a name="58"></a>     *   be inexpensive (i.e., to run fast), since the whole point of the
<a name="59"></a>     *   hash is to reduce the amount of time it takes to find a string; if
<a name="60"></a>     *   it takes longer to compute the hash value than it would to search
<a name="61"></a>     *   every string in the table, then we don't come out ahead using the
<a name="62"></a>     *   hash.
<a name="63"></a>     *   
<a name="64"></a>     *   matchValues(inputStr, dictStr) - compare the given input string with
<a name="65"></a>     *   the given dictionary string, and return a result indicating whether
<a name="66"></a>     *   or not they match for the purposes of the comparator.  A return
<a name="67"></a>     *   value of zero or nil indicates that the values do not match; any
<a name="68"></a>     *   other return value indicates a match.
<a name="69"></a>     *   
<a name="70"></a>     *   Typically, matchValues() will return a non-zero integer to indicate
<a name="71"></a>     *   a match and to encode additional information about the match using a
<a name="72"></a>     *   bitwise-OR'd combination of flag values.  For example, a comparator
<a name="73"></a>     *   that allows case folding could use bit flag 0x0001 to indicate any
<a name="74"></a>     *   match, and bit flag 0x0002 to indicate a match where the case of one
<a name="75"></a>     *   or more input letters did not match the case of the corresponding
<a name="76"></a>     *   letters in the dictionary string.  So, a return value of 0x0001
<a name="77"></a>     *   would indicate an exact match, and 0x0003 would indicate a match
<a name="78"></a>     *   with case differences.
<a name="79"></a>     *   
<a name="80"></a>     *   Note the asymmetry in the matchValues() arguments: we specifically
<a name="81"></a>     *   designate one string as the input string and one as the dictionary
<a name="82"></a>     *   string.  This allows for asymmetrical comparisons, which are
<a name="83"></a>     *   desirable in some cases: we sometimes want a given input string to
<a name="84"></a>     *   match a given dictionary string even when the two are not identical
<a name="85"></a>     *   character-by-character.  For example, we might want to allow the
<a name="86"></a>     *   user to type only the first six or eight characters of a string in
<a name="87"></a>     *   the dictionary, to save typing; or, we might want to allow a user to
<a name="88"></a>     *   enter unaccented letters and still match dictionary words containing
<a name="89"></a>     *   the corresponding letters with accents.  The asymmetry in the
<a name="90"></a>     *   arguments is there because we often only want these "fuzzy" match
<a name="91"></a>     *   rules to work in one direction; for the truncation example, we'd
<a name="92"></a>     *   want an input word that's a truncated version of a dictionary word
<a name="93"></a>     *   to match, but not the other way around.
<a name="94"></a>     *   
<a name="95"></a>     *   Important: Note that, although the hash value computation is up to
<a name="96"></a>     *   the implementing object to define, we impose one requirement.  It is
<a name="97"></a>     *   REQUIRED that for any two strings s1 and s2, if matchValues(s1, s2)
<a name="98"></a>     *   indicates a match (i.e., returns a value other than 0 or nil), then
<a name="99"></a>     *   calcHash(s1) MUST EQUAL calcHash(s2).  (This does NOT mean that two
<a name="100"></a>     *   strings with equal hash values must be equal, or, equivalently, that
<a name="101"></a>     *   two unequal strings must have different hash values.  Hash
<a name="102"></a>     *   collisions are explicitly allowed, so two strings that don't match
<a name="103"></a>     *   can still have the same hash value.)  
<a name="104"></a>     */
<a name="105"></a>    setComparator(compObj);
<a name="106"></a>
<a name="107"></a>    /* 
<a name="108"></a>     *   Find a word; returns a list giving the objects associated with the
<a name="109"></a>     *   string in the dictionary.  If voc_prop is specified, only objects
<a name="110"></a>     *   associated with the word by the given vocabulary property are
<a name="111"></a>     *   returned.  We match the string using the comparator defined for the
<a name="112"></a>     *   dictionary.
<a name="113"></a>     *   
<a name="114"></a>     *   The return value is a list consisting of pairs of entries.  The
<a name="115"></a>     *   first element of each pair is the matching object, and the second is
<a name="116"></a>     *   gives the comparator result for matching the word.  If we use a
<a name="117"></a>     *   StringComparator, this will be a non-zero integer value giving
<a name="118"></a>     *   information on truncation, case folding, and any equivalence
<a name="119"></a>     *   mappings defined in the comparator.  If the comparator is a custom
<a name="120"></a>     *   object, then the second element of the pair will be whatever the
<a name="121"></a>     *   custom comparator's matchValues() method returned for matching the
<a name="122"></a>     *   value for that dictionary entry.
<a name="123"></a>     *   
<a name="124"></a>     *   The reason for giving a matchValues() return value for every
<a name="125"></a>     *   individual match is that the same input string 'str' might match
<a name="126"></a>     *   multiple entries in the dictionary.  For example, the same string
<a name="127"></a>     *   might match one word exactly and one with truncation.  The match
<a name="128"></a>     *   result code lets the caller determine if some matches are "better"
<a name="129"></a>     *   than others, based on how the string matched for each individual
<a name="130"></a>     *   object entry.  
<a name="131"></a>     */
<a name="132"></a>    findWord(str, voc_prop?);
<a name="133"></a>
<a name="134"></a>    /*
<a name="135"></a>     *   Add a word to the dictionary, associating the given object with the
<a name="136"></a>     *   given string and property combination. 
<a name="137"></a>     */
<a name="138"></a>    addWord(obj, str, voc_prop);
<a name="139"></a>
<a name="140"></a>    /*
<a name="141"></a>     *   Remove the given word association from the dictionary.  This
<a name="142"></a>     *   removes only the association for the given object; other objects
<a name="143"></a>     *   associated with the same word are not affected.  
<a name="144"></a>     */
<a name="145"></a>    removeWord(obj, str, voc_prop);
<a name="146"></a>
<a name="147"></a>    /* 
<a name="148"></a>     *   Check to see if the given string 'str' is defined in the dictionary.
<a name="149"></a>     *   Returns true if the word is defined, nil if not.
<a name="150"></a>     *   
<a name="151"></a>     *   If the 'filter' argument is provided, it gives a callback function
<a name="152"></a>     *   that is invoked to determine whether or not to count a particular
<a name="153"></a>     *   word in the dictionary as a match.  The callback is invoked with one
<a name="154"></a>     *   argument: (filter)(match), where 'match' is the result of the
<a name="155"></a>     *   comparator's matchValues(str,dstr) method, where 'dstr' is a
<a name="156"></a>     *   dictionary string matching 'str'.  The filter function returns true
<a name="157"></a>     *   if the string should be counted as a match, nil if not.  The return
<a name="158"></a>     *   value of isWordDefined thus will be true if the filter function
<a name="159"></a>     *   returns true for at least one match, nil if not.  The purpose of the
<a name="160"></a>     *   filter function is to allow the caller to impose a more restrictive
<a name="161"></a>     *   condition than the dictionary's current comparator does; for
<a name="162"></a>     *   example, the caller might use the filter to determine if the
<a name="163"></a>     *   dictionary contains any matches for 'str' that match without any
<a name="164"></a>     *   truncation.  
<a name="165"></a>     */
<a name="166"></a>    isWordDefined(str, filter?);
<a name="167"></a>
<a name="168"></a>    /*
<a name="169"></a>     *   Invoke the callback func(str, obj, prop) for each word in the
<a name="170"></a>     *   dictionary.  Note that the callback can be invoked with a single
<a name="171"></a>     *   string multiple times, since the callback is invoked once per
<a name="172"></a>     *   word/object/property association; in other words, the callback is
<a name="173"></a>     *   invoked once for each association created with addWord() or during
<a name="174"></a>     *   compilation.  
<a name="175"></a>     */
<a name="176"></a>    forEachWord(func);
<a name="177"></a>}
<a name="178"></a>
<a name="179"></a>/* 
<a name="180"></a> *   We rely on certain methods defined by the comparator interface, so
<a name="181"></a> *   export those method names.  
<a name="182"></a> */
<a name="183"></a>property calcHash, matchValues;
<a name="184"></a>export calcHash 'IfcComparator.calcHash';
<a name="185"></a>export matchValues 'IfcComparator.matchValues';
<a name="186"></a>
<a name="187"></a>#endif /* _DICT_H_ */
</pre>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/6/2009 from TADS version 3.0.18.1</div>
</body>
</html>
