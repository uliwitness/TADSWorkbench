<html><head><link rel=stylesheet type="text/css" href="../libref.css"><title>file.h</title></head><body>
<table class=ban><tr><td><h1>file.h</h1><td align=right><a href="../file/file.h.html">documentation</a></table><pre>
<a name="1"></a>#charset "us-ascii"
<a name="2"></a>
<a name="3"></a>/*
<a name="4"></a> *   Copyright (c) 2001, 2006 Michael J. Roberts
<a name="5"></a> *   
<a name="6"></a> *   This file is part of TADS 3.
<a name="7"></a> *   
<a name="8"></a> *   This header defines the File intrinsic class.  
<a name="9"></a> */
<a name="10"></a>
<a name="11"></a>#ifndef _FILE_H_
<a name="12"></a>#define _FILE_H_
<a name="13"></a>
<a name="14"></a>/* include our base class definition */
<a name="15"></a>#include "systype.h"
<a name="16"></a>
<a name="17"></a>/*
<a name="18"></a> *   File methods use the CharacterSet and ByteArray intrinsic
<a name="19"></a> *   classes, so include their headers to make sure they're available to
<a name="20"></a> *   File users.  
<a name="21"></a> */
<a name="22"></a>#include "charset.h"
<a name="23"></a>#include "bytearr.h"
<a name="24"></a>
<a name="25"></a>
<a name="26"></a>/* ------------------------------------------------------------------------ */
<a name="27"></a>/*
<a name="28"></a> *   File access modes.  These are used when calling the file open methods
<a name="29"></a> *   to specify how the file is to be accessed.
<a name="30"></a> */
<a name="31"></a>
<a name="32"></a>/* 
<a name="33"></a> *   Read mode - the file is opened for reading (writing is not allowed).
<a name="34"></a> *   When opened in this mode, the file must exist, or a
<a name="35"></a> *   FileNotFoundException is thrown from the open method. 
<a name="36"></a> */
<a name="37"></a>#define FileAccessRead            0x0001
<a name="38"></a>
<a name="39"></a>/*
<a name="40"></a> *   Write mode - the file is opened for writing (reading is not allowed).
<a name="41"></a> *   When opened in this mode, if the file doesn't already exist, a new file
<a name="42"></a> *   is created; if the file does already exist, the existing data in the
<a name="43"></a> *   file are discarded (i.e., the file is truncated to zero length) on
<a name="44"></a> *   open. 
<a name="45"></a> */
<a name="46"></a>#define FileAccessWrite           0x0002
<a name="47"></a>
<a name="48"></a>/*
<a name="49"></a> *   Read/write mode, keeping existing contents - the file is opened for
<a name="50"></a> *   both reading and writing.  If the file does not exist, a new file is
<a name="51"></a> *   created.  If the file does already exist, the existing contents of the
<a name="52"></a> *   file are kept intact on open.  
<a name="53"></a> */
<a name="54"></a>#define FileAccessReadWriteKeep   0x0003
<a name="55"></a>
<a name="56"></a>/*
<a name="57"></a> *   Read/write mode, truncating existing contents - the file is opened for
<a name="58"></a> *   both reading and writing.  If the file does not exist, a new file is
<a name="59"></a> *   created.  If the file does already exist, the existing contents of the
<a name="60"></a> *   file are discarded (i.e., the file is truncated to zero length) on
<a name="61"></a> *   open.  
<a name="62"></a> */
<a name="63"></a>#define FileAccessReadWriteTrunc  0x0004
<a name="64"></a>
<a name="65"></a>
<a name="66"></a>/* ------------------------------------------------------------------------ */
<a name="67"></a>/*
<a name="68"></a> *   Special file identifiers.  These identifiers can be passed to the 'open'
<a name="69"></a> *   routines in place of the filename string argument.
<a name="70"></a> *   
<a name="71"></a> *   The actual name and location of a special file is determined by the
<a name="72"></a> *   interpreter.  Since games use these internal identifiers rather than the
<a name="73"></a> *   actual system filenames when accessing special files, different
<a name="74"></a> *   interpreters can adapt to different local conventions without bothering
<a name="75"></a> *   the game code with the details.  The game code simply refers to the file
<a name="76"></a> *   it wants using the virtual identifier, and the interpreter takes care of
<a name="77"></a> *   the rest.
<a name="78"></a> *   
<a name="79"></a> *   Note that special files generally bypass the interpreter "file safety"
<a name="80"></a> *   settings.  This is important because it allows the library and games a
<a name="81"></a> *   degree of controlled access to the file system, even when the file
<a name="82"></a> *   safety settings wouldn't normally allow similar access for arbitrary
<a name="83"></a> *   file operations.  Even though this special file access can bypass the
<a name="84"></a> *   file safety level, it doesn't compromise security, because the
<a name="85"></a> *   interpreter has exclusive control over the names and locations of the
<a name="86"></a> *   special files - thus a game can only access the particular files that
<a name="87"></a> *   the interpreter designates as special, and can't use special files to
<a name="88"></a> *   access arbitrary file system entities.  
<a name="89"></a> */
<a name="90"></a>
<a name="91"></a>/*
<a name="92"></a> *   The library defaults file.  This is the special file where the library
<a name="93"></a> *   stores user-controlled start-up default settings.  
<a name="94"></a> */
<a name="95"></a>#define LibraryDefaultsFile    0x0001
<a name="96"></a>
<a name="97"></a>
<a name="98"></a>/* ------------------------------------------------------------------------ */
<a name="99"></a>/*
<a name="100"></a> *   The File intrinsic class provides access to files in the external file
<a name="101"></a> *   system.  This lets you create, read, and write files.  The class
<a name="102"></a> *   supports text files (with translations to and from local character
<a name="103"></a> *   sets), "data" files (using the special TADS 2 binary file format), and
<a name="104"></a> *   "raw" files (this mode lets you manipulate files in arbitrary text or
<a name="105"></a> *   binary formats by giving you direct access to the raw bytes in the
<a name="106"></a> *   file).  
<a name="107"></a> */
<a name="108"></a>intrinsic class File 'file/030002': Object
<a name="109"></a>{
<a name="110"></a>    /*
<a name="111"></a>     *   File has no constructors, so it is not possible to create a File
<a name="112"></a>     *   with the 'new' operator.  To create a file, use one of the static
<a name="113"></a>     *   creator methods instead:
<a name="114"></a>     *   
<a name="115"></a>     *   f = File.openTextFile()
<a name="116"></a>     *   
<a name="117"></a>     *   All of the open methods throw exceptions if the open fails:
<a name="118"></a>     *   
<a name="119"></a>     *   FileNotFoundException - indicates that the requested file doesn't
<a name="120"></a>     *   exist.  This is thrown when the access mode requires an existing
<a name="121"></a>     *   file but the named file does not exist.
<a name="122"></a>     *   
<a name="123"></a>     *   FileCreationException - indicates that the requested file could not
<a name="124"></a>     *   be created.  This is thrown when the access mode requires creating
<a name="125"></a>     *   a new file but the named file cannot be created.
<a name="126"></a>     *   
<a name="127"></a>     *   FileOpenException - indicates that the requested file could not be
<a name="128"></a>     *   opened.  This is thrown when the access mode allows either an
<a name="129"></a>     *   existing file to be opened or a new file to be created, but neither
<a name="130"></a>     *   could be accomplished.
<a name="131"></a>     *   
<a name="132"></a>     *   FileSafetyException - the requested access mode is not allowed for
<a name="133"></a>     *   the given file due to the current file safety level set by the
<a name="134"></a>     *   user.  Users can set the file safety level (through command-line
<a name="135"></a>     *   switches or other preference mechanisms which vary by interpreter)
<a name="136"></a>     *   to restrict the types of file operations that applications are
<a name="137"></a>     *   allowed to perform, in order to protect their systems from
<a name="138"></a>     *   malicious programs.  This exception indicates that the user has set
<a name="139"></a>     *   a safety level that is too restrictive for the requested operation.
<a name="140"></a>     */
<a name="141"></a>
<a name="142"></a>    /*
<a name="143"></a>     *   Static creator method: open a text file.  Returns a File object
<a name="144"></a>     *   that can be used to read or write the file.  'access' is the
<a name="145"></a>     *   read/write mode, and must be one of FileAccessRead or
<a name="146"></a>     *   FileAccessWrite.  'charset' is a CharacterSet object, or can
<a name="147"></a>     *   optionally be a string naming a character set, in which case a
<a name="148"></a>     *   CharacterSet object for the named character set will automatically
<a name="149"></a>     *   be created.  If 'charset' is omitted, a default "us-ascii"
<a name="150"></a>     *   character set will be used.
<a name="151"></a>     *   
<a name="152"></a>     *   When a file is opened in text mode for reading, each call to
<a name="153"></a>     *   readFile() reads and returns a line of text from the file.  When a
<a name="154"></a>     *   file is opened in text mode for writing, any existing file is
<a name="155"></a>     *   discarded and replaced with the new data.  Each read and write to a
<a name="156"></a>     *   text file is mapped through the CharacterSet in effect at the time
<a name="157"></a>     *   of the read or write.  
<a name="158"></a>     */
<a name="159"></a>    static openTextFile(filename, access, charset?);
<a name="160"></a>
<a name="161"></a>    /*
<a name="162"></a>     *   Static creator method: open a file in 'data' mode.  Returns a File
<a name="163"></a>     *   object that can be used to read or write the file.  'access'
<a name="164"></a>     *   indicates the desired read/write access and the disposition of any
<a name="165"></a>     *   existing file; any of the FileAccessXxx modes can be used.
<a name="166"></a>     *   
<a name="167"></a>     *   When a file is opened in data mode, you can read and write
<a name="168"></a>     *   integers, strings, and 'true' values to the file, and the values in
<a name="169"></a>     *   the file are marked with their datatype in a private data format.
<a name="170"></a>     *   Because the file uses a tads-specific format, this mode cannot be
<a name="171"></a>     *   used to read files created by other applications or write files for
<a name="172"></a>     *   use by other applications; however, this storage format is
<a name="173"></a>     *   convenient for storing simple data values because the File object
<a name="174"></a>     *   takes care of converting to and from a portable binary format.  
<a name="175"></a>     */
<a name="176"></a>    static openDataFile(filename, access);
<a name="177"></a>
<a name="178"></a>    /*
<a name="179"></a>     *   Static creator method: open a file in 'raw' mode.  Returns a File
<a name="180"></a>     *   object that can be used to read or write the file.  'access'
<a name="181"></a>     *   indicates the desired read/write access mode and the disposition of
<a name="182"></a>     *   any existing file; any of the FileAccessXxx modes can be used.
<a name="183"></a>     *   
<a name="184"></a>     *   When a file is opened in raw mode, only ByteArray values can be
<a name="185"></a>     *   read and written.  The File object performs no translations of the
<a name="186"></a>     *   bytes read or written.  This mode requires the calling program
<a name="187"></a>     *   itself to perform all data conversions to and from a raw byte
<a name="188"></a>     *   format, but the benefit of this extra work is that this mode can be
<a name="189"></a>     *   used to read and write files in arbitrary data formats, including
<a name="190"></a>     *   formats defined by other applications.  
<a name="191"></a>     */
<a name="192"></a>    static openRawFile(filename, access);
<a name="193"></a>
<a name="194"></a>    /* 
<a name="195"></a>     *   get the CharacterSet object the File is currently using; returns
<a name="196"></a>     *   nil for a non-text file 
<a name="197"></a>     */
<a name="198"></a>    getCharacterSet();
<a name="199"></a>
<a name="200"></a>    /*
<a name="201"></a>     *   Set the CharacterSet object the File is to use from now on.  This
<a name="202"></a>     *   is not meaningful except for text files.  'charset' must be a
<a name="203"></a>     *   CharacterSet object; in particular note that a character set name
<a name="204"></a>     *   given as a string is not allowed here.  
<a name="205"></a>     */
<a name="206"></a>    setCharacterSet(charset);
<a name="207"></a>
<a name="208"></a>    /*
<a name="209"></a>     *   Close the file.  Flushes any buffered information to the underlying
<a name="210"></a>     *   system file and releases any system resources (such as share locks
<a name="211"></a>     *   or system buffers) associated with the file.  After this routine is
<a name="212"></a>     *   called, no further operations on the file can be performed (a
<a name="213"></a>     *   FileClosedException will be thrown if any subsequent operations are
<a name="214"></a>     *   attempted).
<a name="215"></a>     *   
<a name="216"></a>     *   It's not strictly necessary to call closeFile() on a File, since the
<a name="217"></a>     *   system will automatically do this work when the File object becomes
<a name="218"></a>     *   unreachable and is discarded by the garbage collector.  However, it
<a name="219"></a>     *   is good practice to close a file explicitly by calling this method
<a name="220"></a>     *   as soon as the program reaches a point at which it knows it's done
<a name="221"></a>     *   with the file, because garbage collection might not run for a
<a name="222"></a>     *   significant amount of time after the program is actually done with
<a name="223"></a>     *   the file, in which case the system resources associated with the
<a name="224"></a>     *   file would be needlessly retained for this extended time.  
<a name="225"></a>     */
<a name="226"></a>    closeFile();
<a name="227"></a>
<a name="228"></a>    /*
<a name="229"></a>     *   Read from the file.  Returns a data value that depends on the file
<a name="230"></a>     *   mode, as described below, or nil at end of file.
<a name="231"></a>     *   
<a name="232"></a>     *   If the file is open in text mode, this reads a line of text from the
<a name="233"></a>     *   file and returns a string with the text of the line read.  A line of
<a name="234"></a>     *   text is a sequence of characters terminated with a line-ending
<a name="235"></a>     *   sequence, which is a carriage return, line feed, CR/LF pair, LF/CR
<a name="236"></a>     *   pair, or a Unicode line terminator character (0x2028) if the file is
<a name="237"></a>     *   being read with one of the Unicode encodings.  If the line read ends
<a name="238"></a>     *   in a line-ending sequence, the returned text will end in a '\n'
<a name="239"></a>     *   character, regardless of which of the possible line-ending sequences
<a name="240"></a>     *   is actually in the file, so the caller need not worry about the
<a name="241"></a>     *   details of the external file's format.  Every line read from the
<a name="242"></a>     *   file will end in a '\n' except possibly the last line - if the file
<a name="243"></a>     *   does not end with a line-ending sequence, then the last line read
<a name="244"></a>     *   from the file will not end in a '\n' character.  All bytes read from
<a name="245"></a>     *   the file will be mapped to characters through the CharacterSet
<a name="246"></a>     *   object currently in effect in the file, so the returned string will
<a name="247"></a>     *   always be a standard Unicode string, regardless of the byte encoding
<a name="248"></a>     *   of the file.
<a name="249"></a>     *   
<a name="250"></a>     *   If the file is open in 'data' mode, this reads one data element
<a name="251"></a>     *   using the private tads-specific data format.  The result is a value
<a name="252"></a>     *   of one of the types writable with writeFile() in 'data' mode.  In
<a name="253"></a>     *   order to read a 'data' file, the file must have been previously
<a name="254"></a>     *   written in 'data' mode.  
<a name="255"></a>     */
<a name="256"></a>    readFile();
<a name="257"></a>
<a name="258"></a>    /*
<a name="259"></a>     *   Write to the file.  Writes the given value to the file in a format
<a name="260"></a>     *   that depends on the file mode, as described below.  No return
<a name="261"></a>     *   value; if an error occurs writing the data, this throws a
<a name="262"></a>     *   FileIOException.
<a name="263"></a>     *   
<a name="264"></a>     *   If the file is open in text mode, this writes text to the file,
<a name="265"></a>     *   converting the given value to a string if necessary (and throwing
<a name="266"></a>     *   an error if such a conversion is not possible), and translating the
<a name="267"></a>     *   string to be written to bytes by mapping the string through the
<a name="268"></a>     *   CharacterSet object currently in effect for the file.  Note that no
<a name="269"></a>     *   line-ending characters are automatically added to the output, so if
<a name="270"></a>     *   the caller wishes to write line terminators, it should simply
<a name="271"></a>     *   include a '\n' character at the end of each line.
<a name="272"></a>     *   
<a name="273"></a>     *   If the file is open in 'data' mode, this writes the value, which
<a name="274"></a>     *   must be a string, integer, enum, or 'true' value, in a private
<a name="275"></a>     *   tads-specific data format that can later be read using the same
<a name="276"></a>     *   format.  The values are converted to the private binary format,
<a name="277"></a>     *   which is portable across platforms: a file written in 'data' mode
<a name="278"></a>     *   on one machine can be copied (byte-for-byte) to another machine,
<a name="279"></a>     *   even one that uses different hardware and a different operating
<a name="280"></a>     *   system, and read back in 'data' mode on the new machine to yield
<a name="281"></a>     *   the original values written.  
<a name="282"></a>     */
<a name="283"></a>    writeFile(val);
<a name="284"></a>
<a name="285"></a>    /*
<a name="286"></a>     *   Read bytes from the file into the given ByteArray object.  This can
<a name="287"></a>     *   only be used for a file opened in 'raw' mode.  If 'start' and 'cnt'
<a name="288"></a>     *   are given, they give the starting index in the byte array at which
<a name="289"></a>     *   the bytes read are to be stored, and the number of bytes to read,
<a name="290"></a>     *   respectively; if these are omitted, one byte is read from the file
<a name="291"></a>     *   for each byte in the byte array.
<a name="292"></a>     *   
<a name="293"></a>     *   Returns the number of bytes actually read into the byte array,
<a name="294"></a>     *   which will be less than or equal to the number requested.  If the
<a name="295"></a>     *   number read is less than the number requested, it means that the
<a name="296"></a>     *   end of the file was encountered, and only the returned number of
<a name="297"></a>     *   bytes were available.  
<a name="298"></a>     */
<a name="299"></a>    readBytes(byteArr, start?, cnt?);
<a name="300"></a>
<a name="301"></a>    /*
<a name="302"></a>     *   Write bytes from the ByteArray object into the file.  This can only
<a name="303"></a>     *   be used for a file opened in 'raw' mode.  If 'start' and 'cnt' are
<a name="304"></a>     *   given, they give the starting index in the byte array of the bytes
<a name="305"></a>     *   to be written, and the number of bytes to write, respectively; if
<a name="306"></a>     *   these are omitted, all of the bytes in the array are written.
<a name="307"></a>     *   
<a name="308"></a>     *   No return value; if an error occurs writing the data, a
<a name="309"></a>     *   FileIOException is thrown.  
<a name="310"></a>     */
<a name="311"></a>    writeBytes(byteArr, start?, cnt?);
<a name="312"></a>
<a name="313"></a>    /*
<a name="314"></a>     *   Get the current read/write position in the file.  Returns the byte
<a name="315"></a>     *   offset in the file of the next byte to be read or written.  Note
<a name="316"></a>     *   that this value is an offset, so 0 is the offset of the first byte
<a name="317"></a>     *   in the file.  
<a name="318"></a>     */
<a name="319"></a>    getPos();
<a name="320"></a>
<a name="321"></a>    /*
<a name="322"></a>     *   Set the current read/write position in the file.  'pos' is a byte
<a name="323"></a>     *   offset in the file; 0 is the offset of the first byte.
<a name="324"></a>     *   
<a name="325"></a>     *   For files in 'text' and 'data' modes, a caller should NEVER set the
<a name="326"></a>     *   file position to any value other than a value previously returned
<a name="327"></a>     *   by getPos(), because other positions might violate the format
<a name="328"></a>     *   constraints.  For example, if you move the file position to a byte
<a name="329"></a>     *   in the middle of a line-ending sequence in a text file, subsequent
<a name="330"></a>     *   reading from the file might misinterpret the sequence as something
<a name="331"></a>     *   other than a line ending, or as an extra line ending.  If you move
<a name="332"></a>     *   the position in a 'data' file to a byte in the middle of an integer
<a name="333"></a>     *   value, reading from the file would misinterpret as a data type tag
<a name="334"></a>     *   a byte that is part of the integer value instead.  So it is never
<a name="335"></a>     *   meaningful or safe to set an arbitrary byte offset in these file
<a name="336"></a>     *   formats; only values known to be valid by virtue of having been
<a name="337"></a>     *   returned from getPos() can be used here in these modes.  
<a name="338"></a>     */
<a name="339"></a>    setPos(pos);
<a name="340"></a>
<a name="341"></a>    /*
<a name="342"></a>     *   Set the current read/write position to the end of the file.  This
<a name="343"></a>     *   can be used, for example, to open a 'data' mode file for
<a name="344"></a>     *   read/write/keep access (keeping the contents of an existing file)
<a name="345"></a>     *   and then adding more data after all of the existing data in the
<a name="346"></a>     *   file.  
<a name="347"></a>     */
<a name="348"></a>    setPosEnd();
<a name="349"></a>
<a name="350"></a>    /*
<a name="351"></a>     *   Static creator method: open a resource in 'text' mode.  This acts
<a name="352"></a>     *   like openTextFile(), but rather than opening an ordinary file, this
<a name="353"></a>     *   method opens a resource.  Resources differ from ordinary files in
<a name="354"></a>     *   two important respects.  First, a resource is named with a
<a name="355"></a>     *   URL-style path rather than a local file system name.  Second, a
<a name="356"></a>     *   resource can be embedded in the program's executable (.t3) file, or
<a name="357"></a>     *   can be embedded in an external resource bundle (.3r0, etc) file.
<a name="358"></a>     *   
<a name="359"></a>     *   Resources are read-only, so the access mode is implicitly
<a name="360"></a>     *   FileAccessRead.  
<a name="361"></a>     */
<a name="362"></a>    static openTextResource(resname, charset?);
<a name="363"></a>
<a name="364"></a>    /*
<a name="365"></a>     *   Static creator method: open a resource in 'raw' mode.  This acts
<a name="366"></a>     *   like openRawFile(), but opens a resource rather than an ordinary
<a name="367"></a>     *   file.
<a name="368"></a>     *   
<a name="369"></a>     *   Resources are read-only, so the access mode is implicitly
<a name="370"></a>     *   FileAccessRead.  
<a name="371"></a>     */
<a name="372"></a>    static openRawResource(resname);
<a name="373"></a>
<a name="374"></a>    /* get the size in bytes of the file */
<a name="375"></a>    getFileSize();
<a name="376"></a>}
<a name="377"></a>
<a name="378"></a>#endif /* _FILE_H_ */
</pre>
<div class=ftr>TADS 3 Library Manual<br>Generated on 5/6/2009 from TADS version 3.0.18.1</div>
</body>
</html>
